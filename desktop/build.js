!function(t) {
    if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = t();
    else if ("function" == typeof define && define.amd)
        define([], t);
    else {
        var e;
        e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this,
        e.PIXI = t()
    }
}(function() {
    var t;
    return function e(t, r, i) {
        function n(o, a) {
            if (!r[o]) {
                if (!t[o]) {
                    var h = "function" == typeof require && require;
                    if (!a && h)
                        return h(o, !0);
                    if (s)
                        return s(o, !0);
                    var u = new Error("Cannot find module '" + o + "'");
                    throw u.code = "MODULE_NOT_FOUND",
                    u;
                }
                var l = r[o] = {
                    exports: {}
                };
                t[o][0].call(l.exports, function(e) {
                    var r = t[o][1][e];
                    return n(r ? r : e)
                }, l, l.exports, e, t, r, i)
            }
            return r[o].exports
        }
        for (var s = "function" == typeof require && require, o = 0; o < i.length; o++)
            n(i[o]);
        return n
    }({
        1: [function(t, e, r) {
            (function(r) {
                t("./polyfill");
                var i = e.exports = t("./core");
                i.extras = t("./extras"),
                i.filters = t("./filters"),
                i.interaction = t("./interaction"),
                i.loaders = t("./loaders"),
                i.mesh = t("./mesh"),
                i.ticker = t("./ticker"),
                i.loader = new i.loaders.Loader,
                Object.assign(i, t("./deprecation")),
                r.PIXI = i
            }
            ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }
        , {
            "./core": 25,
            "./deprecation": 73,
            "./extras": 80,
            "./filters": 3,
            "./interaction": 83,
            "./loaders": 86,
            "./mesh": 3,
            "./polyfill": 91,
            "./ticker": 94
        }],
        2: [function(e, r, i) {
            (function(e) {
                !function() {
                    function i(t) {
                        var e = !1;
                        return function() {
                            if (e)
                                throw new Error("Callback was already called.");
                            e = !0,
                            t.apply(n, arguments)
                        }
                    }
                    var n, s, o = {};
                    n = this,
                    null != n && (s = n.async),
                    o.noConflict = function() {
                        return n.async = s,
                        o
                    }
                    ;
                    var a = Object.prototype.toString
                      , h = Array.isArray || function(t) {
                        return "[object Array]" === a.call(t)
                    }
                      , u = function(t, e) {
                        for (var r = 0; r < t.length; r += 1)
                            e(t[r], r, t)
                    }
                      , l = function(t, e) {
                        if (t.map)
                            return t.map(e);
                        var r = [];
                        return u(t, function(t, i, n) {
                            r.push(e(t, i, n))
                        }),
                        r
                    }
                      , c = function(t, e, r) {
                        return t.reduce ? t.reduce(e, r) : (u(t, function(t, i, n) {
                            r = e(r, t, i, n)
                        }),
                        r)
                    }
                      , d = function(t) {
                        if (Object.keys)
                            return Object.keys(t);
                        var e = [];
                        for (var r in t)
                            t.hasOwnProperty(r) && e.push(r);
                        return e
                    };
                    "undefined" != typeof e && e.nextTick ? (o.nextTick = e.nextTick,
                    "undefined" != typeof setImmediate ? o.setImmediate = function(t) {
                        setImmediate(t)
                    }
                    : o.setImmediate = o.nextTick) : "function" == typeof setImmediate ? (o.nextTick = function(t) {
                        setImmediate(t)
                    }
                    ,
                    o.setImmediate = o.nextTick) : (o.nextTick = function(t) {
                        setTimeout(t, 0)
                    }
                    ,
                    o.setImmediate = o.nextTick),
                    o.each = function(t, e, r) {
                        function n(e) {
                            e ? (r(e),
                            r = function() {}
                            ) : (s += 1,
                            s >= t.length && r())
                        }
                        if (r = r || function() {}
                        ,
                        !t.length)
                            return r();
                        var s = 0;
                        u(t, function(t) {
                            e(t, i(n))
                        })
                    }
                    ,
                    o.forEach = o.each,
                    o.eachSeries = function(t, e, r) {
                        if (r = r || function() {}
                        ,
                        !t.length)
                            return r();
                        var i = 0
                          , n = function() {
                            e(t[i], function(e) {
                                e ? (r(e),
                                r = function() {}
                                ) : (i += 1,
                                i >= t.length ? r() : n())
                            })
                        };
                        n()
                    }
                    ,
                    o.forEachSeries = o.eachSeries,
                    o.eachLimit = function(t, e, r, i) {
                        var n = p(e);
                        n.apply(null, [t, r, i])
                    }
                    ,
                    o.forEachLimit = o.eachLimit;
                    var p = function(t) {
                        return function(e, r, i) {
                            if (i = i || function() {}
                            ,
                            !e.length || t <= 0)
                                return i();
                            var n = 0
                              , s = 0
                              , o = 0;
                            !function a() {
                                if (n >= e.length)
                                    return i();
                                for (; o < t && s < e.length; )
                                    s += 1,
                                    o += 1,
                                    r(e[s - 1], function(t) {
                                        t ? (i(t),
                                        i = function() {}
                                        ) : (n += 1,
                                        o -= 1,
                                        n >= e.length ? i() : a())
                                    })
                            }()
                        }
                    }
                      , f = function(t) {
                        return function() {
                            var e = Array.prototype.slice.call(arguments);
                            return t.apply(null, [o.each].concat(e))
                        }
                    }
                      , g = function(t, e) {
                        return function() {
                            var r = Array.prototype.slice.call(arguments);
                            return e.apply(null, [p(t)].concat(r))
                        }
                    }
                      , v = function(t) {
                        return function() {
                            var e = Array.prototype.slice.call(arguments);
                            return t.apply(null, [o.eachSeries].concat(e))
                        }
                    }
                      , y = function(t, e, r, i) {
                        if (e = l(e, function(t, e) {
                            return {
                                index: e,
                                value: t
                            }
                        }),
                        i) {
                            var n = [];
                            t(e, function(t, e) {
                                r(t.value, function(r, i) {
                                    n[t.index] = i,
                                    e(r)
                                })
                            }, function(t) {
                                i(t, n)
                            })
                        } else
                            t(e, function(t, e) {
                                r(t.value, function(t) {
                                    e(t)
                                })
                            })
                    };
                    o.map = f(y),
                    o.mapSeries = v(y),
                    o.mapLimit = function(t, e, r, i) {
                        return m(e)(t, r, i)
                    }
                    ;
                    var m = function(t) {
                        return g(t, y)
                    };
                    o.reduce = function(t, e, r, i) {
                        o.eachSeries(t, function(t, i) {
                            r(e, t, function(t, r) {
                                e = r,
                                i(t)
                            })
                        }, function(t) {
                            i(t, e)
                        })
                    }
                    ,
                    o.inject = o.reduce,
                    o.foldl = o.reduce,
                    o.reduceRight = function(t, e, r, i) {
                        var n = l(t, function(t) {
                            return t
                        }).reverse();
                        o.reduce(n, e, r, i)
                    }
                    ,
                    o.foldr = o.reduceRight;
                    var x = function(t, e, r, i) {
                        var n = [];
                        e = l(e, function(t, e) {
                            return {
                                index: e,
                                value: t
                            }
                        }),
                        t(e, function(t, e) {
                            r(t.value, function(r) {
                                r && n.push(t),
                                e()
                            })
                        }, function(t) {
                            i(l(n.sort(function(t, e) {
                                return t.index - e.index
                            }), function(t) {
                                return t.value
                            }))
                        })
                    };
                    o.filter = f(x),
                    o.filterSeries = v(x),
                    o.select = o.filter,
                    o.selectSeries = o.filterSeries;
                    var _ = function(t, e, r, i) {
                        var n = [];
                        e = l(e, function(t, e) {
                            return {
                                index: e,
                                value: t
                            }
                        }),
                        t(e, function(t, e) {
                            r(t.value, function(r) {
                                r || n.push(t),
                                e()
                            })
                        }, function(t) {
                            i(l(n.sort(function(t, e) {
                                return t.index - e.index
                            }), function(t) {
                                return t.value
                            }))
                        })
                    };
                    o.reject = f(_),
                    o.rejectSeries = v(_);
                    var E = function(t, e, r, i) {
                        t(e, function(t, e) {
                            r(t, function(r) {
                                r ? (i(t),
                                i = function() {}
                                ) : e()
                            })
                        }, function(t) {
                            i()
                        })
                    };
                    o.detect = f(E),
                    o.detectSeries = v(E),
                    o.some = function(t, e, r) {
                        o.each(t, function(t, i) {
                            e(t, function(t) {
                                t && (r(!0),
                                r = function() {}
                                ),
                                i()
                            })
                        }, function(t) {
                            r(!1)
                        })
                    }
                    ,
                    o.any = o.some,
                    o.every = function(t, e, r) {
                        o.each(t, function(t, i) {
                            e(t, function(t) {
                                t || (r(!1),
                                r = function() {}
                                ),
                                i()
                            })
                        }, function(t) {
                            r(!0)
                        })
                    }
                    ,
                    o.all = o.every,
                    o.sortBy = function(t, e, r) {
                        o.map(t, function(t, r) {
                            e(t, function(e, i) {
                                e ? r(e) : r(null, {
                                    value: t,
                                    criteria: i
                                })
                            })
                        }, function(t, e) {
                            if (t)
                                return r(t);
                            var i = function(t, e) {
                                var r = t.criteria
                                  , i = e.criteria;
                                return r < i ? -1 : r > i ? 1 : 0
                            };
                            r(null, l(e.sort(i), function(t) {
                                return t.value
                            }))
                        })
                    }
                    ,
                    o.auto = function(t, e) {
                        e = e || function() {}
                        ;
                        var r = d(t)
                          , i = r.length;
                        if (!i)
                            return e();
                        var n = {}
                          , s = []
                          , a = function(t) {
                            s.unshift(t)
                        }
                          , l = function(t) {
                            for (var e = 0; e < s.length; e += 1)
                                if (s[e] === t)
                                    return void s.splice(e, 1)
                        }
                          , p = function() {
                            i--,
                            u(s.slice(0), function(t) {
                                t()
                            })
                        };
                        a(function() {
                            if (!i) {
                                var t = e;
                                e = function() {}
                                ,
                                t(null, n)
                            }
                        }),
                        u(r, function(r) {
                            var i = h(t[r]) ? t[r] : [t[r]]
                              , s = function(t) {
                                var i = Array.prototype.slice.call(arguments, 1);
                                if (i.length <= 1 && (i = i[0]),
                                t) {
                                    var s = {};
                                    u(d(n), function(t) {
                                        s[t] = n[t]
                                    }),
                                    s[r] = i,
                                    e(t, s),
                                    e = function() {}
                                } else
                                    n[r] = i,
                                    o.setImmediate(p)
                            }
                              , f = i.slice(0, Math.abs(i.length - 1)) || []
                              , g = function() {
                                return c(f, function(t, e) {
                                    return t && n.hasOwnProperty(e)
                                }, !0) && !n.hasOwnProperty(r)
                            };
                            if (g())
                                i[i.length - 1](s, n);
                            else {
                                var v = function() {
                                    g() && (l(v),
                                    i[i.length - 1](s, n))
                                };
                                a(v)
                            }
                        })
                    }
                    ,
                    o.retry = function(t, e, r) {
                        var i = 5
                          , n = [];
                        "function" == typeof t && (r = e,
                        e = t,
                        t = i),
                        t = parseInt(t, 10) || i;
                        var s = function(i, s) {
                            for (var a = function(t, e) {
                                return function(r) {
                                    t(function(t, i) {
                                        r(!t || e, {
                                            err: t,
                                            result: i
                                        })
                                    }, s)
                                }
                            }; t; )
                                n.push(a(e, !(t -= 1)));
                            o.series(n, function(t, e) {
                                e = e[e.length - 1],
                                (i || r)(e.err, e.result)
                            })
                        };
                        return r ? s() : s
                    }
                    ,
                    o.waterfall = function(t, e) {
                        if (e = e || function() {}
                        ,
                        !h(t)) {
                            var r = new Error("First argument to waterfall must be an array of functions");
                            return e(r)
                        }
                        if (!t.length)
                            return e();
                        var i = function(t) {
                            return function(r) {
                                if (r)
                                    e.apply(null, arguments),
                                    e = function() {}
                                    ;
                                else {
                                    var n = Array.prototype.slice.call(arguments, 1)
                                      , s = t.next();
                                    s ? n.push(i(s)) : n.push(e),
                                    o.setImmediate(function() {
                                        t.apply(null, n)
                                    })
                                }
                            }
                        };
                        i(o.iterator(t))()
                    }
                    ;
                    var b = function(t, e, r) {
                        if (r = r || function() {}
                        ,
                        h(e))
                            t.map(e, function(t, e) {
                                t && t(function(t) {
                                    var r = Array.prototype.slice.call(arguments, 1);
                                    r.length <= 1 && (r = r[0]),
                                    e.call(null, t, r)
                                })
                            }, r);
                        else {
                            var i = {};
                            t.each(d(e), function(t, r) {
                                e[t](function(e) {
                                    var n = Array.prototype.slice.call(arguments, 1);
                                    n.length <= 1 && (n = n[0]),
                                    i[t] = n,
                                    r(e)
                                })
                            }, function(t) {
                                r(t, i)
                            })
                        }
                    };
                    o.parallel = function(t, e) {
                        b({
                            map: o.map,
                            each: o.each
                        }, t, e)
                    }
                    ,
                    o.parallelLimit = function(t, e, r) {
                        b({
                            map: m(e),
                            each: p(e)
                        }, t, r)
                    }
                    ,
                    o.series = function(t, e) {
                        if (e = e || function() {}
                        ,
                        h(t))
                            o.mapSeries(t, function(t, e) {
                                t && t(function(t) {
                                    var r = Array.prototype.slice.call(arguments, 1);
                                    r.length <= 1 && (r = r[0]),
                                    e.call(null, t, r)
                                })
                            }, e);
                        else {
                            var r = {};
                            o.eachSeries(d(t), function(e, i) {
                                t[e](function(t) {
                                    var n = Array.prototype.slice.call(arguments, 1);
                                    n.length <= 1 && (n = n[0]),
                                    r[e] = n,
                                    i(t)
                                })
                            }, function(t) {
                                e(t, r)
                            })
                        }
                    }
                    ,
                    o.iterator = function(t) {
                        var e = function(r) {
                            var i = function() {
                                return t.length && t[r].apply(null, arguments),
                                i.next()
                            };
                            return i.next = function() {
                                return r < t.length - 1 ? e(r + 1) : null
                            }
                            ,
                            i
                        };
                        return e(0)
                    }
                    ,
                    o.apply = function(t) {
                        var e = Array.prototype.slice.call(arguments, 1);
                        return function() {
                            return t.apply(null, e.concat(Array.prototype.slice.call(arguments)))
                        }
                    }
                    ;
                    var T = function(t, e, r, i) {
                        var n = [];
                        t(e, function(t, e) {
                            r(t, function(t, r) {
                                n = n.concat(r || []),
                                e(t)
                            })
                        }, function(t) {
                            i(t, n)
                        })
                    };
                    o.concat = f(T),
                    o.concatSeries = v(T),
                    o.whilst = function(t, e, r) {
                        t() ? e(function(i) {
                            return i ? r(i) : void o.whilst(t, e, r)
                        }) : r()
                    }
                    ,
                    o.doWhilst = function(t, e, r) {
                        t(function(i) {
                            if (i)
                                return r(i);
                            var n = Array.prototype.slice.call(arguments, 1);
                            e.apply(null, n) ? o.doWhilst(t, e, r) : r()
                        })
                    }
                    ,
                    o.until = function(t, e, r) {
                        t() ? r() : e(function(i) {
                            return i ? r(i) : void o.until(t, e, r)
                        })
                    }
                    ,
                    o.doUntil = function(t, e, r) {
                        t(function(i) {
                            if (i)
                                return r(i);
                            var n = Array.prototype.slice.call(arguments, 1);
                            e.apply(null, n) ? r() : o.doUntil(t, e, r)
                        })
                    }
                    ,
                    o.queue = function(t, e) {
                        function r(t, e, r, i) {
                            return t.started || (t.started = !0),
                            h(e) || (e = [e]),
                            0 == e.length ? o.setImmediate(function() {
                                t.drain && t.drain()
                            }) : void u(e, function(e) {
                                var n = {
                                    data: e,
                                    callback: "function" == typeof i ? i : null
                                };
                                r ? t.tasks.unshift(n) : t.tasks.push(n),
                                t.saturated && t.tasks.length === t.concurrency && t.saturated(),
                                o.setImmediate(t.process)
                            })
                        }
                        void 0 === e && (e = 1);
                        var n = 0
                          , s = {
                            tasks: [],
                            concurrency: e,
                            saturated: null,
                            empty: null,
                            drain: null,
                            started: !1,
                            paused: !1,
                            push: function(t, e) {
                                r(s, t, !1, e)
                            },
                            kill: function() {
                                s.drain = null,
                                s.tasks = []
                            },
                            unshift: function(t, e) {
                                r(s, t, !0, e)
                            },
                            process: function() {
                                if (!s.paused && n < s.concurrency && s.tasks.length) {
                                    var e = s.tasks.shift();
                                    s.empty && 0 === s.tasks.length && s.empty(),
                                    n += 1;
                                    var r = function() {
                                        n -= 1,
                                        e.callback && e.callback.apply(e, arguments),
                                        s.drain && s.tasks.length + n === 0 && s.drain(),
                                        s.process()
                                    }
                                      , o = i(r);
                                    t(e.data, o)
                                }
                            },
                            length: function() {
                                return s.tasks.length
                            },
                            running: function() {
                                return n
                            },
                            idle: function() {
                                return s.tasks.length + n === 0
                            },
                            pause: function() {
                                s.paused !== !0 && (s.paused = !0)
                            },
                            resume: function() {
                                if (s.paused !== !1) {
                                    s.paused = !1;
                                    for (var t = 1; t <= s.concurrency; t++)
                                        o.setImmediate(s.process)
                                }
                            }
                        };
                        return s
                    }
                    ,
                    o.priorityQueue = function(t, e) {
                        function r(t, e) {
                            return t.priority - e.priority
                        }
                        function i(t, e, r) {
                            for (var i = -1, n = t.length - 1; i < n; ) {
                                var s = i + (n - i + 1 >>> 1);
                                r(e, t[s]) >= 0 ? i = s : n = s - 1
                            }
                            return i
                        }
                        function n(t, e, n, s) {
                            return t.started || (t.started = !0),
                            h(e) || (e = [e]),
                            0 == e.length ? o.setImmediate(function() {
                                t.drain && t.drain()
                            }) : void u(e, function(e) {
                                var a = {
                                    data: e,
                                    priority: n,
                                    callback: "function" == typeof s ? s : null
                                };
                                t.tasks.splice(i(t.tasks, a, r) + 1, 0, a),
                                t.saturated && t.tasks.length === t.concurrency && t.saturated(),
                                o.setImmediate(t.process)
                            })
                        }
                        var s = o.queue(t, e);
                        return s.push = function(t, e, r) {
                            n(s, t, e, r)
                        }
                        ,
                        delete s.unshift,
                        s
                    }
                    ,
                    o.cargo = function(t, e) {
                        var r = !1
                          , i = []
                          , n = {
                            tasks: i,
                            payload: e,
                            saturated: null,
                            empty: null,
                            drain: null,
                            drained: !0,
                            push: function(t, r) {
                                h(t) || (t = [t]),
                                u(t, function(t) {
                                    i.push({
                                        data: t,
                                        callback: "function" == typeof r ? r : null
                                    }),
                                    n.drained = !1,
                                    n.saturated && i.length === e && n.saturated()
                                }),
                                o.setImmediate(n.process)
                            },
                            process: function s() {
                                if (!r) {
                                    if (0 === i.length)
                                        return n.drain && !n.drained && n.drain(),
                                        void (n.drained = !0);
                                    var o = "number" == typeof e ? i.splice(0, e) : i.splice(0, i.length)
                                      , a = l(o, function(t) {
                                        return t.data
                                    });
                                    n.empty && n.empty(),
                                    r = !0,
                                    t(a, function() {
                                        r = !1;
                                        var t = arguments;
                                        u(o, function(e) {
                                            e.callback && e.callback.apply(null, t)
                                        }),
                                        s()
                                    })
                                }
                            },
                            length: function() {
                                return i.length
                            },
                            running: function() {
                                return r
                            }
                        };
                        return n
                    }
                    ;
                    var w = function(t) {
                        return function(e) {
                            var r = Array.prototype.slice.call(arguments, 1);
                            e.apply(null, r.concat([function(e) {
                                var r = Array.prototype.slice.call(arguments, 1);
                                "undefined" != typeof console && (e ? console.error && console.error(e) : console[t] && u(r, function(e) {
                                    console[t](e)
                                }))
                            }
                            ]))
                        }
                    };
                    o.log = w("log"),
                    o.dir = w("dir"),
                    o.memoize = function(t, e) {
                        var r = {}
                          , i = {};
                        e = e || function(t) {
                            return t
                        }
                        ;
                        var n = function() {
                            var n = Array.prototype.slice.call(arguments)
                              , s = n.pop()
                              , a = e.apply(null, n);
                            a in r ? o.nextTick(function() {
                                s.apply(null, r[a])
                            }) : a in i ? i[a].push(s) : (i[a] = [s],
                            t.apply(null, n.concat([function() {
                                r[a] = arguments;
                                var t = i[a];
                                delete i[a];
                                for (var e = 0, n = t.length; e < n; e++)
                                    t[e].apply(null, arguments)
                            }
                            ])))
                        };
                        return n.memo = r,
                        n.unmemoized = t,
                        n
                    }
                    ,
                    o.unmemoize = function(t) {
                        return function() {
                            return (t.unmemoized || t).apply(null, arguments)
                        }
                    }
                    ,
                    o.times = function(t, e, r) {
                        for (var i = [], n = 0; n < t; n++)
                            i.push(n);
                        return o.map(i, e, r)
                    }
                    ,
                    o.timesSeries = function(t, e, r) {
                        for (var i = [], n = 0; n < t; n++)
                            i.push(n);
                        return o.mapSeries(i, e, r)
                    }
                    ,
                    o.seq = function() {
                        var t = arguments;
                        return function() {
                            var e = this
                              , r = Array.prototype.slice.call(arguments)
                              , i = r.pop();
                            o.reduce(t, r, function(t, r, i) {
                                r.apply(e, t.concat([function() {
                                    var t = arguments[0]
                                      , e = Array.prototype.slice.call(arguments, 1);
                                    i(t, e)
                                }
                                ]))
                            }, function(t, r) {
                                i.apply(e, [t].concat(r))
                            })
                        }
                    }
                    ,
                    o.compose = function() {
                        return o.seq.apply(null, Array.prototype.reverse.call(arguments))
                    }
                    ;
                    var S = function(t, e) {
                        var r = function() {
                            var r = this
                              , i = Array.prototype.slice.call(arguments)
                              , n = i.pop();
                            return t(e, function(t, e) {
                                t.apply(r, i.concat([e]))
                            }, n)
                        };
                        if (arguments.length > 2) {
                            var i = Array.prototype.slice.call(arguments, 2);
                            return r.apply(this, i)
                        }
                        return r
                    };
                    o.applyEach = f(S),
                    o.applyEachSeries = v(S),
                    o.forever = function(t, e) {
                        function r(i) {
                            if (i) {
                                if (e)
                                    return e(i);
                                throw i;
                            }
                            t(r)
                        }
                        r()
                    }
                    ,
                    "undefined" != typeof r && r.exports ? r.exports = o : "undefined" != typeof t && t.amd ? t([], function() {
                        return o
                    }) : n.async = o
                }()
            }
            ).call(this, e("_process"))
        }
        , {
            _process: 5
        }],
        3: [function(t, e, r) {}
        , {}],
        4: [function(t, e, r) {
            (function(t) {
                function e(t, e) {
                    for (var r = 0, i = t.length - 1; i >= 0; i--) {
                        var n = t[i];
                        "." === n ? t.splice(i, 1) : ".." === n ? (t.splice(i, 1),
                        r++) : r && (t.splice(i, 1),
                        r--)
                    }
                    if (e)
                        for (; r--; r)
                            t.unshift("..");
                    return t
                }
                function i(t, e) {
                    if (t.filter)
                        return t.filter(e);
                    for (var r = [], i = 0; i < t.length; i++)
                        e(t[i], i, t) && r.push(t[i]);
                    return r
                }
                var n = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/
                  , s = function(t) {
                    return n.exec(t).slice(1)
                };
                r.resolve = function() {
                    for (var r = "", n = !1, s = arguments.length - 1; s >= -1 && !n; s--) {
                        var o = s >= 0 ? arguments[s] : t.cwd();
                        if ("string" != typeof o)
                            throw new TypeError("Arguments to path.resolve must be strings");
                        o && (r = o + "/" + r,
                        n = "/" === o.charAt(0))
                    }
                    return r = e(i(r.split("/"), function(t) {
                        return !!t
                    }), !n).join("/"),
                    (n ? "/" : "") + r || "."
                }
                ,
                r.normalize = function(t) {
                    var n = r.isAbsolute(t)
                      , s = "/" === o(t, -1);
                    return t = e(i(t.split("/"), function(t) {
                        return !!t
                    }), !n).join("/"),
                    t || n || (t = "."),
                    t && s && (t += "/"),
                    (n ? "/" : "") + t
                }
                ,
                r.isAbsolute = function(t) {
                    return "/" === t.charAt(0)
                }
                ,
                r.join = function() {
                    var t = Array.prototype.slice.call(arguments, 0);
                    return r.normalize(i(t, function(t, e) {
                        if ("string" != typeof t)
                            throw new TypeError("Arguments to path.join must be strings");
                        return t
                    }).join("/"))
                }
                ,
                r.relative = function(t, e) {
                    function i(t) {
                        for (var e = 0; e < t.length && "" === t[e]; e++)
                            ;
                        for (var r = t.length - 1; r >= 0 && "" === t[r]; r--)
                            ;
                        return e > r ? [] : t.slice(e, r - e + 1)
                    }
                    t = r.resolve(t).substr(1),
                    e = r.resolve(e).substr(1);
                    for (var n = i(t.split("/")), s = i(e.split("/")), o = Math.min(n.length, s.length), a = o, h = 0; h < o; h++)
                        if (n[h] !== s[h]) {
                            a = h;
                            break
                        }
                    for (var u = [], h = a; h < n.length; h++)
                        u.push("..");
                    return u = u.concat(s.slice(a)),
                    u.join("/")
                }
                ,
                r.sep = "/",
                r.delimiter = ":",
                r.dirname = function(t) {
                    var e = s(t)
                      , r = e[0]
                      , i = e[1];
                    return r || i ? (i && (i = i.substr(0, i.length - 1)),
                    r + i) : "."
                }
                ,
                r.basename = function(t, e) {
                    var r = s(t)[2];
                    return e && r.substr(-1 * e.length) === e && (r = r.substr(0, r.length - e.length)),
                    r
                }
                ,
                r.extname = function(t) {
                    return s(t)[3]
                }
                ;
                var o = "b" === "ab".substr(-1) ? function(t, e, r) {
                    return t.substr(e, r)
                }
                : function(t, e, r) {
                    return e < 0 && (e = t.length + e),
                    t.substr(e, r)
                }
            }
            ).call(this, t("_process"))
        }
        , {
            _process: 5
        }],
        5: [function(t, e, r) {
            function i() {
                if (!a) {
                    a = !0;
                    for (var t, e = o.length; e; ) {
                        t = o,
                        o = [];
                        for (var r = -1; ++r < e; )
                            t[r]();
                        e = o.length
                    }
                    a = !1
                }
            }
            function n() {}
            var s = e.exports = {}
              , o = []
              , a = !1;
            s.nextTick = function(t) {
                o.push(t),
                a || setTimeout(i, 0)
            }
            ,
            s.title = "browser",
            s.browser = !0,
            s.env = {},
            s.argv = [],
            s.version = "",
            s.versions = {},
            s.on = n,
            s.addListener = n,
            s.once = n,
            s.off = n,
            s.removeListener = n,
            s.removeAllListeners = n,
            s.emit = n,
            s.binding = function(t) {
                throw new Error("process.binding is not supported");
            }
            ,
            s.cwd = function() {
                return "/"
            }
            ,
            s.chdir = function(t) {
                throw new Error("process.chdir is not supported");
            }
            ,
            s.umask = function() {
                return 0
            }
        }
        , {}],
        6: [function(t, e, r) {
            function i(t, e, r) {
                this.fn = t,
                this.context = e,
                this.once = r || !1
            }
            function n() {}
            var s = Object.prototype.hasOwnProperty
              , o = "function" != typeof Object.create && "~";
            n.prototype._events = void 0,
            n.prototype.eventNames = function() {
                var t, e = this._events, r = [];
                if (!e)
                    return r;
                for (t in e)
                    s.call(e, t) && r.push(o ? t.slice(1) : t);
                return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r
            }
            ,
            n.prototype.listeners = function(t, e) {
                var r = o ? o + t : t
                  , i = this._events && this._events[r];
                if (e)
                    return !!i;
                if (!i)
                    return [];
                if (i.fn)
                    return [i.fn];
                for (var n = 0, s = i.length, a = new Array(s); n < s; n++)
                    a[n] = i[n].fn;
                return a
            }
            ,
            n.prototype.emit = function(t, e, r, i, n, s) {
                var a = o ? o + t : t;
                if (!this._events || !this._events[a])
                    return !1;
                var h, u, l = this._events[a], c = arguments.length;
                if ("function" == typeof l.fn) {
                    switch (l.once && this.removeListener(t, l.fn, void 0, !0),
                    c) {
                    case 1:
                        return l.fn.call(l.context),
                        !0;
                    case 2:
                        return l.fn.call(l.context, e),
                        !0;
                    case 3:
                        return l.fn.call(l.context, e, r),
                        !0;
                    case 4:
                        return l.fn.call(l.context, e, r, i),
                        !0;
                    case 5:
                        return l.fn.call(l.context, e, r, i, n),
                        !0;
                    case 6:
                        return l.fn.call(l.context, e, r, i, n, s),
                        !0
                    }
                    for (u = 1,
                    h = new Array(c - 1); u < c; u++)
                        h[u - 1] = arguments[u];
                    l.fn.apply(l.context, h)
                } else {
                    var d, p = l.length;
                    for (u = 0; u < p; u++)
                        switch (l[u].once && this.removeListener(t, l[u].fn, void 0, !0),
                        c) {
                        case 1:
                            l[u].fn.call(l[u].context);
                            break;
                        case 2:
                            l[u].fn.call(l[u].context, e);
                            break;
                        case 3:
                            l[u].fn.call(l[u].context, e, r);
                            break;
                        default:
                            if (!h)
                                for (d = 1,
                                h = new Array(c - 1); d < c; d++)
                                    h[d - 1] = arguments[d];
                            l[u].fn.apply(l[u].context, h)
                        }
                }
                return !0
            }
            ,
            n.prototype.on = function(t, e, r) {
                var n = new i(e,r || this)
                  , s = o ? o + t : t;
                return this._events || (this._events = o ? {} : Object.create(null)),
                this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], n] : this._events[s].push(n) : this._events[s] = n,
                this
            }
            ,
            n.prototype.once = function(t, e, r) {
                var n = new i(e,r || this,!0)
                  , s = o ? o + t : t;
                return this._events || (this._events = o ? {} : Object.create(null)),
                this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], n] : this._events[s].push(n) : this._events[s] = n,
                this
            }
            ,
            n.prototype.removeListener = function(t, e, r, i) {
                var n = o ? o + t : t;
                if (!this._events || !this._events[n])
                    return this;
                var s = this._events[n]
                  , a = [];
                if (e)
                    if (s.fn)
                        (s.fn !== e || i && !s.once || r && s.context !== r) && a.push(s);
                    else
                        for (var h = 0, u = s.length; h < u; h++)
                            (s[h].fn !== e || i && !s[h].once || r && s[h].context !== r) && a.push(s[h]);
                return a.length ? this._events[n] = 1 === a.length ? a[0] : a : delete this._events[n],
                this
            }
            ,
            n.prototype.removeAllListeners = function(t) {
                return this._events ? (t ? delete this._events[o ? o + t : t] : this._events = o ? {} : Object.create(null),
                this) : this
            }
            ,
            n.prototype.off = n.prototype.removeListener,
            n.prototype.addListener = n.prototype.on,
            n.prototype.setMaxListeners = function() {
                return this
            }
            ,
            n.prefixed = o,
            "undefined" != typeof e && (e.exports = n)
        }
        , {}],
        7: [function(t, e, r) {
            function i(t) {
                if (null == t)
                    throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(t)
            }
            e.exports = Object.assign || function(t, e) {
                for (var r, n, s = i(t), o = 1; o < arguments.length; o++) {
                    r = arguments[o],
                    n = Object.keys(Object(r));
                    for (var a = 0; a < n.length; a++)
                        s[n[a]] = r[n[a]]
                }
                return s
            }
        }
        , {}],
        8: [function(t, e, r) {
            function i() {}
            function n(t, e, r) {
                this.fn = t,
                this.context = e,
                this.once = r || !1
            }
            function s() {
                this._events = new i,
                this._eventsCount = 0
            }
            var o = Object.prototype.hasOwnProperty
              , a = "~";
            Object.create && (i.prototype = Object.create(null),
            (new i).__proto__ || (a = !1)),
            s.prototype.eventNames = function() {
                var t, e, r = [];
                if (0 === this._eventsCount)
                    return r;
                for (e in t = this._events)
                    o.call(t, e) && r.push(a ? e.slice(1) : e);
                return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r
            }
            ,
            s.prototype.listeners = function(t, e) {
                var r = a ? a + t : t
                  , i = this._events[r];
                if (e)
                    return !!i;
                if (!i)
                    return [];
                if (i.fn)
                    return [i.fn];
                for (var n = 0, s = i.length, o = new Array(s); n < s; n++)
                    o[n] = i[n].fn;
                return o
            }
            ,
            s.prototype.emit = function(t, e, r, i, n, s) {
                var o = a ? a + t : t;
                if (!this._events[o])
                    return !1;
                var h, u, l = this._events[o], c = arguments.length;
                if (l.fn) {
                    switch (l.once && this.removeListener(t, l.fn, void 0, !0),
                    c) {
                    case 1:
                        return l.fn.call(l.context),
                        !0;
                    case 2:
                        return l.fn.call(l.context, e),
                        !0;
                    case 3:
                        return l.fn.call(l.context, e, r),
                        !0;
                    case 4:
                        return l.fn.call(l.context, e, r, i),
                        !0;
                    case 5:
                        return l.fn.call(l.context, e, r, i, n),
                        !0;
                    case 6:
                        return l.fn.call(l.context, e, r, i, n, s),
                        !0
                    }
                    for (u = 1,
                    h = new Array(c - 1); u < c; u++)
                        h[u - 1] = arguments[u];
                    l.fn.apply(l.context, h)
                } else {
                    var d, p = l.length;
                    for (u = 0; u < p; u++)
                        switch (l[u].once && this.removeListener(t, l[u].fn, void 0, !0),
                        c) {
                        case 1:
                            l[u].fn.call(l[u].context);
                            break;
                        case 2:
                            l[u].fn.call(l[u].context, e);
                            break;
                        case 3:
                            l[u].fn.call(l[u].context, e, r);
                            break;
                        case 4:
                            l[u].fn.call(l[u].context, e, r, i);
                            break;
                        default:
                            if (!h)
                                for (d = 1,
                                h = new Array(c - 1); d < c; d++)
                                    h[d - 1] = arguments[d];
                            l[u].fn.apply(l[u].context, h)
                        }
                }
                return !0
            }
            ,
            s.prototype.on = function(t, e, r) {
                var i = new n(e,r || this)
                  , s = a ? a + t : t;
                return this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], i] : this._events[s].push(i) : (this._events[s] = i,
                this._eventsCount++),
                this
            }
            ,
            s.prototype.once = function(t, e, r) {
                var i = new n(e,r || this,!0)
                  , s = a ? a + t : t;
                return this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], i] : this._events[s].push(i) : (this._events[s] = i,
                this._eventsCount++),
                this
            }
            ,
            s.prototype.removeListener = function(t, e, r, n) {
                var s = a ? a + t : t;
                if (!this._events[s])
                    return this;
                if (!e)
                    return 0 === --this._eventsCount ? this._events = new i : delete this._events[s],
                    this;
                var o = this._events[s];
                if (o.fn)
                    o.fn !== e || n && !o.once || r && o.context !== r || (0 === --this._eventsCount ? this._events = new i : delete this._events[s]);
                else {
                    for (var h = 0, u = [], l = o.length; h < l; h++)
                        (o[h].fn !== e || n && !o[h].once || r && o[h].context !== r) && u.push(o[h]);
                    u.length ? this._events[s] = 1 === u.length ? u[0] : u : 0 === --this._eventsCount ? this._events = new i : delete this._events[s]
                }
                return this
            }
            ,
            s.prototype.removeAllListeners = function(t) {
                var e;
                return t ? (e = a ? a + t : t,
                this._events[e] && (0 === --this._eventsCount ? this._events = new i : delete this._events[e])) : (this._events = new i,
                this._eventsCount = 0),
                this
            }
            ,
            s.prototype.off = s.prototype.removeListener,
            s.prototype.addListener = s.prototype.on,
            s.prototype.setMaxListeners = function() {
                return this
            }
            ,
            s.prefixed = a,
            s.EventEmitter = s,
            "undefined" != typeof e && (e.exports = s)
        }
        , {}],
        9: [function(t, e, r) {
            e.exports = function(t, e) {
                e = e || {};
                for (var r = {
                    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                    q: {
                        name: "queryKey",
                        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                    },
                    parser: {
                        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                        loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                    }
                }, i = r.parser[e.strictMode ? "strict" : "loose"].exec(t), n = {}, s = 14; s--; )
                    n[r.key[s]] = i[s] || "";
                return n[r.q.name] = {},
                n[r.key[12]].replace(r.q.parser, function(t, e, i) {
                    e && (n[r.q.name][e] = i)
                }),
                n
            }
        }
        , {}],
        10: [function(t, e, r) {
            function i(t, e) {
                a.call(this),
                e = e || h,
                this.baseUrl = t || "",
                this.progress = 0,
                this.loading = !1,
                this._progressChunk = 0,
                this._beforeMiddleware = [],
                this._afterMiddleware = [],
                this._boundLoadResource = this._loadResource.bind(this),
                this._buffer = [],
                this._numToLoad = 0,
                this._queue = s.queue(this._boundLoadResource, e),
                this.resources = {}
            }
            var n = t("parse-uri")
              , s = t("./async")
              , o = t("./Resource")
              , a = t("eventemitter3")
              , h = 10
              , u = 100;
            i.prototype = Object.create(a.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.add = i.prototype.enqueue = function(t, e, r, i) {
                if (Array.isArray(t)) {
                    for (var n = 0; n < t.length; ++n)
                        this.add(t[n]);
                    return this
                }
                if ("object" == typeof t && (i = e || t.callback || t.onComplete,
                r = t,
                e = t.url,
                t = t.name || t.key || t.url),
                "string" != typeof e && (i = r,
                r = e,
                e = t),
                "string" != typeof e)
                    throw new Error("No url passed to add resource to loader.");
                if ("function" == typeof r && (i = r,
                r = null),
                this.resources[t])
                    throw new Error('Resource with name "' + t + '" already exists.');
                return e = this._prepareUrl(e),
                this.resources[t] = new o(t,e,r),
                "function" == typeof i && this.resources[t].once("afterMiddleware", i),
                this._numToLoad++,
                this._queue.started ? (this._queue.push(this.resources[t]),
                this._progressChunk = (u - this.progress) / (this._queue.length() + this._queue.running())) : (this._buffer.push(this.resources[t]),
                this._progressChunk = u / this._buffer.length),
                this
            }
            ,
            i.prototype.before = i.prototype.pre = function(t) {
                return this._beforeMiddleware.push(t),
                this
            }
            ,
            i.prototype.after = i.prototype.use = function(t) {
                return this._afterMiddleware.push(t),
                this
            }
            ,
            i.prototype.reset = function() {
                this.progress = 0,
                this.loading = !1,
                this._progressChunk = 0,
                this._buffer.length = 0,
                this._numToLoad = 0,
                this._queue.kill(),
                this._queue.started = !1;
                for (var t in this.resources) {
                    var e = this.resources[t];
                    e.off("complete", this._onLoad, this),
                    e.isLoading && e.abort()
                }
                return this.resources = {},
                this
            }
            ,
            i.prototype.load = function(t) {
                if ("function" == typeof t && this.once("complete", t),
                this._queue.started)
                    return this;
                this.emit("start", this),
                this.loading = !0;
                for (var e = 0; e < this._buffer.length; ++e)
                    this._queue.push(this._buffer[e]);
                return this._buffer.length = 0,
                this
            }
            ,
            i.prototype._prepareUrl = function(t) {
                var e = n(t, {
                    strictMode: !0
                });
                return e.protocol || !e.path || 0 === e.path.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t
            }
            ,
            i.prototype._loadResource = function(t, e) {
                var r = this;
                t._dequeue = e,
                s.eachSeries(this._beforeMiddleware, function(e, i) {
                    e.call(r, t, function() {
                        i(t.isComplete ? {} : null)
                    })
                }, function() {
                    t.isComplete ? r._onLoad(t) : (t.once("complete", r._onLoad, r),
                    t.load())
                })
            }
            ,
            i.prototype._onComplete = function() {
                this.loading = !1,
                this.emit("complete", this, this.resources)
            }
            ,
            i.prototype._onLoad = function(t) {
                var e = this;
                s.eachSeries(this._afterMiddleware, function(r, i) {
                    r.call(e, t, i)
                }, function() {
                    t.emit("afterMiddleware", t),
                    e._numToLoad--,
                    e.progress += e._progressChunk,
                    e.emit("progress", e, t),
                    t.error ? e.emit("error", t.error, e, t) : e.emit("load", e, t),
                    0 === e._numToLoad && (e.progress = 100,
                    e._onComplete())
                }),
                t._dequeue()
            }
            ,
            i.LOAD_TYPE = o.LOAD_TYPE,
            i.XHR_RESPONSE_TYPE = o.XHR_RESPONSE_TYPE
        }
        , {
            "./Resource": 11,
            "./async": 12,
            eventemitter3: 8,
            "parse-uri": 9
        }],
        11: [function(t, e, r) {
            function i(t, e, r) {
                if (o.call(this),
                r = r || {},
                "string" != typeof t || "string" != typeof e)
                    throw new Error("Both name and url are required for constructing a resource.");
                this.name = t,
                this.url = e,
                this.isDataUrl = 0 === this.url.indexOf("data:"),
                this.data = null,
                this.crossOrigin = r.crossOrigin === !0 ? "anonymous" : r.crossOrigin,
                this.loadType = r.loadType || this._determineLoadType(),
                this.xhrType = r.xhrType,
                this.metadata = r.metadata || {},
                this.error = null,
                this.xhr = null,
                this.isJson = !1,
                this.isXml = !1,
                this.isImage = !1,
                this.isAudio = !1,
                this.isVideo = !1,
                this.isComplete = !1,
                this.isLoading = !1,
                this._dequeue = null,
                this._boundComplete = this.complete.bind(this),
                this._boundOnError = this._onError.bind(this),
                this._boundOnProgress = this._onProgress.bind(this),
                this._boundXhrOnError = this._xhrOnError.bind(this),
                this._boundXhrOnAbort = this._xhrOnAbort.bind(this),
                this._boundXhrOnLoad = this._xhrOnLoad.bind(this),
                this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this)
            }
            function n(t) {
                return t.toString().replace("object ", "")
            }
            function s(t, e, r) {
                e && 0 === e.indexOf(".") && (e = e.substring(1)),
                e && (t[e] = r)
            }
            var o = t("eventemitter3")
              , a = t("parse-uri")
              , h = !(!window.XDomainRequest || "withCredentials"in new XMLHttpRequest)
              , u = null
              , l = 0
              , c = 200
              , d = 204;
            i.prototype = Object.create(o.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.complete = function() {
                if (this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1),
                this.data.removeEventListener("load", this._boundComplete, !1),
                this.data.removeEventListener("progress", this._boundOnProgress, !1),
                this.data.removeEventListener("canplaythrough", this._boundComplete, !1)),
                this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1),
                this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1),
                this.xhr.removeEventListener("progress", this._boundOnProgress, !1),
                this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null,
                this.xhr.ontimeout = null,
                this.xhr.onprogress = null,
                this.xhr.onload = null)),
                this.isComplete)
                    throw new Error("Complete called again for an already completed resource.");
                this.isComplete = !0,
                this.isLoading = !1,
                this.emit("complete", this)
            }
            ,
            i.prototype.abort = function(t) {
                if (!this.error) {
                    if (this.error = new Error(t),
                    this.xhr)
                        this.xhr.abort();
                    else if (this.xdr)
                        this.xdr.abort();
                    else if (this.data)
                        if ("undefined" != typeof this.data.src)
                            this.data.src = "";
                        else
                            for (; this.data.firstChild; )
                                this.data.removeChild(this.data.firstChild);
                    this.complete()
                }
            }
            ,
            i.prototype.load = function(t) {
                if (!this.isLoading)
                    if (this.isComplete) {
                        if (t) {
                            var e = this;
                            setTimeout(function() {
                                t(e)
                            }, 1)
                        }
                    } else
                        switch (t && this.once("complete", t),
                        this.isLoading = !0,
                        this.emit("start", this),
                        this.crossOrigin !== !1 && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)),
                        this.loadType) {
                        case i.LOAD_TYPE.IMAGE:
                            this._loadElement("image");
                            break;
                        case i.LOAD_TYPE.AUDIO:
                            this._loadSourceElement("audio");
                            break;
                        case i.LOAD_TYPE.VIDEO:
                            this._loadSourceElement("video");
                            break;
                        case i.LOAD_TYPE.XHR:
                        default:
                            h && this.crossOrigin ? this._loadXdr() : this._loadXhr()
                        }
            }
            ,
            i.prototype._loadElement = function(t) {
                this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && "undefined" != typeof window.Image ? this.data = new Image : this.data = document.createElement(t),
                this.crossOrigin && (this.data.crossOrigin = this.crossOrigin),
                this.metadata.skipSource || (this.data.src = this.url);
                var e = "is" + t[0].toUpperCase() + t.substring(1);
                this[e] === !1 && (this[e] = !0),
                this.data.addEventListener("error", this._boundOnError, !1),
                this.data.addEventListener("load", this._boundComplete, !1),
                this.data.addEventListener("progress", this._boundOnProgress, !1)
            }
            ,
            i.prototype._loadSourceElement = function(t) {
                if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && "undefined" != typeof window.Audio ? this.data = new Audio : this.data = document.createElement(t),
                null === this.data)
                    return void this.abort("Unsupported element " + t);
                if (!this.metadata.skipSource)
                    if (navigator.isCocoonJS)
                        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
                    else if (Array.isArray(this.url))
                        for (var e = 0; e < this.url.length; ++e)
                            this.data.appendChild(this._createSource(t, this.url[e]));
                    else
                        this.data.appendChild(this._createSource(t, this.url));
                this["is" + t[0].toUpperCase() + t.substring(1)] = !0,
                this.data.addEventListener("error", this._boundOnError, !1),
                this.data.addEventListener("load", this._boundComplete, !1),
                this.data.addEventListener("progress", this._boundOnProgress, !1),
                this.data.addEventListener("canplaythrough", this._boundComplete, !1),
                this.data.load()
            }
            ,
            i.prototype._loadXhr = function() {
                "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                var t = this.xhr = new XMLHttpRequest;
                t.open("GET", this.url, !0),
                this.xhrType === i.XHR_RESPONSE_TYPE.JSON || this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = i.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType,
                t.addEventListener("error", this._boundXhrOnError, !1),
                t.addEventListener("abort", this._boundXhrOnAbort, !1),
                t.addEventListener("progress", this._boundOnProgress, !1),
                t.addEventListener("load", this._boundXhrOnLoad, !1),
                t.send()
            }
            ,
            i.prototype._loadXdr = function() {
                "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                var t = this.xhr = new XDomainRequest;
                t.timeout = 5E3,
                t.onerror = this._boundXhrOnError,
                t.ontimeout = this._boundXdrOnTimeout,
                t.onprogress = this._boundOnProgress,
                t.onload = this._boundXhrOnLoad,
                t.open("GET", this.url, !0),
                setTimeout(function() {
                    t.send()
                }, 0)
            }
            ,
            i.prototype._createSource = function(t, e, r) {
                r || (r = t + "/" + e.substr(e.lastIndexOf(".") + 1));
                var i = document.createElement("source");
                return i.src = e,
                i.type = r,
                i
            }
            ,
            i.prototype._onError = function(t) {
                this.abort("Failed to load element using " + t.target.nodeName)
            }
            ,
            i.prototype._onProgress = function(t) {
                t && t.lengthComputable && this.emit("progress", this, t.loaded / t.total)
            }
            ,
            i.prototype._xhrOnError = function() {
                var t = this.xhr;
                this.abort(n(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"')
            }
            ,
            i.prototype._xhrOnAbort = function() {
                this.abort(n(this.xhr) + " Request was aborted by the user.")
            }
            ,
            i.prototype._xdrOnTimeout = function() {
                this.abort(n(this.xhr) + " Request timed out.")
            }
            ,
            i.prototype._xhrOnLoad = function() {
                var t = this.xhr
                  , e = "undefined" == typeof t.status ? t.status : c;
                if (!(e === c || e === d || e === l && t.responseText.length > 0))
                    return void this.abort("[" + t.status + "]" + t.statusText + ":" + t.responseURL);
                if (this.xhrType === i.XHR_RESPONSE_TYPE.TEXT)
                    this.data = t.responseText;
                else if (this.xhrType === i.XHR_RESPONSE_TYPE.JSON)
                    try {
                        this.data = JSON.parse(t.responseText),
                        this.isJson = !0
                    } catch (r) {
                        return void this.abort("Error trying to parse loaded json:", r)
                    }
                else if (this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT)
                    try {
                        if (window.DOMParser) {
                            var n = new DOMParser;
                            this.data = n.parseFromString(t.responseText, "text/xml")
                        } else {
                            var s = document.createElement("div");
                            s.innerHTML = t.responseText,
                            this.data = s
                        }
                        this.isXml = !0
                    } catch (r) {
                        return void this.abort("Error trying to parse loaded xml:", r)
                    }
                else
                    this.data = t.response || t.responseText;
                this.complete()
            }
            ,
            i.prototype._determineCrossOrigin = function(t, e) {
                if (0 === t.indexOf("data:"))
                    return "";
                e = e || window.location,
                u || (u = document.createElement("a")),
                u.href = t,
                t = a(u.href, {
                    strictMode: !0
                });
                var r = !t.port && "" === e.port || t.port === e.port
                  , i = t.protocol ? t.protocol + ":" : "";
                return t.host === e.hostname && r && i === e.protocol ? "" : "anonymous"
            }
            ,
            i.prototype._determineXhrType = function() {
                return i._xhrTypeMap[this._getExtension()] || i.XHR_RESPONSE_TYPE.TEXT
            }
            ,
            i.prototype._determineLoadType = function() {
                return i._loadTypeMap[this._getExtension()] || i.LOAD_TYPE.XHR
            }
            ,
            i.prototype._getExtension = function() {
                var t = this.url
                  , e = "";
                if (this.isDataUrl) {
                    var r = t.indexOf("/");
                    e = t.substring(r + 1, t.indexOf(";", r))
                } else {
                    var i = t.indexOf("?");
                    i !== -1 && (t = t.substring(0, i)),
                    e = t.substring(t.lastIndexOf(".") + 1)
                }
                return e.toLowerCase()
            }
            ,
            i.prototype._getMimeFromXhrType = function(t) {
                switch (t) {
                case i.XHR_RESPONSE_TYPE.BUFFER:
                    return "application/octet-binary";
                case i.XHR_RESPONSE_TYPE.BLOB:
                    return "application/blob";
                case i.XHR_RESPONSE_TYPE.DOCUMENT:
                    return "application/xml";
                case i.XHR_RESPONSE_TYPE.JSON:
                    return "application/json";
                case i.XHR_RESPONSE_TYPE.DEFAULT:
                case i.XHR_RESPONSE_TYPE.TEXT:
                default:
                    return "text/plain"
                }
            }
            ,
            i.LOAD_TYPE = {
                XHR: 1,
                IMAGE: 2,
                AUDIO: 3,
                VIDEO: 4
            },
            i.XHR_RESPONSE_TYPE = {
                DEFAULT: "text",
                BUFFER: "arraybuffer",
                BLOB: "blob",
                DOCUMENT: "document",
                JSON: "json",
                TEXT: "text"
            },
            i._loadTypeMap = {
                gif: i.LOAD_TYPE.IMAGE,
                png: i.LOAD_TYPE.IMAGE,
                bmp: i.LOAD_TYPE.IMAGE,
                jpg: i.LOAD_TYPE.IMAGE,
                jpeg: i.LOAD_TYPE.IMAGE,
                tif: i.LOAD_TYPE.IMAGE,
                tiff: i.LOAD_TYPE.IMAGE,
                webp: i.LOAD_TYPE.IMAGE,
                tga: i.LOAD_TYPE.IMAGE,
                "svg+xml": i.LOAD_TYPE.IMAGE
            },
            i._xhrTypeMap = {
                xhtml: i.XHR_RESPONSE_TYPE.DOCUMENT,
                html: i.XHR_RESPONSE_TYPE.DOCUMENT,
                htm: i.XHR_RESPONSE_TYPE.DOCUMENT,
                xml: i.XHR_RESPONSE_TYPE.DOCUMENT,
                tmx: i.XHR_RESPONSE_TYPE.DOCUMENT,
                tsx: i.XHR_RESPONSE_TYPE.DOCUMENT,
                svg: i.XHR_RESPONSE_TYPE.DOCUMENT,
                gif: i.XHR_RESPONSE_TYPE.BLOB,
                png: i.XHR_RESPONSE_TYPE.BLOB,
                bmp: i.XHR_RESPONSE_TYPE.BLOB,
                jpg: i.XHR_RESPONSE_TYPE.BLOB,
                jpeg: i.XHR_RESPONSE_TYPE.BLOB,
                tif: i.XHR_RESPONSE_TYPE.BLOB,
                tiff: i.XHR_RESPONSE_TYPE.BLOB,
                webp: i.XHR_RESPONSE_TYPE.BLOB,
                tga: i.XHR_RESPONSE_TYPE.BLOB,
                json: i.XHR_RESPONSE_TYPE.JSON,
                text: i.XHR_RESPONSE_TYPE.TEXT,
                txt: i.XHR_RESPONSE_TYPE.TEXT
            },
            i.setExtensionLoadType = function(t, e) {
                s(i._loadTypeMap, t, e)
            }
            ,
            i.setExtensionXhrType = function(t, e) {
                s(i._xhrTypeMap, t, e)
            }
        }
        , {
            eventemitter3: 8,
            "parse-uri": 9
        }],
        12: [function(t, e, r) {
            function i() {}
            function n(t, e, r) {
                var i = 0
                  , n = t.length;
                !function s(o) {
                    return o || i === n ? void (r && r(o)) : void e(t[i++], s)
                }()
            }
            function s(t) {
                return function() {
                    if (null === t)
                        throw new Error("Callback was already called.");
                    var e = t;
                    t = null,
                    e.apply(this, arguments)
                }
            }
            function o(t, e) {
                function r(t, e, r) {
                    if (null != r && "function" != typeof r)
                        throw new Error("task callback must be a function");
                    if (a.started = !0,
                    null == t && a.idle())
                        return void setTimeout(function() {
                            a.drain()
                        }, 1);
                    var n = {
                        data: t,
                        callback: "function" == typeof r ? r : i
                    };
                    e ? a._tasks.unshift(n) : a._tasks.push(n),
                    setTimeout(function() {
                        a.process()
                    }, 1)
                }
                function n(t) {
                    return function() {
                        o -= 1,
                        t.callback.apply(t, arguments),
                        null != arguments[0] && a.error(arguments[0], t.data),
                        o <= a.concurrency - a.buffer && a.unsaturated(),
                        a.idle() && a.drain(),
                        a.process()
                    }
                }
                if (null == e)
                    e = 1;
                else if (0 === e)
                    throw new Error("Concurrency must not be zero");
                var o = 0
                  , a = {
                    _tasks: [],
                    concurrency: e,
                    saturated: i,
                    unsaturated: i,
                    buffer: e / 4,
                    empty: i,
                    drain: i,
                    error: i,
                    started: !1,
                    paused: !1,
                    push: function(t, e) {
                        r(t, !1, e)
                    },
                    kill: function() {
                        a.drain = i,
                        a._tasks = []
                    },
                    unshift: function(t, e) {
                        r(t, !0, e)
                    },
                    process: function() {
                        for (; !a.paused && o < a.concurrency && a._tasks.length; ) {
                            var e = a._tasks.shift();
                            0 === a._tasks.length && a.empty(),
                            o += 1,
                            o === a.concurrency && a.saturated(),
                            t(e.data, s(n(e)))
                        }
                    },
                    length: function() {
                        return a._tasks.length
                    },
                    running: function() {
                        return o
                    },
                    idle: function() {
                        return a._tasks.length + o === 0
                    },
                    pause: function() {
                        a.paused !== !0 && (a.paused = !0)
                    },
                    resume: function() {
                        if (a.paused !== !1) {
                            a.paused = !1;
                            for (var t = 1; t <= a.concurrency; t++)
                                a.process()
                        }
                    }
                };
                return a
            }
            e.exports = {
                eachSeries: n,
                queue: o
            }
        }
        , {}],
        13: [function(t, e, r) {
            e.exports = {
                _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                encodeBinary: function(t) {
                    for (var e, r = "", i = new Array(4), n = 0, s = 0, o = 0; n < t.length; ) {
                        for (e = new Array(3),
                        s = 0; s < e.length; s++)
                            n < t.length ? e[s] = 255 & t.charCodeAt(n++) : e[s] = 0;
                        switch (i[0] = e[0] >> 2,
                        i[1] = (3 & e[0]) << 4 | e[1] >> 4,
                        i[2] = (15 & e[1]) << 2 | e[2] >> 6,
                        i[3] = 63 & e[2],
                        o = n - (t.length - 1)) {
                        case 2:
                            i[3] = 64,
                            i[2] = 64;
                            break;
                        case 1:
                            i[3] = 64
                        }
                        for (s = 0; s < i.length; s++)
                            r += this._keyStr.charAt(i[s])
                    }
                    return r
                }
            }
        }
        , {}],
        14: [function(t, e, r) {
            e.exports = t("./Loader"),
            e.exports.Resource = t("./Resource"),
            e.exports.middleware = {
                caching: {
                    memory: t("./middlewares/caching/memory")
                },
                parsing: {
                    blob: t("./middlewares/parsing/blob")
                }
            },
            e.exports.async = t("./async")
        }
        , {
            "./Loader": 10,
            "./Resource": 11,
            "./async": 12,
            "./middlewares/caching/memory": 15,
            "./middlewares/parsing/blob": 16
        }],
        15: [function(t, e, r) {
            var i = {};
            e.exports = function() {
                return function(t, e) {
                    i[t.url] ? (t.data = i[t.url],
                    t.complete()) : t.once("complete", function() {
                        i[this.url] = this.data
                    }),
                    e()
                }
            }
        }
        , {}],
        16: [function(t, e, r) {
            var i = t("../../Resource")
              , n = t("../../b64")
              , s = window.URL || window.webkitURL;
            e.exports = function() {
                return function(t, e) {
                    if (!t.data)
                        return void e();
                    if (t.xhr && t.xhrType === i.XHR_RESPONSE_TYPE.BLOB)
                        if (window.Blob && "string" != typeof t.data) {
                            if (0 === t.data.type.indexOf("image")) {
                                var r = s.createObjectURL(t.data);
                                return t.blob = t.data,
                                t.data = new Image,
                                t.data.src = r,
                                t.isImage = !0,
                                void (t.data.onload = function() {
                                    s.revokeObjectURL(r),
                                    t.data.onload = null,
                                    e()
                                }
                                )
                            }
                        } else {
                            var o = t.xhr.getResponseHeader("content-type");
                            if (o && 0 === o.indexOf("image"))
                                return t.data = new Image,
                                t.data.src = "data:" + o + ";base64," + n.encodeBinary(t.xhr.responseText),
                                t.isImage = !0,
                                void (t.data.onload = function() {
                                    t.data.onload = null,
                                    e()
                                }
                                )
                        }
                    e()
                }
            }
        }
        , {
            "../../Resource": 11,
            "../../b64": 13
        }],
        17: [function(t, e, r) {
            e.exports = {
                name: "pixi.js",
                version: "3.0.2",
                description: "Pixi.js is a fast lightweight 2D library that works across all devices.",
                author: "Mat Groves",
                contributors: ["Chad Engler <chad@pantherdev.com>", "Richard Davey <rdavey@gmail.com>"],
                main: "./src/index.js",
                homepage: "http://goodboydigital.com/",
                bugs: "https://github.com/GoodBoyDigital/pixi.js/issues",
                license: "MIT",
                repository: {
                    type: "git",
                    url: "https://github.com/GoodBoyDigital/pixi.js.git"
                },
                scripts: {
                    test: "gulp && testem ci",
                    docs: "jsdoc -c ./gulp/util/jsdoc.conf.json -R README.md"
                },
                dependencies: {
                    async: "^0.9.0",
                    brfs: "^1.4.0",
                    eventemitter3: "^1.0.1",
                    "object-assign": "^2.0.0",
                    "resource-loader": "^1.5.2"
                },
                devDependencies: {
                    browserify: "^9.0.8",
                    chai: "^2.2.0",
                    del: "^1.1.1",
                    gulp: "^3.8.11",
                    "gulp-cached": "^1.0.4",
                    "gulp-concat": "^2.5.2",
                    "gulp-debug": "^2.0.1",
                    "gulp-jshint": "^1.10.0",
                    "gulp-mirror": "^0.4.0",
                    "gulp-plumber": "^1.0.0",
                    "gulp-rename": "^1.2.2",
                    "gulp-sourcemaps": "^1.5.2",
                    "gulp-uglify": "^1.2.0",
                    "gulp-util": "^3.0.4",
                    "ink-docstrap": "git+https://github.com/Pilatch/docstrap.git",
                    jsdoc: "^3.3.0-beta3",
                    "jshint-summary": "^0.4.0",
                    minimist: "^1.1.1",
                    mocha: "^2.2.4",
                    "require-dir": "^0.3.0",
                    "run-sequence": "^1.0.2",
                    testem: "^0.8.2",
                    "vinyl-buffer": "^1.0.0",
                    "vinyl-source-stream": "^1.1.0",
                    watchify: "^3.1.2"
                },
                browserify: {
                    transform: ["brfs"]
                }
            }
        }
        , {}],
        18: [function(t, e, r) {
            e.exports = {
                VERSION: t("../../package.json").version,
                PI_2: 2 * Math.PI,
                RAD_TO_DEG: 180 / Math.PI,
                DEG_TO_RAD: Math.PI / 180,
                TARGET_FPMS: .06,
                RENDERER_TYPE: {
                    UNKNOWN: 0,
                    WEBGL: 1,
                    CANVAS: 2
                },
                BLEND_MODES: {
                    NORMAL: 0,
                    ADD: 1,
                    MULTIPLY: 2,
                    SCREEN: 3,
                    OVERLAY: 4,
                    DARKEN: 5,
                    LIGHTEN: 6,
                    COLOR_DODGE: 7,
                    COLOR_BURN: 8,
                    HARD_LIGHT: 9,
                    SOFT_LIGHT: 10,
                    DIFFERENCE: 11,
                    EXCLUSION: 12,
                    HUE: 13,
                    SATURATION: 14,
                    COLOR: 15,
                    LUMINOSITY: 16
                },
                SCALE_MODES: {
                    DEFAULT: 0,
                    LINEAR: 0,
                    NEAREST: 1
                },
                RETINA_PREFIX: /@(.+)x/,
                RESOLUTION: 1,
                FILTER_RESOLUTION: 1,
                DEFAULT_RENDER_OPTIONS: {
                    view: null,
                    resolution: 1,
                    antialias: !1,
                    forceFXAA: !1,
                    autoResize: !1,
                    transparent: !1,
                    backgroundColor: 0,
                    clearBeforeRender: !0,
                    preserveDrawingBuffer: !1
                },
                SHAPES: {
                    POLY: 0,
                    RECT: 1,
                    CIRC: 2,
                    ELIP: 3,
                    RREC: 4
                },
                SPRITE_BATCH_SIZE: 2E3
            }
        }
        , {
            "../../package.json": 17
        }],
        19: [function(t, e, r) {
            function i() {
                s.call(this),
                this.children = []
            }
            var n = t("../math")
              , s = t("./DisplayObject")
              , o = t("../textures/RenderTexture")
              , a = new n.Matrix;
            i.prototype = Object.create(s.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this.scale.x * this.getLocalBounds().width
                    },
                    set: function(t) {
                        var e = this.getLocalBounds().width;
                        0 !== e ? this.scale.x = t / e : this.scale.x = 1,
                        this._width = t
                    }
                },
                height: {
                    get: function() {
                        return this.scale.y * this.getLocalBounds().height
                    },
                    set: function(t) {
                        var e = this.getLocalBounds().height;
                        0 !== e ? this.scale.y = t / e : this.scale.y = 1,
                        this._height = t
                    }
                }
            }),
            i.prototype.addChild = function(t) {
                return this.addChildAt(t, this.children.length)
            }
            ,
            i.prototype.addChildAt = function(t, e) {
                if (t === this)
                    return t;
                if (e >= 0 && e <= this.children.length)
                    return t.parent && t.parent.removeChild(t),
                    t.parent = this,
                    this.children.splice(e, 0, t),
                    t;
                throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
            }
            ,
            i.prototype.swapChildren = function(t, e) {
                if (t !== e) {
                    var r = this.getChildIndex(t)
                      , i = this.getChildIndex(e);
                    if (r < 0 || i < 0)
                        throw new Error("swapChildren: Both the supplied DisplayObjects must be children of the caller.");
                    this.children[r] = e,
                    this.children[i] = t
                }
            }
            ,
            i.prototype.getChildIndex = function(t) {
                var e = this.children.indexOf(t);
                if (e === -1)
                    throw new Error("The supplied DisplayObject must be a child of the caller");
                return e
            }
            ,
            i.prototype.setChildIndex = function(t, e) {
                if (e < 0 || e >= this.children.length)
                    throw new Error("The supplied index is out of bounds");
                var r = this.getChildIndex(t);
                this.children.splice(r, 1),
                this.children.splice(e, 0, t)
            }
            ,
            i.prototype.getChildAt = function(t) {
                if (t < 0 || t >= this.children.length)
                    throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject is not a child of the caller");
                return this.children[t]
            }
            ,
            i.prototype.removeChild = function(t) {
                var e = this.children.indexOf(t);
                if (e !== -1)
                    return this.removeChildAt(e)
            }
            ,
            i.prototype.removeChildAt = function(t) {
                var e = this.getChildAt(t);
                return e.parent = null,
                this.children.splice(t, 1),
                e
            }
            ,
            i.prototype.removeChildren = function(t, e) {
                var r = t || 0
                  , i = "number" == typeof e ? e : this.children.length
                  , n = i - r;
                if (n > 0 && n <= i) {
                    for (var s = this.children.splice(r, n), o = 0; o < s.length; ++o)
                        s[o].parent = null;
                    return s
                }
                if (0 === n && 0 === this.children.length)
                    return [];
                throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
            }
            ,
            i.prototype.generateTexture = function(t, e, r) {
                var i = this.getLocalBounds()
                  , n = new o(t,0 | i.width,0 | i.height,t,r,e);
                return a.tx = -i.x,
                a.ty = -i.y,
                n.render(this, a),
                n
            }
            ,
            i.prototype.updateTransform = function() {
                if (this.visible) {
                    if (0 != this.dirtyWT && (this.displayObjectUpdateTransform(),
                    this.dirtyWT = !0),
                    0 != this.dirtyChildren || 0 != this.dirtyWT)
                        for (var t = 0, e = this.children.length; t < e; ++t)
                            1 == this.dirtyWT && (this.children[t].dirtyWT = !0),
                            this.children[t].updateTransform();
                    this.dirtyWT = !1,
                    this.dirtyChildren = !1
                }
            }
            ,
            i.prototype.containerUpdateTransform = i.prototype.updateTransform,
            i.prototype.getBounds = function() {
                if (!this._currentBounds) {
                    if (0 === this.children.length)
                        return n.Rectangle.EMPTY;
                    for (var t, e, r, i = 1 / 0, s = 1 / 0, o = -(1 / 0), a = -(1 / 0), h = !1, u = 0, l = this.children.length; u < l; ++u) {
                        var c = this.children[u];
                        c.visible && (h = !0,
                        t = this.children[u].getBounds(),
                        i = i < t.x ? i : t.x,
                        s = s < t.y ? s : t.y,
                        e = t.width + t.x,
                        r = t.height + t.y,
                        o = o > e ? o : e,
                        a = a > r ? a : r)
                    }
                    if (!h)
                        return n.Rectangle.EMPTY;
                    var d = this._bounds;
                    d.x = i,
                    d.y = s,
                    d.width = o - i,
                    d.height = a - s,
                    this._currentBounds = d
                }
                return this._currentBounds
            }
            ,
            i.prototype.containerGetBounds = i.prototype.getBounds,
            i.prototype.getLocalBounds = function() {
                var t = this.worldTransform;
                this.worldTransform = n.Matrix.IDENTITY;
                for (var e = 0, r = this.children.length; e < r; ++e)
                    this.children[e].updateTransform();
                return this.worldTransform = t,
                this._currentBounds = null,
                this.getBounds(n.Matrix.IDENTITY)
            }
            ,
            i.prototype.renderWebGL = function(t) {
                if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
                    var e, r;
                    if (this._mask || this._filters) {
                        for (t.currentRenderer.flush(),
                        this._filters && t.filterManager.pushFilter(this, this._filters),
                        this._mask && t.maskManager.pushMask(this, this._mask),
                        t.currentRenderer.start(),
                        this._renderWebGL(t),
                        e = 0,
                        r = this.children.length; e < r; e++)
                            this.children[e].renderWebGL(t);
                        t.currentRenderer.flush(),
                        this._mask && t.maskManager.popMask(this, this._mask),
                        this._filters && t.filterManager.popFilter(),
                        t.currentRenderer.start()
                    } else
                        for (this._renderWebGL(t),
                        e = 0,
                        r = this.children.length; e < r; ++e)
                            this.children[e].renderWebGL(t)
                }
            }
            ,
            i.prototype._renderWebGL = function(t) {}
            ,
            i.prototype._renderCanvas = function(t) {}
            ,
            i.prototype.renderCanvas = function(t) {
                if (this.visible && !(this.alpha <= 0) && this.renderable) {
                    this._mask && t.maskManager.pushMask(this._mask, t),
                    this._renderCanvas(t);
                    for (var e = 0, r = this.children.length; e < r; ++e)
                        this.children[e].renderCanvas(t);
                    this._mask && t.maskManager.popMask(t)
                }
            }
            ,
            i.prototype.destroy = function(t) {
                if (s.prototype.destroy.call(this),
                t)
                    for (var e = 0, r = this.children.length; e < r; ++e)
                        this.children[e].destroy(t);
                this.removeChildren(),
                this.children = null
            }
        }
        , {
            "../math": 28,
            "../textures/RenderTexture": 66,
            "./DisplayObject": 20
        }],
        20: [function(t, e, r) {
            function i() {
                o.call(this),
                this.position = new n.Point,
                this.scale = new n.Point(1,1),
                this.pivot = new n.Point(0,0),
                this.rotation = 0,
                this.alpha = 1,
                this.visible = !0,
                this.renderable = !0,
                this.parent = null,
                this.worldAlpha = 1,
                this.worldTransform = new n.Matrix,
                this.filterArea = null,
                this._sr = 0,
                this._cr = 1,
                this._bounds = new n.Rectangle(0,0,1,1),
                this._currentBounds = null,
                this._mask = null,
                this._cacheAsBitmap = !1,
                this._cachedObject = null
            }
            var n = t("../math")
              , s = t("../textures/RenderTexture")
              , o = t("eventemitter3")
              , a = t("../const")
              , h = new n.Matrix;
            i.prototype = Object.create(o.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                x: {
                    get: function() {
                        return this.position.x
                    },
                    set: function(t) {
                        this.position.x = t
                    }
                },
                y: {
                    get: function() {
                        return this.position.y
                    },
                    set: function(t) {
                        this.position.y = t
                    }
                },
                worldVisible: {
                    get: function() {
                        var t = this;
                        do {
                            if (!t.visible)
                                return !1;
                            t = t.parent
                        } while (t);return !0
                    }
                },
                mask: {
                    get: function() {
                        return this._mask
                    },
                    set: function(t) {
                        this._mask && (this._mask.renderable = !0),
                        this._mask = t,
                        this._mask && (this._mask.renderable = !1)
                    }
                },
                filters: {
                    get: function() {
                        return this._filters && this._filters.slice()
                    },
                    set: function(t) {
                        this._filters = t && t.slice()
                    }
                }
            }),
            i.prototype.updateTransform = function() {
                if (0 != this.dirtyWT) {
                    var t, e, r, i, n, s, o = this.parent.worldTransform, h = this.worldTransform;
                    this.rotation % a.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation,
                    this._sr = Math.sin(this.rotation),
                    this._cr = Math.cos(this.rotation)),
                    t = this._cr * this.scale.x,
                    e = this._sr * this.scale.x,
                    r = -this._sr * this.scale.y,
                    i = this._cr * this.scale.y,
                    n = this.position.x,
                    s = this.position.y,
                    (this.pivot.x || this.pivot.y) && (n -= this.pivot.x * t + this.pivot.y * r,
                    s -= this.pivot.x * e + this.pivot.y * i),
                    h.a = t * o.a + e * o.c,
                    h.b = t * o.b + e * o.d,
                    h.c = r * o.a + i * o.c,
                    h.d = r * o.b + i * o.d,
                    h.tx = n * o.a + s * o.c + o.tx,
                    h.ty = n * o.b + s * o.d + o.ty) : (t = this.scale.x,
                    i = this.scale.y,
                    n = this.position.x - this.pivot.x * t,
                    s = this.position.y - this.pivot.y * i,
                    h.a = t * o.a,
                    h.b = t * o.b,
                    h.c = i * o.c,
                    h.d = i * o.d,
                    h.tx = n * o.a + s * o.c + o.tx,
                    h.ty = n * o.b + s * o.d + o.ty),
                    this.worldAlpha = this.alpha * this.parent.worldAlpha,
                    this._currentBounds = null,
                    this.dirtyWT = !1
                }
            }
            ,
            i.prototype.displayObjectUpdateTransform = i.prototype.updateTransform,
            i.prototype.getBounds = function(t) {
                return n.Rectangle.EMPTY
            }
            ,
            i.prototype.getLocalBounds = function() {
                return this.getBounds(n.Matrix.IDENTITY)
            }
            ,
            i.prototype.toGlobal = function(t) {
                return this.displayObjectUpdateTransform(),
                this.worldTransform.apply(t)
            }
            ,
            i.prototype.toLocal = function(t, e) {
                return e && (t = e.toGlobal(t)),
                this.displayObjectUpdateTransform(),
                this.worldTransform.applyInverse(t)
            }
            ,
            i.prototype.renderWebGL = function(t) {}
            ,
            i.prototype.renderCanvas = function(t) {}
            ,
            i.prototype.generateTexture = function(t, e, r) {
                var i = this.getLocalBounds()
                  , n = new s(t,0 | i.width,0 | i.height,t,r,e);
                return h.tx = -i.x,
                h.ty = -i.y,
                n.render(this, h),
                n
            }
            ,
            i.prototype.destroy = function() {
                this.position = null,
                this.scale = null,
                this.pivot = null,
                this.parent = null,
                this._bounds = null,
                this._currentBounds = null,
                this._mask = null,
                this.worldTransform = null,
                this.filterArea = null
            }
        }
        , {
            "../const": 18,
            "../math": 28,
            "../textures/RenderTexture": 66,
            eventemitter3: 6
        }],
        21: [function(t, e, r) {
            function i() {
                n.call(this),
                this.fillAlpha = 1,
                this.lineWidth = 0,
                this.lineColor = 0,
                this.graphicsData = [],
                this.tint = 16777215,
                this._prevTint = 16777215,
                this.blendMode = c.BLEND_MODES.NORMAL,
                this.currentPath = null,
                this._webGL = {},
                this.isMask = !1,
                this.boundsPadding = 0,
                this._localBounds = new l.Rectangle(0,0,1,1),
                this.dirty = !0,
                this.glDirty = !1,
                this.boundsDirty = !0,
                this.cachedSpriteDirty = !1
            }
            var n = t("../display/Container")
              , s = t("../sprites/Sprite")
              , o = t("../textures/Texture")
              , a = t("../renderers/canvas/utils/CanvasBuffer")
              , h = t("../renderers/canvas/utils/CanvasGraphics")
              , u = t("./GraphicsData")
              , l = t("../math")
              , c = t("../const")
              , d = new l.Point;
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {}),
            i.prototype.clone = function() {
                var t = new i;
                t.renderable = this.renderable,
                t.fillAlpha = this.fillAlpha,
                t.lineWidth = this.lineWidth,
                t.lineColor = this.lineColor,
                t.tint = this.tint,
                t.blendMode = this.blendMode,
                t.isMask = this.isMask,
                t.boundsPadding = this.boundsPadding,
                t.dirty = this.dirty,
                t.glDirty = this.glDirty,
                t.cachedSpriteDirty = this.cachedSpriteDirty;
                for (var e = 0; e < this.graphicsData.length; ++e)
                    t.graphicsData.push(this.graphicsData[e].clone());
                return t.currentPath = t.graphicsData[t.graphicsData.length - 1],
                t.updateLocalBounds(),
                t
            }
            ,
            i.prototype.lineStyle = function(t, e, r) {
                return this.lineWidth = t || 0,
                this.lineColor = e || 0,
                this.lineAlpha = void 0 === r ? 1 : r,
                this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new l.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth,
                this.currentPath.lineColor = this.lineColor,
                this.currentPath.lineAlpha = this.lineAlpha)),
                this
            }
            ,
            i.prototype.moveTo = function(t, e) {
                return this.drawShape(new l.Polygon([t, e])),
                this
            }
            ,
            i.prototype.lineTo = function(t, e) {
                return this.currentPath.shape.points.push(t, e),
                this.dirty = !0,
                this
            }
            ,
            i.prototype.quadraticCurveTo = function(t, e, r, i) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                var n, s, o = 20, a = this.currentPath.shape.points;
                0 === a.length && this.moveTo(0, 0);
                for (var h = a[a.length - 2], u = a[a.length - 1], l = 0, c = 1; c <= o; ++c)
                    l = c / o,
                    n = h + (t - h) * l,
                    s = u + (e - u) * l,
                    a.push(n + (t + (r - t) * l - n) * l, s + (e + (i - e) * l - s) * l);
                return this.dirty = this.boundsDirty = !0,
                this
            }
            ,
            i.prototype.bezierCurveTo = function(t, e, r, i, n, s) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                for (var o, a, h, u, l, c = 20, d = this.currentPath.shape.points, p = d[d.length - 2], f = d[d.length - 1], g = 0, v = 1; v <= c; ++v)
                    g = v / c,
                    o = 1 - g,
                    a = o * o,
                    h = a * o,
                    u = g * g,
                    l = u * g,
                    d.push(h * p + 3 * a * g * t + 3 * o * u * r + l * n, h * f + 3 * a * g * e + 3 * o * u * i + l * s);
                return this.dirty = this.boundsDirty = !0,
                this
            }
            ,
            i.prototype.arcTo = function(t, e, r, i, n) {
                this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
                var s = this.currentPath.shape.points
                  , o = s[s.length - 2]
                  , a = s[s.length - 1]
                  , h = a - e
                  , u = o - t
                  , l = i - e
                  , c = r - t
                  , d = Math.abs(h * c - u * l);
                if (d < 1E-8 || 0 === n)
                    s[s.length - 2] === t && s[s.length - 1] === e || s.push(t, e);
                else {
                    var p = h * h + u * u
                      , f = l * l + c * c
                      , g = h * l + u * c
                      , v = n * Math.sqrt(p) / d
                      , y = n * Math.sqrt(f) / d
                      , m = v * g / p
                      , x = y * g / f
                      , _ = v * c + y * u
                      , E = v * l + y * h
                      , b = u * (y + m)
                      , T = h * (y + m)
                      , w = c * (v + x)
                      , S = l * (v + x)
                      , A = Math.atan2(T - E, b - _)
                      , R = Math.atan2(S - E, w - _);
                    this.arc(_ + t, E + e, n, A, R, u * l > c * h)
                }
                return this.dirty = this.boundsDirty = !0,
                this
            }
            ,
            i.prototype.arc = function(t, e, r, i, n, s) {
                if (s = s || !1,
                i === n)
                    return this;
                !s && n <= i ? n += 2 * Math.PI : s && i <= n && (i += 2 * Math.PI);
                var o = s ? (i - n) * -1 : n - i
                  , a = 40 * Math.ceil(Math.abs(o) / (2 * Math.PI));
                if (0 === o)
                    return this;
                var h = t + Math.cos(i) * r
                  , u = e + Math.sin(i) * r;
                this.currentPath ? s && this.filling ? this.currentPath.shape.points.push(t, e) : this.currentPath.shape.points.push(h, u) : s && this.filling ? this.moveTo(t, e) : this.moveTo(h, u);
                for (var l = this.currentPath.shape.points, c = o / (2 * a), d = 2 * c, p = Math.cos(c), f = Math.sin(c), g = a - 1, v = g % 1 / g, y = 0; y <= g; y++) {
                    var m = y + v * y
                      , x = c + i + d * m
                      , _ = Math.cos(x)
                      , E = -Math.sin(x);
                    l.push((p * _ + f * E) * r + t, (p * -E + f * _) * r + e)
                }
                return this.dirty = this.boundsDirty = !0,
                this
            }
            ,
            i.prototype.beginFill = function(t, e) {
                return this.filling = !0,
                this.fillColor = t || 0,
                this.fillAlpha = void 0 === e ? 1 : e,
                this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling,
                this.currentPath.fillColor = this.fillColor,
                this.currentPath.fillAlpha = this.fillAlpha),
                this
            }
            ,
            i.prototype.endFill = function() {
                return this.filling = !1,
                this.fillColor = null,
                this.fillAlpha = 1,
                this
            }
            ,
            i.prototype.drawRect = function(t, e, r, i) {
                return this.drawShape(new l.Rectangle(t,e,r,i)),
                this
            }
            ,
            i.prototype.drawRoundedRect = function(t, e, r, i, n) {
                return this.drawShape(new l.RoundedRectangle(t,e,r,i,n)),
                this
            }
            ,
            i.prototype.drawCircle = function(t, e, r) {
                return this.drawShape(new l.Circle(t,e,r)),
                this
            }
            ,
            i.prototype.drawEllipse = function(t, e, r, i) {
                return this.drawShape(new l.Ellipse(t,e,r,i)),
                this
            }
            ,
            i.prototype.drawPolygon = function(t) {
                var e = t;
                if (!Array.isArray(e)) {
                    e = new Array(arguments.length);
                    for (var r = 0; r < e.length; ++r)
                        e[r] = arguments[r]
                }
                return this.drawShape(new l.Polygon(e)),
                this
            }
            ,
            i.prototype.clear = function() {
                return this.lineWidth = 0,
                this.filling = !1,
                this.dirty = !0,
                this.clearDirty = !0,
                this.graphicsData = [],
                this
            }
            ,
            i.prototype.generateTexture = function(t, e, r) {
                e = e || 1;
                var i = this.getLocalBounds()
                  , n = new a(i.width * e,i.height * e)
                  , s = o.fromCanvas(n.canvas, r);
                return s.baseTexture.resolution = e,
                n.context.scale(e, e),
                n.context.translate(-i.x, -i.y),
                h.renderGraphics(this, n.context),
                s
            }
            ,
            i.prototype._renderWebGL = function(t) {
                this.glDirty && (this.dirty = !0,
                this.glDirty = !1),
                t.setObjectRenderer(t.plugins.graphics),
                t.plugins.graphics.render(this)
            }
            ,
            i.prototype._renderCanvas = function(t) {
                if (this.isMask !== !0) {
                    if (this._prevTint !== this.tint && (this.dirty = !0,
                    this._prevTint = this.tint),
                    this._cacheAsBitmap)
                        return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(),
                        this.updateCachedSpriteTexture(),
                        this.cachedSpriteDirty = !1,
                        this.dirty = !1),
                        this._cachedSprite.alpha = this.alpha,
                        void s.prototype._renderCanvas.call(this._cachedSprite, t);
                    var e = t.context
                      , r = this.worldTransform;
                    this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                    e.globalCompositeOperation = t.blendModes[t.currentBlendMode]);
                    var i = t.resolution;
                    e.setTransform(r.a * i, r.b * i, r.c * i, r.d * i, r.tx * i, r.ty * i),
                    h.renderGraphics(this, e)
                }
            }
            ,
            i.prototype.getBounds = function(t) {
                if (!this._currentBounds) {
                    if (!this.renderable)
                        return l.Rectangle.EMPTY;
                    this.boundsDirty && (this.updateLocalBounds(),
                    this.glDirty = !0,
                    this.cachedSpriteDirty = !0,
                    this.boundsDirty = !1);
                    var e = this._localBounds
                      , r = e.x
                      , i = e.width + e.x
                      , n = e.y
                      , s = e.height + e.y
                      , o = t || this.worldTransform
                      , a = o.a
                      , h = o.b
                      , u = o.c
                      , c = o.d
                      , d = o.tx
                      , p = o.ty
                      , f = a * i + u * s + d
                      , g = c * s + h * i + p
                      , v = a * r + u * s + d
                      , y = c * s + h * r + p
                      , m = a * r + u * n + d
                      , x = c * n + h * r + p
                      , _ = a * i + u * n + d
                      , E = c * n + h * i + p
                      , b = f
                      , T = g
                      , w = f
                      , S = g;
                    w = v < w ? v : w,
                    w = m < w ? m : w,
                    w = _ < w ? _ : w,
                    S = y < S ? y : S,
                    S = x < S ? x : S,
                    S = E < S ? E : S,
                    b = v > b ? v : b,
                    b = m > b ? m : b,
                    b = _ > b ? _ : b,
                    T = y > T ? y : T,
                    T = x > T ? x : T,
                    T = E > T ? E : T,
                    this._bounds.x = w,
                    this._bounds.width = b - w,
                    this._bounds.y = S,
                    this._bounds.height = T - S,
                    this._currentBounds = this._bounds
                }
                return this._currentBounds
            }
            ,
            i.prototype.containsPoint = function(t) {
                this.worldTransform.applyInverse(t, d);
                for (var e = this.graphicsData, r = 0; r < e.length; r++) {
                    var i = e[r];
                    if (i.fill && i.shape && i.shape.contains(d.x, d.y))
                        return !0
                }
                return !1
            }
            ,
            i.prototype.updateLocalBounds = function() {
                var t = 1 / 0
                  , e = -(1 / 0)
                  , r = 1 / 0
                  , i = -(1 / 0);
                if (this.graphicsData.length)
                    for (var n, s, o, a, h, u, l = 0; l < this.graphicsData.length; l++) {
                        var d = this.graphicsData[l]
                          , p = d.type
                          , f = d.lineWidth;
                        if (n = d.shape,
                        p === c.SHAPES.RECT || p === c.SHAPES.RREC)
                            o = n.x - f / 2,
                            a = n.y - f / 2,
                            h = n.width + f,
                            u = n.height + f,
                            t = o < t ? o : t,
                            e = o + h > e ? o + h : e,
                            r = a < r ? a : r,
                            i = a + u > i ? a + u : i;
                        else if (p === c.SHAPES.CIRC)
                            o = n.x,
                            a = n.y,
                            h = n.radius + f / 2,
                            u = n.radius + f / 2,
                            t = o - h < t ? o - h : t,
                            e = o + h > e ? o + h : e,
                            r = a - u < r ? a - u : r,
                            i = a + u > i ? a + u : i;
                        else if (p === c.SHAPES.ELIP)
                            o = n.x,
                            a = n.y,
                            h = n.width + f / 2,
                            u = n.height + f / 2,
                            t = o - h < t ? o - h : t,
                            e = o + h > e ? o + h : e,
                            r = a - u < r ? a - u : r,
                            i = a + u > i ? a + u : i;
                        else {
                            s = n.points;
                            for (var g = 0; g < s.length; g += 2)
                                o = s[g],
                                a = s[g + 1],
                                t = o - f < t ? o - f : t,
                                e = o + f > e ? o + f : e,
                                r = a - f < r ? a - f : r,
                                i = a + f > i ? a + f : i
                        }
                    }
                else
                    t = 0,
                    e = 0,
                    r = 0,
                    i = 0;
                var v = this.boundsPadding;
                this._localBounds.x = t - v,
                this._localBounds.width = e - t + 2 * v,
                this._localBounds.y = r - v,
                this._localBounds.height = i - r + 2 * v
            }
            ,
            i.prototype.drawShape = function(t) {
                this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(),
                this.currentPath = null;
                var e = new u(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.filling,t);
                return this.graphicsData.push(e),
                e.type === c.SHAPES.POLY && (e.shape.closed = this.filling,
                this.currentPath = e),
                this.dirty = this.boundsDirty = !0,
                e
            }
            ,
            i.prototype.destroy = function() {
                n.prototype.destroy.apply(this, arguments);
                for (var t = 0; t < this.graphicsData.length; ++t)
                    this.graphicsData[t].destroy();
                for (var e in this._webgl)
                    for (var r = 0; r < this._webgl[e].data.length; ++r)
                        this._webgl[e].data[r].destroy();
                this.graphicsData = null,
                this.currentPath = null,
                this._webgl = null,
                this._localBounds = null
            }
        }
        , {
            "../const": 18,
            "../display/Container": 19,
            "../math": 28,
            "../renderers/canvas/utils/CanvasBuffer": 40,
            "../renderers/canvas/utils/CanvasGraphics": 41,
            "../sprites/Sprite": 62,
            "../textures/Texture": 67,
            "./GraphicsData": 22
        }],
        22: [function(t, e, r) {
            function i(t, e, r, i, n, s, o) {
                this.lineWidth = t,
                this.lineColor = e,
                this.lineAlpha = r,
                this._lineTint = e,
                this.fillColor = i,
                this.fillAlpha = n,
                this._fillTint = i,
                this.fill = s,
                this.shape = o,
                this.type = o.type
            }
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.clone = function() {
                return new i(this.lineWidth,this.lineColor,this.lineAlpha,this.fillColor,this.fillAlpha,this.fill,this.shape)
            }
            ,
            i.prototype.destroy = function() {
                this.shape = null
            }
        }
        , {}],
        23: [function(t, e, r) {
            function i(t) {
                a.call(this, t),
                this.graphicsDataPool = [],
                this.primitiveShader = null,
                this.complexPrimitiveShader = null
            }
            var n = t("../../utils")
              , s = t("../../math")
              , o = t("../../const")
              , a = t("../../renderers/webgl/utils/ObjectRenderer")
              , h = t("../../renderers/webgl/WebGLRenderer")
              , u = t("./WebGLGraphicsData");
            i.prototype = Object.create(a.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            h.registerPlugin("graphics", i),
            i.prototype.onContextChange = function() {}
            ,
            i.prototype.destroy = function() {
                a.prototype.destroy.call(this);
                for (var t = 0; t < this.graphicsDataPool.length; ++t)
                    this.graphicsDataPool[t].destroy();
                this.graphicsDataPool = null
            }
            ,
            i.prototype.render = function(t) {
                var e, r = this.renderer, i = r.gl, s = r.shaderManager.plugins.primitiveShader;
                t.dirty && this.updateGraphics(t, i);
                var o = t._webGL[i.id];
                r.blendModeManager.setBlendMode(t.blendMode);
                for (var a = 0; a < o.data.length; a++)
                    1 === o.data[a].mode ? (e = o.data[a],
                    r.stencilManager.pushStencil(t, e, r),
                    i.drawElements(i.TRIANGLE_FAN, 4, i.UNSIGNED_SHORT, 2 * (e.indices.length - 4)),
                    r.stencilManager.popStencil(t, e, r)) : (e = o.data[a],
                    s = r.shaderManager.primitiveShader,
                    r.shaderManager.setShader(s),
                    i.uniformMatrix3fv(s.uniforms.translationMatrix._location, !1, t.worldTransform.toArray(!0)),
                    i.uniformMatrix3fv(s.uniforms.projectionMatrix._location, !1, r.currentRenderTarget.projectionMatrix.toArray(!0)),
                    i.uniform3fv(s.uniforms.tint._location, n.hex2rgb(t.tint)),
                    i.uniform1f(s.uniforms.alpha._location, t.worldAlpha),
                    i.bindBuffer(i.ARRAY_BUFFER, e.buffer),
                    i.vertexAttribPointer(s.attributes.aVertexPosition, 2, i.FLOAT, !1, 24, 0),
                    i.vertexAttribPointer(s.attributes.aColor, 4, i.FLOAT, !1, 24, 8),
                    i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.indexBuffer),
                    i.drawElements(i.TRIANGLE_STRIP, e.indices.length, i.UNSIGNED_SHORT, 0))
            }
            ,
            i.prototype.updateGraphics = function(t) {
                var e = this.renderer.gl
                  , r = t._webGL[e.id];
                r || (r = t._webGL[e.id] = {
                    lastIndex: 0,
                    data: [],
                    gl: e
                }),
                t.dirty = !1;
                var i;
                if (t.clearDirty) {
                    for (t.clearDirty = !1,
                    i = 0; i < r.data.length; i++) {
                        var n = r.data[i];
                        n.reset(),
                        this.graphicsDataPool.push(n)
                    }
                    r.data = [],
                    r.lastIndex = 0
                }
                var s;
                for (i = r.lastIndex; i < t.graphicsData.length; i++) {
                    var a = t.graphicsData[i];
                    if (a.type === o.SHAPES.POLY) {
                        if (a.points = a.shape.points.slice(),
                        a.shape.closed && (a.points[0] === a.points[a.points.length - 2] && a.points[1] === a.points[a.points.length - 1] || a.points.push(a.points[0], a.points[1])),
                        a.fill && a.points.length >= 6)
                            if (a.points.length < 12) {
                                s = this.switchMode(r, 0);
                                var h = this.buildPoly(a, s);
                                h || (s = this.switchMode(r, 1),
                                this.buildComplexPoly(a, s))
                            } else
                                s = this.switchMode(r, 1),
                                this.buildComplexPoly(a, s);
                        a.lineWidth > 0 && (s = this.switchMode(r, 0),
                        this.buildLine(a, s))
                    } else
                        s = this.switchMode(r, 0),
                        a.type === o.SHAPES.RECT ? this.buildRectangle(a, s) : a.type === o.SHAPES.CIRC || a.type === o.SHAPES.ELIP ? this.buildCircle(a, s) : a.type === o.SHAPES.RREC && this.buildRoundedRectangle(a, s);
                    r.lastIndex++
                }
                for (i = 0; i < r.data.length; i++)
                    s = r.data[i],
                    s.dirty && s.upload()
            }
            ,
            i.prototype.switchMode = function(t, e) {
                var r;
                return t.data.length ? (r = t.data[t.data.length - 1],
                (r.points.length > 32E4 || r.mode !== e || 1 === e) && (r = this.graphicsDataPool.pop() || new u(t.gl),
                r.mode = e,
                t.data.push(r))) : (r = this.graphicsDataPool.pop() || new u(t.gl),
                r.mode = e,
                t.data.push(r)),
                r.dirty = !0,
                r
            }
            ,
            i.prototype.buildRectangle = function(t, e) {
                var r = t.shape
                  , i = r.x
                  , s = r.y
                  , o = r.width
                  , a = r.height;
                if (t.fill) {
                    var h = n.hex2rgb(t.fillColor)
                      , u = t.fillAlpha
                      , l = h[0] * u
                      , c = h[1] * u
                      , d = h[2] * u
                      , p = e.points
                      , f = e.indices
                      , g = p.length / 6;
                    p.push(i, s),
                    p.push(l, c, d, u),
                    p.push(i + o, s),
                    p.push(l, c, d, u),
                    p.push(i, s + a),
                    p.push(l, c, d, u),
                    p.push(i + o, s + a),
                    p.push(l, c, d, u),
                    f.push(g, g, g + 1, g + 2, g + 3, g + 3)
                }
                if (t.lineWidth) {
                    var v = t.points;
                    t.points = [i, s, i + o, s, i + o, s + a, i, s + a, i, s],
                    this.buildLine(t, e),
                    t.points = v
                }
            }
            ,
            i.prototype.buildRoundedRectangle = function(t, e) {
                var r = t.shape
                  , i = r.x
                  , s = r.y
                  , o = r.width
                  , a = r.height
                  , h = r.radius
                  , u = [];
                if (u.push(i, s + h),
                this.quadraticBezierCurve(i, s + a - h, i, s + a, i + h, s + a, u),
                this.quadraticBezierCurve(i + o - h, s + a, i + o, s + a, i + o, s + a - h, u),
                this.quadraticBezierCurve(i + o, s + h, i + o, s, i + o - h, s, u),
                this.quadraticBezierCurve(i + h, s, i, s, i, s + h + 1E-10, u),
                t.fill) {
                    var l = n.hex2rgb(t.fillColor)
                      , c = t.fillAlpha
                      , d = l[0] * c
                      , p = l[1] * c
                      , f = l[2] * c
                      , g = e.points
                      , v = e.indices
                      , y = g.length / 6
                      , m = n.PolyK.Triangulate(u)
                      , x = 0;
                    for (x = 0; x < m.length; x += 3)
                        v.push(m[x] + y),
                        v.push(m[x] + y),
                        v.push(m[x + 1] + y),
                        v.push(m[x + 2] + y),
                        v.push(m[x + 2] + y);
                    for (x = 0; x < u.length; x++)
                        g.push(u[x], u[++x], d, p, f, c)
                }
                if (t.lineWidth) {
                    var _ = t.points;
                    t.points = u,
                    this.buildLine(t, e),
                    t.points = _
                }
            }
            ,
            i.prototype.quadraticBezierCurve = function(t, e, r, i, n, s, o) {
                function a(t, e, r) {
                    var i = e - t;
                    return t + i * r
                }
                for (var h, u, l, c, d, p, f = 20, g = o || [], v = 0, y = 0; y <= f; y++)
                    v = y / f,
                    h = a(t, r, v),
                    u = a(e, i, v),
                    l = a(r, n, v),
                    c = a(i, s, v),
                    d = a(h, l, v),
                    p = a(u, c, v),
                    g.push(d, p);
                return g
            }
            ,
            i.prototype.buildCircle = function(t, e) {
                var r, i, s = t.shape, a = s.x, h = s.y;
                t.type === o.SHAPES.CIRC ? (r = s.radius,
                i = s.radius) : (r = s.width,
                i = s.height);
                var u = 40
                  , l = 2 * Math.PI / u
                  , c = 0;
                if (t.fill) {
                    var d = n.hex2rgb(t.fillColor)
                      , p = t.fillAlpha
                      , f = d[0] * p
                      , g = d[1] * p
                      , v = d[2] * p
                      , y = e.points
                      , m = e.indices
                      , x = y.length / 6;
                    for (m.push(x),
                    c = 0; c < u + 1; c++)
                        y.push(a, h, f, g, v, p),
                        y.push(a + Math.sin(l * c) * r, h + Math.cos(l * c) * i, f, g, v, p),
                        m.push(x++, x++);
                    m.push(x - 1)
                }
                if (t.lineWidth) {
                    var _ = t.points;
                    for (t.points = [],
                    c = 0; c < u + 1; c++)
                        t.points.push(a + Math.sin(l * c) * r, h + Math.cos(l * c) * i);
                    this.buildLine(t, e),
                    t.points = _
                }
            }
            ,
            i.prototype.buildLine = function(t, e) {
                var r = 0
                  , i = t.points;
                if (0 !== i.length) {
                    if (t.lineWidth % 2)
                        for (r = 0; r < i.length; r++)
                            i[r] += .5;
                    var o = new s.Point(i[0],i[1])
                      , a = new s.Point(i[i.length - 2],i[i.length - 1]);
                    if (o.x === a.x && o.y === a.y) {
                        i = i.slice(),
                        i.pop(),
                        i.pop(),
                        a = new s.Point(i[i.length - 2],i[i.length - 1]);
                        var h = a.x + .5 * (o.x - a.x)
                          , u = a.y + .5 * (o.y - a.y);
                        i.unshift(h, u),
                        i.push(h, u)
                    }
                    var l, c, d, p, f, g, v, y, m, x, _, E, b, T, w, S, A, R, M, C, P, O, D, L = e.points, B = e.indices, I = i.length / 2, N = i.length, F = L.length / 6, U = t.lineWidth / 2, k = n.hex2rgb(t.lineColor), G = t.lineAlpha, j = k[0] * G, W = k[1] * G, X = k[2] * G;
                    for (d = i[0],
                    p = i[1],
                    f = i[2],
                    g = i[3],
                    m = -(p - g),
                    x = d - f,
                    D = Math.sqrt(m * m + x * x),
                    m /= D,
                    x /= D,
                    m *= U,
                    x *= U,
                    L.push(d - m, p - x, j, W, X, G),
                    L.push(d + m, p + x, j, W, X, G),
                    r = 1; r < I - 1; r++)
                        d = i[2 * (r - 1)],
                        p = i[2 * (r - 1) + 1],
                        f = i[2 * r],
                        g = i[2 * r + 1],
                        v = i[2 * (r + 1)],
                        y = i[2 * (r + 1) + 1],
                        m = -(p - g),
                        x = d - f,
                        D = Math.sqrt(m * m + x * x),
                        m /= D,
                        x /= D,
                        m *= U,
                        x *= U,
                        _ = -(g - y),
                        E = f - v,
                        D = Math.sqrt(_ * _ + E * E),
                        _ /= D,
                        E /= D,
                        _ *= U,
                        E *= U,
                        w = -x + p - (-x + g),
                        S = -m + f - (-m + d),
                        A = (-m + d) * (-x + g) - (-m + f) * (-x + p),
                        R = -E + y - (-E + g),
                        M = -_ + f - (-_ + v),
                        C = (-_ + v) * (-E + g) - (-_ + f) * (-E + y),
                        P = w * M - R * S,
                        Math.abs(P) < .1 ? (P += 10.1,
                        L.push(f - m, g - x, j, W, X, G),
                        L.push(f + m, g + x, j, W, X, G)) : (l = (S * C - M * A) / P,
                        c = (R * A - w * C) / P,
                        O = (l - f) * (l - f) + (c - g) + (c - g),
                        O > 19600 ? (b = m - _,
                        T = x - E,
                        D = Math.sqrt(b * b + T * T),
                        b /= D,
                        T /= D,
                        b *= U,
                        T *= U,
                        L.push(f - b, g - T),
                        L.push(j, W, X, G),
                        L.push(f + b, g + T),
                        L.push(j, W, X, G),
                        L.push(f - b, g - T),
                        L.push(j, W, X, G),
                        N++) : (L.push(l, c),
                        L.push(j, W, X, G),
                        L.push(f - (l - f), g - (c - g)),
                        L.push(j, W, X, G)));
                    for (d = i[2 * (I - 2)],
                    p = i[2 * (I - 2) + 1],
                    f = i[2 * (I - 1)],
                    g = i[2 * (I - 1) + 1],
                    m = -(p - g),
                    x = d - f,
                    D = Math.sqrt(m * m + x * x),
                    m /= D,
                    x /= D,
                    m *= U,
                    x *= U,
                    L.push(f - m, g - x),
                    L.push(j, W, X, G),
                    L.push(f + m, g + x),
                    L.push(j, W, X, G),
                    B.push(F),
                    r = 0; r < N; r++)
                        B.push(F++);
                    B.push(F - 1)
                }
            }
            ,
            i.prototype.buildComplexPoly = function(t, e) {
                var r = t.points.slice();
                if (!(r.length < 6)) {
                    var i = e.indices;
                    e.points = r,
                    e.alpha = t.fillAlpha,
                    e.color = n.hex2rgb(t.fillColor);
                    for (var s, o, a = 1 / 0, h = -(1 / 0), u = 1 / 0, l = -(1 / 0), c = 0; c < r.length; c += 2)
                        s = r[c],
                        o = r[c + 1],
                        a = s < a ? s : a,
                        h = s > h ? s : h,
                        u = o < u ? o : u,
                        l = o > l ? o : l;
                    r.push(a, u, h, u, h, l, a, l);
                    var d = r.length / 2;
                    for (c = 0; c < d; c++)
                        i.push(c)
                }
            }
            ,
            i.prototype.buildPoly = function(t, e) {
                var r = t.points;
                if (!(r.length < 6)) {
                    var i = e.points
                      , s = e.indices
                      , o = r.length / 2
                      , a = n.hex2rgb(t.fillColor)
                      , h = t.fillAlpha
                      , u = a[0] * h
                      , l = a[1] * h
                      , c = a[2] * h
                      , d = n.PolyK.Triangulate(r);
                    if (!d)
                        return !1;
                    var p = i.length / 6
                      , f = 0;
                    for (f = 0; f < d.length; f += 3)
                        s.push(d[f] + p),
                        s.push(d[f] + p),
                        s.push(d[f + 1] + p),
                        s.push(d[f + 2] + p),
                        s.push(d[f + 2] + p);
                    for (f = 0; f < o; f++)
                        i.push(r[2 * f], r[2 * f + 1], u, l, c, h);
                    return !0
                }
            }
        }
        , {
            "../../const": 18,
            "../../math": 28,
            "../../renderers/webgl/WebGLRenderer": 44,
            "../../renderers/webgl/utils/ObjectRenderer": 58,
            "../../utils": 71,
            "./WebGLGraphicsData": 24
        }],
        24: [function(t, e, r) {
            function i(t) {
                this.gl = t,
                this.color = [0, 0, 0],
                this.points = [],
                this.indices = [],
                this.buffer = t.createBuffer(),
                this.indexBuffer = t.createBuffer(),
                this.mode = 1,
                this.alpha = 1,
                this.dirty = !0,
                this.glPoints = null,
                this.glIndices = null
            }
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.reset = function() {
                this.points.length = 0,
                this.indices.length = 0
            }
            ,
            i.prototype.upload = function() {
                var t = this.gl;
                this.glPoints = new Float32Array(this.points),
                t.bindBuffer(t.ARRAY_BUFFER, this.buffer),
                t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW),
                this.glIndices = new Uint16Array(this.indices),
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
                t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndices, t.STATIC_DRAW),
                this.dirty = !1
            }
            ,
            i.prototype.destroy = function() {
                this.gl = null,
                this.color = null,
                this.points = null,
                this.indices = null,
                this.gl.deleteBuffer(this.buffer),
                this.gl.deleteBuffer(this.indexBuffer),
                this.buffer = null,
                this.indexBuffer = null,
                this.glPoints = null,
                this.glIndices = null
            }
        }
        , {}],
        25: [function(t, e, r) {
            var i = e.exports = Object.assign(t("./const"), t("./math"), {
                utils: t("./utils"),
                math: t("./math"),
                DisplayObject: t("./display/DisplayObject"),
                Container: t("./display/Container"),
                Sprite: t("./sprites/Sprite"),
                ParticleContainer: t("./particles/ParticleContainer"),
                SpriteRenderer: t("./sprites/webgl/SpriteRenderer"),
                ParticleRenderer: t("./particles/webgl/ParticleRenderer"),
                Text: t("./text/Text"),
                Graphics: t("./graphics/Graphics"),
                GraphicsData: t("./graphics/GraphicsData"),
                GraphicsRenderer: t("./graphics/webgl/GraphicsRenderer"),
                Texture: t("./textures/Texture"),
                BaseTexture: t("./textures/BaseTexture"),
                RenderTexture: t("./textures/RenderTexture"),
                VideoBaseTexture: t("./textures/VideoBaseTexture"),
                TextureUvs: t("./textures/TextureUvs"),
                CanvasRenderer: t("./renderers/canvas/CanvasRenderer"),
                CanvasGraphics: t("./renderers/canvas/utils/CanvasGraphics"),
                CanvasBuffer: t("./renderers/canvas/utils/CanvasBuffer"),
                WebGLRenderer: t("./renderers/webgl/WebGLRenderer"),
                ShaderManager: t("./renderers/webgl/managers/ShaderManager"),
                Shader: t("./renderers/webgl/shaders/Shader"),
                ObjectRenderer: t("./renderers/webgl/utils/ObjectRenderer"),
                RenderTarget: t("./renderers/webgl/utils/RenderTarget"),
                AbstractFilter: t("./renderers/webgl/filters/AbstractFilter"),
                autoDetectRenderer: function(t, e, r, n) {
                    return t = t || 800,
                    e = e || 600,
                    !n && i.utils.isWebGLSupported() ? new i.WebGLRenderer(t,e,r) : new i.CanvasRenderer(t,e,r)
                }
            })
        }
        , {
            "./const": 18,
            "./display/Container": 19,
            "./display/DisplayObject": 20,
            "./graphics/Graphics": 21,
            "./graphics/GraphicsData": 22,
            "./graphics/webgl/GraphicsRenderer": 23,
            "./math": 28,
            "./particles/ParticleContainer": 34,
            "./particles/webgl/ParticleRenderer": 36,
            "./renderers/canvas/CanvasRenderer": 39,
            "./renderers/canvas/utils/CanvasBuffer": 40,
            "./renderers/canvas/utils/CanvasGraphics": 41,
            "./renderers/webgl/WebGLRenderer": 44,
            "./renderers/webgl/filters/AbstractFilter": 45,
            "./renderers/webgl/managers/ShaderManager": 51,
            "./renderers/webgl/shaders/Shader": 56,
            "./renderers/webgl/utils/ObjectRenderer": 58,
            "./renderers/webgl/utils/RenderTarget": 60,
            "./sprites/Sprite": 62,
            "./sprites/webgl/SpriteRenderer": 63,
            "./text/Text": 64,
            "./textures/BaseTexture": 65,
            "./textures/RenderTexture": 66,
            "./textures/Texture": 67,
            "./textures/TextureUvs": 68,
            "./textures/VideoBaseTexture": 69,
            "./utils": 71
        }],
        26: [function(t, e, r) {
            function i() {
                this.a = 1,
                this.b = 0,
                this.c = 0,
                this.d = 1,
                this.tx = 0,
                this.ty = 0
            }
            var n = t("./Point");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.fromArray = function(t) {
                this.a = t[0],
                this.b = t[1],
                this.c = t[3],
                this.d = t[4],
                this.tx = t[2],
                this.ty = t[5]
            }
            ,
            i.prototype.toArray = function(t) {
                this.array || (this.array = new Float32Array(9));
                var e = this.array;
                return t ? (e[0] = this.a,
                e[1] = this.b,
                e[2] = 0,
                e[3] = this.c,
                e[4] = this.d,
                e[5] = 0,
                e[6] = this.tx,
                e[7] = this.ty,
                e[8] = 1) : (e[0] = this.a,
                e[1] = this.c,
                e[2] = this.tx,
                e[3] = this.b,
                e[4] = this.d,
                e[5] = this.ty,
                e[6] = 0,
                e[7] = 0,
                e[8] = 1),
                e
            }
            ,
            i.prototype.apply = function(t, e) {
                e = e || new n;
                var r = t.x
                  , i = t.y;
                return e.x = this.a * r + this.c * i + this.tx,
                e.y = this.b * r + this.d * i + this.ty,
                e
            }
            ,
            i.prototype.applyInverse = function(t, e) {
                e = e || new n;
                var r = 1 / (this.a * this.d + this.c * -this.b)
                  , i = t.x
                  , s = t.y;
                return e.x = this.d * r * i + -this.c * r * s + (this.ty * this.c - this.tx * this.d) * r,
                e.y = this.a * r * s + -this.b * r * i + (-this.ty * this.a + this.tx * this.b) * r,
                e
            }
            ,
            i.prototype.translate = function(t, e) {
                return this.tx += t,
                this.ty += e,
                this
            }
            ,
            i.prototype.scale = function(t, e) {
                return this.a *= t,
                this.d *= e,
                this.c *= t,
                this.b *= e,
                this.tx *= t,
                this.ty *= e,
                this
            }
            ,
            i.prototype.rotate = function(t) {
                var e = Math.cos(t)
                  , r = Math.sin(t)
                  , i = this.a
                  , n = this.c
                  , s = this.tx;
                return this.a = i * e - this.b * r,
                this.b = i * r + this.b * e,
                this.c = n * e - this.d * r,
                this.d = n * r + this.d * e,
                this.tx = s * e - this.ty * r,
                this.ty = s * r + this.ty * e,
                this
            }
            ,
            i.prototype.append = function(t) {
                var e = this.a
                  , r = this.b
                  , i = this.c
                  , n = this.d;
                return this.a = t.a * e + t.b * i,
                this.b = t.a * r + t.b * n,
                this.c = t.c * e + t.d * i,
                this.d = t.c * r + t.d * n,
                this.tx = t.tx * e + t.ty * i + this.tx,
                this.ty = t.tx * r + t.ty * n + this.ty,
                this
            }
            ,
            i.prototype.prepend = function(t) {
                var e = this.tx;
                if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
                    var r = this.a
                      , i = this.c;
                    this.a = r * t.a + this.b * t.c,
                    this.b = r * t.b + this.b * t.d,
                    this.c = i * t.a + this.d * t.c,
                    this.d = i * t.b + this.d * t.d
                }
                return this.tx = e * t.a + this.ty * t.c + t.tx,
                this.ty = e * t.b + this.ty * t.d + t.ty,
                this
            }
            ,
            i.prototype.invert = function() {
                var t = this.a
                  , e = this.b
                  , r = this.c
                  , i = this.d
                  , n = this.tx
                  , s = t * i - e * r;
                return this.a = i / s,
                this.b = -e / s,
                this.c = -r / s,
                this.d = t / s,
                this.tx = (r * this.ty - i * n) / s,
                this.ty = -(t * this.ty - e * n) / s,
                this
            }
            ,
            i.prototype.identity = function() {
                return this.a = 1,
                this.b = 0,
                this.c = 0,
                this.d = 1,
                this.tx = 0,
                this.ty = 0,
                this
            }
            ,
            i.prototype.clone = function() {
                var t = new i;
                return t.a = this.a,
                t.b = this.b,
                t.c = this.c,
                t.d = this.d,
                t.tx = this.tx,
                t.ty = this.ty,
                t
            }
            ,
            i.prototype.copy = function(t) {
                return t.a = this.a,
                t.b = this.b,
                t.c = this.c,
                t.d = this.d,
                t.tx = this.tx,
                t.ty = this.ty,
                t
            }
            ,
            i.IDENTITY = new i,
            i.TEMP_MATRIX = new i
        }
        , {
            "./Point": 27
        }],
        27: [function(t, e, r) {
            function i(t, e) {
                this.x = t || 0,
                this.y = e || 0
            }
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.clone = function() {
                return new i(this.x,this.y)
            }
            ,
            i.prototype.copy = function(t) {
                this.set(t.x, t.y)
            }
            ,
            i.prototype.equals = function(t) {
                return t.x === this.x && t.y === this.y
            }
            ,
            i.prototype.set = function(t, e) {
                this.x = t || 0,
                this.y = e || (0 !== e ? this.x : 0)
            }
        }
        , {}],
        28: [function(t, e, r) {
            e.exports = {
                Point: t("./Point"),
                Matrix: t("./Matrix"),
                Circle: t("./shapes/Circle"),
                Ellipse: t("./shapes/Ellipse"),
                Polygon: t("./shapes/Polygon"),
                Rectangle: t("./shapes/Rectangle"),
                RoundedRectangle: t("./shapes/RoundedRectangle")
            }
        }
        , {
            "./Matrix": 26,
            "./Point": 27,
            "./shapes/Circle": 29,
            "./shapes/Ellipse": 30,
            "./shapes/Polygon": 31,
            "./shapes/Rectangle": 32,
            "./shapes/RoundedRectangle": 33
        }],
        29: [function(t, e, r) {
            function i(t, e, r) {
                this.x = t || 0,
                this.y = e || 0,
                this.radius = r || 0,
                this.type = s.SHAPES.CIRC
            }
            var n = t("./Rectangle")
              , s = t("../../const");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.clone = function() {
                return new i(this.x,this.y,this.radius)
            }
            ,
            i.prototype.contains = function(t, e) {
                if (this.radius <= 0)
                    return !1;
                var r = this.x - t
                  , i = this.y - e
                  , n = this.radius * this.radius;
                return r *= r,
                i *= i,
                r + i <= n
            }
            ,
            i.prototype.getBounds = function() {
                return new n(this.x - this.radius,this.y - this.radius,2 * this.radius,2 * this.radius)
            }
        }
        , {
            "../../const": 18,
            "./Rectangle": 32
        }],
        30: [function(t, e, r) {
            function i(t, e, r, i) {
                this.x = t || 0,
                this.y = e || 0,
                this.width = r || 0,
                this.height = i || 0,
                this.type = s.SHAPES.ELIP
            }
            var n = t("./Rectangle")
              , s = t("../../const");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.clone = function() {
                return new i(this.x,this.y,this.width,this.height)
            }
            ,
            i.prototype.contains = function(t, e) {
                if (this.width <= 0 || this.height <= 0)
                    return !1;
                var r = (t - this.x) / this.width
                  , i = (e - this.y) / this.height;
                return r *= r,
                i *= i,
                r + i <= 1
            }
            ,
            i.prototype.getBounds = function() {
                return new n(this.x - this.width,this.y - this.height,this.width,this.height)
            }
        }
        , {
            "../../const": 18,
            "./Rectangle": 32
        }],
        31: [function(t, e, r) {
            function i(t) {
                var e = t;
                if (!Array.isArray(e)) {
                    e = new Array(arguments.length);
                    for (var r = 0; r < e.length; ++r)
                        e[r] = arguments[r]
                }
                if (e[0]instanceof n) {
                    for (var i = [], o = 0, a = e.length; o < a; o++)
                        i.push(e[o].x, e[o].y);
                    e = i
                }
                this.closed = !0,
                this.points = e,
                this.type = s.SHAPES.POLY
            }
            var n = t("../Point")
              , s = t("../../const");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.clone = function() {
                return new i(this.points.slice())
            }
            ,
            i.prototype.contains = function(t, e) {
                for (var r = !1, i = this.points.length / 2, n = 0, s = i - 1; n < i; s = n++) {
                    var o = this.points[2 * n]
                      , a = this.points[2 * n + 1]
                      , h = this.points[2 * s]
                      , u = this.points[2 * s + 1]
                      , l = a > e != u > e && t < (h - o) * (e - a) / (u - a) + o;
                    l && (r = !r)
                }
                return r
            }
        }
        , {
            "../../const": 18,
            "../Point": 27
        }],
        32: [function(t, e, r) {
            function i(t, e, r, i) {
                this.x = t || 0,
                this.y = e || 0,
                this.width = r || 0,
                this.height = i || 0,
                this.type = n.SHAPES.RECT
            }
            var n = t("../../const");
            i.prototype.constructor = i,
            e.exports = i,
            i.EMPTY = new i(0,0,0,0),
            i.prototype.clone = function() {
                return new i(this.x,this.y,this.width,this.height)
            }
            ,
            i.prototype.contains = function(t, e) {
                return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height)
            }
        }
        , {
            "../../const": 18
        }],
        33: [function(t, e, r) {
            function i(t, e, r, i, s) {
                this.x = t || 0,
                this.y = e || 0,
                this.width = r || 0,
                this.height = i || 0,
                this.radius = s || 20,
                this.type = n.SHAPES.RREC
            }
            var n = t("../../const");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.clone = function() {
                return new i(this.x,this.y,this.width,this.height,this.radius)
            }
            ,
            i.prototype.contains = function(t, e) {
                return !(this.width <= 0 || this.height <= 0) && (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height)
            }
        }
        , {
            "../../const": 18
        }],
        34: [function(t, e, r) {
            function i(t, e) {
                n.call(this),
                this._properties = [!1, !0, !1, !1, !1],
                this._size = t || 15E3,
                this._buffers = null,
                this._updateStatic = !1,
                this.interactiveChildren = !1,
                this.blendMode = s.BLEND_MODES.NORMAL,
                this.roundPixels = !0,
                this.setProperties(e)
            }
            var n = t("../display/Container")
              , s = t("../const");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.setProperties = function(t) {
                t && (this._properties[0] = "scale"in t ? !!t.scale : this._properties[0],
                this._properties[1] = "position"in t ? !!t.position : this._properties[1],
                this._properties[2] = "rotation"in t ? !!t.rotation : this._properties[2],
                this._properties[3] = "uvs"in t ? !!t.uvs : this._properties[3],
                this._properties[4] = "alpha"in t ? !!t.alpha : this._properties[4])
            }
            ,
            i.prototype.updateTransform = function() {
                this.displayObjectUpdateTransform()
            }
            ,
            i.prototype.renderWebGL = function(t) {
                this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (t.setObjectRenderer(t.plugins.particle),
                t.plugins.particle.render(this))
            }
            ,
            i.prototype.addChildAt = function(t, e) {
                if (t === this)
                    return t;
                if (e >= 0 && e <= this.children.length)
                    return t.parent && t.parent.removeChild(t),
                    t.parent = this,
                    this.children.splice(e, 0, t),
                    this._updateStatic = !0,
                    t;
                throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
            }
            ,
            i.prototype.removeChildAt = function(t) {
                var e = this.getChildAt(t);
                return e.parent = null,
                this.children.splice(t, 1),
                this._updateStatic = !0,
                e
            }
            ,
            i.prototype.renderCanvas = function(t) {
                if (this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable) {
                    var e = t.context
                      , r = this.worldTransform
                      , i = !0
                      , n = 0
                      , s = 0
                      , o = 0
                      , a = 0;
                    e.globalAlpha = this.worldAlpha,
                    this.displayObjectUpdateTransform();
                    for (var h = 0; h < this.children.length; ++h) {
                        var u = this.children[h];
                        if (u.visible) {
                            var l = u.texture.frame;
                            if (e.globalAlpha = this.worldAlpha * u.alpha,
                            u.rotation % (2 * Math.PI) === 0)
                                i && (e.setTransform(r.a, r.b, r.c, r.d, r.tx, r.ty),
                                i = !1),
                                n = u.anchor.x * (-l.width * u.scale.x) + u.position.x + .5,
                                s = u.anchor.y * (-l.height * u.scale.y) + u.position.y + .5,
                                o = l.width * u.scale.x,
                                a = l.height * u.scale.y;
                            else {
                                i || (i = !0),
                                u.displayObjectUpdateTransform();
                                var c = u.worldTransform;
                                t.roundPixels ? e.setTransform(c.a, c.b, c.c, c.d, 0 | c.tx, 0 | c.ty) : e.setTransform(c.a, c.b, c.c, c.d, c.tx, c.ty),
                                n = u.anchor.x * -l.width + .5,
                                s = u.anchor.y * -l.height + .5,
                                o = l.width,
                                a = l.height
                            }
                            e.drawImage(u.texture.baseTexture.source, l.x, l.y, l.width, l.height, n, s, o, a)
                        }
                    }
                }
            }
            ,
            i.prototype.destroy = function() {
                if (n.prototype.destroy.apply(this, arguments),
                this._buffers)
                    for (var t = 0; t < this._buffers.length; ++t)
                        this._buffers.destroy();
                this._properties = null,
                this._buffers = null
            }
        }
        , {
            "../const": 18,
            "../display/Container": 19
        }],
        35: [function(t, e, r) {
            function i(t, e, r) {
                this.gl = t,
                this.vertSize = 2,
                this.vertByteSize = 4 * this.vertSize,
                this.size = r,
                this.dynamicProperties = [],
                this.staticProperties = [];
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.dynamic ? this.dynamicProperties.push(n) : this.staticProperties.push(n)
                }
                this.staticStride = 0,
                this.staticBuffer = null,
                this.staticData = null,
                this.dynamicStride = 0,
                this.dynamicBuffer = null,
                this.dynamicData = null,
                this.initBuffers()
            }
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.initBuffers = function() {
                var t, e, r = this.gl, i = 0;
                for (this.dynamicStride = 0,
                t = 0; t < this.dynamicProperties.length; t++)
                    e = this.dynamicProperties[t],
                    e.offset = i,
                    i += e.size,
                    this.dynamicStride += e.size;
                this.dynamicData = new Float32Array(this.size * this.dynamicStride * 4),
                this.dynamicBuffer = r.createBuffer(),
                r.bindBuffer(r.ARRAY_BUFFER, this.dynamicBuffer),
                r.bufferData(r.ARRAY_BUFFER, this.dynamicData, r.DYNAMIC_DRAW);
                var n = 0;
                for (this.staticStride = 0,
                t = 0; t < this.staticProperties.length; t++)
                    e = this.staticProperties[t],
                    e.offset = n,
                    n += e.size,
                    this.staticStride += e.size;
                this.staticData = new Float32Array(this.size * this.staticStride * 4),
                this.staticBuffer = r.createBuffer(),
                r.bindBuffer(r.ARRAY_BUFFER, this.staticBuffer),
                r.bufferData(r.ARRAY_BUFFER, this.staticData, r.DYNAMIC_DRAW)
            }
            ,
            i.prototype.uploadDynamic = function(t, e, r) {
                for (var i = this.gl, n = 0; n < this.dynamicProperties.length; n++) {
                    var s = this.dynamicProperties[n];
                    s.uploadFunction(t, e, r, this.dynamicData, this.dynamicStride, s.offset)
                }
                i.bindBuffer(i.ARRAY_BUFFER, this.dynamicBuffer),
                i.bufferSubData(i.ARRAY_BUFFER, 0, this.dynamicData)
            }
            ,
            i.prototype.uploadStatic = function(t, e, r) {
                for (var i = this.gl, n = 0; n < this.staticProperties.length; n++) {
                    var s = this.staticProperties[n];
                    s.uploadFunction(t, e, r, this.staticData, this.staticStride, s.offset)
                }
                i.bindBuffer(i.ARRAY_BUFFER, this.staticBuffer),
                i.bufferSubData(i.ARRAY_BUFFER, 0, this.staticData)
            }
            ,
            i.prototype.bind = function() {
                var t, e, r = this.gl;
                for (r.bindBuffer(r.ARRAY_BUFFER, this.dynamicBuffer),
                t = 0; t < this.dynamicProperties.length; t++)
                    e = this.dynamicProperties[t],
                    r.vertexAttribPointer(e.attribute, e.size, r.FLOAT, !1, 4 * this.dynamicStride, 4 * e.offset);
                for (r.bindBuffer(r.ARRAY_BUFFER, this.staticBuffer),
                t = 0; t < this.staticProperties.length; t++)
                    e = this.staticProperties[t],
                    r.vertexAttribPointer(e.attribute, e.size, r.FLOAT, !1, 4 * this.staticStride, 4 * e.offset)
            }
            ,
            i.prototype.destroy = function() {
                this.dynamicProperties = null,
                this.dynamicData = null,
                this.gl.deleteBuffer(this.dynamicBuffer),
                this.staticProperties = null,
                this.staticData = null,
                this.gl.deleteBuffer(this.staticBuffer)
            }
        }
        , {}],
        36: [function(t, e, r) {
            function i(t) {
                n.call(this, t),
                this.size = 250;
                var e = 6 * this.size;
                this.indices = new Uint16Array(e);
                for (var r = 0, i = 0; r < e; r += 6,
                i += 4)
                    this.indices[r + 0] = i + 0,
                    this.indices[r + 1] = i + 1,
                    this.indices[r + 2] = i + 2,
                    this.indices[r + 3] = i + 0,
                    this.indices[r + 4] = i + 2,
                    this.indices[r + 5] = i + 3;
                this.shader = null,
                this.indexBuffer = null,
                this.properties = null,
                this.tempMatrix = new h.Matrix
            }
            var n = t("../../renderers/webgl/utils/ObjectRenderer")
              , s = t("../../renderers/webgl/WebGLRenderer")
              , o = t("./ParticleShader")
              , a = t("./ParticleBuffer")
              , h = t("../../math");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            s.registerPlugin("particle", i),
            i.prototype.onContextChange = function() {
                var t = this.renderer.gl;
                this.shader = new o(this.renderer.shaderManager),
                this.indexBuffer = t.createBuffer(),
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
                t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
                this.properties = [{
                    attribute: this.shader.attributes.aVertexPosition,
                    dynamic: !1,
                    size: 2,
                    uploadFunction: this.uploadVertices,
                    offset: 0
                }, {
                    attribute: this.shader.attributes.aPositionCoord,
                    dynamic: !0,
                    size: 2,
                    uploadFunction: this.uploadPosition,
                    offset: 0
                }, {
                    attribute: this.shader.attributes.aRotation,
                    dynamic: !1,
                    size: 1,
                    uploadFunction: this.uploadRotation,
                    offset: 0
                }, {
                    attribute: this.shader.attributes.aTextureCoord,
                    dynamic: !1,
                    size: 2,
                    uploadFunction: this.uploadUvs,
                    offset: 0
                }, {
                    attribute: this.shader.attributes.aColor,
                    dynamic: !1,
                    size: 1,
                    uploadFunction: this.uploadAlpha,
                    offset: 0
                }]
            }
            ,
            i.prototype.start = function() {
                var t = this.renderer.gl;
                t.activeTexture(t.TEXTURE0),
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var e = this.shader;
                this.renderer.shaderManager.setShader(e)
            }
            ,
            i.prototype.render = function(t) {
                var e = t.children
                  , r = e.length
                  , i = t._size;
                if (0 !== r) {
                    r > i && (r = i),
                    t._buffers || (t._buffers = this.generateBuffers(t)),
                    this.renderer.blendModeManager.setBlendMode(t.blendMode);
                    var n = this.renderer.gl
                      , s = t.worldTransform.copy(this.tempMatrix);
                    s.prepend(this.renderer.currentRenderTarget.projectionMatrix),
                    n.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, !1, s.toArray(!0)),
                    n.uniform1f(this.shader.uniforms.uAlpha._location, t.worldAlpha);
                    var o = t._updateStatic
                      , a = e[0]._texture.baseTexture;
                    if (a._glTextures[n.id])
                        n.bindTexture(n.TEXTURE_2D, a._glTextures[n.id]);
                    else {
                        if (!this.renderer.updateTexture(a))
                            return;
                        this.properties[0].dynamic && this.properties[3].dynamic || (o = !0)
                    }
                    for (var h = 0, u = 0; u < r; u += this.size) {
                        var l = r - u;
                        l > this.size && (l = this.size);
                        var c = t._buffers[h++];
                        c.uploadDynamic(e, u, l),
                        o && c.uploadStatic(e, u, l),
                        c.bind(this.shader),
                        n.drawElements(n.TRIANGLES, 6 * l, n.UNSIGNED_SHORT, 0),
                        this.renderer.drawCount++
                    }
                    t._updateStatic = !1
                }
            }
            ,
            i.prototype.generateBuffers = function(t) {
                var e, r = this.renderer.gl, i = [], n = t._size;
                for (e = 0; e < t._properties.length; e++)
                    this.properties[e].dynamic = t._properties[e];
                for (e = 0; e < n; e += this.size)
                    i.push(new a(r,this.properties,this.size,this.shader));
                return i
            }
            ,
            i.prototype.uploadVertices = function(t, e, r, i, n, s) {
                for (var o, a, h, u, l, c, d, p, f, g = 0; g < r; g++)
                    o = t[e + g],
                    a = o._texture,
                    u = o.scale.x,
                    l = o.scale.y,
                    a.trim ? (h = a.trim,
                    d = h.x - o.anchor.x * h.width,
                    c = d + a.crop.width,
                    f = h.y - o.anchor.y * h.height,
                    p = f + a.crop.height) : (c = a._frame.width * (1 - o.anchor.x),
                    d = a._frame.width * -o.anchor.x,
                    p = a._frame.height * (1 - o.anchor.y),
                    f = a._frame.height * -o.anchor.y),
                    i[s] = d * u,
                    i[s + 1] = f * l,
                    i[s + n] = c * u,
                    i[s + n + 1] = f * l,
                    i[s + 2 * n] = c * u,
                    i[s + 2 * n + 1] = p * l,
                    i[s + 3 * n] = d * u,
                    i[s + 3 * n + 1] = p * l,
                    s += 4 * n
            }
            ,
            i.prototype.uploadPosition = function(t, e, r, i, n, s) {
                for (var o = 0; o < r; o++) {
                    var a = t[e + o].position;
                    i[s] = a.x,
                    i[s + 1] = a.y,
                    i[s + n] = a.x,
                    i[s + n + 1] = a.y,
                    i[s + 2 * n] = a.x,
                    i[s + 2 * n + 1] = a.y,
                    i[s + 3 * n] = a.x,
                    i[s + 3 * n + 1] = a.y,
                    s += 4 * n
                }
            }
            ,
            i.prototype.uploadRotation = function(t, e, r, i, n, s) {
                for (var o = 0; o < r; o++) {
                    var a = t[e + o].rotation;
                    i[s] = a,
                    i[s + n] = a,
                    i[s + 2 * n] = a,
                    i[s + 3 * n] = a,
                    s += 4 * n
                }
            }
            ,
            i.prototype.uploadUvs = function(t, e, r, i, n, s) {
                for (var o = 0; o < r; o++) {
                    var a = t[e + o]._texture._uvs;
                    a ? (i[s] = a.x0,
                    i[s + 1] = a.y0,
                    i[s + n] = a.x1,
                    i[s + n + 1] = a.y1,
                    i[s + 2 * n] = a.x2,
                    i[s + 2 * n + 1] = a.y2,
                    i[s + 3 * n] = a.x3,
                    i[s + 3 * n + 1] = a.y3,
                    s += 4 * n) : (i[s] = 0,
                    i[s + 1] = 0,
                    i[s + n] = 0,
                    i[s + n + 1] = 0,
                    i[s + 2 * n] = 0,
                    i[s + 2 * n + 1] = 0,
                    i[s + 3 * n] = 0,
                    i[s + 3 * n + 1] = 0,
                    s += 4 * n)
                }
            }
            ,
            i.prototype.uploadAlpha = function(t, e, r, i, n, s) {
                for (var o = 0; o < r; o++) {
                    var a = t[e + o].alpha;
                    i[s] = a,
                    i[s + n] = a,
                    i[s + 2 * n] = a,
                    i[s + 3 * n] = a,
                    s += 4 * n
                }
            }
            ,
            i.prototype.destroy = function() {
                this.renderer.gl && this.renderer.gl.deleteBuffer(this.indexBuffer),
                n.prototype.destroy.apply(this, arguments),
                this.shader.destroy(),
                this.indices = null,
                this.tempMatrix = null
            }
        }
        , {
            "../../math": 28,
            "../../renderers/webgl/WebGLRenderer": 44,
            "../../renderers/webgl/utils/ObjectRenderer": 58,
            "./ParticleBuffer": 35,
            "./ParticleShader": 37
        }],
        37: [function(t, e, r) {
            function i(t) {
                n.call(this, t, ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "uniform mat3 projectionMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "void main(void){", "   vec2 v = aVertexPosition;", "   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);", "   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);", "   v = v + aPositionCoord;", "   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"].join("\n"), ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "uniform float uAlpha;", "void main(void){", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * uAlpha ;", "}"].join("\n"), {
                    uAlpha: {
                        type: "1f",
                        value: 1
                    }
                }, {
                    aPositionCoord: 0,
                    aRotation: 0
                })
            }
            var n = t("../../renderers/webgl/shaders/TextureShader");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i
        }
        , {
            "../../renderers/webgl/shaders/TextureShader": 57
        }],
        38: [function(t, e, r) {
            function i(t, e, r, i) {
                if (a.call(this),
                n.sayHello(t),
                i)
                    for (var h in o.DEFAULT_RENDER_OPTIONS)
                        "undefined" == typeof i[h] && (i[h] = o.DEFAULT_RENDER_OPTIONS[h]);
                else
                    i = o.DEFAULT_RENDER_OPTIONS;
                this.type = o.RENDERER_TYPE.UNKNOWN,
                this.width = e || 800,
                this.height = r || 600,
                this.view = i.view || document.createElement("canvas"),
                this.resolution = i.resolution,
                this.transparent = i.transparent,
                this.autoResize = i.autoResize || !1,
                this.blendModes = null,
                this.preserveDrawingBuffer = i.preserveDrawingBuffer,
                this.clearBeforeRender = i.clearBeforeRender,
                this._backgroundColor = 0,
                this._backgroundColorRgb = [0, 0, 0],
                this._backgroundColorString = "#000000",
                this.backgroundColor = i.backgroundColor || this._backgroundColor,
                this._tempDisplayObjectParent = {
                    worldTransform: new s.Matrix,
                    worldAlpha: 1,
                    children: []
                },
                this._lastObjectRendered = this._tempDisplayObjectParent
            }
            var n = t("../utils")
              , s = t("../math")
              , o = t("../const")
              , a = t("eventemitter3");
            i.prototype = Object.create(a.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                backgroundColor: {
                    get: function() {
                        return this._backgroundColor
                    },
                    set: function(t) {
                        this._backgroundColor = t,
                        this._backgroundColorString = n.hex2string(t),
                        n.hex2rgb(t, this._backgroundColorRgb)
                    }
                }
            }),
            i.prototype.resize = function(t, e) {
                this.width = t * this.resolution,
                this.height = e * this.resolution,
                this.view.width = this.width,
                this.view.height = this.height,
                this.autoResize && (this.view.style.width = this.width / this.resolution + "px",
                this.view.style.height = this.height / this.resolution + "px")
            }
            ,
            i.prototype.destroy = function(t) {
                t && this.view.parent && this.view.parent.removeChild(this.view),
                this.type = o.RENDERER_TYPE.UNKNOWN,
                this.width = 0,
                this.height = 0,
                this.view = null,
                this.resolution = 0,
                this.transparent = !1,
                this.autoResize = !1,
                this.blendModes = null,
                this.preserveDrawingBuffer = !1,
                this.clearBeforeRender = !1,
                this._backgroundColor = 0,
                this._backgroundColorRgb = null,
                this._backgroundColorString = null
            }
        }
        , {
            "../const": 18,
            "../math": 28,
            "../utils": 71,
            eventemitter3: 6
        }],
        39: [function(t, e, r) {
            function i(t, e, r) {
                n.call(this, "Canvas", t, e, r),
                this.type = h.RENDERER_TYPE.CANVAS,
                this.context = this.view.getContext("2d", {
                    alpha: this.transparent
                }),
                this.refresh = !0,
                this.maskManager = new s,
                this.roundPixels = !1,
                this.currentScaleMode = h.SCALE_MODES.DEFAULT,
                this.currentBlendMode = h.BLEND_MODES.NORMAL,
                this.smoothProperty = "imageSmoothingEnabled",
                this.context.imageSmoothingEnabled || (this.context.webkitImageSmoothingEnabled ? this.smoothProperty = "webkitImageSmoothingEnabled" : this.context.mozImageSmoothingEnabled ? this.smoothProperty = "mozImageSmoothingEnabled" : this.context.oImageSmoothingEnabled ? this.smoothProperty = "oImageSmoothingEnabled" : this.context.msImageSmoothingEnabled && (this.smoothProperty = "msImageSmoothingEnabled")),
                this.initPlugins(),
                this._mapBlendModes(),
                this._tempDisplayObjectParent = {
                    worldTransform: new a.Matrix,
                    worldAlpha: 1
                },
                this.resize(t, e)
            }
            var n = t("../SystemRenderer")
              , s = t("./utils/CanvasMaskManager")
              , o = t("../../utils")
              , a = t("../../math")
              , h = t("../../const");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            o.pluginTarget.mixin(i),
            i.prototype.render = function(t) {
                var e = t.parent;
                this._lastObjectRendered = t,
                t.parent = this._tempDisplayObjectParent,
                t.updateTransform(),
                t.parent = e,
                this.context.setTransform(1, 0, 0, 1, 0, 0),
                this.context.globalAlpha = 1,
                this.currentBlendMode = h.BLEND_MODES.NORMAL,
                this.context.globalCompositeOperation = this.blendModes[h.BLEND_MODES.NORMAL],
                navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black",
                this.context.clear()),
                this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : (this.context.fillStyle = this._backgroundColorString,
                this.context.fillRect(0, 0, this.width, this.height))),
                this.renderDisplayObject(t, this.context)
            }
            ,
            i.prototype.destroy = function(t) {
                this.destroyPlugins(),
                n.prototype.destroy.call(this, t),
                this.context = null,
                this.refresh = !0,
                this.maskManager.destroy(),
                this.maskManager = null,
                this.roundPixels = !1,
                this.currentScaleMode = 0,
                this.currentBlendMode = 0,
                this.smoothProperty = null
            }
            ,
            i.prototype.renderDisplayObject = function(t, e) {
                var r = this.context;
                this.context = e,
                t.renderCanvas(this),
                this.context = r
            }
            ,
            i.prototype._mapBlendModes = function() {
                this.blendModes || (this.blendModes = {},
                o.canUseNewCanvasBlendModes() ? (this.blendModes[h.BLEND_MODES.NORMAL] = "source-over",
                this.blendModes[h.BLEND_MODES.ADD] = "lighter",
                this.blendModes[h.BLEND_MODES.MULTIPLY] = "multiply",
                this.blendModes[h.BLEND_MODES.SCREEN] = "screen",
                this.blendModes[h.BLEND_MODES.OVERLAY] = "overlay",
                this.blendModes[h.BLEND_MODES.DARKEN] = "darken",
                this.blendModes[h.BLEND_MODES.LIGHTEN] = "lighten",
                this.blendModes[h.BLEND_MODES.COLOR_DODGE] = "color-dodge",
                this.blendModes[h.BLEND_MODES.COLOR_BURN] = "color-burn",
                this.blendModes[h.BLEND_MODES.HARD_LIGHT] = "hard-light",
                this.blendModes[h.BLEND_MODES.SOFT_LIGHT] = "soft-light",
                this.blendModes[h.BLEND_MODES.DIFFERENCE] = "difference",
                this.blendModes[h.BLEND_MODES.EXCLUSION] = "exclusion",
                this.blendModes[h.BLEND_MODES.HUE] = "hue",
                this.blendModes[h.BLEND_MODES.SATURATION] = "saturation",
                this.blendModes[h.BLEND_MODES.COLOR] = "color",
                this.blendModes[h.BLEND_MODES.LUMINOSITY] = "luminosity") : (this.blendModes[h.BLEND_MODES.NORMAL] = "source-over",
                this.blendModes[h.BLEND_MODES.ADD] = "lighter",
                this.blendModes[h.BLEND_MODES.MULTIPLY] = "source-over",
                this.blendModes[h.BLEND_MODES.SCREEN] = "source-over",
                this.blendModes[h.BLEND_MODES.OVERLAY] = "source-over",
                this.blendModes[h.BLEND_MODES.DARKEN] = "source-over",
                this.blendModes[h.BLEND_MODES.LIGHTEN] = "source-over",
                this.blendModes[h.BLEND_MODES.COLOR_DODGE] = "source-over",
                this.blendModes[h.BLEND_MODES.COLOR_BURN] = "source-over",
                this.blendModes[h.BLEND_MODES.HARD_LIGHT] = "source-over",
                this.blendModes[h.BLEND_MODES.SOFT_LIGHT] = "source-over",
                this.blendModes[h.BLEND_MODES.DIFFERENCE] = "source-over",
                this.blendModes[h.BLEND_MODES.EXCLUSION] = "source-over",
                this.blendModes[h.BLEND_MODES.HUE] = "source-over",
                this.blendModes[h.BLEND_MODES.SATURATION] = "source-over",
                this.blendModes[h.BLEND_MODES.COLOR] = "source-over",
                this.blendModes[h.BLEND_MODES.LUMINOSITY] = "source-over"))
            }
        }
        , {
            "../../const": 18,
            "../../math": 28,
            "../../utils": 71,
            "../SystemRenderer": 38,
            "./utils/CanvasMaskManager": 42
        }],
        40: [function(t, e, r) {
            function i(t, e) {
                this.canvas = document.createElement("canvas"),
                this.context = this.canvas.getContext("2d"),
                this.canvas.width = t,
                this.canvas.height = e
            }
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this.canvas.width
                    },
                    set: function(t) {
                        this.canvas.width = t
                    }
                },
                height: {
                    get: function() {
                        return this.canvas.height
                    },
                    set: function(t) {
                        this.canvas.height = t
                    }
                }
            }),
            i.prototype.clear = function() {
                this.context.setTransform(1, 0, 0, 1, 0, 0),
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
            }
            ,
            i.prototype.resize = function(t, e) {
                this.canvas.width = t,
                this.canvas.height = e
            }
            ,
            i.prototype.destroy = function() {
                this.context = null,
                this.canvas = null
            }
        }
        , {}],
        41: [function(t, e, r) {
            var i = t("../../../const")
              , n = e.exports = {};
            n.renderGraphics = function(t, e) {
                var r = t.worldAlpha;
                t.dirty && (this.updateGraphicsTint(t),
                t.dirty = !1);
                for (var n = 0; n < t.graphicsData.length; n++) {
                    var s = t.graphicsData[n]
                      , o = s.shape
                      , a = s._fillTint
                      , h = s._lineTint;
                    if (e.lineWidth = s.lineWidth,
                    s.type === i.SHAPES.POLY) {
                        e.beginPath();
                        var u = o.points;
                        e.moveTo(u[0], u[1]);
                        for (var l = 1; l < u.length / 2; l++)
                            e.lineTo(u[2 * l], u[2 * l + 1]);
                        o.closed && e.lineTo(u[0], u[1]),
                        u[0] === u[u.length - 2] && u[1] === u[u.length - 1] && e.closePath(),
                        s.fill && (e.globalAlpha = s.fillAlpha * r,
                        e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                        e.fill()),
                        s.lineWidth && (e.globalAlpha = s.lineAlpha * r,
                        e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                        e.stroke())
                    } else if (s.type === i.SHAPES.RECT)
                        (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * r,
                        e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                        e.fillRect(o.x, o.y, o.width, o.height)),
                        s.lineWidth && (e.globalAlpha = s.lineAlpha * r,
                        e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                        e.strokeRect(o.x, o.y, o.width, o.height));
                    else if (s.type === i.SHAPES.CIRC)
                        e.beginPath(),
                        e.arc(o.x, o.y, o.radius, 0, 2 * Math.PI),
                        e.closePath(),
                        s.fill && (e.globalAlpha = s.fillAlpha * r,
                        e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                        e.fill()),
                        s.lineWidth && (e.globalAlpha = s.lineAlpha * r,
                        e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                        e.stroke());
                    else if (s.type === i.SHAPES.ELIP) {
                        var c = 2 * o.width
                          , d = 2 * o.height
                          , p = o.x - c / 2
                          , f = o.y - d / 2;
                        e.beginPath();
                        var g = .5522848
                          , v = c / 2 * g
                          , y = d / 2 * g
                          , m = p + c
                          , x = f + d
                          , _ = p + c / 2
                          , E = f + d / 2;
                        e.moveTo(p, E),
                        e.bezierCurveTo(p, E - y, _ - v, f, _, f),
                        e.bezierCurveTo(_ + v, f, m, E - y, m, E),
                        e.bezierCurveTo(m, E + y, _ + v, x, _, x),
                        e.bezierCurveTo(_ - v, x, p, E + y, p, E),
                        e.closePath(),
                        s.fill && (e.globalAlpha = s.fillAlpha * r,
                        e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                        e.fill()),
                        s.lineWidth && (e.globalAlpha = s.lineAlpha * r,
                        e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                        e.stroke())
                    } else if (s.type === i.SHAPES.RREC) {
                        var b = o.x
                          , T = o.y
                          , w = o.width
                          , S = o.height
                          , A = o.radius
                          , R = Math.min(w, S) / 2 | 0;
                        A = A > R ? R : A,
                        e.beginPath(),
                        e.moveTo(b, T + A),
                        e.lineTo(b, T + S - A),
                        e.quadraticCurveTo(b, T + S, b + A, T + S),
                        e.lineTo(b + w - A, T + S),
                        e.quadraticCurveTo(b + w, T + S, b + w, T + S - A),
                        e.lineTo(b + w, T + A),
                        e.quadraticCurveTo(b + w, T, b + w - A, T),
                        e.lineTo(b + A, T),
                        e.quadraticCurveTo(b, T, b, T + A),
                        e.closePath(),
                        (s.fillColor || 0 === s.fillColor) && (e.globalAlpha = s.fillAlpha * r,
                        e.fillStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6),
                        e.fill()),
                        s.lineWidth && (e.globalAlpha = s.lineAlpha * r,
                        e.strokeStyle = "#" + ("00000" + (0 | h).toString(16)).substr(-6),
                        e.stroke())
                    }
                }
            }
            ,
            n.renderGraphicsMask = function(t, e) {
                var r = t.graphicsData.length;
                if (0 !== r) {
                    e.beginPath();
                    for (var n = 0; n < r; n++) {
                        var s = t.graphicsData[n]
                          , o = s.shape;
                        if (s.type === i.SHAPES.POLY) {
                            var a = o.points;
                            e.moveTo(a[0], a[1]);
                            for (var h = 1; h < a.length / 2; h++)
                                e.lineTo(a[2 * h], a[2 * h + 1]);
                            a[0] === a[a.length - 2] && a[1] === a[a.length - 1] && e.closePath()
                        } else if (s.type === i.SHAPES.RECT)
                            e.rect(o.x, o.y, o.width, o.height),
                            e.closePath();
                        else if (s.type === i.SHAPES.CIRC)
                            e.arc(o.x, o.y, o.radius, 0, 2 * Math.PI),
                            e.closePath();
                        else if (s.type === i.SHAPES.ELIP) {
                            var u = 2 * o.width
                              , l = 2 * o.height
                              , c = o.x - u / 2
                              , d = o.y - l / 2
                              , p = .5522848
                              , f = u / 2 * p
                              , g = l / 2 * p
                              , v = c + u
                              , y = d + l
                              , m = c + u / 2
                              , x = d + l / 2;
                            e.moveTo(c, x),
                            e.bezierCurveTo(c, x - g, m - f, d, m, d),
                            e.bezierCurveTo(m + f, d, v, x - g, v, x),
                            e.bezierCurveTo(v, x + g, m + f, y, m, y),
                            e.bezierCurveTo(m - f, y, c, x + g, c, x),
                            e.closePath()
                        } else if (s.type === i.SHAPES.RREC) {
                            var _ = o.x
                              , E = o.y
                              , b = o.width
                              , T = o.height
                              , w = o.radius
                              , S = Math.min(b, T) / 2 | 0;
                            w = w > S ? S : w,
                            e.moveTo(_, E + w),
                            e.lineTo(_, E + T - w),
                            e.quadraticCurveTo(_, E + T, _ + w, E + T),
                            e.lineTo(_ + b - w, E + T),
                            e.quadraticCurveTo(_ + b, E + T, _ + b, E + T - w),
                            e.lineTo(_ + b, E + w),
                            e.quadraticCurveTo(_ + b, E, _ + b - w, E),
                            e.lineTo(_ + w, E),
                            e.quadraticCurveTo(_, E, _, E + w),
                            e.closePath()
                        }
                    }
                }
            }
            ,
            n.updateGraphicsTint = function(t) {
                if (16777215 !== t.tint)
                    for (var e = (t.tint >> 16 & 255) / 255, r = (t.tint >> 8 & 255) / 255, i = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                        var s = t.graphicsData[n]
                          , o = 0 | s.fillColor
                          , a = 0 | s.lineColor;
                        s._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * r * 255 << 8) + (255 & o) / 255 * i * 255,
                        s._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * r * 255 << 8) + (255 & a) / 255 * i * 255
                    }
            }
        }
        , {
            "../../../const": 18
        }],
        42: [function(t, e, r) {
            function i() {}
            var n = t("./CanvasGraphics");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.pushMask = function(t, e) {
                e.context.save();
                var r = t.alpha
                  , i = t.worldTransform
                  , s = e.resolution;
                e.context.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, i.tx * s, i.ty * s),
                t.texture || (n.renderGraphicsMask(t, e.context),
                e.context.clip()),
                t.worldAlpha = r
            }
            ,
            i.prototype.popMask = function(t) {
                t.context.restore()
            }
        }
        , {
            "./CanvasGraphics": 41
        }],
        43: [function(t, e, r) {
            var i = t("../../../utils")
              , n = e.exports = {};
            n.getTintedTexture = function(t, e) {
                var r = t.texture;
                e = n.roundColor(e);
                var i = "#" + ("00000" + (0 | e).toString(16)).substr(-6);
                if (r.tintCache = r.tintCache || {},
                r.tintCache[i])
                    return r.tintCache[i];
                var s = n.canvas || document.createElement("canvas");
                if (n.tintMethod(r, e, s),
                n.convertTintToImage) {
                    var o = new Image;
                    o.src = s.toDataURL(),
                    r.tintCache[i] = o
                } else
                    r.tintCache[i] = s,
                    n.canvas = null;
                return s
            }
            ,
            n.tintWithMultiply = function(t, e, r) {
                var i = r.getContext("2d")
                  , n = t.crop;
                r.width = n.width,
                r.height = n.height,
                i.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6),
                i.fillRect(0, 0, n.width, n.height),
                i.globalCompositeOperation = "multiply",
                i.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height),
                i.globalCompositeOperation = "destination-atop",
                i.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
            }
            ,
            n.tintWithOverlay = function(t, e, r) {
                var i = r.getContext("2d")
                  , n = t.crop;
                r.width = n.width,
                r.height = n.height,
                i.globalCompositeOperation = "copy",
                i.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6),
                i.fillRect(0, 0, n.width, n.height),
                i.globalCompositeOperation = "destination-atop",
                i.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
            }
            ,
            n.tintWithPerPixel = function(t, e, r) {
                var n = r.getContext("2d")
                  , s = t.crop;
                r.width = s.width,
                r.height = s.height,
                n.globalCompositeOperation = "copy",
                n.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height);
                for (var o = i.hex2rgb(e), a = o[0], h = o[1], u = o[2], l = n.getImageData(0, 0, s.width, s.height), c = l.data, d = 0; d < c.length; d += 4)
                    c[d + 0] *= a,
                    c[d + 1] *= h,
                    c[d + 2] *= u;
                n.putImageData(l, 0, 0)
            }
            ,
            n.roundColor = function(t) {
                var e = n.cacheStepsPerColorChannel
                  , r = i.hex2rgb(t);
                return r[0] = Math.min(255, r[0] / e * e),
                r[1] = Math.min(255, r[1] / e * e),
                r[2] = Math.min(255, r[2] / e * e),
                i.rgb2hex(r)
            }
            ,
            n.cacheStepsPerColorChannel = 8,
            n.convertTintToImage = !1,
            n.canUseMultiply = i.canUseNewCanvasBlendModes(),
            n.tintMethod = n.canUseMultiply ? n.tintWithMultiply : n.tintWithPerPixel
        }
        , {
            "../../../utils": 71
        }],
        44: [function(t, e, r) {
            function i(t, e, r) {
                r = r || {},
                n.call(this, "WebGL", t, e, r),
                this.type = f.RENDERER_TYPE.WEBGL,
                this.handleContextLost = this.handleContextLost.bind(this),
                this.handleContextRestored = this.handleContextRestored.bind(this),
                this.view.addEventListener("webglcontextlost", this.handleContextLost, !1),
                this.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1),
                this._useFXAA = !!r.forceFXAA && r.antialias,
                this._FXAAFilter = null,
                this._contextOptions = {
                    alpha: this.transparent,
                    antialias: r.antialias,
                    premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                    stencil: !0,
                    preserveDrawingBuffer: r.preserveDrawingBuffer
                },
                this.drawCount = 0,
                this.shaderManager = new s(this),
                this.maskManager = new o(this),
                this.stencilManager = new a(this),
                this.filterManager = new h(this),
                this.blendModeManager = new u(this),
                this.currentRenderTarget = null,
                this.currentRenderer = new c(this),
                this.initPlugins(),
                this._initContext(),
                this._mapBlendModes(),
                this._renderTargetStack = []
            }
            var n = t("../SystemRenderer")
              , s = t("./managers/ShaderManager")
              , o = t("./managers/MaskManager")
              , a = t("./managers/StencilManager")
              , h = t("./managers/FilterManager")
              , u = t("./managers/BlendModeManager")
              , l = t("./utils/RenderTarget")
              , c = t("./utils/ObjectRenderer")
              , d = t("./filters/FXAAFilter")
              , p = t("../../utils")
              , f = t("../../const");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            p.pluginTarget.mixin(i),
            i.glContextId = 0,
            i.prototype._initContext = function() {
                var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
                if (this.gl = t,
                !t)
                    throw new Error("This browser does not support webGL. Try using the canvas renderer");
                this.glContextId = i.glContextId++,
                t.id = this.glContextId,
                t.renderer = this,
                t.disable(t.DEPTH_TEST),
                t.disable(t.CULL_FACE),
                t.enable(t.BLEND),
                this.renderTarget = new l(this.gl,this.width,this.height,null,this.resolution,!0),
                this.setRenderTarget(this.renderTarget),
                this.emit("context", t),
                this.resize(this.width, this.height),
                this._useFXAA || (this._useFXAA = this._contextOptions.antialias && !t.getContextAttributes().antialias),
                this._useFXAA && (window.console.warn("FXAA antialiasing being used instead of native antialiasing"),
                this._FXAAFilter = [new d])
            }
            ,
            i.prototype.render = function(t) {
                if (!this.gl.isContextLost()) {
                    this.drawCount = 0,
                    this._lastObjectRendered = t,
                    this._useFXAA && (this._FXAAFilter[0].uniforms.resolution.value.x = this.width,
                    this._FXAAFilter[0].uniforms.resolution.value.y = this.height,
                    t.filterArea = this.renderTarget.size,
                    t.filters = this._FXAAFilter);
                    var e = t.parent;
                    t.parent = this._tempDisplayObjectParent,
                    t.updateTransform(),
                    t.parent = e;
                    var r = this.gl;
                    this.setRenderTarget(this.renderTarget),
                    this.clearBeforeRender && (this.transparent ? r.clearColor(0, 0, 0, 0) : r.clearColor(this._backgroundColorRgb[0], this._backgroundColorRgb[1], this._backgroundColorRgb[2], 1),
                    r.clear(r.COLOR_BUFFER_BIT)),
                    this.renderDisplayObject(t, this.renderTarget)
                }
            }
            ,
            i.prototype.renderDisplayObject = function(t, e, r) {
                this.setRenderTarget(e),
                r && e.clear(),
                this.filterManager.setFilterStack(e.filterStack),
                t.renderWebGL(this),
                this.currentRenderer.flush()
            }
            ,
            i.prototype.setObjectRenderer = function(t) {
                this.currentRenderer !== t && (this.currentRenderer.stop(),
                this.currentRenderer = t,
                this.currentRenderer.start())
            }
            ,
            i.prototype.setRenderTarget = function(t) {
                this.currentRenderTarget !== t && (this.currentRenderTarget = t,
                this.currentRenderTarget.activate(),
                this.stencilManager.setMaskStack(t.stencilMaskStack))
            }
            ,
            i.prototype.resize = function(t, e) {
                n.prototype.resize.call(this, t, e),
                this.gl.viewport(0, 0, this.width, this.height),
                this.filterManager.resize(t, e),
                this.renderTarget.resize(t, e),
                this.currentRenderTarget === this.renderTarget && this.renderTarget.activate()
            }
            ,
            i.prototype.updateTexture = function(t) {
                if (t = t.baseTexture || t,
                t.hasLoaded) {
                    var e = this.gl;
                    return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture(),
                    t.on("update", this.updateTexture, this),
                    t.on("dispose", this.destroyTexture, this)),
                    e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]),
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha),
                    e.texImage2D(e.TEXTURE_2D, 0, t.hasAlpha ? e.RGBA : e.RGB, t.hasAlpha ? e.RGBA : e.RGB, e.UNSIGNED_BYTE, t.source),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === f.SCALE_MODES.LINEAR ? e.LINEAR : e.NEAREST),
                    t.mipmap && t.isPowerOfTwo ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === f.SCALE_MODES.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST),
                    e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === f.SCALE_MODES.LINEAR ? e.LINEAR : e.NEAREST),
                    t.isPowerOfTwo ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)),
                    t._glTextures[e.id]
                }
            }
            ,
            i.prototype.destroyTexture = function(t) {
                t = t.baseTexture || t,
                t.hasLoaded && t._glTextures[this.gl.id] && this.gl.deleteTexture(t._glTextures[this.gl.id])
            }
            ,
            i.prototype.handleContextLost = function(t) {
                t.preventDefault()
            }
            ,
            i.prototype.handleContextRestored = function() {
                this._initContext();
                for (var t in p.BaseTextureCache)
                    p.BaseTextureCache[t]._glTextures.length = 0
            }
            ,
            i.prototype.destroy = function(t) {
                this.destroyPlugins(),
                this.view.removeEventListener("webglcontextlost", this.handleContextLost),
                this.view.removeEventListener("webglcontextrestored", this.handleContextRestored),
                n.prototype.destroy.call(this, t),
                this.uuid = 0,
                this.shaderManager.destroy(),
                this.maskManager.destroy(),
                this.stencilManager.destroy(),
                this.filterManager.destroy(),
                this.shaderManager = null,
                this.maskManager = null,
                this.filterManager = null,
                this.blendModeManager = null,
                this.handleContextLost = null,
                this.handleContextRestored = null,
                this._contextOptions = null,
                this.drawCount = 0,
                this.gl = null
            }
            ,
            i.prototype._mapBlendModes = function() {
                var t = this.gl;
                this.blendModes || (this.blendModes = {},
                this.blendModes[f.BLEND_MODES.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.ADD] = [t.SRC_ALPHA, t.DST_ALPHA],
                this.blendModes[f.BLEND_MODES.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.SCREEN] = [t.SRC_ALPHA, t.ONE],
                this.blendModes[f.BLEND_MODES.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA],
                this.blendModes[f.BLEND_MODES.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA])
            }
        }
        , {
            "../../const": 18,
            "../../utils": 71,
            "../SystemRenderer": 38,
            "./filters/FXAAFilter": 46,
            "./managers/BlendModeManager": 48,
            "./managers/FilterManager": 49,
            "./managers/MaskManager": 50,
            "./managers/ShaderManager": 51,
            "./managers/StencilManager": 52,
            "./utils/ObjectRenderer": 58,
            "./utils/RenderTarget": 60
        }],
        45: [function(t, e, r) {
            function i(t, e, r) {
                this.shaders = [],
                this.padding = 0,
                this.uniforms = r || {},
                this.vertexSrc = t || n.defaultVertexSrc,
                this.fragmentSrc = e || n.defaultFragmentSrc
            }
            var n = t("../shaders/TextureShader");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.getShader = function(t) {
                var e = t.gl
                  , r = this.shaders[e.id];
                return r || (r = new n(t.shaderManager,this.vertexSrc,this.fragmentSrc,this.uniforms,this.attributes),
                this.shaders[e.id] = r),
                r
            }
            ,
            i.prototype.applyFilter = function(t, e, r, i) {
                var n = this.getShader(t);
                t.filterManager.applyFilter(n, e, r, i)
            }
            ,
            i.prototype.syncUniform = function(t) {
                for (var e = 0, r = this.shaders.length; e < r; ++e)
                    this.shaders[e].syncUniform(t)
            }
        }
        , {
            "../shaders/TextureShader": 57
        }],
        46: [function(t, e, r) {
            function i() {
                n.call(this, "\nprecision mediump float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform vec2 resolution;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n            out vec2 v_rgbNW, out vec2 v_rgbNE,\n            out vec2 v_rgbSW, out vec2 v_rgbSE,\n            out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n   vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n   vResolution = resolution;\n\n   //compute the texture coords and send them to varyings\n   texcoords(aTextureCoord * resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", 'precision lowp float;\n\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it\'s\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE,\n            vec2 v_rgbSW, vec2 v_rgbSE,\n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying vec2 vResolution;\n\n//texcoords computed in vertex step\n//to avoid dependent texture reads\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform sampler2D uSampler;\n\n\nvoid main(void){\n\n    gl_FragColor = fxaa(uSampler, vTextureCoord * vResolution, vResolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n}\n', {
                    resolution: {
                        type: "v2",
                        value: {
                            x: 1,
                            y: 1
                        }
                    }
                })
            }
            var n = t("./AbstractFilter");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.applyFilter = function(t, e, r) {
                var i = t.filterManager
                  , n = this.getShader(t);
                i.applyFilter(n, e, r)
            }
        }
        , {
            "./AbstractFilter": 45
        }],
        47: [function(t, e, r) {
            function i(t) {
                var e = new s.Matrix;
                n.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n", "precision lowp float;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    original *= (masky.r * masky.a * alpha * clip);\n    gl_FragColor = original;\n}\n", {
                    mask: {
                        type: "sampler2D",
                        value: t._texture
                    },
                    alpha: {
                        type: "f",
                        value: 1
                    },
                    otherMatrix: {
                        type: "mat3",
                        value: e.toArray(!0)
                    }
                }),
                this.maskSprite = t,
                this.maskMatrix = e
            }
            var n = t("./AbstractFilter")
              , s = t("../../../math");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.applyFilter = function(t, e, r) {
                var i = t.filterManager;
                this.uniforms.mask.value = this.maskSprite._texture,
                i.calculateMappedMatrix(e.frame, this.maskSprite, this.maskMatrix),
                this.uniforms.otherMatrix.value = this.maskMatrix.toArray(!0),
                this.uniforms.alpha.value = this.maskSprite.worldAlpha;
                var n = this.getShader(t);
                i.applyFilter(n, e, r)
            }
            ,
            Object.defineProperties(i.prototype, {
                map: {
                    get: function() {
                        return this.uniforms.mask.value
                    },
                    set: function(t) {
                        this.uniforms.mask.value = t
                    }
                },
                offset: {
                    get: function() {
                        return this.uniforms.offset.value
                    },
                    set: function(t) {
                        this.uniforms.offset.value = t
                    }
                }
            })
        }
        , {
            "../../../math": 28,
            "./AbstractFilter": 45
        }],
        48: [function(t, e, r) {
            function i(t) {
                n.call(this, t),
                this.currentBlendMode = 99999
            }
            var n = t("./WebGLManager");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.setBlendMode = function(t) {
                if (this.currentBlendMode === t)
                    return !1;
                this.currentBlendMode = t;
                var e = this.renderer.blendModes[this.currentBlendMode];
                return this.renderer.gl.blendFunc(e[0], e[1]),
                !0
            }
        }
        , {
            "./WebGLManager": 53
        }],
        49: [function(t, e, r) {
            function i(t) {
                n.call(this, t),
                this.filterStack = [],
                this.filterStack.push({
                    renderTarget: t.currentRenderTarget,
                    filter: [],
                    bounds: null
                }),
                this.texturePool = [],
                this.textureSize = new h.Rectangle(0,0,t.width,t.height),
                this.currentFrame = null
            }
            var n = t("./WebGLManager")
              , s = t("../utils/RenderTarget")
              , o = t("../../../const")
              , a = t("../utils/Quad")
              , h = t("../../../math");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.onContextChange = function() {
                this.texturePool.length = 0;
                var t = this.renderer.gl;
                this.quad = new a(t)
            }
            ,
            i.prototype.setFilterStack = function(t) {
                this.filterStack = t
            }
            ,
            i.prototype.pushFilter = function(t, e) {
                var r = t.filterArea ? t.filterArea.clone() : t.getBounds();
                r.x = 0 | r.x,
                r.y = 0 | r.y,
                r.width = 0 | r.width,
                r.height = 0 | r.height;
                var i = 0 | e[0].padding;
                if (r.x -= i,
                r.y -= i,
                r.width += 2 * i,
                r.height += 2 * i,
                this.renderer.currentRenderTarget.transform) {
                    var n = this.renderer.currentRenderTarget.transform;
                    r.x += n.tx,
                    r.y += n.ty,
                    this.capFilterArea(r),
                    r.x -= n.tx,
                    r.y -= n.ty
                } else
                    this.capFilterArea(r);
                if (r.width > 0 && r.height > 0) {
                    this.currentFrame = r;
                    var s = this.getRenderTarget();
                    this.renderer.setRenderTarget(s),
                    s.clear(),
                    this.filterStack.push({
                        renderTarget: s,
                        filter: e
                    })
                } else
                    this.filterStack.push({
                        renderTarget: null,
                        filter: e
                    })
            }
            ,
            i.prototype.popFilter = function() {
                var t = this.filterStack.pop()
                  , e = this.filterStack[this.filterStack.length - 1]
                  , r = t.renderTarget;
                if (t.renderTarget) {
                    var i = e.renderTarget
                      , n = this.renderer.gl;
                    this.currentFrame = r.frame,
                    this.quad.map(this.textureSize, r.frame),
                    n.bindBuffer(n.ARRAY_BUFFER, this.quad.vertexBuffer),
                    n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);
                    var s = t.filter;
                    if (n.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, n.FLOAT, !1, 0, 0),
                    n.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, n.FLOAT, !1, 0, 32),
                    n.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, n.FLOAT, !1, 0, 64),
                    this.renderer.blendModeManager.setBlendMode(o.BLEND_MODES.NORMAL),
                    1 === s.length)
                        s[0].uniforms.dimensions && (s[0].uniforms.dimensions.value[0] = this.renderer.width,
                        s[0].uniforms.dimensions.value[1] = this.renderer.height,
                        s[0].uniforms.dimensions.value[2] = this.quad.vertices[0],
                        s[0].uniforms.dimensions.value[3] = this.quad.vertices[5]),
                        s[0].applyFilter(this.renderer, r, i),
                        this.returnRenderTarget(r);
                    else {
                        for (var a = r, h = this.getRenderTarget(!0), u = 0; u < s.length - 1; u++) {
                            var l = s[u];
                            l.uniforms.dimensions && (l.uniforms.dimensions.value[0] = this.renderer.width,
                            l.uniforms.dimensions.value[1] = this.renderer.height,
                            l.uniforms.dimensions.value[2] = this.quad.vertices[0],
                            l.uniforms.dimensions.value[3] = this.quad.vertices[5]),
                            l.applyFilter(this.renderer, a, h);
                            var c = a;
                            a = h,
                            h = c
                        }
                        s[s.length - 1].applyFilter(this.renderer, a, i),
                        this.returnRenderTarget(a),
                        this.returnRenderTarget(h)
                    }
                    return t.filter
                }
            }
            ,
            i.prototype.getRenderTarget = function(t) {
                var e = this.texturePool.pop() || new s(this.renderer.gl,this.textureSize.width,this.textureSize.height,o.SCALE_MODES.LINEAR,this.renderer.resolution * o.FILTER_RESOLUTION);
                return e.frame = this.currentFrame,
                t && e.clear(!0),
                e
            }
            ,
            i.prototype.returnRenderTarget = function(t) {
                this.texturePool.push(t)
            }
            ,
            i.prototype.applyFilter = function(t, e, r, i) {
                var n = this.renderer.gl;
                this.renderer.setRenderTarget(r),
                i && r.clear(),
                this.renderer.shaderManager.setShader(t),
                t.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(!0),
                t.syncUniforms(),
                n.activeTexture(n.TEXTURE0),
                n.bindTexture(n.TEXTURE_2D, e.texture),
                n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0)
            }
            ,
            i.prototype.calculateMappedMatrix = function(t, e, r) {
                var i = e.worldTransform.copy(h.Matrix.TEMP_MATRIX)
                  , n = e._texture.baseTexture
                  , s = r.identity()
                  , o = this.textureSize.height / this.textureSize.width;
                s.translate(t.x / this.textureSize.width, t.y / this.textureSize.height),
                s.scale(1, o);
                var a = this.textureSize.width / n.width
                  , u = this.textureSize.height / n.height;
                return i.tx /= n.width * a,
                i.ty /= n.width * a,
                i.invert(),
                s.prepend(i),
                s.scale(1, 1 / o),
                s.scale(a, u),
                s.translate(e.anchor.x, e.anchor.y),
                s
            }
            ,
            i.prototype.capFilterArea = function(t) {
                t.x < 0 && (t.width += t.x,
                t.x = 0),
                t.y < 0 && (t.height += t.y,
                t.y = 0),
                t.x + t.width > this.textureSize.width && (t.width = this.textureSize.width - t.x),
                t.y + t.height > this.textureSize.height && (t.height = this.textureSize.height - t.y)
            }
            ,
            i.prototype.resize = function(t, e) {
                this.textureSize.width = t,
                this.textureSize.height = e;
                for (var r = 0; r < this.texturePool.length; r++)
                    this.texturePool[r].resize(t, e)
            }
            ,
            i.prototype.destroy = function() {
                this.filterStack = null,
                this.offsetY = 0;
                for (var t = 0; t < this.texturePool.length; t++)
                    this.texturePool[t].destroy();
                this.texturePool = null
            }
        }
        , {
            "../../../const": 18,
            "../../../math": 28,
            "../utils/Quad": 59,
            "../utils/RenderTarget": 60,
            "./WebGLManager": 53
        }],
        50: [function(t, e, r) {
            function i(t) {
                n.call(this, t),
                this.stencilStack = [],
                this.reverse = !0,
                this.count = 0,
                this.alphaMaskPool = []
            }
            var n = t("./WebGLManager")
              , s = t("../filters/SpriteMaskFilter");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.pushMask = function(t, e) {
                e.texture ? this.pushSpriteMask(t, e) : this.pushStencilMask(t, e)
            }
            ,
            i.prototype.popMask = function(t, e) {
                e.texture ? this.popSpriteMask(t, e) : this.popStencilMask(t, e)
            }
            ,
            i.prototype.pushSpriteMask = function(t, e) {
                var r = this.alphaMaskPool.pop();
                r || (r = [new s(e)]),
                r[0].maskSprite = e,
                this.renderer.filterManager.pushFilter(t, r)
            }
            ,
            i.prototype.popSpriteMask = function() {
                var t = this.renderer.filterManager.popFilter();
                this.alphaMaskPool.push(t)
            }
            ,
            i.prototype.pushStencilMask = function(t, e) {
                this.renderer.stencilManager.pushMask(e)
            }
            ,
            i.prototype.popStencilMask = function(t, e) {
                this.renderer.stencilManager.popMask(e)
            }
        }
        , {
            "../filters/SpriteMaskFilter": 47,
            "./WebGLManager": 53
        }],
        51: [function(t, e, r) {
            function i(t) {
                n.call(this, t),
                this.maxAttibs = 10,
                this.attribState = [],
                this.tempAttribState = [];
                for (var e = 0; e < this.maxAttibs; e++)
                    this.attribState[e] = !1;
                this.stack = [],
                this._currentId = -1,
                this.currentShader = null
            }
            var n = t("./WebGLManager")
              , s = t("../shaders/TextureShader")
              , o = t("../shaders/ComplexPrimitiveShader")
              , a = t("../shaders/PrimitiveShader")
              , h = t("../../../utils");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            h.pluginTarget.mixin(i),
            e.exports = i,
            i.prototype.onContextChange = function() {
                this.initPlugins();
                var t = this.renderer.gl;
                this.maxAttibs = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                this.attribState = [];
                for (var e = 0; e < this.maxAttibs; e++)
                    this.attribState[e] = !1;
                this.defaultShader = new s(this),
                this.primitiveShader = new a(this),
                this.complexPrimitiveShader = new o(this)
            }
            ,
            i.prototype.setAttribs = function(t) {
                var e;
                for (e = 0; e < this.tempAttribState.length; e++)
                    this.tempAttribState[e] = !1;
                for (var r in t)
                    this.tempAttribState[t[r]] = !0;
                var i = this.renderer.gl;
                for (e = 0; e < this.attribState.length; e++)
                    this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e],
                    this.attribState[e] ? i.enableVertexAttribArray(e) : i.disableVertexAttribArray(e))
            }
            ,
            i.prototype.setShader = function(t) {
                return this._currentId !== t.uuid && (this._currentId = t.uuid,
                this.currentShader = t,
                this.renderer.gl.useProgram(t.program),
                this.setAttribs(t.attributes),
                !0)
            }
            ,
            i.prototype.destroy = function() {
                n.prototype.destroy.call(this),
                this.destroyPlugins(),
                this.attribState = null,
                this.tempAttribState = null
            }
        }
        , {
            "../../../utils": 71,
            "../shaders/ComplexPrimitiveShader": 54,
            "../shaders/PrimitiveShader": 55,
            "../shaders/TextureShader": 57,
            "./WebGLManager": 53
        }],
        52: [function(t, e, r) {
            function i(t) {
                n.call(this, t),
                this.stencilMaskStack = null
            }
            var n = t("./WebGLManager")
              , s = t("../../../utils");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.setMaskStack = function(t) {
                this.stencilMaskStack = t;
                var e = this.renderer.gl;
                0 === t.stencilStack.length ? e.disable(e.STENCIL_TEST) : e.enable(e.STENCIL_TEST)
            }
            ,
            i.prototype.pushStencil = function(t, e) {
                this.renderer.currentRenderTarget.attachStencilBuffer();
                var r = this.renderer.gl
                  , i = this.stencilMaskStack;
                this.bindGraphics(t, e, this.renderer),
                0 === i.stencilStack.length && (r.enable(r.STENCIL_TEST),
                r.clear(r.STENCIL_BUFFER_BIT),
                i.reverse = !0,
                i.count = 0),
                i.stencilStack.push(e);
                var n = i.count;
                r.colorMask(!1, !1, !1, !1),
                r.stencilFunc(r.ALWAYS, 0, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.INVERT),
                1 === e.mode ? (r.drawElements(r.TRIANGLE_FAN, e.indices.length - 4, r.UNSIGNED_SHORT, 0),
                i.reverse ? (r.stencilFunc(r.EQUAL, 255 - n, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.DECR)) : (r.stencilFunc(r.EQUAL, n, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.INCR)),
                r.drawElements(r.TRIANGLE_FAN, 4, r.UNSIGNED_SHORT, 2 * (e.indices.length - 4)),
                i.reverse ? r.stencilFunc(r.EQUAL, 255 - (n + 1), 255) : r.stencilFunc(r.EQUAL, n + 1, 255),
                i.reverse = !i.reverse) : (i.reverse ? (r.stencilFunc(r.EQUAL, n, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.INCR)) : (r.stencilFunc(r.EQUAL, 255 - n, 255),
                r.stencilOp(r.KEEP, r.KEEP, r.DECR)),
                r.drawElements(r.TRIANGLE_STRIP, e.indices.length, r.UNSIGNED_SHORT, 0),
                i.reverse ? r.stencilFunc(r.EQUAL, n + 1, 255) : r.stencilFunc(r.EQUAL, 255 - (n + 1), 255)),
                r.colorMask(!0, !0, !0, !0),
                r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
                i.count++
            }
            ,
            i.prototype.bindGraphics = function(t, e) {
                this._currentGraphics = t;
                var r, i = this.renderer.gl;
                1 === e.mode ? (r = this.renderer.shaderManager.complexPrimitiveShader,
                this.renderer.shaderManager.setShader(r),
                i.uniformMatrix3fv(r.uniforms.translationMatrix._location, !1, t.worldTransform.toArray(!0)),
                i.uniformMatrix3fv(r.uniforms.projectionMatrix._location, !1, this.renderer.currentRenderTarget.projectionMatrix.toArray(!0)),
                i.uniform3fv(r.uniforms.tint._location, s.hex2rgb(t.tint)),
                i.uniform3fv(r.uniforms.color._location, e.color),
                i.uniform1f(r.uniforms.alpha._location, t.worldAlpha),
                i.bindBuffer(i.ARRAY_BUFFER, e.buffer),
                i.vertexAttribPointer(r.attributes.aVertexPosition, 2, i.FLOAT, !1, 8, 0),
                i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (r = this.renderer.shaderManager.primitiveShader,
                this.renderer.shaderManager.setShader(r),
                i.uniformMatrix3fv(r.uniforms.translationMatrix._location, !1, t.worldTransform.toArray(!0)),
                i.uniformMatrix3fv(r.uniforms.projectionMatrix._location, !1, this.renderer.currentRenderTarget.projectionMatrix.toArray(!0)),
                i.uniform3fv(r.uniforms.tint._location, s.hex2rgb(t.tint)),
                i.uniform1f(r.uniforms.alpha._location, t.worldAlpha),
                i.bindBuffer(i.ARRAY_BUFFER, e.buffer),
                i.vertexAttribPointer(r.attributes.aVertexPosition, 2, i.FLOAT, !1, 24, 0),
                i.vertexAttribPointer(r.attributes.aColor, 4, i.FLOAT, !1, 24, 8),
                i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
            }
            ,
            i.prototype.popStencil = function(t, e) {
                var r = this.renderer.gl
                  , i = this.stencilMaskStack;
                if (i.stencilStack.pop(),
                i.count--,
                0 === i.stencilStack.length)
                    r.disable(r.STENCIL_TEST);
                else {
                    var n = i.count;
                    this.bindGraphics(t, e, this.renderer),
                    r.colorMask(!1, !1, !1, !1),
                    1 === e.mode ? (i.reverse = !i.reverse,
                    i.reverse ? (r.stencilFunc(r.EQUAL, 255 - (n + 1), 255),
                    r.stencilOp(r.KEEP, r.KEEP, r.INCR)) : (r.stencilFunc(r.EQUAL, n + 1, 255),
                    r.stencilOp(r.KEEP, r.KEEP, r.DECR)),
                    r.drawElements(r.TRIANGLE_FAN, 4, r.UNSIGNED_SHORT, 2 * (e.indices.length - 4)),
                    r.stencilFunc(r.ALWAYS, 0, 255),
                    r.stencilOp(r.KEEP, r.KEEP, r.INVERT),
                    r.drawElements(r.TRIANGLE_FAN, e.indices.length - 4, r.UNSIGNED_SHORT, 0),
                    i.reverse ? r.stencilFunc(r.EQUAL, n, 255) : r.stencilFunc(r.EQUAL, 255 - n, 255)) : (i.reverse ? (r.stencilFunc(r.EQUAL, n + 1, 255),
                    r.stencilOp(r.KEEP, r.KEEP, r.DECR)) : (r.stencilFunc(r.EQUAL, 255 - (n + 1), 255),
                    r.stencilOp(r.KEEP, r.KEEP, r.INCR)),
                    r.drawElements(r.TRIANGLE_STRIP, e.indices.length, r.UNSIGNED_SHORT, 0),
                    i.reverse ? r.stencilFunc(r.EQUAL, n, 255) : r.stencilFunc(r.EQUAL, 255 - n, 255)),
                    r.colorMask(!0, !0, !0, !0),
                    r.stencilOp(r.KEEP, r.KEEP, r.KEEP)
                }
            }
            ,
            i.prototype.destroy = function() {
                n.prototype.destroy.call(this),
                this.stencilMaskStack.stencilStack = null
            }
            ,
            i.prototype.pushMask = function(t) {
                this.renderer.setObjectRenderer(this.renderer.plugins.graphics),
                t.dirty && this.renderer.plugins.graphics.updateGraphics(t, this.renderer.gl),
                t._webGL[this.renderer.gl.id].data.length && this.pushStencil(t, t._webGL[this.renderer.gl.id].data[0], this.renderer)
            }
            ,
            i.prototype.popMask = function(t) {
                this.renderer.setObjectRenderer(this.renderer.plugins.graphics),
                this.popStencil(t, t._webGL[this.renderer.gl.id].data[0], this.renderer)
            }
        }
        , {
            "../../../utils": 71,
            "./WebGLManager": 53
        }],
        53: [function(t, e, r) {
            function i(t) {
                this.renderer = t,
                this.renderer.on("context", this.onContextChange, this)
            }
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.onContextChange = function() {}
            ,
            i.prototype.destroy = function() {
                this.renderer.off("context", this.onContextChange),
                this.renderer = null
            }
        }
        , {}],
        54: [function(t, e, r) {
            function i(t) {
                n.call(this, t, ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform mat3 projectionMatrix;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"].join("\n"), ["precision mediump float;", "varying vec4 vColor;", "void main(void){", "   gl_FragColor = vColor;", "}"].join("\n"), {
                    tint: {
                        type: "3f",
                        value: [0, 0, 0]
                    },
                    alpha: {
                        type: "1f",
                        value: 0
                    },
                    color: {
                        type: "3f",
                        value: [0, 0, 0]
                    },
                    translationMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    },
                    projectionMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    }
                }, {
                    aVertexPosition: 0
                })
            }
            var n = t("./Shader");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i
        }
        , {
            "./Shader": 56
        }],
        55: [function(t, e, r) {
            function i(t) {
                n.call(this, t, ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform mat3 projectionMatrix;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"].join("\n"), ["precision mediump float;", "varying vec4 vColor;", "void main(void){", "   gl_FragColor = vColor;", "}"].join("\n"), {
                    tint: {
                        type: "3f",
                        value: [0, 0, 0]
                    },
                    alpha: {
                        type: "1f",
                        value: 0
                    },
                    translationMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    },
                    projectionMatrix: {
                        type: "mat3",
                        value: new Float32Array(9)
                    }
                }, {
                    aVertexPosition: 0,
                    aColor: 0
                })
            }
            var n = t("./Shader");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i
        }
        , {
            "./Shader": 56
        }],
        56: [function(t, e, r) {
            function i(t, e, r, i, s) {
                if (!e || !r)
                    throw new Error("Pixi.js Error. Shader requires vertexSrc and fragmentSrc");
                this.uuid = n.uuid(),
                this.gl = t.renderer.gl,
                this.shaderManager = t,
                this.program = null,
                this.uniforms = i || {},
                this.attributes = s || {},
                this.textureCount = 1,
                this.vertexSrc = e,
                this.fragmentSrc = r,
                this.init()
            }
            var n = t("../../../utils");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.init = function() {
                this.compile(),
                this.gl.useProgram(this.program),
                this.cacheUniformLocations(Object.keys(this.uniforms)),
                this.cacheAttributeLocations(Object.keys(this.attributes))
            }
            ,
            i.prototype.cacheUniformLocations = function(t) {
                for (var e = 0; e < t.length; ++e)
                    this.uniforms[t[e]]._location = this.gl.getUniformLocation(this.program, t[e])
            }
            ,
            i.prototype.cacheAttributeLocations = function(t) {
                for (var e = 0; e < t.length; ++e)
                    this.attributes[t[e]] = this.gl.getAttribLocation(this.program, t[e])
            }
            ,
            i.prototype.compile = function() {
                var t = this.gl
                  , e = this._glCompile(t.VERTEX_SHADER, this.vertexSrc)
                  , r = this._glCompile(t.FRAGMENT_SHADER, this.fragmentSrc)
                  , i = t.createProgram();
                return t.attachShader(i, e),
                t.attachShader(i, r),
                t.linkProgram(i),
                t.getProgramParameter(i, t.LINK_STATUS) || (console.error("Pixi.js Error: Could not initialize shader."),
                console.error("gl.VALIDATE_STATUS", t.getProgramParameter(i, t.VALIDATE_STATUS)),
                console.error("gl.getError()", t.getError()),
                "" !== t.getProgramInfoLog(i) && console.warn("Pixi.js Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(i)),
                t.deleteProgram(i),
                i = null),
                t.deleteShader(e),
                t.deleteShader(r),
                this.program = i
            }
            ,
            i.prototype.syncUniform = function(t) {
                var e, r, i = t._location, s = t.value, o = this.gl;
                switch (t.type) {
                case "i":
                case "1i":
                    o.uniform1i(i, s);
                    break;
                case "f":
                case "1f":
                    o.uniform1f(i, s);
                    break;
                case "2f":
                    o.uniform2f(i, s[0], s[1]);
                    break;
                case "3f":
                    o.uniform3f(i, s[0], s[1], s[2]);
                    break;
                case "4f":
                    o.uniform4f(i, s[0], s[1], s[2], s[3]);
                    break;
                case "v2":
                    o.uniform2f(i, s.x, s.y);
                    break;
                case "v3":
                    o.uniform3f(i, s.x, s.y, s.z);
                    break;
                case "v4":
                    o.uniform4f(i, s.x, s.y, s.z, s.w);
                    break;
                case "1iv":
                    o.uniform1iv(i, s);
                    break;
                case "2iv":
                    o.uniform2iv(i, s);
                    break;
                case "3iv":
                    o.uniform3iv(i, s);
                    break;
                case "4iv":
                    o.uniform4iv(i, s);
                    break;
                case "1fv":
                    o.uniform1fv(i, s);
                    break;
                case "2fv":
                    o.uniform2fv(i, s);
                    break;
                case "3fv":
                    o.uniform3fv(i, s);
                    break;
                case "4fv":
                    o.uniform4fv(i, s);
                    break;
                case "m2":
                case "mat2":
                case "Matrix2fv":
                    o.uniformMatrix2fv(i, t.transpose, s);
                    break;
                case "m3":
                case "mat3":
                case "Matrix3fv":
                    o.uniformMatrix3fv(i, t.transpose, s);
                    break;
                case "m4":
                case "mat4":
                case "Matrix4fv":
                    o.uniformMatrix4fv(i, t.transpose, s);
                    break;
                case "c":
                    "number" == typeof s && (s = n.hex2rgb(s)),
                    o.uniform3f(i, s[0], s[1], s[2]);
                    break;
                case "iv1":
                    o.uniform1iv(i, s);
                    break;
                case "iv":
                    o.uniform3iv(i, s);
                    break;
                case "fv1":
                    o.uniform1fv(i, s);
                    break;
                case "fv":
                    o.uniform3fv(i, s);
                    break;
                case "v2v":
                    for (t._array || (t._array = new Float32Array(2 * s.length)),
                    e = 0,
                    r = s.length; e < r; ++e)
                        t._array[2 * e] = s[e].x,
                        t._array[2 * e + 1] = s[e].y;
                    o.uniform2fv(i, t._array);
                    break;
                case "v3v":
                    for (t._array || (t._array = new Float32Array(3 * s.length)),
                    e = 0,
                    r = s.length; e < r; ++e)
                        t._array[3 * e] = s[e].x,
                        t._array[3 * e + 1] = s[e].y,
                        t._array[3 * e + 2] = s[e].z;
                    o.uniform3fv(i, t._array);
                    break;
                case "v4v":
                    for (t._array || (t._array = new Float32Array(4 * s.length)),
                    e = 0,
                    r = s.length; e < r; ++e)
                        t._array[4 * e] = s[e].x,
                        t._array[4 * e + 1] = s[e].y,
                        t._array[4 * e + 2] = s[e].z,
                        t._array[4 * e + 3] = s[e].w;
                    o.uniform4fv(i, t._array);
                    break;
                case "t":
                case "sampler2D":
                    if (!t.value || !t.value.baseTexture.hasLoaded)
                        break;
                    o.activeTexture(o["TEXTURE" + this.textureCount]);
                    var a = t.value.baseTexture._glTextures[o.id];
                    a || this.initSampler2D(t),
                    o.bindTexture(o.TEXTURE_2D, a),
                    o.uniform1i(t._location, this.textureCount),
                    this.textureCount++;
                    break;
                default:
                    console.warn("Pixi.js Shader Warning: Unknown uniform type: " + t.type)
                }
            }
            ,
            i.prototype.syncUniforms = function() {
                this.textureCount = 1;
                for (var t in this.uniforms)
                    this.syncUniform(this.uniforms[t])
            }
            ,
            i.prototype.initSampler2D = function(t) {
                var e = this.gl
                  , r = t.value.baseTexture;
                if (r.hasLoaded)
                    if (t.textureData) {
                        var i = t.textureData;
                        r._glTextures[e.id] = e.createTexture(),
                        e.bindTexture(e.TEXTURE_2D, r._glTextures[e.id]),
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultipliedAlpha),
                        e.texImage2D(e.TEXTURE_2D, 0, i.luminance ? e.LUMINANCE : e.RGBA, e.RGBA, e.UNSIGNED_BYTE, r.source),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, i.magFilter ? i.magFilter : e.LINEAR),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE)
                    } else
                        this.shaderManager.renderer.updateTexture(r)
            }
            ,
            i.prototype.destroy = function() {
                this.gl.deleteProgram(this.program),
                this.gl = null,
                this.uniforms = null,
                this.attributes = null,
                this.vertexSrc = null,
                this.fragmentSrc = null
            }
            ,
            i.prototype._glCompile = function(t, e) {
                var r = this.gl.createShader(t);
                return this.gl.shaderSource(r, e),
                this.gl.compileShader(r),
                this.gl.getShaderParameter(r, this.gl.COMPILE_STATUS) ? r : (console.log(this.gl.getShaderInfoLog(r)),
                null)
            }
        }
        , {
            "../../../utils": 71
        }],
        57: [function(t, e, r) {
            function i(t, e, r, s, o) {
                var a = {
                    uSampler: {
                        type: "sampler2D",
                        value: 0
                    },
                    projectionMatrix: {
                        type: "mat3",
                        value: new Float32Array(1,0,0,0,1,0,0,0,1)
                    }
                };
                if (s)
                    for (var h in s)
                        a[h] = s[h];
                var u = {
                    aVertexPosition: 0,
                    aTextureCoord: 0,
                    aColor: 0
                };
                if (o)
                    for (var l in o)
                        u[l] = o[l];
                e = e || i.defaultVertexSrc,
                r = r || i.defaultFragmentSrc,
                n.call(this, t, e, r, a, u)
            }
            var n = t("./Shader");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.defaultVertexSrc = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform mat3 projectionMatrix;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"].join("\n"),
            i.defaultFragmentSrc = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void){", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"].join("\n")
        }
        , {
            "./Shader": 56
        }],
        58: [function(t, e, r) {
            function i(t) {
                n.call(this, t)
            }
            var n = t("../managers/WebGLManager");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.start = function() {}
            ,
            i.prototype.stop = function() {
                this.flush()
            }
            ,
            i.prototype.flush = function() {}
            ,
            i.prototype.render = function(t) {}
        }
        , {
            "../managers/WebGLManager": 53
        }],
        59: [function(t, e, r) {
            function i(t) {
                this.gl = t,
                this.vertices = new Float32Array([0, 0, 200, 0, 200, 200, 0, 200]),
                this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                this.colors = new Float32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
                this.indices = new Uint16Array([0, 1, 2, 0, 3, 2]),
                this.vertexBuffer = t.createBuffer(),
                this.indexBuffer = t.createBuffer(),
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
                t.bufferData(t.ARRAY_BUFFER, 128, t.DYNAMIC_DRAW),
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
                t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
                this.upload()
            }
            i.prototype.constructor = i,
            i.prototype.map = function(t, e) {
                var r = 0
                  , i = 0;
                this.uvs[0] = r,
                this.uvs[1] = i,
                this.uvs[2] = r + e.width / t.width,
                this.uvs[3] = i,
                this.uvs[4] = r + e.width / t.width,
                this.uvs[5] = i + e.height / t.height,
                this.uvs[6] = r,
                this.uvs[7] = i + e.height / t.height,
                r = e.x,
                i = e.y,
                this.vertices[0] = r,
                this.vertices[1] = i,
                this.vertices[2] = r + e.width,
                this.vertices[3] = i,
                this.vertices[4] = r + e.width,
                this.vertices[5] = i + e.height,
                this.vertices[6] = r,
                this.vertices[7] = i + e.height,
                this.upload()
            }
            ,
            i.prototype.upload = function() {
                var t = this.gl;
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
                t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices),
                t.bufferSubData(t.ARRAY_BUFFER, 32, this.uvs),
                t.bufferSubData(t.ARRAY_BUFFER, 64, this.colors)
            }
            ,
            e.exports = i
        }
        , {}],
        60: [function(t, e, r) {
            var i = t("../../../math")
              , n = t("../../../utils")
              , s = t("../../../const")
              , o = t("./StencilMaskStack")
              , a = function(t, e, r, a, h, u) {
                if (this.gl = t,
                this.frameBuffer = null,
                this.texture = null,
                this.size = new i.Rectangle(0,0,1,1),
                this.resolution = h || s.RESOLUTION,
                this.projectionMatrix = new i.Matrix,
                this.transform = null,
                this.frame = null,
                this.stencilBuffer = null,
                this.stencilMaskStack = new o,
                this.filterStack = [{
                    renderTarget: this,
                    filter: [],
                    bounds: this.size
                }],
                this.scaleMode = a || s.SCALE_MODES.DEFAULT,
                this.root = u,
                !this.root) {
                    this.frameBuffer = t.createFramebuffer(),
                    this.texture = t.createTexture(),
                    t.bindTexture(t.TEXTURE_2D, this.texture),
                    t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, a === s.SCALE_MODES.LINEAR ? t.LINEAR : t.NEAREST),
                    t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, a === s.SCALE_MODES.LINEAR ? t.LINEAR : t.NEAREST);
                    var l = n.isPowerOfTwo(e, r);
                    l ? (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT),
                    t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT)) : (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                    t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)),
                    t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer),
                    t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0)
                }
                this.resize(e, r)
            };
            a.prototype.constructor = a,
            e.exports = a,
            a.prototype.clear = function(t) {
                var e = this.gl;
                t && e.bindFramebuffer(e.FRAMEBUFFER, this.frameBuffer),
                e.clearColor(0, 0, 0, 0),
                e.clear(e.COLOR_BUFFER_BIT)
            }
            ,
            a.prototype.attachStencilBuffer = function() {
                if (!this.stencilBuffer && !this.root) {
                    var t = this.gl;
                    this.stencilBuffer = t.createRenderbuffer(),
                    t.bindRenderbuffer(t.RENDERBUFFER, this.stencilBuffer),
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.stencilBuffer),
                    t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, this.size.width * this.resolution, this.size.height * this.resolution)
                }
            }
            ,
            a.prototype.activate = function() {
                var t = this.gl;
                t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer);
                var e = this.frame || this.size;
                this.calculateProjection(e),
                this.transform && this.projectionMatrix.append(this.transform),
                t.viewport(0, 0, e.width * this.resolution, e.height * this.resolution)
            }
            ,
            a.prototype.calculateProjection = function(t) {
                var e = this.projectionMatrix;
                e.identity(),
                this.root ? (e.a = 1 / t.width * 2,
                e.d = -1 / t.height * 2,
                e.tx = -1 - t.x * e.a,
                e.ty = 1 - t.y * e.d) : (e.a = 1 / t.width * 2,
                e.d = 1 / t.height * 2,
                e.tx = -1 - t.x * e.a,
                e.ty = -1 - t.y * e.d)
            }
            ,
            a.prototype.resize = function(t, e) {
                if (t = 0 | t,
                e = 0 | e,
                this.size.width !== t || this.size.height !== e) {
                    if (this.size.width = t,
                    this.size.height = e,
                    !this.root) {
                        var r = this.gl;
                        r.bindTexture(r.TEXTURE_2D, this.texture),
                        r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, t * this.resolution, e * this.resolution, 0, r.RGBA, r.UNSIGNED_BYTE, null),
                        this.stencilBuffer && (r.bindRenderbuffer(r.RENDERBUFFER, this.stencilBuffer),
                        r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t * this.resolution, e * this.resolution))
                    }
                    var i = this.frame || this.size;
                    this.calculateProjection(i)
                }
            }
            ,
            a.prototype.destroy = function() {
                var t = this.gl;
                t.deleteFramebuffer(this.frameBuffer),
                t.deleteTexture(this.texture),
                this.frameBuffer = null,
                this.texture = null
            }
        }
        , {
            "../../../const": 18,
            "../../../math": 28,
            "../../../utils": 71,
            "./StencilMaskStack": 61
        }],
        61: [function(t, e, r) {
            function i() {
                this.stencilStack = [],
                this.reverse = !0,
                this.count = 0
            }
            i.prototype.constructor = i,
            e.exports = i
        }
        , {}],
        62: [function(t, e, r) {
            function i(t) {
                o.call(this),
                this.anchor = new n.Point,
                this._texture = null,
                this._width = 0,
                this._height = 0,
                this.tint = 16777215,
                this.blendMode = u.BLEND_MODES.NORMAL,
                this.shader = null,
                this.cachedTint = 16777215,
                this.texture = t || s.EMPTY
            }
            var n = t("../math")
              , s = t("../textures/Texture")
              , o = t("../display/Container")
              , a = t("../renderers/canvas/utils/CanvasTinter")
              , h = t("../utils")
              , u = t("../const")
              , l = new n.Point;
            i.prototype = Object.create(o.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this.scale.x * this.texture._frame.width
                    },
                    set: function(t) {
                        this.scale.x = t / this.texture._frame.width,
                        this._width = t
                    }
                },
                height: {
                    get: function() {
                        return this.scale.y * this.texture._frame.height
                    },
                    set: function(t) {
                        this.scale.y = t / this.texture._frame.height,
                        this._height = t
                    }
                },
                texture: {
                    get: function() {
                        return this._texture
                    },
                    set: function(t) {
                        this._texture !== t && (this._texture = t,
                        this.cachedTint = 16777215,
                        t && (t.baseTexture.hasLoaded ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
                    }
                }
            }),
            i.prototype._onTextureUpdate = function() {
                this._width && (this.scale.x = this._width / this.texture.frame.width),
                this._height && (this.scale.y = this._height / this.texture.frame.height)
            }
            ,
            i.prototype._renderWebGL = function(t) {
                t.setObjectRenderer(t.plugins.sprite),
                t.plugins.sprite.render(this)
            }
            ,
            i.prototype.getBounds = function(t) {
                if (!this._currentBounds) {
                    var e, r, i, n, s = this._texture._frame.width, o = this._texture._frame.height, a = s * (1 - this.anchor.x), h = s * -this.anchor.x, u = o * (1 - this.anchor.y), l = o * -this.anchor.y, c = t || this.worldTransform, d = c.a, p = c.b, f = c.c, g = c.d, v = c.tx, y = c.ty;
                    if (0 === p && 0 === f)
                        d < 0 && (d *= -1),
                        g < 0 && (g *= -1),
                        e = d * h + v,
                        r = d * a + v,
                        i = g * l + y,
                        n = g * u + y;
                    else {
                        var m = d * h + f * l + v
                          , x = g * l + p * h + y
                          , _ = d * a + f * l + v
                          , E = g * l + p * a + y
                          , b = d * a + f * u + v
                          , T = g * u + p * a + y
                          , w = d * h + f * u + v
                          , S = g * u + p * h + y;
                        e = m,
                        e = _ < e ? _ : e,
                        e = b < e ? b : e,
                        e = w < e ? w : e,
                        i = x,
                        i = E < i ? E : i,
                        i = T < i ? T : i,
                        i = S < i ? S : i,
                        r = m,
                        r = _ > r ? _ : r,
                        r = b > r ? b : r,
                        r = w > r ? w : r,
                        n = x,
                        n = E > n ? E : n,
                        n = T > n ? T : n,
                        n = S > n ? S : n
                    }
                    if (this.children.length) {
                        var A = this.containerGetBounds();
                        a = A.x,
                        h = A.x + A.width,
                        u = A.y,
                        l = A.y + A.height,
                        e = e < a ? e : a,
                        i = i < u ? i : u,
                        r = r > h ? r : h,
                        n = n > l ? n : l
                    }
                    var R = this._bounds;
                    R.x = e,
                    R.width = r - e,
                    R.y = i,
                    R.height = n - i,
                    this._currentBounds = R
                }
                return this._currentBounds
            }
            ,
            i.prototype.getLocalBounds = function() {
                return this._bounds.x = -this._texture._frame.width * this.anchor.x,
                this._bounds.y = -this._texture._frame.height * this.anchor.y,
                this._bounds.width = this._texture._frame.width,
                this._bounds.height = this._texture._frame.height,
                this._bounds
            }
            ,
            i.prototype.containsPoint = function(t) {
                this.worldTransform.applyInverse(t, l);
                var e, r = this._texture._frame.width, i = this._texture._frame.height, n = -r * this.anchor.x;
                return l.x > n && l.x < n + r && (e = -i * this.anchor.y,
                l.y > e && l.y < e + i)
            }
            ,
            i.prototype._renderCanvas = function(t) {
                if (!(this.texture.crop.width <= 0 || this.texture.crop.height <= 0) && (this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                t.context.globalCompositeOperation = t.blendModes[t.currentBlendMode]),
                this.texture.valid)) {
                    var e, r, i, n, s = this._texture, o = this.worldTransform, h = s.baseTexture.resolution / t.resolution;
                    if (t.context.globalAlpha = this.worldAlpha,
                    t.smoothProperty && t.currentScaleMode !== s.baseTexture.scaleMode && (t.currentScaleMode = s.baseTexture.scaleMode,
                    t.context[t.smoothProperty] = t.currentScaleMode === u.SCALE_MODES.LINEAR),
                    s.rotate) {
                        var l = o.a
                          , c = o.b;
                        o.a = -o.c,
                        o.b = -o.d,
                        o.c = l,
                        o.d = c,
                        i = s.crop.height,
                        n = s.crop.width,
                        e = s.trim ? s.trim.y - this.anchor.y * s.trim.height : this.anchor.y * -s._frame.height,
                        r = s.trim ? s.trim.x - this.anchor.x * s.trim.width : this.anchor.x * -s._frame.width
                    } else
                        i = s.crop.width,
                        n = s.crop.height,
                        e = s.trim ? s.trim.x - this.anchor.x * s.trim.width : this.anchor.x * -s._frame.width,
                        r = s.trim ? s.trim.y - this.anchor.y * s.trim.height : this.anchor.y * -s._frame.height;
                    t.roundPixels ? (t.context.setTransform(o.a, o.b, o.c, o.d, o.tx * t.resolution | 0, o.ty * t.resolution | 0),
                    e = 0 | e,
                    r = 0 | r) : t.context.setTransform(o.a, o.b, o.c, o.d, o.tx * t.resolution, o.ty * t.resolution),
                    16777215 !== this.tint ? (this.cachedTint !== this.tint && (this.cachedTint = this.tint,
                    this.tintedTexture = a.getTintedTexture(this, this.tint)),
                    t.context.drawImage(this.tintedTexture, 0, 0, i * h * t.resolution, n * h * t.resolution, e, r, i * t.resolution, n * t.resolution)) : t.context.drawImage(s.baseTexture.source, s.crop.x * h, s.crop.y * h, i * h * t.resolution, n * h * t.resolution, e, r, i * t.resolution, n * t.resolution)
                }
            }
            ,
            i.prototype.destroy = function(t, e) {
                o.prototype.destroy.call(this),
                this.anchor = null,
                t && this._texture.destroy(e),
                this._texture = null,
                this.shader = null
            }
            ,
            i.fromFrame = function(t) {
                var e = h.TextureCache[t];
                if (!e)
                    throw new Error('The frameId "' + t + '" does not exist in the texture cache');
                return new i(e)
            }
            ,
            i.fromImage = function(t, e, r) {
                return new i(s.fromImage(t, e, r))
            }
        }
        , {
            "../const": 18,
            "../display/Container": 19,
            "../math": 28,
            "../renderers/canvas/utils/CanvasTinter": 43,
            "../textures/Texture": 67,
            "../utils": 71
        }],
        63: [function(t, e, r) {
            function i(t) {
                n.call(this, t),
                this.vertSize = 5,
                this.vertByteSize = 4 * this.vertSize,
                this.size = o.SPRITE_BATCH_SIZE;
                var e = 4 * this.size * this.vertByteSize
                  , r = 6 * this.size;
                this.vertices = new ArrayBuffer(e),
                this.positions = new Float32Array(this.vertices),
                this.colors = new Uint32Array(this.vertices),
                this.indices = new Uint16Array(r),
                this.lastIndexCount = 0;
                for (var i = 0, s = 0; i < r; i += 6,
                s += 4)
                    this.indices[i + 0] = s + 0,
                    this.indices[i + 1] = s + 1,
                    this.indices[i + 2] = s + 2,
                    this.indices[i + 3] = s + 0,
                    this.indices[i + 4] = s + 2,
                    this.indices[i + 5] = s + 3;
                this.drawing = !1,
                this.currentBatchSize = 0,
                this.currentBaseTexture = null,
                this.textures = [],
                this.blendModes = [],
                this.shaders = [],
                this.sprites = [],
                this.shader = null
            }
            var n = t("../../renderers/webgl/utils/ObjectRenderer")
              , s = t("../../renderers/webgl/WebGLRenderer")
              , o = t("../../const");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            s.registerPlugin("sprite", i),
            i.prototype.onContextChange = function() {
                var t = this.renderer.gl;
                this.shader = this.renderer.shaderManager.defaultShader,
                this.vertexBuffer = t.createBuffer(),
                this.indexBuffer = t.createBuffer(),
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer),
                t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW),
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
                t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW),
                this.currentBlendMode = 99999
            }
            ,
            i.prototype.render = function(t) {
                var e = t._texture;
                this.currentBatchSize >= this.size && (this.flush(),
                this.currentBaseTexture = e.baseTexture);
                var r = e._uvs;
                if (r) {
                    var i, n, s, o, a = t.anchor.x, h = t.anchor.y;
                    if (e.trim) {
                        var u = e.trim;
                        n = u.x - a * u.width,
                        i = n + e.crop.width,
                        o = u.y - h * u.height,
                        s = o + e.crop.height
                    } else
                        i = e._frame.width * (1 - a),
                        n = e._frame.width * -a,
                        s = e._frame.height * (1 - h),
                        o = e._frame.height * -h;
                    var l = this.currentBatchSize * this.vertByteSize
                      , c = t.worldTransform
                      , d = c.a
                      , p = c.b
                      , f = c.c
                      , g = c.d
                      , v = c.tx
                      , y = c.ty
                      , m = this.colors
                      , x = this.positions;
                    this.renderer.roundPixels ? (x[l] = d * n + f * o + v | 0,
                    x[l + 1] = g * o + p * n + y | 0,
                    x[l + 5] = d * i + f * o + v | 0,
                    x[l + 6] = g * o + p * i + y | 0,
                    x[l + 10] = d * i + f * s + v | 0,
                    x[l + 11] = g * s + p * i + y | 0,
                    x[l + 15] = d * n + f * s + v | 0,
                    x[l + 16] = g * s + p * n + y | 0) : (x[l] = d * n + f * o + v,
                    x[l + 1] = g * o + p * n + y,
                    x[l + 5] = d * i + f * o + v,
                    x[l + 6] = g * o + p * i + y,
                    x[l + 10] = d * i + f * s + v,
                    x[l + 11] = g * s + p * i + y,
                    x[l + 15] = d * n + f * s + v,
                    x[l + 16] = g * s + p * n + y),
                    x[l + 2] = r.x0,
                    x[l + 3] = r.y0,
                    x[l + 7] = r.x1,
                    x[l + 8] = r.y1,
                    x[l + 12] = r.x2,
                    x[l + 13] = r.y2,
                    x[l + 17] = r.x3,
                    x[l + 18] = r.y3;
                    var _ = t.tint;
                    m[l + 4] = m[l + 9] = m[l + 14] = m[l + 19] = (_ >> 16) + (65280 & _) + ((255 & _) << 16) + (255 * t.worldAlpha << 24),
                    this.sprites[this.currentBatchSize++] = t
                }
            }
            ,
            i.prototype.flush = function() {
                if (0 !== this.currentBatchSize) {
                    var t, e = this.renderer.gl;
                    if (this.currentBatchSize > .5 * this.size)
                        e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices);
                    else {
                        var r = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);
                        e.bufferSubData(e.ARRAY_BUFFER, 0, r)
                    }
                    for (var i, n, s, o, a = 0, h = 0, u = null, l = this.renderer.blendModeManager.currentBlendMode, c = null, d = !1, p = !1, f = 0, g = this.currentBatchSize; f < g; f++)
                        o = this.sprites[f],
                        i = o._texture.baseTexture,
                        n = o.blendMode,
                        s = o.shader || this.shader,
                        d = l !== n,
                        p = c !== s,
                        (u !== i || d || p) && (this.renderBatch(u, a, h),
                        h = f,
                        a = 0,
                        u = i,
                        d && (l = n,
                        this.renderer.blendModeManager.setBlendMode(l)),
                        p && (c = s,
                        t = c.shaders ? c.shaders[e.id] : c,
                        t || (t = c.getShader(this.renderer)),
                        this.renderer.shaderManager.setShader(t),
                        t.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(!0),
                        t.syncUniforms(),
                        e.activeTexture(e.TEXTURE0))),
                        a++;
                    this.renderBatch(u, a, h),
                    this.currentBatchSize = 0
                }
            }
            ,
            i.prototype.renderBatch = function(t, e, r) {
                if (0 !== e) {
                    var i = this.renderer.gl;
                    t._glTextures[i.id] ? i.bindTexture(i.TEXTURE_2D, t._glTextures[i.id]) : this.renderer.updateTexture(t),
                    i.drawElements(i.TRIANGLES, 6 * e, i.UNSIGNED_SHORT, 6 * r * 2),
                    this.renderer.drawCount++
                }
            }
            ,
            i.prototype.start = function() {
                var t = this.renderer.gl;
                t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                var e = this.vertByteSize;
                t.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, t.FLOAT, !1, e, 0),
                t.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, t.FLOAT, !1, e, 8),
                t.vertexAttribPointer(this.shader.attributes.aColor, 4, t.UNSIGNED_BYTE, !0, e, 16)
            }
            ,
            i.prototype.destroy = function() {
                this.renderer.gl.deleteBuffer(this.vertexBuffer),
                this.renderer.gl.deleteBuffer(this.indexBuffer),
                this.shader.destroy(),
                this.renderer = null,
                this.vertices = null,
                this.positions = null,
                this.colors = null,
                this.indices = null,
                this.vertexBuffer = null,
                this.indexBuffer = null,
                this.currentBaseTexture = null,
                this.drawing = !1,
                this.textures = null,
                this.blendModes = null,
                this.shaders = null,
                this.sprites = null,
                this.shader = null
            }
        }
        , {
            "../../const": 18,
            "../../renderers/webgl/WebGLRenderer": 44,
            "../../renderers/webgl/utils/ObjectRenderer": 58
        }],
        64: [function(t, e, r) {
            function i(t, e, r) {
                this.canvas = document.createElement("canvas"),
                this.context = this.canvas.getContext("2d"),
                this.resolution = r || a.RESOLUTION,
                this._text = null,
                this._style = null;
                var i = s.fromCanvas(this.canvas);
                i.trim = new o.Rectangle,
                n.call(this, i),
                this.text = t,
                this.style = e
            }
            var n = t("../sprites/Sprite")
              , s = t("../textures/Texture")
              , o = t("../math")
              , a = t("../const");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.fontPropertiesCache = {},
            i.fontPropertiesCanvas = document.createElement("canvas"),
            i.fontPropertiesContext = i.fontPropertiesCanvas.getContext("2d"),
            Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this.dirty && this.updateText(),
                        this.scale.x * (this._texture._frame.width - this.extraWidthDueToEffects)
                    },
                    set: function(t) {
                        this.scale.x = t / (this._texture._frame.width - this.extraWidthDueToEffects),
                        this._width = t
                    }
                },
                height: {
                    get: function() {
                        return this.dirty && this.updateText(),
                        this.scale.y * (this._texture._frame.height - this._hack_extraOffsetTop - this.extraHeightDueToEffects)
                    },
                    set: function(t) {
                        this.scale.y = t / (this._texture._frame.height - this._hack_extraOffsetTop - this.extraHeightDueToEffects),
                        this._height = t
                    }
                },
                style: {
                    get: function() {
                        return this._style
                    },
                    set: function(t) {
                        t = t || {},
                        t.font = t.font || "bold 20pt Arial",
                        t.fill = t.fill || "black",
                        t.align = t.align || "left",
                        t.stroke = t.stroke || "black",
                        t.strokeThickness = t.strokeThickness || 0,
                        t.wordWrap = t.wordWrap || !1,
                        t.wordWrapWidth = t.wordWrapWidth || 100,
                        t.dropShadow = t.dropShadow || !1,
                        t.dropShadowColor = t.dropShadowColor || "#000000",
                        t.dropShadowAngle = t.dropShadowAngle || Math.PI / 6,
                        t.dropShadowDistance = t.dropShadowDistance || 5,
                        t.blurShadow = t.blurShadow || !1,
                        t.blurShadowX = t.blurShadowX || 5,
                        t.blurShadowY = t.blurShadowY || 5,
                        t.padding = t.padding || 0,
                        t.textBaseline = t.textBaseline || "alphabetic",
                        t.lineJoin = t.lineJoin || "round",
                        t.miterLimit = t.miterLimit || 10,
                        this._style = t,
                        this.dirty = !0
                    }
                },
                text: {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t = t.toString() || " ",
                        this._text !== t && (this._text = t,
                        this.dirty = !0)
                    }
                }
            }),
            i.prototype.updateText = function() {
                var t = this._style;
                this.context.font = t.font;
                for (var e = t.wordWrap ? this.wordWrap(this._text) : this._text, r = e.split(/(?:\r\n|\r|\n)/), i = new Array(r.length), n = 0, s = this.determineFontProperties(t.font), o = 0; o < r.length; o++) {
                    var a = this.context.measureText(r[o]).width;
                    i[o] = a,
                    n = Math.max(n, a)
                }
                var h = n;
                this.extraWidthDueToEffects = t.strokeThickness + (this._hack_NoCutFix ? 0 : s.fontSize),
                t.dropShadow && (this.extraWidthDueToEffects += t.dropShadowDistance),
                t.blurShadow && (this.extraWidthDueToEffects += Math.max(2 * t.dropShadowDistance + Math.abs(t.blurShadowX), 0)),
                h += this.extraWidthDueToEffects,
                this.canvas.width = h * this.resolution;
                var u = this.style.lineHeight || s.fontSize
                  , l = this.style.spacingY || 0
                  , c = u * r.length + l * (r.length - 1) + s.extraSizeTop;
                this.extraHeightDueToEffects = t.strokeThickness,
                t.dropShadow && (this.extraHeightDueToEffects += t.dropShadowDistance),
                t.blurShadow && (this.extraHeightDueToEffects += Math.max(2 * t.dropShadowDistance + Math.abs(t.blurShadowY), 0)),
                c += this.extraHeightDueToEffects,
                this.canvas.height = (c + 2 * this._style.padding) * this.resolution,
                this.context.scale(this.resolution, this.resolution),
                navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height),
                this.context.font = t.font,
                this.context.strokeStyle = t.stroke,
                this.context.lineWidth = t.strokeThickness,
                this.context.textBaseline = t.textBaseline,
                this.context.lineJoin = t.lineJoin,
                this.context.miterLimit = t.miterLimit;
                var d, p;
                if (1 != this._skipUpdateTexture && t.dropShadow) {
                    this.context.fillStyle = t.dropShadowColor;
                    var f = Math.cos(t.dropShadowAngle) * t.dropShadowDistance
                      , g = Math.sin(t.dropShadowAngle) * t.dropShadowDistance;
                    for (o = 0; o < r.length; o++)
                        d = t.strokeThickness / 2 + (this._hack_NoCutFix ? 0 : s.fontSize / 2),
                        p = t.strokeThickness / 2 + o * (u + l) + s.ascent + s.extraSizeTop,
                        "right" === t.align ? d += n - i[o] : "center" === t.align && (d += (n - i[o]) / 2),
                        t.fill && this.context.fillText(r[o], d + f, p + g + this._style.padding)
                }
                if (this.context.fillStyle = t.fill,
                t.blurShadow) {
                    var v = void 0 != window.safari || document.documentElement.className.indexOf("iOS") >= 0 && document.documentElement.className.indexOf("MobileSafari") >= 0;
                    this.context.shadowBlur = t.dropShadowDistance * (v ? .66 : 1),
                    this.context.shadowOffsetX = t.blurShadowX,
                    this.context.shadowOffsetY = t.blurShadowY
                }
                if (1 != this._skipUpdateTexture)
                    for (o = 0; o < r.length; o++) {
                        if (d = t.strokeThickness / 2 + (this._hack_NoCutFix ? 0 : s.fontSize / 2),
                        p = t.strokeThickness / 2 + o * (u + l) + s.ascent + s.extraSizeTop,
                        t.blurShadow && (this.context.shadowColor = t.dropShadowColor,
                        d += Math.max(t.dropShadowDistance - t.blurShadowX, 0),
                        p += Math.max(t.dropShadowDistance - t.blurShadowY, 0)),
                        t.mFillUseGradient || t.mOutlineUseGradient) {
                            var y = .5 * u
                              , m = d + .5 * i[o]
                              , x = t.strokeThickness / 2 + o * (u + l) + y;
                            t.blurShadow && (x += Math.max(t.dropShadowDistance - t.blurShadowY, 0));
                            var _ = .5 * Math.max(i[o], u)
                              , E = 0
                              , b = 0
                              , T = 0
                              , w = 0;
                            if (t.mFillUseGradient) {
                                E = Math.cos(t.mFillGradientAngle + Math.PI) * _,
                                T = Math.sin(t.mFillGradientAngle + Math.PI) * _,
                                T = T >= 0 ? Math.min(T, y) : Math.max(T, -y),
                                b = Math.cos(t.mFillGradientAngle) * _,
                                w = Math.sin(t.mFillGradientAngle) * _,
                                w = w >= 0 ? Math.min(w, y) : Math.max(w, -y);
                                for (var S = this.context.createLinearGradient(m + E, x + T, m + b, x + w), A = 0; A < t.mFillGradient.colorKeys.length; A++)
                                    S.addColorStop(t.mFillGradient.colorKeys[A].time, t.mFillGradient.colorKeys[A].color.rgbAsString());
                                this.context.fillStyle = S
                            }
                            if (t.mOutlineUseGradient) {
                                E = Math.cos(t.mOutlineGradientAngle + Math.PI) * _,
                                T = Math.sin(t.mOutlineGradientAngle + Math.PI) * _,
                                T = T >= 0 ? Math.min(T, y) : Math.max(T, -y),
                                b = Math.cos(t.mOutlineGradientAngle) * _,
                                w = Math.sin(t.mOutlineGradientAngle) * _,
                                w = w >= 0 ? Math.min(w, y) : Math.max(w, -y);
                                for (var R = this.context.createLinearGradient(m + E, x + T, m + b, x + w), M = 0; M < t.mOutlineGradient.colorKeys.length; M++)
                                    R.addColorStop(t.mOutlineGradient.colorKeys[M].time, t.mOutlineGradient.colorKeys[M].color.rgbAsString());
                                this.context.strokeStyle = R
                            }
                        }
                        "right" === t.align ? d += n - i[o] : "center" === t.align && (d += (n - i[o]) / 2),
                        t.stroke && t.strokeThickness && (t.blurShadow && 0 != t.fillCenter && this.context.fillText(r[o], d, p + this._style.padding),
                        this.context.strokeText(r[o], d, p + this._style.padding),
                        this.context.shadowColor = "RGBA(0, 0, 0, 0)"),
                        t.fill && 0 != t.fillCenter && this.context.fillText(r[o], d, p + this._style.padding)
                    }
                this._hack_extraOffsetTop = s.extraSizeTop,
                this._hack_extraOffsetBottom = l,
                this.updateTexture()
            }
            ,
            i.prototype.updateTexture = function() {
                var t = this._texture;
                t.baseTexture.hasLoaded = !0,
                t.baseTexture.resolution = this.resolution,
                t.baseTexture.width = this.canvas.width / this.resolution,
                t.baseTexture.height = this.canvas.height / this.resolution,
                t.crop.width = t._frame.width = this.canvas.width / this.resolution,
                t.crop.height = t._frame.height = this.canvas.height / this.resolution,
                t.trim.x = 0,
                t.trim.y = -this._style.padding,
                t.trim.width = t._frame.width,
                t.trim.height = t._frame.height - 2 * this._style.padding,
                this._width = this.canvas.width / this.resolution,
                this._height = this.canvas.height / this.resolution,
                1 != this._skipUpdateTexture && t.baseTexture.emit("update", t.baseTexture),
                this.dirty = !1
            }
            ,
            i.prototype.renderWebGL = function(t) {
                this.dirty && this.updateText(),
                n.prototype.renderWebGL.call(this, t)
            }
            ,
            i.prototype._renderCanvas = function(t) {
                this.dirty && this.updateText(),
                n.prototype._renderCanvas.call(this, t)
            }
            ,
            i.prototype.determineFontProperties = function(t) {
                var e = i.fontPropertiesCache[t];
                if (!e) {
                    e = {};
                    var r = i.fontPropertiesCanvas
                      , n = i.fontPropertiesContext;
                    n.font = t;
                    var s = Math.ceil(n.measureText("|Mq").width)
                      , o = Math.ceil(n.measureText("M").width)
                      , a = 2 * o;
                    o = 1.4 * o | 0,
                    r.width = s,
                    r.height = a,
                    n.fillStyle = "#f00",
                    n.fillRect(0, 0, s, a),
                    n.font = t,
                    n.textBaseline = "alphabetic",
                    n.fillStyle = "#000",
                    n.fillText("|MEq", 0, o);
                    var h, u, l = n.getImageData(0, 0, s, a).data, c = l.length, d = 4 * s, p = 0, f = !1;
                    for (h = 0; h < o; h++) {
                        for (u = 0; u < d; u += 4)
                            if (255 !== l[p + u]) {
                                f = !0;
                                break
                            }
                        if (f)
                            break;
                        p += d
                    }
                    for (e.ascent = o - h + 1,
                    p = c - d,
                    f = !1,
                    h = a; h > o; h--) {
                        for (u = 0; u < d; u += 4)
                            if (255 !== l[p + u]) {
                                f = !0;
                                break
                            }
                        if (f)
                            break;
                        p -= d
                    }
                    for (e.descent = h - o,
                    e.fontSize = e.ascent + e.descent,
                    n.fillStyle = "#f00",
                    n.fillRect(0, 0, s, a),
                    n.textBaseline = "alphabetic",
                    n.fillStyle = "#000",
                    n.fillText("|Mq", 0, o),
                    l = n.getImageData(0, 0, s, a).data,
                    c = l.length,
                    p = 0,
                    f = !1,
                    h = 0; h < o; h++) {
                        for (u = 0; u < d; u += 4)
                            if (255 !== l[p + u]) {
                                f = !0;
                                break
                            }
                        if (f)
                            break;
                        p += d
                    }
                    e.extraSizeTop = o - h - e.ascent,
                    i.fontPropertiesCache[t] = e
                }
                return e
            }
            ,
            i.prototype.wordWrap = function(t) {
                for (var e = "", r = t.split("\n"), i = this._style.wordWrapWidth, n = 0; n < r.length; n++) {
                    for (var s = i, o = r[n].split(" "), a = 0; a < o.length; a++) {
                        var h = this.context.measureText(o[a]).width
                          , u = h + this.context.measureText(" ").width;
                        0 === a || u > s ? (a > 0 && (e += "\n"),
                        e += o[a],
                        s = i - h) : (s -= u,
                        e += " " + o[a])
                    }
                    n < r.length - 1 && (e += "\n")
                }
                return e
            }
            ,
            i.prototype.getBounds = function(t) {
                return this.dirty && this.updateText(),
                n.prototype.getBounds.call(this, t)
            }
            ,
            i.prototype.destroy = function(t) {
                this.context = null,
                this.canvas = null,
                this._style = null,
                this._texture.destroy(void 0 === t || t)
            }
        }
        , {
            "../const": 18,
            "../math": 28,
            "../sprites/Sprite": 62,
            "../textures/Texture": 67
        }],
        65: [function(t, e, r) {
            function i(t, e, r) {
                o.call(this),
                this.uuid = n.uuid(),
                this.resolution = r || 1,
                this.width = 100,
                this.height = 100,
                this.realWidth = 100,
                this.realHeight = 100,
                this.scaleMode = e || s.SCALE_MODES.DEFAULT,
                this.hasLoaded = !1,
                this.isLoading = !1,
                this.source = null,
                this.premultipliedAlpha = !0,
                this.imageUrl = null,
                this.isPowerOfTwo = !1,
                this.mipmap = !1,
                this._glTextures = [],
                this.hasAlpha = !0,
                t && this.loadSource(t)
            }
            var n = t("../utils")
              , s = t("../const")
              , o = t("eventemitter3");
            i.prototype = Object.create(o.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.update = function() {
                this.realWidth = this.source.naturalWidth || this.source.width,
                this.realHeight = this.source.naturalHeight || this.source.height,
                this.width = this.realWidth / this.resolution,
                this.height = this.realHeight / this.resolution,
                this.isPowerOfTwo = n.isPowerOfTwo(this.realWidth, this.realHeight),
                this.emit("update", this)
            }
            ,
            i.prototype.loadSource = function(t) {
                var e = this.isLoading;
                if (this.hasLoaded = !1,
                this.isLoading = !1,
                e && this.source && (this.source.onload = null,
                this.source.onerror = null),
                this.source = t,
                (this.source.complete || this.source.getContext) && this.source.width && this.source.height)
                    this._sourceLoaded();
                else if (!t.getContext) {
                    this.isLoading = !0;
                    var r = this;
                    t.onload = function() {
                        t.onload = null,
                        t.onerror = null,
                        r.isLoading && (r.isLoading = !1,
                        r._sourceLoaded(),
                        r.emit("loaded", r))
                    }
                    ,
                    t.onerror = function() {
                        t.onload = null,
                        t.onerror = null,
                        r.isLoading && (r.isLoading = !1,
                        r.emit("error", r))
                    }
                    ,
                    t.complete && t.src && (this.isLoading = !1,
                    t.onload = null,
                    t.onerror = null,
                    t.width && t.height ? (this._sourceLoaded(),
                    e && this.emit("loaded", this)) : e && this.emit("error", this))
                }
            }
            ,
            i.prototype._sourceLoaded = function() {
                this.hasLoaded = !0,
                this.update()
            }
            ,
            i.prototype.destroy = function() {
                this.imageUrl ? (delete n.BaseTextureCache[this.imageUrl],
                delete n.TextureCache[this.imageUrl],
                this.imageUrl = null,
                navigator.isCocoonJS || (this.source.src = "")) : this.source && this.source._pixiId && delete n.BaseTextureCache[this.source._pixiId],
                this.source = null,
                this.dispose()
            }
            ,
            i.prototype.dispose = function() {
                this.emit("dispose", this),
                this._glTextures.length = 0
            }
            ,
            i.prototype.updateSourceImage = function(t) {
                this.source.src = t,
                this.loadSource(this.source)
            }
            ;
            var a = function(t, e, r) {
                e = e || "",
                r = r || 262144;
                for (var i = atob(t), n = [], s = 0; s < i.length; s += r) {
                    for (var o = i.slice(s, s + r), a = new Array(o.length), h = 0; h < o.length; h++)
                        a[h] = o.charCodeAt(h);
                    var u = new Uint8Array(a);
                    n.push(u)
                }
                return new Blob(n,{
                    type: e
                })
            };
            i.fromImage = function(t, e, r) {
                void 0 === e && 0 !== t.indexOf("data:") && (e = !0);
                var n = new Image;
                e && (n.crossOrigin = "");
                var s = new i(n,r)
                  , o = void 0 != window.atob && void 0 != window.Blob && void 0 != window.XMLHttpRequest && void 0 != window.URL && 1 != window.UHT_IMAGESLOADER_NOBLOBS && !(navigator.userAgent.indexOf("UCBrowser") > -1);
                if (o)
                    if ("data:image/png" == t.slice(0, 14)) {
                        var h = t.slice(22)
                          , u = a(h, "image/png")
                          , l = URL.createObjectURL(u);
                        n.src = l
                    } else if ("data:image/jpeg" == t.slice(0, 15)) {
                        s.hasAlpha = !1;
                        var c = t.slice(23)
                          , d = a(c, "image/jpeg")
                          , p = URL.createObjectURL(d);
                        n.src = p
                    } else {
                        ".jpg" == t.slice(t.length - 4, t.length) && (this.hasAlpha = !1);
                        var f = n;
                        f.downloadSizeLoaded = -1,
                        f.downloadSizeTotal = -1;
                        var g = new XMLHttpRequest;
                        g.open("GET", t, !0),
                        g.responseType = "arraybuffer",
                        g.onload = function(t) {
                            f.downloadSizeLoaded = f.downloadSizeTotal;
                            var e = new Blob([this.response]);
                            f.src = window.URL.createObjectURL(e)
                        }
                        ,
                        g.onprogress = function(t) {
                            f.downloadSizeLoaded = t.loaded,
                            f.downloadSizeTotal = t.total
                        }
                        ,
                        g.onloadstart = function() {
                            f.downloadSizeLoaded = 0
                        }
                        ,
                        g.send()
                    }
                else
                    "data:image/jpeg" == t.slice(0, 15) && (this.hasAlpha = !1),
                    ".jpg" == t.slice(t.length - 4, t.length) && (this.hasAlpha = !1),
                    n.src = t;
                return s.resolution = 1,
                s
            }
            ,
            i.fromCanvas = function(t, e) {
                t._pixiId || (t._pixiId = "canvas_" + n.uuid());
                var r = n.BaseTextureCache[t._pixiId];
                return r || (r = new i(t,e),
                n.BaseTextureCache[t._pixiId] = r),
                r
            }
        }
        , {
            "../const": 18,
            "../utils": 71,
            eventemitter3: 6
        }],
        66: [function(t, e, r) {
            function i(t, e, r, i, c) {
                if (!t)
                    throw new Error("Unable to create RenderTexture, you must pass a renderer into the constructor.");
                e = e || 100,
                r = r || 100,
                c = c || l.RESOLUTION;
                var d = new n;
                if (d.width = e,
                d.height = r,
                d.resolution = c,
                d.scaleMode = i || l.SCALE_MODES.DEFAULT,
                d.hasLoaded = !0,
                s.call(this, d, new u.Rectangle(0,0,e,r)),
                this.width = e,
                this.height = r,
                this.resolution = c,
                this.render = null,
                this.renderer = t,
                this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                    var p = this.renderer.gl;
                    this.textureBuffer = new o(p,this.width,this.height,d.scaleMode,this.resolution),
                    this.baseTexture._glTextures[p.id] = this.textureBuffer.texture,
                    this.filterManager = new a(this.renderer),
                    this.filterManager.onContextChange(),
                    this.filterManager.resize(e, r),
                    this.render = this.renderWebGL,
                    this.renderer.currentRenderer.start(),
                    this.renderer.currentRenderTarget.activate()
                } else
                    this.render = this.renderCanvas,
                    this.textureBuffer = new h(this.width * this.resolution,this.height * this.resolution),
                    this.baseTexture.source = this.textureBuffer.canvas;
                this.valid = !0,
                this._updateUvs()
            }
            var n = t("./BaseTexture")
              , s = t("./Texture")
              , o = t("../renderers/webgl/utils/RenderTarget")
              , a = t("../renderers/webgl/managers/FilterManager")
              , h = t("../renderers/canvas/utils/CanvasBuffer")
              , u = t("../math")
              , l = t("../const")
              , c = new u.Matrix;
            i.prototype = Object.create(s.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.resize = function(t, e, r) {
                t === this.width && e === this.height || (this.valid = t > 0 && e > 0,
                this.width = this._frame.width = this.crop.width = t,
                this.height = this._frame.height = this.crop.height = e,
                r && (this.baseTexture.width = this.width,
                this.baseTexture.height = this.height),
                this.valid && (this.textureBuffer.resize(this.width * this.resolution, this.height * this.resolution),
                this.filterManager && this.filterManager.resize(this.width, this.height)))
            }
            ,
            i.prototype.clear = function() {
                this.valid && (this.renderer.type === l.RENDERER_TYPE.WEBGL && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer),
                this.textureBuffer.clear())
            }
            ,
            i.prototype.renderWebGL = function(t, e, r, i) {
                if (this.valid) {
                    if (i = void 0 === i || i,
                    this.textureBuffer.transform = e,
                    this.textureBuffer.activate(),
                    t.worldAlpha = t.alpha,
                    i) {
                        t.worldTransform.identity(),
                        t.currentBounds = null;
                        var n, s, o = t.children;
                        for (n = 0,
                        s = o.length; n < s; ++n)
                            o[n].updateTransform()
                    }
                    var a = this.renderer.filterManager;
                    this.renderer.filterManager = this.filterManager,
                    this.renderer.renderDisplayObject(t, this.textureBuffer, r),
                    this.renderer.filterManager = a
                }
            }
            ,
            i.prototype.renderCanvas = function(t, e, r, i) {
                if (this.valid) {
                    i = !!i;
                    var n = t.worldTransform
                      , s = c;
                    s.identity(),
                    e && s.append(e),
                    t.worldTransform = s,
                    t.worldAlpha = 1;
                    var o, a, h = t.children;
                    for (o = 0,
                    a = h.length; o < a; ++o)
                        h[o].updateTransform();
                    r && this.textureBuffer.clear(),
                    t.worldTransform = n;
                    var u = this.textureBuffer.context
                      , l = this.renderer.resolution;
                    this.renderer.resolution = this.resolution,
                    this.renderer.renderDisplayObject(t, u),
                    this.renderer.resolution = l
                }
            }
            ,
            i.prototype.destroy = function() {
                s.prototype.destroy.call(this, !0),
                this.textureBuffer.destroy(),
                this.filterManager && this.filterManager.destroy(),
                this.renderer = null
            }
            ,
            i.prototype.getImage = function() {
                var t = new Image;
                return t.src = this.getBase64(),
                t
            }
            ,
            i.prototype.getBase64 = function() {
                return this.getCanvas().toDataURL()
            }
            ,
            i.prototype.getCanvas = function() {
                if (this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                    var t = this.renderer.gl
                      , e = this.textureBuffer.size.width
                      , r = this.textureBuffer.size.height
                      , i = new Uint8Array(4 * e * r);
                    t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer),
                    t.readPixels(0, 0, e, r, t.RGBA, t.UNSIGNED_BYTE, i),
                    t.bindFramebuffer(t.FRAMEBUFFER, null);
                    var n = new h(e,r)
                      , s = n.context.getImageData(0, 0, e, r);
                    return s.data.set(i),
                    n.context.putImageData(s, 0, 0),
                    n.canvas
                }
                return this.textureBuffer.canvas
            }
            ,
            i.prototype.getPixels = function() {
                var t, e;
                if (this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                    var r = this.renderer.gl;
                    t = this.textureBuffer.size.width,
                    e = this.textureBuffer.size.height;
                    var i = new Uint8Array(4 * t * e);
                    return r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer),
                    r.readPixels(0, 0, t, e, r.RGBA, r.UNSIGNED_BYTE, i),
                    r.bindFramebuffer(r.FRAMEBUFFER, null),
                    i
                }
                return t = this.textureBuffer.canvas.width,
                e = this.textureBuffer.canvas.height,
                this.textureBuffer.canvas.getContext("2d").getImageData(0, 0, t, e).data
            }
            ,
            i.prototype.getPixel = function(t, e) {
                if (this.renderer.type === l.RENDERER_TYPE.WEBGL) {
                    var r = this.renderer.gl
                      , i = new Uint8Array(4);
                    return r.bindFramebuffer(r.FRAMEBUFFER, this.textureBuffer.frameBuffer),
                    r.readPixels(t, e, 1, 1, r.RGBA, r.UNSIGNED_BYTE, i),
                    r.bindFramebuffer(r.FRAMEBUFFER, null),
                    i
                }
                return this.textureBuffer.canvas.getContext("2d").getImageData(t, e, 1, 1).data
            }
            ,
            i.prototype.setPixels = function(t) {
                this.renderer.type !== l.RENDERER_TYPE.WEBGL && this.textureBuffer.canvas.getContext("2d").putImageData(t, 0, 0)
            }
        }
        , {
            "../const": 18,
            "../math": 28,
            "../renderers/canvas/utils/CanvasBuffer": 40,
            "../renderers/webgl/managers/FilterManager": 49,
            "../renderers/webgl/utils/RenderTarget": 60,
            "./BaseTexture": 65,
            "./Texture": 67
        }],
        67: [function(t, e, r) {
            function i(t, e, r, n, s) {
                a.call(this),
                this.noFrame = !1,
                e || (this.noFrame = !0,
                e = new h.Rectangle(0,0,1,1)),
                t instanceof i && (t = t.baseTexture),
                this.baseTexture = t,
                this._frame = e,
                this.trim = n,
                this.valid = !1,
                this.requiresUpdate = !1,
                this._uvs = null,
                this.width = 0,
                this.height = 0,
                this.crop = r || e,
                this.rotate = !!s,
                t.hasLoaded ? (this.noFrame && (e = new h.Rectangle(0,0,t.width,t.height),
                t.on("update", this.onBaseTextureUpdated, this)),
                this.frame = e) : t.once("loaded", this.onBaseTextureLoaded, this)
            }
            var n = t("./BaseTexture")
              , s = t("./VideoBaseTexture")
              , o = t("./TextureUvs")
              , a = t("eventemitter3")
              , h = t("../math")
              , u = t("../utils");
            i.prototype = Object.create(a.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                frame: {
                    get: function() {
                        return this._frame
                    },
                    set: function(t) {
                        if (this._frame = t,
                        this.noFrame = !1,
                        this.width = t.width,
                        this.height = t.height,
                        !this.trim && !this.rotate && (t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height))
                            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                        this.valid = t && t.width && t.height && this.baseTexture.hasLoaded,
                        this.trim ? (this.width = this.trim.width,
                        this.height = this.trim.height,
                        this._frame.width = this.trim.width,
                        this._frame.height = this.trim.height) : this.crop = t,
                        this.valid && this._updateUvs()
                    }
                }
            }),
            i.prototype.update = function() {
                this.baseTexture.update()
            }
            ,
            i.prototype.onBaseTextureLoaded = function(t) {
                this.noFrame ? this.frame = new h.Rectangle(0,0,t.width,t.height) : this.frame = this._frame,
                this.emit("update", this)
            }
            ,
            i.prototype.onBaseTextureUpdated = function(t) {
                this._frame.width = t.width,
                this._frame.height = t.height,
                this.emit("update", this)
            }
            ,
            i.prototype.destroy = function(t) {
                this.baseTexture && (t && this.baseTexture.destroy(),
                this.baseTexture.off("update", this.onBaseTextureUpdated),
                this.baseTexture.off("loaded", this.onBaseTextureLoaded),
                this.baseTexture = null),
                this._frame = null,
                this._uvs = null,
                this.trim = null,
                this.crop = null,
                this.valid = !1
            }
            ,
            i.prototype.clone = function() {
                return new i(this.baseTexture,this.frame,this.crop,this.trim,this.rotate)
            }
            ,
            i.prototype._updateUvs = function() {
                this._uvs || (this._uvs = new o),
                this._uvs.set(this.crop, this.baseTexture, this.rotate)
            }
            ,
            i.fromImage = function(t, e, r, s) {
                if (1 == s) {
                    var o = u.TextureCache[t];
                    if (!o) {
                        var o = new i(n.fromImage(t, e, r));
                        u.TextureCache[t] = o
                    }
                    return o
                }
                return new i(n.fromImage(t, e, r))
            }
            ,
            i.fromFrame = function(t) {
                var e = u.TextureCache[t];
                if (!e)
                    throw new Error('The frameId "' + t + '" does not exist in the texture cache');
                return e
            }
            ,
            i.fromCanvas = function(t, e) {
                return new i(n.fromCanvas(t, e))
            }
            ,
            i.fromVideo = function(t, e) {
                return "string" == typeof t ? i.fromVideoUrl(t, e) : new i(s.fromVideo(t, e))
            }
            ,
            i.fromVideoUrl = function(t, e) {
                return new i(s.fromUrl(t, e))
            }
            ,
            i.addTextureToCache = function(t, e) {
                u.TextureCache[e] = t
            }
            ,
            i.removeTextureFromCache = function(t) {
                var e = u.TextureCache[t];
                return delete u.TextureCache[t],
                delete u.BaseTextureCache[t],
                e
            }
            ,
            i.EMPTY = new i(new n)
        }
        , {
            "../math": 28,
            "../utils": 71,
            "./BaseTexture": 65,
            "./TextureUvs": 68,
            "./VideoBaseTexture": 69,
            eventemitter3: 6
        }],
        68: [function(t, e, r) {
            function i() {
                this.x0 = 0,
                this.y0 = 0,
                this.x1 = 1,
                this.y1 = 0,
                this.x2 = 1,
                this.y2 = 1,
                this.x3 = 0,
                this.y3 = 1
            }
            e.exports = i,
            i.prototype.set = function(t, e, r) {
                var i = e.width
                  , n = e.height;
                r ? (this.x0 = (t.x + t.height) / i,
                this.y0 = t.y / n,
                this.x1 = (t.x + t.height) / i,
                this.y1 = (t.y + t.width) / n,
                this.x2 = t.x / i,
                this.y2 = (t.y + t.width) / n,
                this.x3 = t.x / i,
                this.y3 = t.y / n) : (this.x0 = t.x / i,
                this.y0 = t.y / n,
                this.x1 = (t.x + t.width) / i,
                this.y1 = t.y / n,
                this.x2 = (t.x + t.width) / i,
                this.y2 = (t.y + t.height) / n,
                this.x3 = t.x / i,
                this.y3 = (t.y + t.height) / n)
            }
        }
        , {}],
        69: [function(t, e, r) {
            function i(t, e) {
                if (!t)
                    throw new Error("No video source element specified.");
                (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0),
                s.call(this, t, e),
                this.autoUpdate = !1,
                this._onUpdate = this._onUpdate.bind(this),
                this._onCanPlay = this._onCanPlay.bind(this),
                t.complete || (t.addEventListener("canplay", this._onCanPlay),
                t.addEventListener("canplaythrough", this._onCanPlay),
                t.addEventListener("play", this._onPlayStart.bind(this)),
                t.addEventListener("pause", this._onPlayStop.bind(this))),
                this.__loaded = !1
            }
            function n(t, e) {
                e || (e = "video/" + t.substr(t.lastIndexOf(".") + 1));
                var r = document.createElement("source");
                return r.src = t,
                r.type = e,
                r
            }
            var s = t("./BaseTexture")
              , o = t("../utils");
            i.prototype = Object.create(s.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype._onUpdate = function() {
                this.autoUpdate && (window.requestAnimationFrame(this._onUpdate),
                this.update())
            }
            ,
            i.prototype._onPlayStart = function() {
                this.autoUpdate || (window.requestAnimationFrame(this._onUpdate),
                this.autoUpdate = !0)
            }
            ,
            i.prototype._onPlayStop = function() {
                this.autoUpdate = !1
            }
            ,
            i.prototype._onCanPlay = function() {
                this.hasLoaded = !0,
                this.source && (this.source.removeEventListener("canplay", this._onCanPlay),
                this.source.removeEventListener("canplaythrough", this._onCanPlay),
                this.width = this.source.videoWidth,
                this.height = this.source.videoHeight,
                this.source.play(),
                this.__loaded || (this.__loaded = !0,
                this.emit("loaded", this)))
            }
            ,
            i.prototype.destroy = function() {
                this.source && this.source._pixiId && (delete o.BaseTextureCache[this.source._pixiId],
                delete this.source._pixiId),
                s.prototype.destroy.call(this)
            }
            ,
            i.fromVideo = function(t, e) {
                t._pixiId || (t._pixiId = "video_" + o.uuid());
                var r = o.BaseTextureCache[t._pixiId];
                return r || (r = new i(t,e),
                o.BaseTextureCache[t._pixiId] = r),
                r
            }
            ,
            i.fromUrl = function(t, e) {
                var r = document.createElement("video");
                if (Array.isArray(t))
                    for (var s = 0; s < t.length; ++s)
                        r.appendChild(n(t.src || t, t.mime));
                else
                    r.appendChild(n(t.src || t, t.mime));
                return r.load(),
                r.play(),
                i.fromVideo(r, e)
            }
            ,
            i.fromUrls = i.fromUrl
        }
        , {
            "../utils": 71,
            "./BaseTexture": 65
        }],
        70: [function(t, e, r) {
            var i = e.exports = {};
            i.Triangulate = function(t) {
                var e = !0
                  , r = t.length >> 1;
                if (r < 3)
                    return [];
                for (var n = [], s = [], o = 0; o < r; o++)
                    s.push(o);
                o = 0;
                for (var a = r; a > 3; ) {
                    var h = s[(o + 0) % a]
                      , u = s[(o + 1) % a]
                      , l = s[(o + 2) % a]
                      , c = t[2 * h]
                      , d = t[2 * h + 1]
                      , p = t[2 * u]
                      , f = t[2 * u + 1]
                      , g = t[2 * l]
                      , v = t[2 * l + 1]
                      , y = !1;
                    if (i._convex(c, d, p, f, g, v, e)) {
                        y = !0;
                        for (var m = 0; m < a; m++) {
                            var x = s[m];
                            if (x !== h && x !== u && x !== l && i._PointInTriangle(t[2 * x], t[2 * x + 1], c, d, p, f, g, v)) {
                                y = !1;
                                break
                            }
                        }
                    }
                    if (y)
                        n.push(h, u, l),
                        s.splice((o + 1) % a, 1),
                        a--,
                        o = 0;
                    else if (o++ > 3 * a) {
                        if (!e)
                            return null;
                        for (n = [],
                        s = [],
                        o = 0; o < r; o++)
                            s.push(o);
                        o = 0,
                        a = r,
                        e = !1
                    }
                }
                return n.push(s[0], s[1], s[2]),
                n
            }
            ,
            i._PointInTriangle = function(t, e, r, i, n, s, o, a) {
                var h = o - r
                  , u = a - i
                  , l = n - r
                  , c = s - i
                  , d = t - r
                  , p = e - i
                  , f = h * h + u * u
                  , g = h * l + u * c
                  , v = h * d + u * p
                  , y = l * l + c * c
                  , m = l * d + c * p
                  , x = 1 / (f * y - g * g)
                  , _ = (y * v - g * m) * x
                  , E = (f * m - g * v) * x;
                return _ >= 0 && E >= 0 && _ + E < 1
            }
            ,
            i._convex = function(t, e, r, i, n, s, o) {
                return (e - i) * (n - r) + (r - t) * (s - i) >= 0 === o
            }
        }
        , {}],
        71: [function(t, e, r) {
            var i = t("../const")
              , n = e.exports = {
                _uid: 0,
                _saidHello: !1,
                pluginTarget: t("./pluginTarget"),
                PolyK: t("./PolyK"),
                async: t("async"),
                uuid: function() {
                    return ++n._uid
                },
                hex2rgb: function(t, e) {
                    return e = e || [],
                    e[0] = (t >> 16 & 255) / 255,
                    e[1] = (t >> 8 & 255) / 255,
                    e[2] = (255 & t) / 255,
                    e
                },
                hex2string: function(t) {
                    return t = t.toString(16),
                    t = "000000".substr(0, 6 - t.length) + t,
                    "#" + t
                },
                rgb2hex: function(t) {
                    return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
                },
                canUseNewCanvasBlendModes: function() {
                    if ("undefined" == typeof document)
                        return !1;
                    var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/"
                      , e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg=="
                      , r = new Image;
                    r.src = t + "AP804Oa6" + e;
                    var i = new Image;
                    i.src = t + "/wCKxvRF" + e;
                    var n = document.createElement("canvas");
                    n.width = 6,
                    n.height = 1;
                    var s = n.getContext("2d");
                    s.globalCompositeOperation = "multiply",
                    s.drawImage(r, 0, 0),
                    s.drawImage(i, 2, 0);
                    var o = s.getImageData(2, 0, 1, 1).data;
                    return 255 === o[0] && 0 === o[1] && 0 === o[2]
                },
                getNextPowerOfTwo: function(t) {
                    if (t > 0 && 0 === (t & t - 1))
                        return t;
                    for (var e = 1; e < t; )
                        e <<= 1;
                    return e
                },
                isPowerOfTwo: function(t, e) {
                    return t > 0 && 0 === (t & t - 1) && e > 0 && 0 === (e & e - 1)
                },
                getResolutionOfUrl: function(t) {
                    var e = i.RETINA_PREFIX.exec(t);
                    return e ? parseFloat(e[1]) : 1
                },
                sayHello: function(t) {
                    if (!n._saidHello) {
                        if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                            var e = ["\n %c %c %c Pixi.js " + i.VERSION + " -  " + t + "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
                            window.console.log.apply(console, e)
                        } else
                            window.console && window.console.log("Pixi.js " + i.VERSION + " - " + t + " - http://www.pixijs.com/");
                        n._saidHello = !0
                    }
                },
                isWebGLSupported: function() {
                    var t = {
                        stencil: !0
                    };
                    try {
                        if (!window.WebGLRenderingContext)
                            return !1;
                        var e = document.createElement("canvas")
                          , r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t);
                        return !(!r || !r.getContextAttributes().stencil)
                    } catch (i) {
                        return !1
                    }
                },
                TextureCache: {},
                BaseTextureCache: {}
            }
        }
        , {
            "../const": 18,
            "./PolyK": 70,
            "./pluginTarget": 72,
            async: 2
        }],
        72: [function(t, e, r) {
            function i(t) {
                t.__plugins = {},
                t.registerPlugin = function(e, r) {
                    t.__plugins[e] = r
                }
                ,
                t.prototype.initPlugins = function() {
                    this.plugins = this.plugins || {};
                    for (var e in t.__plugins)
                        this.plugins[e] = new t.__plugins[e](this)
                }
                ,
                t.prototype.destroyPlugins = function() {
                    for (var t in this.plugins)
                        this.plugins[t].destroy(),
                        this.plugins[t] = null;
                    this.plugins = null
                }
            }
            e.exports = {
                mixin: function(t) {
                    i(t)
                }
            }
        }
        , {}],
        73: [function(t, e, r) {
            var i = t("./core")
              , n = t("./mesh")
              , s = t("./extras")
              , o = t("./core/utils");
            i.SpriteBatch = function() {
                throw new ReferenceError("SpriteBatch does not exist any more, please use the new ParticleContainer instead.");
            }
            ,
            i.AssetLoader = function() {
                throw new ReferenceError("The loader system was overhauled in pixi v3, please see the new PIXI.loaders.Loader class.");
            }
            ,
            Object.defineProperties(i, {
                Stage: {
                    get: function() {
                        return console.warn("You do not need to use a PIXI Stage any more, you can simply render any container."),
                        i.Container
                    }
                },
                DisplayObjectContainer: {
                    get: function() {
                        return console.warn("DisplayObjectContainer has been shortened to Container, please use Container from now on."),
                        i.Container
                    }
                },
                Strip: {
                    get: function() {
                        return console.warn("The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on."),
                        n.Mesh
                    }
                },
                Rope: {
                    get: function() {
                        return console.warn("The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on."),
                        n.Rope
                    }
                },
                MovieClip: {
                    get: function() {
                        return console.warn("The MovieClip class has been moved to extras.MovieClip, please use extras.MovieClip from now on."),
                        s.MovieClip
                    }
                },
                TilingSprite: {
                    get: function() {
                        return console.warn("The TilingSprite class has been moved to extras.TilingSprite, please use extras.TilingSprite from now on."),
                        s.TilingSprite
                    }
                },
                BitmapText: {
                    get: function() {
                        return console.warn("The BitmapText class has been moved to extras.BitmapText, please use extras.BitmapText from now on."),
                        s.BitmapText
                    }
                },
                blendModes: {
                    get: function() {
                        return console.warn("The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on."),
                        i.BLEND_MODES
                    }
                },
                scaleModes: {
                    get: function() {
                        return console.warn("The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on."),
                        i.SCALE_MODES
                    }
                },
                BaseTextureCache: {
                    get: function() {
                        return console.warn("The BaseTextureCache class has been moved to utils.BaseTextureCache, please use utils.BaseTextureCache from now on."),
                        o.BaseTextureCache
                    }
                },
                TextureCache: {
                    get: function() {
                        return console.warn("The TextureCache class has been moved to utils.TextureCache, please use utils.TextureCache from now on."),
                        o.TextureCache
                    }
                }
            }),
            i.Sprite.prototype.setTexture = function(t) {
                this.texture = t,
                console.warn("setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;")
            }
            ,
            s.BitmapText.prototype.setText = function(t) {
                this.text = t,
                console.warn("setText is now deprecated, please use the text property, e.g : myBitmapText.text = 'my text';")
            }
            ,
            i.Text.prototype.setText = function(t) {
                this.text = t,
                console.warn("setText is now deprecated, please use the text property, e.g : myText.text = 'my text';")
            }
            ,
            i.Text.prototype.setStyle = function(t) {
                this.style = t,
                console.warn("setStyle is now deprecated, please use the style property, e.g : myText.style = style;")
            }
            ,
            i.Texture.prototype.setFrame = function(t) {
                this.frame = t,
                console.warn("setFrame is now deprecated, please use the frame property, e.g : myTexture.frame = frame;")
            }
        }
        , {
            "./core": 25,
            "./core/utils": 71,
            "./extras": 80,
            "./mesh": 3
        }],
        74: [function(t, e, r) {
            function i(t, e) {
                n.Container.call(this),
                e = e || {},
                this.textWidth = 0,
                this.textHeight = 0,
                this._glyphs = [],
                this._font = {
                    tint: void 0 !== e.tint ? e.tint : 16777215,
                    align: e.align || "left",
                    name: null,
                    size: 0
                },
                this.font = e.font,
                this._text = t,
                this.maxWidth = 0,
                this.dirty = !1,
                this.updateText()
            }
            var n = t("../core");
            i.prototype = Object.create(n.Container.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                tint: {
                    get: function() {
                        return this._font.tint
                    },
                    set: function(t) {
                        this._font.tint = "number" == typeof t && t >= 0 ? t : 16777215,
                        this.dirty = !0
                    }
                },
                align: {
                    get: function() {
                        return this._font.align
                    },
                    set: function(t) {
                        this._font.align = t || "left",
                        this.dirty = !0
                    }
                },
                font: {
                    get: function() {
                        return this._font
                    },
                    set: function(t) {
                        t && ("string" == typeof t ? (t = t.split(" "),
                        this._font.name = 1 === t.length ? t[0] : t.slice(1).join(" "),
                        this._font.size = t.length >= 2 ? parseInt(t[0], 10) : i.fonts[this._font.name].size) : (this._font.name = t.name,
                        this._font.size = "number" == typeof t.size ? t.size : parseInt(t.size, 10)),
                        this.dirty = !0)
                    }
                },
                text: {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t = t.toString() || " ",
                        this._text !== t && (this._text = t,
                        this.dirty = !0)
                    }
                }
            }),
            i.parse = function(t, e) {
                var r = {}
                  , s = t.getElementsByTagName("info")[0]
                  , o = t.getElementsByTagName("common")[0];
                r.font = s.getAttribute("face"),
                r.size = parseInt(s.getAttribute("size"), 10),
                r.lineHeight = parseInt(o.getAttribute("lineHeight"), 10),
                r.chars = {};
                for (var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) {
                    var u = parseInt(a[h].getAttribute("id"), 10)
                      , l = new n.math.Rectangle(parseInt(a[h].getAttribute("x"), 10) + e.frame.x,parseInt(a[h].getAttribute("y"), 10) + e.frame.y,parseInt(a[h].getAttribute("width"), 10),parseInt(a[h].getAttribute("height"), 10));
                    r.chars[u] = {
                        xOffset: parseInt(a[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(a[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(a[h].getAttribute("xadvance"), 10),
                        kerning: {},
                        texture: new n.Texture(e.baseTexture,l)
                    }
                }
                var c = t.getElementsByTagName("kerning");
                for (h = 0; h < c.length; h++) {
                    var d = parseInt(c[h].getAttribute("first"), 10)
                      , p = parseInt(c[h].getAttribute("second"), 10)
                      , f = parseInt(c[h].getAttribute("amount"), 10);
                    r.chars[p].kerning[d] = f
                }
                i.fonts[r.font] = r
            }
            ,
            i.prototype.updateText = function() {
                for (var t = i.fonts[this._font.name], e = new n.math.Point, r = null, s = [], o = 0, a = 0, h = [], u = 0, l = this._font.size / t.size, c = -1, d = 0; d < this.text.length; d++) {
                    var p = this.text.charCodeAt(d);
                    if (c = /(\s)/.test(this.text.charAt(d)) ? d : c,
                    /(?:\r\n|\r|\n)/.test(this.text.charAt(d)))
                        h.push(o),
                        a = Math.max(a, o),
                        u++,
                        e.x = 0,
                        e.y += t.lineHeight,
                        r = null;
                    else if (c !== -1 && this.maxWidth > 0 && e.x * l > this.maxWidth)
                        s.splice(c, d - c),
                        d = c,
                        c = -1,
                        h.push(o),
                        a = Math.max(a, o),
                        u++,
                        e.x = 0,
                        e.y += t.lineHeight,
                        r = null;
                    else {
                        var f = t.chars[p];
                        f && (r && f.kerning[r] && (e.x += f.kerning[r]),
                        s.push({
                            texture: f.texture,
                            line: u,
                            charCode: p,
                            position: new n.math.Point(e.x + f.xOffset,e.y + f.yOffset)
                        }),
                        o = e.x + f.xAdvance,
                        e.x += f.xAdvance,
                        r = p)
                    }
                }
                h.push(o),
                a = Math.max(a, o);
                var g = [];
                for (d = 0; d <= u; d++) {
                    var v = 0;
                    "right" === this._font.align ? v = a - h[d] : "center" === this._font.align && (v = (a - h[d]) / 2),
                    g.push(v)
                }
                var y = s.length
                  , m = this.tint;
                for (d = 0; d < y; d++) {
                    var x = this._glyphs[d];
                    x ? x.texture = s[d].texture : (x = new n.Sprite(s[d].texture),
                    this._glyphs.push(x)),
                    x.position.x = (s[d].position.x + g[s[d].line]) * l,
                    x.position.y = s[d].position.y * l,
                    x.scale.x = x.scale.y = l,
                    x.tint = m,
                    x.parent || this.addChild(x)
                }
                for (d = y; d < this._glyphs.length; ++d)
                    this.removeChild(this._glyphs[d]);
                this.textWidth = a * l,
                this.textHeight = (e.y + t.lineHeight) * l
            }
            ,
            i.prototype.updateTransform = function() {
                this.dirty && (this.updateText(),
                this.dirty = !1),
                this.containerUpdateTransform()
            }
            ,
            i.fonts = {}
        }
        , {
            "../core": 25
        }],
        75: [function(t, e, r) {
            function i(t) {
                n.Sprite.call(this, t[0]),
                this._textures = t,
                this.animationSpeed = 1,
                this.loop = !0,
                this.onComplete = null,
                this._currentTime = 0,
                this.playing = !1
            }
            var n = t("../core")
              , s = t("../ticker");
            i.prototype = Object.create(n.Sprite.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                totalFrames: {
                    get: function() {
                        return this._textures.length
                    }
                },
                textures: {
                    get: function() {
                        return this._textures
                    },
                    set: function(t) {
                        this._textures = t,
                        this.texture = this._textures[Math.floor(this._currentTime) % this._textures.length]
                    }
                },
                currentFrame: {
                    get: function() {
                        return Math.floor(this._currentTime) % this._textures.length
                    }
                }
            }),
            i.prototype.stop = function() {
                this.playing && (this.playing = !1,
                s.shared.remove(this.update, this))
            }
            ,
            i.prototype.play = function() {
                this.playing || (this.playing = !0,
                s.shared.add(this.update, this))
            }
            ,
            i.prototype.gotoAndStop = function(t) {
                this.stop(),
                this._currentTime = t;
                var e = Math.floor(this._currentTime);
                this._texture = this._textures[e % this._textures.length]
            }
            ,
            i.prototype.gotoAndPlay = function(t) {
                this._currentTime = t,
                this.play()
            }
            ,
            i.prototype.update = function(t) {
                this._currentTime += this.animationSpeed * t;
                var e = Math.floor(this._currentTime);
                e < 0 ? this.loop ? (this._currentTime += this._textures.length,
                this._texture = this._textures[this._currentTime]) : (this.gotoAndStop(0),
                this.onComplete && this.onComplete()) : this.loop || e < this._textures.length ? this._texture = this._textures[e % this._textures.length] : e >= this._textures.length && (this.gotoAndStop(this.textures.length - 1),
                this.onComplete && this.onComplete())
            }
            ,
            i.prototype.destroy = function() {
                this.stop(),
                n.Sprite.prototype.destroy.call(this)
            }
            ,
            i.fromFrames = function(t) {
                for (var e = [], r = 0; r < t.length; ++r)
                    e.push(new n.Texture.fromFrame(t[r]));
                return new i(e)
            }
            ,
            i.fromImages = function(t) {
                for (var e = [], r = 0; r < t.length; ++r)
                    e.push(new n.Texture.fromImage(t[r]));
                return new i(e)
            }
        }
        , {
            "../core": 25,
            "../ticker": 94
        }],
        76: [function(t, e, r) {
            function i(t, e, r) {
                n.Sprite.call(this, t),
                this.tileScale = new n.math.Point(1,1),
                this.tilePosition = new n.math.Point(0,0),
                this._width = e || 100,
                this._height = r || 100,
                this._uvs = new n.TextureUvs,
                this._canvasPattern = null,
                this.shader = new n.AbstractFilter(["precision lowp float;", "attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform mat3 projectionMatrix;", "uniform vec4 uFrame;", "uniform vec4 uTransform;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vec2 coord = aTextureCoord;", "   coord -= uTransform.xy;", "   coord /= uTransform.zw;", "   coord /= uFrame.zw;", "   vTextureCoord = coord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"].join("\n"),["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "uniform vec4 uFrame;", "void main(void){", "   vec2 coord = fract(vTextureCoord);", "   coord *= uFrame.zw;", "   coord += uFrame.xy;", "   gl_FragColor =  texture2D(uSampler, coord) * vColor ;", "}"].join("\n"),{
                    uFrame: {
                        type: "4fv",
                        value: [0, 0, 1, 1]
                    },
                    uTransform: {
                        type: "4fv",
                        value: [0, 0, 1, 1]
                    }
                })
            }
            var n = t("../core")
              , s = new n.Point;
            i.prototype = Object.create(n.Sprite.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            Object.defineProperties(i.prototype, {
                width: {
                    get: function() {
                        return this._width
                    },
                    set: function(t) {
                        this._width = t
                    }
                },
                height: {
                    get: function() {
                        return this._height
                    },
                    set: function(t) {
                        this._height = t
                    }
                }
            }),
            i.prototype._onTextureUpdate = function() {}
            ,
            i.prototype._renderWebGL = function(t) {
                var e = this._texture;
                if (e && e._uvs) {
                    var r = e._uvs
                      , i = e._frame.width
                      , n = e._frame.height
                      , s = e.baseTexture.width
                      , o = e.baseTexture.height;
                    e._uvs = this._uvs,
                    e._frame.width = this.width,
                    e._frame.height = this.height,
                    this.shader.uniforms.uFrame.value[0] = r.x0 + .5 / s,
                    this.shader.uniforms.uFrame.value[1] = r.y0 + .5 / o,
                    this.shader.uniforms.uFrame.value[2] = r.x1 - r.x0 + -1 / s,
                    this.shader.uniforms.uFrame.value[3] = r.y2 - r.y0 + -1 / o,
                    this.shader.uniforms.uTransform.value[0] = this.tilePosition.x % s / this._width,
                    this.shader.uniforms.uTransform.value[1] = this.tilePosition.y % o / this._height,
                    this.shader.uniforms.uTransform.value[2] = s / this._width * this.tileScale.x,
                    this.shader.uniforms.uTransform.value[3] = o / this._height * this.tileScale.y,
                    t.setObjectRenderer(t.plugins.sprite),
                    t.plugins.sprite.render(this),
                    e._uvs = r,
                    e._frame.width = i,
                    e._frame.height = n
                }
            }
            ,
            i.prototype._renderCanvas = function(t) {
                var e = this._texture;
                if (e.baseTexture.hasLoaded) {
                    var r = t.context
                      , i = this.worldTransform
                      , s = t.resolution
                      , o = e.baseTexture
                      , a = this.tilePosition.x % o.width
                      , h = this.tilePosition.y % o.height;
                    if (!this._canvasPattern) {
                        var u = new n.CanvasBuffer(e._frame.width,e._frame.height);
                        u.context.drawImage(o.source, -e._frame.x, -e._frame.y),
                        this._canvasPattern = u.context.createPattern(u.canvas, "repeat")
                    }
                    r.globalAlpha = this.worldAlpha,
                    r.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, i.tx * s, i.ty * s),
                    r.scale(this.tileScale.x, this.tileScale.y),
                    r.translate(a + this.anchor.x * -this._width, h + this.anchor.y * -this._height),
                    this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode,
                    r.globalCompositeOperation = t.blendModes[t.currentBlendMode]),
                    r.fillStyle = this._canvasPattern,
                    r.fillRect(-a, -h, this._width / this.tileScale.x, this._height / this.tileScale.y)
                }
            }
            ,
            i.prototype.getBounds = function() {
                var t, e, r, i, n = this._width, s = this._height, o = n * (1 - this.anchor.x), a = n * -this.anchor.x, h = s * (1 - this.anchor.y), u = s * -this.anchor.y, l = this.worldTransform, c = l.a, d = l.b, p = l.c, f = l.d, g = l.tx, v = l.ty, y = c * a + p * u + g, m = f * u + d * a + v, x = c * o + p * u + g, _ = f * u + d * o + v, E = c * o + p * h + g, b = f * h + d * o + v, T = c * a + p * h + g, w = f * h + d * a + v;
                t = y,
                t = x < t ? x : t,
                t = E < t ? E : t,
                t = T < t ? T : t,
                r = m,
                r = _ < r ? _ : r,
                r = b < r ? b : r,
                r = w < r ? w : r,
                e = y,
                e = x > e ? x : e,
                e = E > e ? E : e,
                e = T > e ? T : e,
                i = m,
                i = _ > i ? _ : i,
                i = b > i ? b : i,
                i = w > i ? w : i;
                var S = this._bounds;
                return S.x = t,
                S.width = e - t,
                S.y = r,
                S.height = i - r,
                this._currentBounds = S,
                S
            }
            ,
            i.prototype.containsPoint = function(t) {
                this.worldTransform.applyInverse(t, s);
                var e, r = this._width, i = this._height, n = -r * this.anchor.x;
                return s.x > n && s.x < n + r && (e = -i * this.anchor.y,
                s.y > e && s.y < e + i)
            }
            ,
            i.prototype.destroy = function() {
                n.Sprite.prototype.destroy.call(this),
                this.tileScale = null,
                this._tileScaleOffset = null,
                this.tilePosition = null,
                this._uvs = null
            }
            ,
            i.fromFrame = function(t, e, r) {
                var s = n.utils.TextureCache[t];
                if (!s)
                    throw new Error('The frameId "' + t + '" does not exist in the texture cache ' + this);
                return new i(s,e,r)
            }
            ,
            i.fromImage = function(t, e, r, s, o) {
                return new i(n.Texture.fromImage(t, s, o),e,r)
            }
        }
        , {
            "../core": 25
        }],
        77: [function(t, e, r) {
            var i = t("../core")
              , n = i.DisplayObject
              , s = new i.Matrix;
            n.prototype._cacheAsBitmap = !1,
            n.prototype._originalRenderWebGL = null,
            n.prototype._originalRenderCanvas = null,
            n.prototype._originalUpdateTransform = null,
            n.prototype._originalHitTest = null,
            n.prototype._originalDestroy = null,
            n.prototype._cachedSprite = null,
            Object.defineProperties(n.prototype, {
                cacheAsBitmap: {
                    get: function() {
                        return this._cacheAsBitmap
                    },
                    set: function(t) {
                        this._cacheAsBitmap !== t && (this._cacheAsBitmap = t,
                        t ? (this._originalRenderWebGL = this.renderWebGL,
                        this._originalRenderCanvas = this.renderCanvas,
                        this._originalUpdateTransform = this.updateTransform,
                        this._originalGetBounds = this.getBounds,
                        this._originalDestroy = this.destroy,
                        this._originalContainesPoint = this.containsPoint,
                        this.renderWebGL = this._renderCachedWebGL,
                        this.renderCanvas = this._renderCachedCanvas,
                        this.destroy = this._cacheAsBitmapDestroy) : (this._cachedSprite && this._destroyCachedDisplayObject(),
                        this.renderWebGL = this._originalRenderWebGL,
                        this.renderCanvas = this._originalRenderCanvas,
                        this.getBounds = this._originalGetBounds,
                        this.destroy = this._originalDestroy,
                        this.updateTransform = this._originalUpdateTransform,
                        this.containsPoint = this._originalContainsPoint))
                    }
                }
            }),
            n.prototype._renderCachedWebGL = function(t) {
                this._initCachedDisplayObject(t),
                this._cachedSprite.worldAlpha = this.worldAlpha,
                t.setObjectRenderer(t.plugins.sprite),
                t.plugins.sprite.render(this._cachedSprite)
            }
            ,
            n.prototype._initCachedDisplayObject = function(t) {
                if (!this._cachedSprite) {
                    t.currentRenderer.flush();
                    var e = this.getLocalBounds().clone();
                    if (this._filters) {
                        var r = this._filters[0].padding;
                        e.x -= r,
                        e.y -= r,
                        e.width += 2 * r,
                        e.height += 2 * r
                    }
                    var n = t.currentRenderTarget
                      , o = t.filterManager.filterStack
                      , a = new i.RenderTexture(t,0 | e.width,0 | e.height)
                      , h = s;
                    h.tx = -e.x,
                    h.ty = -e.y,
                    this.renderWebGL = this._originalRenderWebGL,
                    a.render(this, h, !0, !0),
                    t.setRenderTarget(n),
                    t.filterManager.filterStack = o,
                    this.renderWebGL = this._renderCachedWebGL,
                    this.updateTransform = this.displayObjectUpdateTransform,
                    this.getBounds = this._getCachedBounds,
                    this._cachedSprite = new i.Sprite(a),
                    this._cachedSprite.worldTransform = this.worldTransform,
                    this._cachedSprite.anchor.x = -(e.x / e.width),
                    this._cachedSprite.anchor.y = -(e.y / e.height),
                    this.updateTransform(),
                    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite)
                }
            }
            ,
            n.prototype._renderCachedCanvas = function(t) {
                this._initCachedDisplayObjectCanvas(t),
                this._cachedSprite.worldAlpha = this.worldAlpha,
                this._cachedSprite.renderCanvas(t)
            }
            ,
            n.prototype._initCachedDisplayObjectCanvas = function(t) {
                if (!this._cachedSprite) {
                    var e = this.getLocalBounds()
                      , r = t.context
                      , n = new i.RenderTexture(t,0 | e.width,0 | e.height)
                      , o = s;
                    o.tx = -e.x,
                    o.ty = -e.y,
                    this.renderCanvas = this._originalRenderCanvas,
                    n.render(this, o, !0),
                    t.context = r,
                    this.renderCanvas = this._renderCachedCanvas,
                    this.updateTransform = this.displayObjectUpdateTransform,
                    this.getBounds = this._getCachedBounds,
                    this._cachedSprite = new i.Sprite(n),
                    this._cachedSprite.worldTransform = this.worldTransform,
                    this._cachedSprite.anchor.x = -(e.x / e.width),
                    this._cachedSprite.anchor.y = -(e.y / e.height),
                    this.updateTransform(),
                    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite)
                }
            }
            ,
            n.prototype._getCachedBounds = function() {
                return this._cachedSprite._currentBounds = null,
                this._cachedSprite.getBounds()
            }
            ,
            n.prototype._destroyCachedDisplayObject = function() {
                this._cachedSprite._texture.destroy(),
                this._cachedSprite = null
            }
            ,
            n.prototype._cacheAsBitmapDestroy = function() {
                this.cacheAsBitmap = !1,
                this._originalDestroy()
            }
        }
        , {
            "../core": 25
        }],
        78: [function(t, e, r) {
            var i = t("../core");
            i.DisplayObject.prototype.name = null,
            i.Container.prototype.getChildByName = function(t) {
                for (var e = 0; e < this.children.length; e++)
                    if (this.children[e].name === t)
                        return this.children[e];
                return null
            }
        }
        , {
            "../core": 25
        }],
        79: [function(t, e, r) {
            var i = t("../core");
            i.DisplayObject.prototype.getGlobalPosition = function(t) {
                return t = t || new i.Point,
                this.parent ? (this.displayObjectUpdateTransform(),
                t.x = this.worldTransform.tx,
                t.y = this.worldTransform.ty) : (t.x = this.position.x,
                t.y = this.position.y),
                t
            }
        }
        , {
            "../core": 25
        }],
        80: [function(t, e, r) {
            t("./cacheAsBitmap"),
            t("./getChildByName"),
            t("./getGlobalPosition"),
            e.exports = {
                MovieClip: t("./MovieClip"),
                TilingSprite: t("./TilingSprite"),
                BitmapText: t("./BitmapText")
            }
        }
        , {
            "./BitmapText": 74,
            "./MovieClip": 75,
            "./TilingSprite": 76,
            "./cacheAsBitmap": 77,
            "./getChildByName": 78,
            "./getGlobalPosition": 79
        }],
        81: [function(t, e, r) {
            function i() {
                this.global = new n.Point,
                this.target = null,
                this.originalEvent = null
            }
            var n = t("../core");
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.getLocalPosition = function(t, e, r) {
                var i = t.worldTransform
                  , s = r ? r : this.global
                  , o = i.a
                  , a = i.c
                  , h = i.tx
                  , u = i.b
                  , l = i.d
                  , c = i.ty
                  , d = 1 / (o * l + a * -u);
                return e = e || new n.math.Point,
                e.x = l * d * s.x + -a * d * s.y + (c * a - h * l) * d,
                e.y = o * d * s.y + -u * d * s.x + (-c * o + h * u) * d,
                e
            }
        }
        , {
            "../core": 25
        }],
        82: [function(t, e, r) {
            function i(t, e) {
                e = e || {},
                this.renderer = t,
                this.autoPreventDefault = void 0 === e.autoPreventDefault || e.autoPreventDefault,
                this.interactionFrequency = e.interactionFrequency || 10,
                this.mouse = new s,
                this.eventData = {
                    stopped: !1,
                    target: null,
                    type: null,
                    data: this.mouse,
                    stopPropagation: function() {
                        this.stopped = !0
                    }
                },
                this.interactiveDataPool = [],
                this.interactionDOMElement = null,
                this.eventsAdded = !1,
                this.onMouseUp = this.onMouseUp.bind(this),
                this.processMouseUp = this.processMouseUp.bind(this),
                this.onMouseDown = this.onMouseDown.bind(this),
                this.processMouseDown = this.processMouseDown.bind(this),
                this.onMouseMove = this.onMouseMove.bind(this),
                this.processMouseMove = this.processMouseMove.bind(this),
                this.onMouseOut = this.onMouseOut.bind(this),
                this.processMouseOverOut = this.processMouseOverOut.bind(this),
                this.onTouchStart = this.onTouchStart.bind(this),
                this.processTouchStart = this.processTouchStart.bind(this),
                this.onTouchEnd = this.onTouchEnd.bind(this),
                this.processTouchEnd = this.processTouchEnd.bind(this),
                this.onTouchMove = this.onTouchMove.bind(this),
                this.processTouchMove = this.processTouchMove.bind(this),
                this.last = 0,
                this.currentCursorStyle = "inherit",
                this._tempPoint = new n.Point,
                this.resolution = 1,
                this.setTargetElement(this.renderer.view, this.renderer.resolution)
            }
            var n = t("../core")
              , s = t("./InteractionData");
            Object.assign(n.DisplayObject.prototype, t("./interactiveTarget")),
            i.prototype.constructor = i,
            e.exports = i,
            i.prototype.setTargetElement = function(t, e) {
                this.removeEvents(),
                this.interactionDOMElement = t,
                this.resolution = e || 1,
                this.addEvents()
            }
            ,
            i.prototype.addEvents = function() {
                this.interactionDOMElement && (n.ticker.shared.add(this.update, this),
                window.navigator.msPointerEnabled && (this.interactionDOMElement.style["-ms-content-zooming"] = "none",
                this.interactionDOMElement.style["-ms-touch-action"] = "none"),
                window.document.addEventListener("mousemove", this.onMouseMove, !0),
                this.interactionDOMElement.addEventListener("mousedown", this.onMouseDown, !0),
                this.interactionDOMElement.addEventListener("mouseout", this.onMouseOut, !0),
                this.interactionDOMElement.addEventListener("touchstart", this.onTouchStart, !0),
                this.interactionDOMElement.addEventListener("touchend", this.onTouchEnd, !0),
                this.interactionDOMElement.addEventListener("touchmove", this.onTouchMove, !0),
                window.addEventListener("mouseup", this.onMouseUp, !0),
                this.eventsAdded = !0)
            }
            ,
            i.prototype.removeEvents = function() {
                this.interactionDOMElement && (n.ticker.shared.remove(this.update),
                window.navigator.msPointerEnabled && (this.interactionDOMElement.style["-ms-content-zooming"] = "",
                this.interactionDOMElement.style["-ms-touch-action"] = ""),
                window.document.removeEventListener("mousemove", this.onMouseMove, !0),
                this.interactionDOMElement.removeEventListener("mousedown", this.onMouseDown, !0),
                this.interactionDOMElement.removeEventListener("mouseout", this.onMouseOut, !0),
                this.interactionDOMElement.removeEventListener("touchstart", this.onTouchStart, !0),
                this.interactionDOMElement.removeEventListener("touchend", this.onTouchEnd, !0),
                this.interactionDOMElement.removeEventListener("touchmove", this.onTouchMove, !0),
                this.interactionDOMElement = null,
                window.removeEventListener("mouseup", this.onMouseUp, !0),
                this.eventsAdded = !1)
            }
            ,
            i.prototype.update = function(t) {
                if (this._deltaTime += t,
                !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0,
                this.interactionDOMElement)) {
                    if (this.didMove)
                        return void (this.didMove = !1);
                    this.cursor = "inherit",
                    this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, !0),
                    this.currentCursorStyle !== this.cursor && (this.currentCursorStyle = this.cursor,
                    this.interactionDOMElement.style.cursor = this.cursor)
                }
            }
            ,
            i.prototype.dispatchEvent = function(t, e, r) {
                r.stopped || (r.target = t,
                r.type = e,
                t.emit(e, r),
                t[e] && t[e](r))
            }
            ,
            i.prototype.mapPositionToPoint = function(t, e, r) {
                var i = this.interactionDOMElement.getBoundingClientRect();
                t.x = (e - i.left) * (this.interactionDOMElement.width / i.width) / this.resolution,
                t.y = (r - i.top) * (this.interactionDOMElement.height / i.height) / this.resolution
            }
            ,
            i.prototype.processInteractive = function(t, e, r, i, n) {
                if (!e.visible)
                    return !1;
                var s = e.children
                  , o = !1;
                if (n = n || e.interactive,
                e.interactiveChildren)
                    for (var a = s.length - 1; a >= 0; a--)
                        !o && i ? o = this.processInteractive(t, s[a], r, !0, n) : this.processInteractive(t, s[a], r, !1, !1);
                return n && (i && (e.hitArea ? (e.worldTransform.applyInverse(t, this._tempPoint),
                o = e.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) : e.containsPoint && (o = e.containsPoint(t))),
                e.interactive && r(e, o)),
                o
            }
            ,
            i.prototype.onMouseDown = function(t) {
                this.mouse.originalEvent = t,
                this.eventData.data = this.mouse,
                this.eventData.stopped = !1,
                this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY),
                this.autoPreventDefault && this.mouse.originalEvent.preventDefault(),
                this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseDown, !0)
            }
            ,
            i.prototype.processMouseDown = function(t, e) {
                var r = this.mouse.originalEvent
                  , i = 2 === r.button || 3 === r.which;
                e && (t[i ? "_isRightDown" : "_isLeftDown"] = !0,
                this.dispatchEvent(t, i ? "rightdown" : "mousedown", this.eventData))
            }
            ,
            i.prototype.onMouseUp = function(t) {
                this.mouse.originalEvent = t,
                this.eventData.data = this.mouse,
                this.eventData.stopped = !1,
                this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY),
                this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseUp, !0)
            }
            ,
            i.prototype.processMouseUp = function(t, e) {
                var r = this.mouse.originalEvent
                  , i = 2 === r.button || 3 === r.which
                  , n = i ? "_isRightDown" : "_isLeftDown";
                e ? (this.dispatchEvent(t, i ? "rightup" : "mouseup", this.eventData),
                t[n] && (t[n] = !1,
                this.dispatchEvent(t, i ? "rightclick" : "click", this.eventData))) : t[n] && (t[n] = !1,
                this.dispatchEvent(t, i ? "rightupoutside" : "mouseupoutside", this.eventData))
            }
            ,
            i.prototype.onMouseMove = function(t) {
                this.mouse.originalEvent = t,
                this.eventData.data = this.mouse,
                this.eventData.stopped = !1,
                this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY),
                this.didMove = !0,
                this.cursor = "inherit",
                this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseMove, !0),
                this.currentCursorStyle !== this.cursor && (this.currentCursorStyle = this.cursor,
                this.interactionDOMElement.style.cursor = this.cursor)
            }
            ,
            i.prototype.processMouseMove = function(t, e) {
                this.dispatchEvent(t, "mousemove", this.eventData),
                this.processMouseOverOut(t, e)
            }
            ,
            i.prototype.onMouseOut = function(t) {
                this.mouse.originalEvent = t,
                this.eventData.stopped = !1,
                this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY),
                this.interactionDOMElement.style.cursor = "inherit",
                this.mapPositionToPoint(this.mouse.global, t.clientX, t.clientY),
                this.processInteractive(this.mouse.global, this.renderer._lastObjectRendered, this.processMouseOverOut, !1)
            }
            ,
            i.prototype.processMouseOverOut = function(t, e) {
                e ? (t._over || (t._over = !0,
                this.dispatchEvent(t, "mouseover", this.eventData)),
                t.buttonMode && (this.cursor = t.defaultCursor)) : t._over && (t._over = !1,
                this.dispatchEvent(t, "mouseout", this.eventData))
            }
            ,
            i.prototype.onTouchStart = function(t) {
                this.autoPreventDefault && t.preventDefault();
                for (var e = t.changedTouches, r = e.length, i = 0; i < r; i++) {
                    var n = e[i]
                      , s = this.getTouchData(n);
                    s.originalEvent = t,
                    this.eventData.data = s,
                    this.eventData.stopped = !1,
                    this.processInteractive(s.global, this.renderer._lastObjectRendered, this.processTouchStart, !0),
                    this.returnTouchData(s)
                }
            }
            ,
            i.prototype.processTouchStart = function(t, e) {
                e && (t._touchDown = !0,
                this.dispatchEvent(t, "touchstart", this.eventData))
            }
            ,
            i.prototype.onTouchEnd = function(t) {
                this.autoPreventDefault && t.preventDefault();
                for (var e = t.changedTouches, r = e.length, i = 0; i < r; i++) {
                    var n = e[i]
                      , s = this.getTouchData(n);
                    s.originalEvent = t,
                    this.eventData.data = s,
                    this.eventData.stopped = !1,
                    this.processInteractive(s.global, this.renderer._lastObjectRendered, this.processTouchEnd, !0),
                    this.returnTouchData(s)
                }
            }
            ,
            i.prototype.processTouchEnd = function(t, e) {
                e ? (this.dispatchEvent(t, "touchend", this.eventData),
                t._touchDown && (t._touchDown = !1,
                this.dispatchEvent(t, "tap", this.eventData))) : t._touchDown && (t._touchDown = !1,
                this.dispatchEvent(t, "touchendoutside", this.eventData))
            }
            ,
            i.prototype.onTouchMove = function(t) {
                this.autoPreventDefault && t.preventDefault();
                for (var e = t.changedTouches, r = e.length, i = 0; i < r; i++) {
                    var n = e[i]
                      , s = this.getTouchData(n);
                    s.originalEvent = t,
                    this.eventData.data = s,
                    this.eventData.stopped = !1,
                    this.processInteractive(s.global, this.renderer._lastObjectRendered, this.processTouchMove, !1),
                    this.returnTouchData(s)
                }
            }
            ,
            i.prototype.processTouchMove = function(t, e) {
                e = e,
                this.dispatchEvent(t, "touchmove", this.eventData)
            }
            ,
            i.prototype.getTouchData = function(t) {
                var e = this.interactiveDataPool.pop();
                return e || (e = new s),
                e.identifier = t.identifier,
                this.mapPositionToPoint(e.global, t.clientX, t.clientY),
                t.globalX = e.global.x,
                t.globalY = e.global.y,
                e
            }
            ,
            i.prototype.returnTouchData = function(t) {
                this.interactiveDataPool.push(t)
            }
            ,
            i.prototype.destroy = function() {
                this.removeEvents(),
                this.renderer = null,
                this.mouse = null,
                this.eventData = null,
                this.interactiveDataPool = null,
                this.interactionDOMElement = null,
                this.onMouseUp = null,
                this.processMouseUp = null,
                this.onMouseDown = null,
                this.processMouseDown = null,
                this.onMouseMove = null,
                this.processMouseMove = null,
                this.onMouseOut = null,
                this.processMouseOverOut = null,
                this.onTouchStart = null,
                this.processTouchStart = null,
                this.onTouchEnd = null,
                this.processTouchEnd = null,
                this.onTouchMove = null,
                this.processTouchMove = null,
                this._tempPoint = null
            }
            ,
            n.WebGLRenderer.registerPlugin("interaction", i),
            n.CanvasRenderer.registerPlugin("interaction", i)
        }
        , {
            "../core": 25,
            "./InteractionData": 81,
            "./interactiveTarget": 84
        }],
        83: [function(t, e, r) {
            e.exports = {
                InteractionData: t("./InteractionData"),
                InteractionManager: t("./InteractionManager"),
                interactiveTarget: t("./interactiveTarget")
            }
        }
        , {
            "./InteractionData": 81,
            "./InteractionManager": 82,
            "./interactiveTarget": 84
        }],
        84: [function(t, e, r) {
            e.exports = {
                interactive: !1,
                buttonMode: !1,
                interactiveChildren: !0,
                defaultCursor: "pointer",
                _over: !1,
                _touchDown: !1
            }
        }
        , {}],
        85: [function(t, e, r) {
            function i(t, e) {
                var r = {}
                  , i = t.data.getElementsByTagName("info")[0]
                  , n = t.data.getElementsByTagName("common")[0];
                r.font = i.getAttribute("face"),
                r.size = parseInt(i.getAttribute("size"), 10),
                r.lineHeight = parseInt(n.getAttribute("lineHeight"), 10),
                r.chars = {};
                for (var o = t.data.getElementsByTagName("char"), h = 0; h < o.length; h++) {
                    var u = parseInt(o[h].getAttribute("id"), 10)
                      , l = new s.math.Rectangle(parseInt(o[h].getAttribute("x"), 10) + e.frame.x,parseInt(o[h].getAttribute("y"), 10) + e.frame.y,parseInt(o[h].getAttribute("width"), 10),parseInt(o[h].getAttribute("height"), 10));
                    r.chars[u] = {
                        xOffset: parseInt(o[h].getAttribute("xoffset"), 10),
                        yOffset: parseInt(o[h].getAttribute("yoffset"), 10),
                        xAdvance: parseInt(o[h].getAttribute("xadvance"), 10),
                        kerning: {},
                        texture: new s.Texture(e.baseTexture,l)
                    }
                }
                var c = t.data.getElementsByTagName("kerning");
                for (h = 0; h < c.length; h++) {
                    var d = parseInt(c[h].getAttribute("first"), 10)
                      , p = parseInt(c[h].getAttribute("second"), 10)
                      , f = parseInt(c[h].getAttribute("amount"), 10);
                    r.chars[p].kerning[d] = f
                }
                t.bitmapFont = r,
                a.BitmapText.fonts[r.font] = r
            }
            var n = t("resource-loader").Resource
              , s = t("../core")
              , o = t("../core/utils")
              , a = t("../extras")
              , h = t("path");
            e.exports = function() {
                return function(t, e) {
                    if (!t.data || !t.isXml)
                        return e();
                    if (0 === t.data.getElementsByTagName("page").length || 0 === t.data.getElementsByTagName("info").length || null === t.data.getElementsByTagName("info")[0].getAttribute("face"))
                        return e();
                    var r = h.dirname(t.url);
                    "." === r && (r = ""),
                    this.baseUrl && r && ("/" === this.baseUrl.charAt(this.baseUrl.length - 1) && (r += "/"),
                    r = r.replace(this.baseUrl, "")),
                    r && "/" !== r.charAt(r.length - 1) && (r += "/");
                    var s = t.data.getElementsByTagName("page")[0].getAttribute("file");
                    if (o.TextureCache[s])
                        i(t, o.TextureCache[s]),
                        e();
                    else {
                        var a = {
                            crossOrigin: t.crossOrigin,
                            loadType: n.LOAD_TYPE.IMAGE
                        };
                        this.add(t.name + "_image", s, a, function(r) {
                            i(t, r.texture),
                            e()
                        })
                    }
                }
            }
        }
        , {
            "../core": 25,
            "../core/utils": 71,
            "../extras": 80,
            path: 4,
            "resource-loader": 14
        }],
        86: [function(t, e, r) {
            e.exports = {
                Loader: t("./loader"),
                bitmapFontParser: t("./bitmapFontParser"),
                spritesheetParser: t("./spritesheetParser"),
                textureParser: t("./textureParser"),
                Resource: t("resource-loader").Resource
            }
        }
        , {
            "./bitmapFontParser": 85,
            "./loader": 87,
            "./spritesheetParser": 88,
            "./textureParser": 89,
            "resource-loader": 14
        }],
        87: [function(t, e, r) {
            function i(t, e) {
                n.call(this, t, e);
                for (var r = 0; r < i._pixiMiddleware.length; ++r)
                    this.use(i._pixiMiddleware[r]())
            }
            var n = t("resource-loader")
              , s = t("./textureParser")
              , o = t("./spritesheetParser")
              , a = t("./bitmapFontParser");
            i.prototype = Object.create(n.prototype),
            i.prototype.constructor = i,
            e.exports = i,
            i._pixiMiddleware = [n.middleware.parsing.blob, s, o, a],
            i.addPixiMiddleware = function(t) {
                i._pixiMiddleware.push(t)
            }
            ;
            var h = n.Resource;
            h.setExtensionXhrType("fnt", h.XHR_RESPONSE_TYPE.DOCUMENT)
        }
        , {
            "./bitmapFontParser": 85,
            "./spritesheetParser": 88,
            "./textureParser": 89,
            "resource-loader": 14
        }],
        88: [function(t, e, r) {
            var i = t("resource-loader").Resource
              , n = t("path")
              , s = t("../core");
            e.exports = function() {
                return function(t, e) {
                    if (!t.data || !t.isJson || !t.data.frames)
                        return e();
                    var r = {
                        crossOrigin: t.crossOrigin,
                        loadType: i.LOAD_TYPE.IMAGE
                    }
                      , o = n.dirname(t.url.replace(this.baseUrl, ""))
                      , a = s.utils.getResolutionOfUrl(t.url);
                    this.add(t.name + "_image", o + "/" + t.data.meta.image, r, function(r) {
                        t.textures = {};
                        var i = t.data.frames;
                        for (var n in i) {
                            var o = i[n].frame;
                            if (o) {
                                var h = null
                                  , u = null;
                                if (h = i[n].rotated ? new s.math.Rectangle(o.x,o.y,o.h,o.w) : new s.math.Rectangle(o.x,o.y,o.w,o.h),
                                i[n].trimmed && (u = new s.math.Rectangle(i[n].spriteSourceSize.x / a,i[n].spriteSourceSize.y / a,i[n].sourceSize.w / a,i[n].sourceSize.h / a)),
                                i[n].rotated) {
                                    var l = h.width;
                                    h.width = h.height,
                                    h.height = l
                                }
                                h.x /= a,
                                h.y /= a,
                                h.width /= a,
                                h.height /= a,
                                t.textures[n] = new s.Texture(r.texture.baseTexture,h,h.clone(),u,i[n].rotated),
                                s.utils.TextureCache[n] = t.textures[n]
                            }
                        }
                        e()
                    })
                }
            }
        }
        , {
            "../core": 25,
            path: 4,
            "resource-loader": 14
        }],
        89: [function(t, e, r) {
            var i = t("../core");
            e.exports = function() {
                return function(t, e) {
                    t.data && t.isImage && (t.texture = new i.Texture(new i.BaseTexture(t.data,null,i.utils.getResolutionOfUrl(t.url))),
                    i.utils.TextureCache[t.url] = t.texture),
                    e()
                }
            }
        }
        , {
            "../core": 25
        }],
        90: [function(t, e, r) {
            Object.assign || (Object.assign = t("object-assign"))
        }
        , {
            "object-assign": 7
        }],
        91: [function(t, e, r) {
            t("./Object.assign"),
            t("./requestAnimationFrame")
        }
        , {
            "./Object.assign": 90,
            "./requestAnimationFrame": 92
        }],
        92: [function(t, e, r) {
            (function(t) {
                if (Date.now && Date.prototype.getTime || (Date.now = function() {
                    return (new Date).getTime()
                }
                ),
                !t.performance || !t.performance.now) {
                    var e = Date.now();
                    t.performance || (t.performance = {}),
                    t.performance.now = function() {
                        return Date.now() - e
                    }
                }
                for (var r = Date.now(), i = ["ms", "moz", "webkit", "o"], n = 0; n < i.length && !t.requestAnimationFrame; ++n)
                    t.requestAnimationFrame = t[i[n] + "RequestAnimationFrame"],
                    t.cancelAnimationFrame = t[i[n] + "CancelAnimationFrame"] || t[i[n] + "CancelRequestAnimationFrame"];
                t.requestAnimationFrame || (t.requestAnimationFrame = function(t) {
                    if ("function" != typeof t)
                        throw new TypeError(t + "is not a function");
                    var e = Date.now()
                      , i = 16 + r - e;
                    return i < 0 && (i = 0),
                    r = e,
                    setTimeout(function() {
                        r = Date.now(),
                        t(performance.now())
                    }, i)
                }
                ),
                t.cancelAnimationFrame || (t.cancelAnimationFrame = function(t) {
                    clearTimeout(t)
                }
                )
            }
            ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
        }
        , {}],
        93: [function(t, e, r) {
            function i() {
                var t = this;
                this._tick = function(e) {
                    t._requestId = null,
                    t.started && (t.update(e),
                    t.started && null === t._requestId && t._emitter.listeners(o, !0))
                }
                ,
                this._emitter = new s,
                this._requestId = null,
                this._maxElapsedMS = 100,
                this.autoStart = !1,
                this.deltaTime = 1,
                this.elapsedMS = 1 / n.TARGET_FPMS,
                this.lastTime = 0,
                this.speed = 1,
                this.started = !1
            }
            var n = t("../core")
              , s = t("eventemitter3")
              , o = "tick";
            Object.defineProperties(i.prototype, {
                FPS: {
                    get: function() {
                        return 1E3 / this.elapsedMS
                    }
                },
                minFPS: {
                    get: function() {
                        return 1E3 / this._maxElapsedMS
                    },
                    set: function(t) {
                        var e = Math.min(Math.max(0, t) / 1E3, n.TARGET_FPMS);
                        this._maxElapsedMS = 1 / e
                    }
                }
            }),
            i.prototype._requestIfNeeded = function() {
                null === this._requestId && this._emitter.listeners(o, !0) && (this.lastTime = performance.now(),
                this._requestId = requestAnimationFrame(this._tick))
            }
            ,
            i.prototype._cancelIfNeeded = function() {
                null !== this._requestId && (cancelAnimationFrame(this._requestId),
                this._requestId = null)
            }
            ,
            i.prototype._startIfPossible = function() {
                this.started ? this._requestIfNeeded() : this.autoStart && this.start()
            }
            ,
            i.prototype.add = function(t, e) {
                return this._emitter.on(o, t, e),
                this._startIfPossible(),
                this
            }
            ,
            i.prototype.addOnce = function(t, e) {
                return this._emitter.once(o, t, e),
                this._startIfPossible(),
                this
            }
            ,
            i.prototype.remove = function(t, e) {
                return this._emitter.off(o, t, e),
                this._emitter.listeners(o, !0) || this._cancelIfNeeded(),
                this
            }
            ,
            i.prototype.start = function() {
                this.started || (this.started = !0,
                this._requestIfNeeded())
            }
            ,
            i.prototype.stop = function() {
                this.started && (this.started = !1,
                this._cancelIfNeeded())
            }
            ,
            i.prototype.update = function(t) {
                var e;
                t = t || performance.now(),
                e = this.elapsedMS = t - this.lastTime,
                e > this._maxElapsedMS && (e = this._maxElapsedMS),
                this.deltaTime = e * n.TARGET_FPMS * this.speed,
                this._emitter.emit(o, this.deltaTime),
                this.lastTime = t
            }
            ,
            e.exports = i
        }
        , {
            "../core": 25,
            eventemitter3: 6
        }],
        94: [function(t, e, r) {
            var i = t("./Ticker")
              , n = new i;
            n.autoStart = !0,
            e.exports = {
                shared: n,
                Ticker: i
            }
        }
        , {
            "./Ticker": 93
        }]
    }, {}, [1])(1)
});
this.createjs = this.createjs || {},
function() {
    var a = createjs.SoundJS = createjs.SoundJS || {};
    a.version = "NEXT",
    a.buildDate = "Thu, 08 Oct 2015 16:30:58 GMT"
}(),
this.createjs = this.createjs || {},
createjs.extend = function(a, b) {
    function c() {
        this.constructor = a
    }
    return c.prototype = b.prototype,
    a.prototype = new c
}
,
this.createjs = this.createjs || {},
createjs.promote = function(a, b) {
    var c = a.prototype
      , d = Object.getPrototypeOf && Object.getPrototypeOf(c) || c.__proto__;
    if (d) {
        c[(b += "_") + "constructor"] = d.constructor;
        for (var e in d)
            c.hasOwnProperty(e) && "function" == typeof d[e] && (c[b + e] = d[e])
    }
    return a
}
,
this.createjs = this.createjs || {},
createjs.indexOf = function(a, b) {
    for (var c = 0, d = a.length; d > c; c++)
        if (b === a[c])
            return c;
    return -1
}
,
this.createjs = this.createjs || {},
function() {
    createjs.proxy = function(a, b) {
        var c = Array.prototype.slice.call(arguments, 2);
        return function() {
            return a.apply(b, Array.prototype.slice.call(arguments, 0).concat(c))
        }
    }
}(),
this.createjs = this.createjs || {},
function() {
    function BrowserDetect() {
        throw "BrowserDetect cannot be instantiated";
    }
    var a = BrowserDetect.agent = window.navigator.userAgent;
    BrowserDetect.isWindowPhone = a.indexOf("IEMobile") > -1 || a.indexOf("Windows Phone") > -1,
    BrowserDetect.isFirefox = a.indexOf("Firefox") > -1,
    BrowserDetect.isOpera = null != window.opera,
    BrowserDetect.isChrome = a.indexOf("Chrome") > -1,
    BrowserDetect.isIOS = (a.indexOf("iPod") > -1 || a.indexOf("iPhone") > -1 || a.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone,
    BrowserDetect.isAndroid = a.indexOf("Android") > -1 && !BrowserDetect.isWindowPhone,
    BrowserDetect.isBlackberry = a.indexOf("Blackberry") > -1,
    createjs.BrowserDetect = BrowserDetect
}(),
this.createjs = this.createjs || {},
function() {
    function EventDispatcher() {
        this._listeners = null,
        this._captureListeners = null
    }
    var a = EventDispatcher.prototype;
    EventDispatcher.initialize = function(b) {
        b.addEventListener = a.addEventListener,
        b.on = a.on,
        b.removeEventListener = b.off = a.removeEventListener,
        b.removeAllEventListeners = a.removeAllEventListeners,
        b.hasEventListener = a.hasEventListener,
        b.dispatchEvent = a.dispatchEvent,
        b._dispatchEvent = a._dispatchEvent,
        b.willTrigger = a.willTrigger
    }
    ,
    a.addEventListener = function(a, b, c) {
        var d;
        d = c ? this._captureListeners = this._captureListeners || {} : this._listeners = this._listeners || {};
        var e = d[a];
        return e && this.removeEventListener(a, b, c),
        e = d[a],
        e ? e.push(b) : d[a] = [b],
        b
    }
    ,
    a.on = function(a, b, c, d, e, f) {
        return b.handleEvent && (c = c || b,
        b = b.handleEvent),
        c = c || this,
        this.addEventListener(a, function(a) {
            b.call(c, a, e),
            d && a.remove()
        }, f)
    }
    ,
    a.removeEventListener = function(a, b, c) {
        var d = c ? this._captureListeners : this._listeners;
        if (d) {
            var e = d[a];
            if (e)
                for (var f = 0, g = e.length; g > f; f++)
                    if (e[f] == b) {
                        1 == g ? delete d[a] : e.splice(f, 1);
                        break
                    }
        }
    }
    ,
    a.off = a.removeEventListener,
    a.removeAllEventListeners = function(a) {
        a ? (this._listeners && delete this._listeners[a],
        this._captureListeners && delete this._captureListeners[a]) : this._listeners = this._captureListeners = null
    }
    ,
    a.dispatchEvent = function(a) {
        if ("string" == typeof a) {
            var b = this._listeners;
            if (!b || !b[a])
                return !1;
            a = new createjs.Event(a)
        } else
            a.target && a.clone && (a = a.clone());
        try {
            a.target = this
        } catch (c) {}
        if (a.bubbles && this.parent) {
            for (var d = this, e = [d]; d.parent; )
                e.push(d = d.parent);
            var f, g = e.length;
            for (f = g - 1; f >= 0 && !a.propagationStopped; f--)
                e[f]._dispatchEvent(a, 1 + (0 == f));
            for (f = 1; g > f && !a.propagationStopped; f++)
                e[f]._dispatchEvent(a, 3)
        } else
            this._dispatchEvent(a, 2);
        return a.defaultPrevented
    }
    ,
    a.hasEventListener = function(a) {
        var b = this._listeners
          , c = this._captureListeners;
        return !!(b && b[a] || c && c[a])
    }
    ,
    a.willTrigger = function(a) {
        for (var b = this; b; ) {
            if (b.hasEventListener(a))
                return !0;
            b = b.parent
        }
        return !1
    }
    ,
    a.toString = function() {
        return "[EventDispatcher]"
    }
    ,
    a._dispatchEvent = function(a, b) {
        var c, d = 1 == b ? this._captureListeners : this._listeners;
        if (a && d) {
            var e = d[a.type];
            if (!e || !(c = e.length))
                return;
            try {
                a.currentTarget = this
            } catch (f) {}
            try {
                a.eventPhase = b
            } catch (f) {}
            a.removed = !1,
            e = e.slice();
            for (var g = 0; c > g && !a.immediatePropagationStopped; g++) {
                var h = e[g];
                h.handleEvent ? h.handleEvent(a) : h(a),
                a.removed && (this.off(a.type, h, 1 == b),
                a.removed = !1)
            }
        }
    }
    ,
    createjs.EventDispatcher = EventDispatcher
}(),
this.createjs = this.createjs || {},
function() {
    function Event(a, b, c) {
        this.type = a,
        this.target = null,
        this.currentTarget = null,
        this.eventPhase = 0,
        this.bubbles = !!b,
        this.cancelable = !!c,
        this.timeStamp = (new Date).getTime(),
        this.defaultPrevented = !1,
        this.propagationStopped = !1,
        this.immediatePropagationStopped = !1,
        this.removed = !1
    }
    var a = Event.prototype;
    a.preventDefault = function() {
        this.defaultPrevented = this.cancelable && !0
    }
    ,
    a.stopPropagation = function() {
        this.propagationStopped = !0
    }
    ,
    a.stopImmediatePropagation = function() {
        this.immediatePropagationStopped = this.propagationStopped = !0
    }
    ,
    a.remove = function() {
        this.removed = !0
    }
    ,
    a.clone = function() {
        return new Event(this.type,this.bubbles,this.cancelable)
    }
    ,
    a.set = function(a) {
        for (var b in a)
            this[b] = a[b];
        return this
    }
    ,
    a.toString = function() {
        return "[Event (type=" + this.type + ")]"
    }
    ,
    createjs.Event = Event
}(),
this.createjs = this.createjs || {},
function() {
    function ErrorEvent(a, b, c) {
        this.Event_constructor("error"),
        this.title = a,
        this.message = b,
        this.data = c
    }
    var a = createjs.extend(ErrorEvent, createjs.Event);
    a.clone = function() {
        return new createjs.ErrorEvent(this.title,this.message,this.data)
    }
    ,
    createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event")
}(),
this.createjs = this.createjs || {},
function(a) {
    function ProgressEvent(a, b) {
        this.Event_constructor("progress"),
        this.loaded = a,
        this.total = null == b ? 1 : b,
        this.progress = 0 == b ? 0 : this.loaded / this.total
    }
    var b = createjs.extend(ProgressEvent, createjs.Event);
    b.clone = function() {
        return new createjs.ProgressEvent(this.loaded,this.total)
    }
    ,
    createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event")
}(window),
this.createjs = this.createjs || {},
function() {
    function LoadItem() {
        this.src = null,
        this.type = null,
        this.id = null,
        this.maintainOrder = !1,
        this.callback = null,
        this.data = null,
        this.method = createjs.LoadItem.GET,
        this.values = null,
        this.headers = null,
        this.withCredentials = !1,
        this.mimeType = null,
        this.crossOrigin = null,
        this.loadTimeout = b.LOAD_TIMEOUT_DEFAULT
    }
    var a = LoadItem.prototype = {}
      , b = LoadItem;
    b.LOAD_TIMEOUT_DEFAULT = 8E3,
    b.create = function(a) {
        if ("string" == typeof a) {
            var c = new LoadItem;
            return c.src = a,
            c
        }
        if (a instanceof b)
            return a;
        if (a instanceof Object && a.src)
            return null == a.loadTimeout && (a.loadTimeout = b.LOAD_TIMEOUT_DEFAULT),
            a;
        throw new Error("Type not recognized.");
    }
    ,
    a.set = function(a) {
        for (var b in a)
            this[b] = a[b];
        return this
    }
    ,
    createjs.LoadItem = b
}(),
function() {
    var a = {};
    a.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i,
    a.RELATIVE_PATT = /^[./]*?\//i,
    a.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i,
    a.parseURI = function(b) {
        var c = {
            absolute: !1,
            relative: !1
        };
        if (null == b)
            return c;
        var d = b.indexOf("?");
        d > -1 && (b = b.substr(0, d));
        var e;
        return a.ABSOLUTE_PATT.test(b) ? c.absolute = !0 : a.RELATIVE_PATT.test(b) && (c.relative = !0),
        (e = b.match(a.EXTENSION_PATT)) && (c.extension = e[1].toLowerCase()),
        c
    }
    ,
    a.formatQueryString = function(a, b) {
        if (null == a)
            throw new Error("You must specify data.");
        var c = [];
        for (var d in a)
            c.push(d + "=" + escape(a[d]));
        return b && (c = c.concat(b)),
        c.join("&")
    }
    ,
    a.buildPath = function(a, b) {
        if (null == b)
            return a;
        var c = []
          , d = a.indexOf("?");
        if (-1 != d) {
            var e = a.slice(d + 1);
            c = c.concat(e.split("&"))
        }
        return -1 != d ? a.slice(0, d) + "?" + this._formatQueryString(b, c) : a + "?" + this._formatQueryString(b, c)
    }
    ,
    a.isCrossDomain = function(a) {
        var b = document.createElement("a");
        b.href = a.src;
        var c = document.createElement("a");
        c.href = location.href;
        var d = "" != b.hostname && (b.port != c.port || b.protocol != c.protocol || b.hostname != c.hostname);
        return d
    }
    ,
    a.isLocal = function(a) {
        var b = document.createElement("a");
        return b.href = a.src,
        "" == b.hostname && "file:" == b.protocol
    }
    ,
    a.isBinary = function(a) {
        switch (a) {
        case createjs.AbstractLoader.IMAGE:
        case createjs.AbstractLoader.BINARY:
            return !0;
        default:
            return !1
        }
    }
    ,
    a.isImageTag = function(a) {
        return a instanceof HTMLImageElement
    }
    ,
    a.isAudioTag = function(a) {
        return window.HTMLAudioElement ? a instanceof HTMLAudioElement : !1
    }
    ,
    a.isVideoTag = function(a) {
        return window.HTMLVideoElement ? a instanceof HTMLVideoElement : !1
    }
    ,
    a.isText = function(a) {
        switch (a) {
        case createjs.AbstractLoader.TEXT:
        case createjs.AbstractLoader.JSON:
        case createjs.AbstractLoader.MANIFEST:
        case createjs.AbstractLoader.XML:
        case createjs.AbstractLoader.CSS:
        case createjs.AbstractLoader.SVG:
        case createjs.AbstractLoader.JAVASCRIPT:
        case createjs.AbstractLoader.SPRITESHEET:
            return !0;
        default:
            return !1
        }
    }
    ,
    a.getTypeByExtension = function(a) {
        if (null == a)
            return createjs.AbstractLoader.TEXT;
        switch (a.toLowerCase()) {
        case "jpeg":
        case "jpg":
        case "gif":
        case "png":
        case "webp":
        case "bmp":
            return createjs.AbstractLoader.IMAGE;
        case "ogg":
        case "mp3":
        case "webm":
            return createjs.AbstractLoader.SOUND;
        case "mp4":
        case "webm":
        case "ts":
            return createjs.AbstractLoader.VIDEO;
        case "json":
            return createjs.AbstractLoader.JSON;
        case "xml":
            return createjs.AbstractLoader.XML;
        case "css":
            return createjs.AbstractLoader.CSS;
        case "js":
            return createjs.AbstractLoader.JAVASCRIPT;
        case "svg":
            return createjs.AbstractLoader.SVG;
        default:
            return createjs.AbstractLoader.TEXT
        }
    }
    ,
    createjs.RequestUtils = a
}(),
this.createjs = this.createjs || {},
function() {
    function AbstractLoader(a, b, c) {
        this.EventDispatcher_constructor(),
        this.loaded = !1,
        this.canceled = !1,
        this.progress = 0,
        this.type = c,
        this.resultFormatter = null,
        a ? this._item = createjs.LoadItem.create(a) : this._item = null,
        this._preferXHR = b,
        this._result = null,
        this._rawResult = null,
        this._loadedItems = null,
        this._tagSrcAttribute = null,
        this._tag = null
    }
    var a = createjs.extend(AbstractLoader, createjs.EventDispatcher)
      , b = AbstractLoader;
    b.POST = "POST",
    b.GET = "GET",
    b.BINARY = "binary",
    b.CSS = "css",
    b.IMAGE = "image",
    b.JAVASCRIPT = "javascript",
    b.JSON = "json",
    b.JSONP = "jsonp",
    b.MANIFEST = "manifest",
    b.SOUND = "sound",
    b.VIDEO = "video",
    b.SPRITESHEET = "spritesheet",
    b.SVG = "svg",
    b.TEXT = "text",
    b.XML = "xml",
    a.getItem = function() {
        return this._item
    }
    ,
    a.getResult = function(a) {
        return a ? this._rawResult : this._result
    }
    ,
    a.getTag = function() {
        return this._tag
    }
    ,
    a.setTag = function(a) {
        this._tag = a
    }
    ,
    a.load = function() {
        this._createRequest(),
        this._request.on("complete", this, this),
        this._request.on("progress", this, this),
        this._request.on("loadStart", this, this),
        this._request.on("abort", this, this),
        this._request.on("timeout", this, this),
        this._request.on("error", this, this);
        var a = new createjs.Event("initialize");
        a.loader = this._request,
        this.dispatchEvent(a),
        this._request.load()
    }
    ,
    a.cancel = function() {
        this.canceled = !0,
        this.destroy()
    }
    ,
    a.destroy = function() {
        this._request && (this._request.removeAllEventListeners(),
        this._request.destroy()),
        this._request = null,
        this._item = null,
        this._rawResult = null,
        this._result = null,
        this._loadItems = null,
        this.removeAllEventListeners()
    }
    ,
    a.getLoadedItems = function() {
        return this._loadedItems
    }
    ,
    a._createRequest = function() {
        this._preferXHR ? this._request = new createjs.XHRRequest(this._item) : this._request = new createjs.TagRequest(this._item,this._tag || this._createTag(),this._tagSrcAttribute)
    }
    ,
    a._createTag = function(a) {
        return null
    }
    ,
    a._sendLoadStart = function() {
        this._isCanceled() || this.dispatchEvent("loadstart")
    }
    ,
    a._sendProgress = function(a) {
        if (!this._isCanceled()) {
            var b = null;
            "number" == typeof a ? (this.progress = a,
            b = new createjs.ProgressEvent(this.progress)) : (b = a,
            this.progress = a.loaded / a.total,
            b.progress = this.progress,
            (isNaN(this.progress) || this.progress == 1 / 0) && (this.progress = 0)),
            this.hasEventListener("progress") && this.dispatchEvent(b)
        }
    }
    ,
    a._sendComplete = function() {
        if (!this._isCanceled()) {
            this.loaded = !0;
            var a = new createjs.Event("complete");
            a.rawResult = this._rawResult,
            null != this._result && (a.result = this._result),
            this.dispatchEvent(a)
        }
    }
    ,
    a._sendError = function(a) {
        !this._isCanceled() && this.hasEventListener("error") && (null == a && (a = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY")),
        this.dispatchEvent(a))
    }
    ,
    a._isCanceled = function() {
        return null == window.createjs || this.canceled ? !0 : !1
    }
    ,
    a.resultFormatter = null,
    a.handleEvent = function(a) {
        switch (a.type) {
        case "complete":
            this._rawResult = a.target._response;
            var b = this.resultFormatter && this.resultFormatter(this)
              , c = this;
            b instanceof Function ? b(function(a) {
                c._result = a,
                c._sendComplete()
            }) : (this._result = b || this._rawResult,
            this._sendComplete());
            break;
        case "progress":
            this._sendProgress(a);
            break;
        case "error":
            this._sendError(a);
            break;
        case "loadstart":
            this._sendLoadStart();
            break;
        case "abort":
        case "timeout":
            this._isCanceled() || this.dispatchEvent(a.type)
        }
    }
    ,
    a.buildPath = function(a, b) {
        return createjs.RequestUtils.buildPath(a, b)
    }
    ,
    a.toString = function() {
        return "[PreloadJS AbstractLoader]"
    }
    ,
    createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher")
}(),
this.createjs = this.createjs || {},
function() {
    function AbstractMediaLoader(a, b, c) {
        this.AbstractLoader_constructor(a, b, c),
        this.resultFormatter = this._formatResult,
        this._tagSrcAttribute = "src"
    }
    var a = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);
    a.load = function() {
        this._tag || (this._tag = this._createTag(this._item.src)),
        this._tag.preload = "auto",
        this._tag.load(),
        this.AbstractLoader_load()
    }
    ,
    a._createTag = function() {}
    ,
    a._createRequest = function() {
        this._preferXHR ? this._request = new createjs.XHRRequest(this._item) : this._request = new createjs.MediaTagRequest(this._item,this._tag || this._createTag(),this._tagSrcAttribute)
    }
    ,
    a._formatResult = function(a) {
        return this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler),
        this._tag.onstalled = null,
        this._preferXHR && (a.getTag().src = a.getResult(!0)),
        a.getTag()
    }
    ,
    createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader")
}(),
this.createjs = this.createjs || {},
function() {
    var AbstractRequest = function(a) {
        this._item = a
    }
      , a = createjs.extend(AbstractRequest, createjs.EventDispatcher);
    a.load = function() {}
    ,
    a.destroy = function() {}
    ,
    a.cancel = function() {}
    ,
    createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher")
}(),
this.createjs = this.createjs || {},
function() {
    function TagRequest(a, b, c) {
        this.AbstractRequest_constructor(a),
        this._tag = b,
        this._tagSrcAttribute = c,
        this._loadedHandler = createjs.proxy(this._handleTagComplete, this),
        this._addedToDOM = !1,
        this._startTagVisibility = null
    }
    var a = createjs.extend(TagRequest, createjs.AbstractRequest);
    a.load = function() {
        this._tag.onload = createjs.proxy(this._handleTagComplete, this),
        this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this),
        this._tag.onerror = createjs.proxy(this._handleError, this);
        var a = new createjs.Event("initialize");
        a.loader = this._tag,
        this.dispatchEvent(a),
        this._hideTag(),
        this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout),
        this._tag[this._tagSrcAttribute] = this._item.src,
        null == this._tag.parentNode && (window.document.body.appendChild(this._tag),
        this._addedToDOM = !0)
    }
    ,
    a.destroy = function() {
        this._clean(),
        this._tag = null,
        this.AbstractRequest_destroy()
    }
    ,
    a._handleReadyStateChange = function() {
        clearTimeout(this._loadTimeout);
        var a = this._tag;
        ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete()
    }
    ,
    a._handleError = function() {
        this._clean(),
        this.dispatchEvent("error")
    }
    ,
    a._handleTagComplete = function() {
        this._rawResult = this._tag,
        this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult,
        this._clean(),
        this._showTag(),
        this.dispatchEvent("complete")
    }
    ,
    a._handleTimeout = function() {
        this._clean(),
        this.dispatchEvent(new createjs.Event("timeout"))
    }
    ,
    a._clean = function() {
        this._tag.onload = null,
        this._tag.onreadystatechange = null,
        this._tag.onerror = null,
        this._addedToDOM && null != this._tag.parentNode && this._tag.parentNode.removeChild(this._tag),
        clearTimeout(this._loadTimeout)
    }
    ,
    a._hideTag = function() {
        this._startTagVisibility = this._tag.style.visibility,
        this._tag.style.visibility = "hidden"
    }
    ,
    a._showTag = function() {
        this._tag.style.visibility = this._startTagVisibility
    }
    ,
    a._handleStalled = function() {}
    ,
    createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest")
}(),
this.createjs = this.createjs || {},
function() {
    function MediaTagRequest(a, b, c) {
        this.AbstractRequest_constructor(a),
        this._tag = b,
        this._tagSrcAttribute = c,
        this._loadedHandler = createjs.proxy(this._handleTagComplete, this)
    }
    var a = createjs.extend(MediaTagRequest, createjs.TagRequest);
    a.load = function() {
        var a = createjs.proxy(this._handleStalled, this);
        this._stalledCallback = a;
        var b = createjs.proxy(this._handleProgress, this);
        this._handleProgress = b,
        this._tag.addEventListener("stalled", a),
        this._tag.addEventListener("progress", b),
        this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, !1),
        this.TagRequest_load()
    }
    ,
    a._handleReadyStateChange = function() {
        clearTimeout(this._loadTimeout);
        var a = this._tag;
        ("loaded" == a.readyState || "complete" == a.readyState) && this._handleTagComplete()
    }
    ,
    a._handleStalled = function() {}
    ,
    a._handleProgress = function(a) {
        if (a && !(a.loaded > 0 && 0 == a.total)) {
            var b = new createjs.ProgressEvent(a.loaded,a.total);
            this.dispatchEvent(b)
        }
    }
    ,
    a._clean = function() {
        this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler),
        this._tag.removeEventListener("stalled", this._stalledCallback),
        this._tag.removeEventListener("progress", this._progressCallback),
        this.TagRequest__clean()
    }
    ,
    createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest")
}(),
this.createjs = this.createjs || {},
function() {
    function XHRRequest(a) {
        this.AbstractRequest_constructor(a),
        this._request = null,
        this._loadTimeout = null,
        this._xhrLevel = 1,
        this._response = null,
        this._rawResponse = null,
        this._canceled = !1,
        this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this),
        this._handleProgressProxy = createjs.proxy(this._handleProgress, this),
        this._handleAbortProxy = createjs.proxy(this._handleAbort, this),
        this._handleErrorProxy = createjs.proxy(this._handleError, this),
        this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this),
        this._handleLoadProxy = createjs.proxy(this._handleLoad, this),
        this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this),
        !this._createXHR(a)
    }
    var a = createjs.extend(XHRRequest, createjs.AbstractRequest);
    XHRRequest.ACTIVEX_VERSIONS = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"],
    a.getResult = function(a) {
        return a && this._rawResponse ? this._rawResponse : this._response
    }
    ,
    a.cancel = function() {
        this.canceled = !0,
        this._clean(),
        this._request.abort()
    }
    ,
    a.load = function() {
        if (null == this._request)
            return void this._handleError();
        this._request.addEventListener("loadstart", this._handleLoadStartProxy, !1),
        this._request.addEventListener("progress", this._handleProgressProxy, !1),
        this._request.addEventListener("abort", this._handleAbortProxy, !1),
        this._request.addEventListener("error", this._handleErrorProxy, !1),
        this._request.addEventListener("timeout", this._handleTimeoutProxy, !1),
        this._request.addEventListener("load", this._handleLoadProxy, !1),
        this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, !1),
        1 == this._xhrLevel && (this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout));
        try {
            this._item.values && this._item.method != createjs.AbstractLoader.GET ? this._item.method == createjs.AbstractLoader.POST && this._request.send(createjs.RequestUtils.formatQueryString(this._item.values)) : this._request.send()
        } catch (a) {
            this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND",null,a))
        }
    }
    ,
    a.setResponseType = function(a) {
        this._request.responseType = a
    }
    ,
    a.getAllResponseHeaders = function() {
        return this._request.getAllResponseHeaders instanceof Function ? this._request.getAllResponseHeaders() : null
    }
    ,
    a.getResponseHeader = function(a) {
        return this._request.getResponseHeader instanceof Function ? this._request.getResponseHeader(a) : null
    }
    ,
    a._handleProgress = function(a) {
        if (a && !(a.loaded > 0 && 0 == a.total)) {
            var b = new createjs.ProgressEvent(a.loaded,a.total);
            this.dispatchEvent(b)
        }
    }
    ,
    a._handleLoadStart = function(a) {
        clearTimeout(this._loadTimeout),
        this.dispatchEvent("loadstart")
    }
    ,
    a._handleAbort = function(a) {
        this._clean(),
        this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED",null,a))
    }
    ,
    a._handleError = function(a) {
        this._clean(),
        this.dispatchEvent(new createjs.ErrorEvent(a.message))
    }
    ,
    a._handleReadyStateChange = function(a) {
        4 == this._request.readyState && this._handleLoad()
    }
    ,
    a._handleLoad = function(a) {
        if (!this.loaded) {
            this.loaded = !0;
            var b = this._checkError();
            if (b)
                return void this._handleError(b);
            this._response = this._getResponse(),
            this._clean(),
            this.dispatchEvent(new createjs.Event("complete"))
        }
    }
    ,
    a._handleTimeout = function(a) {
        this._clean(),
        this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT",null,a))
    }
    ,
    a._checkError = function() {
        var a = parseInt(this._request.status);
        switch (a) {
        case 404:
        case 0:
            return new Error(a)
        }
        return null
    }
    ,
    a._getResponse = function() {
        if (null != this._response)
            return this._response;
        if (null != this._request.response)
            return this._request.response;
        try {
            if (null != this._request.responseText)
                return this._request.responseText
        } catch (a) {}
        try {
            if (null != this._request.responseXML)
                return this._request.responseXML
        } catch (a) {}
        return null
    }
    ,
    a._createXHR = function(a) {
        var b = createjs.RequestUtils.isCrossDomain(a)
          , c = {}
          , d = null;
        if (window.XMLHttpRequest)
            d = new XMLHttpRequest,
            b && void 0 === d.withCredentials && window.XDomainRequest && (d = new XDomainRequest);
        else {
            for (var e = 0, f = s.ACTIVEX_VERSIONS.length; f > e; e++) {
                s.ACTIVEX_VERSIONS[e];
                try {
                    d = new ActiveXObject(axVersions);
                    break
                } catch (g) {}
            }
            if (null == d)
                return !1
        }
        null == a.mimeType && createjs.RequestUtils.isText(a.type) && (a.mimeType = "text/plain; charset=utf-8"),
        a.mimeType && d.overrideMimeType && d.overrideMimeType(a.mimeType),
        this._xhrLevel = "string" == typeof d.responseType ? 2 : 1;
        var h = null;
        if (h = a.method == createjs.AbstractLoader.GET ? createjs.RequestUtils.buildPath(a.src, a.values) : a.src,
        d.open(a.method || createjs.AbstractLoader.GET, h, !0),
        b && d instanceof XMLHttpRequest && 1 == this._xhrLevel && (c.Origin = location.origin),
        a.values && a.method == createjs.AbstractLoader.POST && (c["Content-Type"] = "application/x-www-form-urlencoded"),
        b || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest"),
        a.headers)
            for (var i in a.headers)
                c[i] = a.headers[i];
        for (i in c)
            d.setRequestHeader(i, c[i]);
        return d instanceof XMLHttpRequest && void 0 !== a.withCredentials && (d.withCredentials = a.withCredentials),
        this._request = d,
        !0
    }
    ,
    a._clean = function() {
        clearTimeout(this._loadTimeout),
        this._request.removeEventListener("loadstart", this._handleLoadStartProxy),
        this._request.removeEventListener("progress", this._handleProgressProxy),
        this._request.removeEventListener("abort", this._handleAbortProxy),
        this._request.removeEventListener("error", this._handleErrorProxy),
        this._request.removeEventListener("timeout", this._handleTimeoutProxy),
        this._request.removeEventListener("load", this._handleLoadProxy),
        this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy)
    }
    ,
    a.toString = function() {
        return "[PreloadJS XHRRequest]"
    }
    ,
    createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest")
}(),
this.createjs = this.createjs || {},
function() {
    function SoundLoader(a, b) {
        this.AbstractMediaLoader_constructor(a, b, createjs.AbstractLoader.SOUND),
        createjs.RequestUtils.isAudioTag(a) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.src) ? this._tag = a : createjs.RequestUtils.isAudioTag(a.tag) && (this._tag = createjs.RequestUtils.isAudioTag(a) ? a : a.src),
        null != this._tag && (this._preferXHR = !1)
    }
    var a = createjs.extend(SoundLoader, createjs.AbstractMediaLoader)
      , b = SoundLoader;
    b.canLoadItem = function(a) {
        return a.type == createjs.AbstractLoader.SOUND
    }
    ,
    a._createTag = function(a) {
        var b = document.createElement("audio");
        return b.autoplay = !1,
        b.preload = "none",
        b.src = a,
        b
    }
    ,
    createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader")
}(),
this.createjs = this.createjs || {},
function() {
    var PlayPropsConfig = function() {
        this.interrupt = null,
        this.delay = null,
        this.offset = null,
        this.loop = null,
        this.volume = null,
        this.pan = null,
        this.startTime = null,
        this.duration = null
    }
      , a = PlayPropsConfig.prototype = {}
      , b = PlayPropsConfig;
    b.create = function(a) {
        if (a instanceof b || a instanceof Object) {
            var c = new createjs.PlayPropsConfig;
            return c.set(a),
            c
        }
        throw new Error("Type not recognized.");
    }
    ,
    a.set = function(a) {
        for (var b in a)
            this[b] = a[b];
        return this
    }
    ,
    a.toString = function() {
        return "[PlayPropsConfig]"
    }
    ,
    createjs.PlayPropsConfig = b
}(),
this.createjs = this.createjs || {},
function() {
    function Sound() {
        throw "Sound cannot be instantiated";
    }
    function a(a, b) {
        this.init(a, b)
    }
    var b = Sound;
    b.INTERRUPT_ANY = "any",
    b.INTERRUPT_EARLY = "early",
    b.INTERRUPT_LATE = "late",
    b.INTERRUPT_NONE = "none",
    b.PLAY_INITED = "playInited",
    b.PLAY_SUCCEEDED = "playSucceeded",
    b.PLAY_INTERRUPTED = "playInterrupted",
    b.PLAY_FINISHED = "playFinished",
    b.PLAY_FAILED = "playFailed",
    b.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "opus", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"],
    b.EXTENSION_MAP = {
        m4a: "mp4"
    },
    b.FILE_PATTERN = /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?))?([/.]*?(?:[^?]+)?\/)?((?:[^/?]+)\.(\w+))(?:\?(\S+)?)?$/,
    b.defaultInterruptBehavior = b.INTERRUPT_NONE,
    b.alternateExtensions = [],
    b.activePlugin = null,
    b._masterVolume = 1,
    Object.defineProperty(b, "volume", {
        get: function() {
            return this._masterVolume
        },
        set: function(a) {
            if (null == Number(a))
                return !1;
            if (a = Math.max(0, Math.min(1, a)),
            b._masterVolume = a,
            !this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(a))
                for (var c = this._instances, d = 0, e = c.length; e > d; d++)
                    c[d].setMasterVolume(a)
        }
    }),
    b._masterMute = !1,
    Object.defineProperty(b, "muted", {
        get: function() {
            return this._masterMute
        },
        set: function(a) {
            if (null == a)
                return !1;
            if (this._masterMute = a,
            !this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(a))
                for (var b = this._instances, c = 0, d = b.length; d > c; c++)
                    b[c].setMasterMute(a);
            return !0
        }
    }),
    Object.defineProperty(b, "capabilities", {
        get: function() {
            return null == b.activePlugin ? null : b.activePlugin._capabilities
        },
        set: function(a) {
            return !1
        }
    }),
    b._pluginsRegistered = !1,
    b._lastID = 0,
    b._instances = [],
    b._idHash = {},
    b._preloadHash = {},
    b._defaultPlayPropsHash = {},
    b.addEventListener = null,
    b.removeEventListener = null,
    b.removeAllEventListeners = null,
    b.dispatchEvent = null,
    b.hasEventListener = null,
    b._listeners = null,
    createjs.EventDispatcher.initialize(b),
    b.getPreloadHandlers = function() {
        return {
            callback: createjs.proxy(b.initLoad, b),
            types: ["sound"],
            extensions: b.SUPPORTED_EXTENSIONS
        }
    }
    ,
    b._handleLoadComplete = function(a) {
        var c = a.target.getItem().src;
        if (b._preloadHash[c])
            for (var d = 0, e = b._preloadHash[c].length; e > d; d++) {
                var f = b._preloadHash[c][d];
                if (b._preloadHash[c][d] = !0,
                b.hasEventListener("fileload")) {
                    var a = new createjs.Event("fileload");
                    a.src = f.src,
                    a.id = f.id,
                    a.data = f.data,
                    a.sprite = f.sprite,
                    b.dispatchEvent(a)
                }
            }
    }
    ,
    b._handleLoadError = function(a) {
        var c = a.target.getItem().src;
        if (b._preloadHash[c])
            for (var d = 0, e = b._preloadHash[c].length; e > d; d++) {
                var f = b._preloadHash[c][d];
                if (b._preloadHash[c][d] = !1,
                b.hasEventListener("fileerror")) {
                    var a = new createjs.Event("fileerror");
                    a.src = f.src,
                    a.id = f.id,
                    a.data = f.data,
                    a.sprite = f.sprite,
                    b.dispatchEvent(a)
                }
            }
    }
    ,
    b._registerPlugin = function(a) {
        return a.isSupported() ? (b.activePlugin = new a,
        !0) : !1
    }
    ,
    b.registerPlugins = function(a) {
        b._pluginsRegistered = !0;
        for (var c = 0, d = a.length; d > c; c++)
            if (b._registerPlugin(a[c]))
                return !0;
        return !1
    }
    ,
    b.initializeDefaultPlugins = function() {
        return null != b.activePlugin ? !0 : b._pluginsRegistered ? !1 : b.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin]) ? !0 : !1
    }
    ,
    b.isReady = function() {
        return null != b.activePlugin
    }
    ,
    b.getCapabilities = function() {
        return null == b.activePlugin ? null : b.activePlugin._capabilities
    }
    ,
    b.getCapability = function(a) {
        return null == b.activePlugin ? null : b.activePlugin._capabilities[a]
    }
    ,
    b.initLoad = function(a) {
        return b._registerSound(a)
    }
    ,
    b._registerSound = function(c) {
        if (!b.initializeDefaultPlugins())
            return !1;
        var d;
        if (c.src instanceof Object ? (d = b._parseSrc(c.src),
        d.src = c.path + d.src) : d = b._parsePath(c.src),
        null == d)
            return !1;
        c.src = d.src,
        c.type = "sound";
        var e = c.data
          , f = null;
        if (null != e && (isNaN(e.channels) ? isNaN(e) || (f = parseInt(e)) : f = parseInt(e.channels),
        e.audioSprite))
            for (var g, h = e.audioSprite.length; h--; )
                g = e.audioSprite[h],
                b._idHash[g.id] = {
                    src: c.src,
                    startTime: parseInt(g.startTime),
                    duration: parseInt(g.duration)
                },
                g.defaultPlayProps && (b._defaultPlayPropsHash[g.id] = createjs.PlayPropsConfig.create(g.defaultPlayProps));
        null != c.id && (b._idHash[c.id] = {
            src: c.src
        });
        var i = b.activePlugin.register(c);
        return a.create(c.src, f),
        null != e && isNaN(e) ? c.data.channels = f || a.maxPerChannel() : c.data = f || a.maxPerChannel(),
        i.type && (c.type = i.type),
        c.defaultPlayProps && (b._defaultPlayPropsHash[c.src] = createjs.PlayPropsConfig.create(c.defaultPlayProps)),
        i
    }
    ,
    b.registerSound = function(a, c, d, e, f) {
        var g = {
            src: a,
            id: c,
            data: d,
            defaultPlayProps: f
        };
        a instanceof Object && a.src && (e = c,
        g = a),
        g = createjs.LoadItem.create(g),
        g.path = e,
        null == e || g.src instanceof Object || (g.src = e + a);
        var h = b._registerSound(g);
        if (!h)
            return !1;
        if (b._preloadHash[g.src] || (b._preloadHash[g.src] = []),
        b._preloadHash[g.src].push(g),
        1 == b._preloadHash[g.src].length)
            h.on("complete", createjs.proxy(this._handleLoadComplete, this)),
            h.on("error", createjs.proxy(this._handleLoadError, this)),
            b.activePlugin.preload(h);
        else if (1 == b._preloadHash[g.src][0])
            return !0;
        return g
    }
    ,
    b.registerSounds = function(a, b) {
        var c = [];
        a.path && (b ? b += a.path : b = a.path,
        a = a.manifest);
        for (var d = 0, e = a.length; e > d; d++)
            c[d] = createjs.Sound.registerSound(a[d].src, a[d].id, a[d].data, b, a[d].defaultPlayProps);
        return c
    }
    ,
    b.removeSound = function(c, d) {
        if (null == b.activePlugin)
            return !1;
        c instanceof Object && c.src && (c = c.src);
        var e;
        if (c instanceof Object ? e = b._parseSrc(c) : (c = b._getSrcById(c).src,
        e = b._parsePath(c)),
        null == e)
            return !1;
        c = e.src,
        null != d && (c = d + c);
        for (var f in b._idHash)
            b._idHash[f].src == c && delete b._idHash[f];
        return a.removeSrc(c),
        delete b._preloadHash[c],
        b.activePlugin.removeSound(c),
        !0
    }
    ,
    b.removeSounds = function(a, b) {
        var c = [];
        a.path && (b ? b += a.path : b = a.path,
        a = a.manifest);
        for (var d = 0, e = a.length; e > d; d++)
            c[d] = createjs.Sound.removeSound(a[d].src, b);
        return c
    }
    ,
    b.removeAllSounds = function() {
        b._idHash = {},
        b._preloadHash = {},
        a.removeAll(),
        b.activePlugin && b.activePlugin.removeAllSounds()
    }
    ,
    b.loadComplete = function(a) {
        if (!b.isReady())
            return !1;
        var c = b._parsePath(a);
        return a = c ? b._getSrcById(c.src).src : b._getSrcById(a).src,
        void 0 == b._preloadHash[a] ? !1 : 1 == b._preloadHash[a][0]
    }
    ,
    b._parsePath = function(a) {
        "string" != typeof a && (a = a.toString());
        var c = a.match(b.FILE_PATTERN);
        if (null == c)
            return !1;
        for (var d = c[4], e = c[5], f = b.capabilities, g = 0; !f[e]; )
            if (e = b.alternateExtensions[g++],
            g > b.alternateExtensions.length)
                return null;
        a = a.replace("." + c[5], "." + e);
        var h = {
            name: d,
            src: a,
            extension: e
        };
        return h
    }
    ,
    b._parseSrc = function(a) {
        var c = {
            name: void 0,
            src: void 0,
            extension: void 0
        }
          , d = b.capabilities;
        for (var e in a)
            if (a.hasOwnProperty(e) && d[e]) {
                c.src = a[e],
                c.extension = e;
                break
            }
        if (!c.src)
            return !1;
        var f = c.src.lastIndexOf("/");
        return -1 != f ? c.name = c.src.slice(f + 1) : c.name = c.src,
        c
    }
    ,
    b.play = function(a, c, d, e, f, g, h, i, j) {
        var k;
        k = c instanceof Object || c instanceof createjs.PlayPropsConfig ? createjs.PlayPropsConfig.create(c) : createjs.PlayPropsConfig.create({
            interrupt: c,
            delay: d,
            offset: e,
            loop: f,
            volume: g,
            pan: h,
            startTime: i,
            duration: j
        });
        var l = b.createInstance(a, k.startTime, k.duration)
          , m = b._playInstance(l, k);
        return m || l._playFailed(),
        l
    }
    ,
    b.createInstance = function(c, d, e) {
        if (!b.initializeDefaultPlugins())
            return new createjs.DefaultSoundInstance(c,d,e);
        var f = b._defaultPlayPropsHash[c];
        c = b._getSrcById(c);
        var g = b._parsePath(c.src)
          , h = null;
        return null != g && null != g.src ? (a.create(g.src),
        null == d && (d = c.startTime),
        h = b.activePlugin.create(g.src, d, e || c.duration),
        f = f || b._defaultPlayPropsHash[g.src],
        f && h.applyPlayProps(f)) : h = new createjs.DefaultSoundInstance(c,d,e),
        h.uniqueId = b._lastID++,
        h
    }
    ,
    b.stop = function() {
        for (var a = this._instances, b = a.length; b--; )
            a[b].stop()
    }
    ,
    b.setVolume = function(a) {
        if (null == Number(a))
            return !1;
        if (a = Math.max(0, Math.min(1, a)),
        b._masterVolume = a,
        !this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(a))
            for (var c = this._instances, d = 0, e = c.length; e > d; d++)
                c[d].setMasterVolume(a)
    }
    ,
    b.getVolume = function() {
        return this._masterVolume
    }
    ,
    b.setMute = function(a) {
        if (null == a)
            return !1;
        if (this._masterMute = a,
        !this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(a))
            for (var b = this._instances, c = 0, d = b.length; d > c; c++)
                b[c].setMasterMute(a);
        return !0
    }
    ,
    b.getMute = function() {
        return this._masterMute
    }
    ,
    b.setDefaultPlayProps = function(a, c) {
        a = b._getSrcById(a),
        b._defaultPlayPropsHash[b._parsePath(a.src).src] = createjs.PlayPropsConfig.create(c)
    }
    ,
    b.getDefaultPlayProps = function(a) {
        return a = b._getSrcById(a),
        b._defaultPlayPropsHash[b._parsePath(a.src).src]
    }
    ,
    b._playInstance = function(a, c) {
        var d = b._defaultPlayPropsHash[a.src] || {};
        if (null == c.interrupt && (c.interrupt = d.interrupt || b.defaultInterruptBehavior),
        null == c.delay && (c.delay = d.delay || 0),
        null == c.offset && (c.offset = a.getPosition()),
        null == c.loop && (c.loop = a.loop),
        null == c.volume && (c.volume = a.volume),
        null == c.pan && (c.pan = a.pan),
        0 == c.delay) {
            var e = b._beginPlaying(a, c);
            if (!e)
                return !1
        } else {
            var f = setTimeout(function() {
                b._beginPlaying(a, c)
            }, c.delay);
            a.delayTimeoutId = f
        }
        return this._instances.push(a),
        !0
    }
    ,
    b._beginPlaying = function(b, c) {
        if (!a.add(b, c.interrupt))
            return !1;
        var d = b._beginPlaying(c);
        if (!d) {
            var e = createjs.indexOf(this._instances, b);
            return e > -1 && this._instances.splice(e, 1),
            !1
        }
        return !0
    }
    ,
    b._getSrcById = function(a) {
        return b._idHash[a] || {
            src: a
        }
    }
    ,
    b._playFinished = function(b) {
        a.remove(b);
        var c = createjs.indexOf(this._instances, b);
        c > -1 && this._instances.splice(c, 1)
    }
    ,
    createjs.Sound = Sound,
    a.channels = {},
    a.create = function(b, c) {
        var d = a.get(b);
        return null == d ? (a.channels[b] = new a(b,c),
        !0) : !1
    }
    ,
    a.removeSrc = function(b) {
        var c = a.get(b);
        return null == c ? !1 : (c._removeAll(),
        delete a.channels[b],
        !0)
    }
    ,
    a.removeAll = function() {
        for (var b in a.channels)
            a.channels[b]._removeAll();
        a.channels = {}
    }
    ,
    a.add = function(b, c) {
        var d = a.get(b.src);
        return null == d ? !1 : d._add(b, c)
    }
    ,
    a.remove = function(b) {
        var c = a.get(b.src);
        return null == c ? !1 : (c._remove(b),
        !0)
    }
    ,
    a.maxPerChannel = function() {
        return c.maxDefault
    }
    ,
    a.get = function(b) {
        return a.channels[b]
    }
    ;
    var c = a.prototype;
    c.constructor = a,
    c.src = null,
    c.max = null,
    c.maxDefault = 100,
    c.length = 0,
    c.init = function(a, b) {
        this.src = a,
        this.max = b || this.maxDefault,
        -1 == this.max && (this.max = this.maxDefault),
        this._instances = []
    }
    ,
    c._get = function(a) {
        return this._instances[a]
    }
    ,
    c._add = function(a, b) {
        return this._getSlot(b, a) ? (this._instances.push(a),
        this.length++,
        !0) : !1
    }
    ,
    c._remove = function(a) {
        var b = createjs.indexOf(this._instances, a);
        return -1 == b ? !1 : (this._instances.splice(b, 1),
        this.length--,
        !0)
    }
    ,
    c._removeAll = function() {
        for (var a = this.length - 1; a >= 0; a--)
            this._instances[a].stop()
    }
    ,
    c._getSlot = function(a, b) {
        var c, d;
        if (a != Sound.INTERRUPT_NONE && (d = this._get(0),
        null == d))
            return !0;
        for (var e = 0, f = this.max; f > e; e++) {
            if (c = this._get(e),
            null == c)
                return !0;
            if (c.playState == Sound.PLAY_FINISHED || c.playState == Sound.PLAY_INTERRUPTED || c.playState == Sound.PLAY_FAILED) {
                d = c;
                break
            }
            a != Sound.INTERRUPT_NONE && (a == Sound.INTERRUPT_EARLY && c.getPosition() < d.getPosition() || a == Sound.INTERRUPT_LATE && c.getPosition() > d.getPosition()) && (d = c)
        }
        return null != d ? (d._interrupt(),
        this._remove(d),
        !0) : !1
    }
    ,
    c.toString = function() {
        return "[Sound SoundChannel]"
    }
}(),
this.createjs = this.createjs || {},
function() {
    var AbstractSoundInstance = function(a, b, c, d) {
        this.EventDispatcher_constructor(),
        this.src = a,
        this.uniqueId = -1,
        this.playState = null,
        this.delayTimeoutId = null,
        this._volume = 1,
        Object.defineProperty(this, "volume", {
            get: this.getVolume,
            set: this.setVolume
        }),
        this._pan = 0,
        Object.defineProperty(this, "pan", {
            get: this.getPan,
            set: this.setPan
        }),
        this._startTime = Math.max(0, b || 0),
        Object.defineProperty(this, "startTime", {
            get: this.getStartTime,
            set: this.setStartTime
        }),
        this._duration = Math.max(0, c || 0),
        Object.defineProperty(this, "duration", {
            get: this.getDuration,
            set: this.setDuration
        }),
        this._playbackResource = null,
        Object.defineProperty(this, "playbackResource", {
            get: this.getPlaybackResource,
            set: this.setPlaybackResource
        }),
        d !== !1 && d !== !0 && this.setPlaybackResource(d),
        this._position = 0,
        Object.defineProperty(this, "position", {
            get: this.getPosition,
            set: this.setPosition
        }),
        this._loop = 0,
        Object.defineProperty(this, "loop", {
            get: this.getLoop,
            set: this.setLoop
        }),
        this._muted = !1,
        Object.defineProperty(this, "muted", {
            get: this.getMuted,
            set: this.setMuted
        }),
        this._paused = !1,
        Object.defineProperty(this, "paused", {
            get: this.getPaused,
            set: this.setPaused
        })
    }
      , a = createjs.extend(AbstractSoundInstance, createjs.EventDispatcher);
    a.play = function(a, b, c, d, e, f) {
        var g;
        return g = a instanceof Object || a instanceof createjs.PlayPropsConfig ? createjs.PlayPropsConfig.create(a) : createjs.PlayPropsConfig.create({
            interrupt: a,
            delay: b,
            offset: c,
            loop: d,
            volume: e,
            pan: f
        }),
        this.playState == createjs.Sound.PLAY_SUCCEEDED ? (this.applyPlayProps(g),
        void (this._paused && this.setPaused(!1))) : (this._cleanUp(),
        createjs.Sound._playInstance(this, g),
        this)
    }
    ,
    a.stop = function() {
        return this._position = 0,
        this._paused = !1,
        this._handleStop(),
        this._cleanUp(),
        this.playState = createjs.Sound.PLAY_FINISHED,
        this
    }
    ,
    a.destroy = function() {
        this._cleanUp(),
        this.src = null,
        this.playbackResource = null,
        this.removeAllEventListeners()
    }
    ,
    a.applyPlayProps = function(a) {
        return null != a.offset && this.setPosition(a.offset),
        null != a.loop && this.setLoop(a.loop),
        null != a.volume && this.setVolume(a.volume),
        null != a.pan && this.setPan(a.pan),
        null != a.startTime && (this.setStartTime(a.startTime),
        this.setDuration(a.duration)),
        this
    }
    ,
    a.toString = function() {
        return "[AbstractSoundInstance]"
    }
    ,
    a.getPaused = function() {
        return this._paused
    }
    ,
    a.setPaused = function(a) {
        return a !== !0 && a !== !1 || this._paused == a || 1 == a && this.playState != createjs.Sound.PLAY_SUCCEEDED ? void 0 : (this._paused = a,
        a ? this._pause() : this._resume(),
        clearTimeout(this.delayTimeoutId),
        this)
    }
    ,
    a.setVolume = function(a) {
        return a == this._volume ? this : (this._volume = Math.max(0, Math.min(1, a)),
        this._muted || this._updateVolume(),
        this)
    }
    ,
    a.getVolume = function() {
        return this._volume
    }
    ,
    a.setMuted = function(a) {
        return a === !0 || a === !1 ? (this._muted = a,
        this._updateVolume(),
        this) : void 0
    }
    ,
    a.getMuted = function() {
        return this._muted
    }
    ,
    a.setPan = function(a) {
        return a == this._pan ? this : (this._pan = Math.max(-1, Math.min(1, a)),
        this._updatePan(),
        this)
    }
    ,
    a.getPan = function() {
        return this._pan
    }
    ,
    a.getPosition = function() {
        return this._paused || this.playState != createjs.Sound.PLAY_SUCCEEDED || (this._position = this._calculateCurrentPosition()),
        this._position
    }
    ,
    a.setPosition = function(a) {
        return this._position = Math.max(0, a),
        this.playState == createjs.Sound.PLAY_SUCCEEDED && this._updatePosition(),
        this
    }
    ,
    a.getStartTime = function() {
        return this._startTime
    }
    ,
    a.setStartTime = function(a) {
        return a == this._startTime ? this : (this._startTime = Math.max(0, a || 0),
        this._updateStartTime(),
        this)
    }
    ,
    a.getDuration = function() {
        return this._duration
    }
    ,
    a.setDuration = function(a) {
        return a == this._duration ? this : (this._duration = Math.max(0, a || 0),
        this._updateDuration(),
        this)
    }
    ,
    a.setPlaybackResource = function(a) {
        return this._playbackResource = a,
        0 == this._duration && this._setDurationFromSource(),
        this
    }
    ,
    a.getPlaybackResource = function() {
        return this._playbackResource
    }
    ,
    a.getLoop = function() {
        return this._loop
    }
    ,
    a.setLoop = function(a) {
        null != this._playbackResource && (0 != this._loop && 0 == a ? this._removeLooping(a) : 0 == this._loop && 0 != a && this._addLooping(a)),
        this._loop = a
    }
    ,
    a._sendEvent = function(a) {
        var b = new createjs.Event(a);
        this.dispatchEvent(b)
    }
    ,
    a._cleanUp = function() {
        clearTimeout(this.delayTimeoutId),
        this._handleCleanUp(),
        this._paused = !1,
        createjs.Sound._playFinished(this)
    }
    ,
    a._interrupt = function() {
        this._cleanUp(),
        this.playState = createjs.Sound.PLAY_INTERRUPTED,
        this._sendEvent("interrupted")
    }
    ,
    a._beginPlaying = function(a) {
        return this.setPosition(a.offset),
        this.setLoop(a.loop),
        this.setVolume(a.volume),
        this.setPan(a.pan),
        null != a.startTime && (this.setStartTime(a.startTime),
        this.setDuration(a.duration)),
        null != this._playbackResource && this._position < this._duration ? (this._paused = !1,
        this._handleSoundReady(),
        this.playState = createjs.Sound.PLAY_SUCCEEDED,
        this._sendEvent("succeeded"),
        !0) : (this._playFailed(),
        !1)
    }
    ,
    a._playFailed = function() {
        this._cleanUp(),
        this.playState = createjs.Sound.PLAY_FAILED,
        this._sendEvent("failed")
    }
    ,
    a._handleSoundComplete = function(a) {
        return this._position = 0,
        0 != this._loop ? (this._loop--,
        this._handleLoop(),
        void this._sendEvent("loop")) : (this._cleanUp(),
        this.playState = createjs.Sound.PLAY_FINISHED,
        void this._sendEvent("complete"))
    }
    ,
    a._handleSoundReady = function() {}
    ,
    a._updateVolume = function() {}
    ,
    a._updatePan = function() {}
    ,
    a._updateStartTime = function() {}
    ,
    a._updateDuration = function() {}
    ,
    a._setDurationFromSource = function() {}
    ,
    a._calculateCurrentPosition = function() {}
    ,
    a._updatePosition = function() {}
    ,
    a._removeLooping = function(a) {}
    ,
    a._addLooping = function(a) {}
    ,
    a._pause = function() {}
    ,
    a._resume = function() {}
    ,
    a._handleStop = function() {}
    ,
    a._handleCleanUp = function() {}
    ,
    a._handleLoop = function() {}
    ,
    createjs.AbstractSoundInstance = createjs.promote(AbstractSoundInstance, "EventDispatcher"),
    createjs.DefaultSoundInstance = createjs.AbstractSoundInstance
}(),
this.createjs = this.createjs || {},
function() {
    var AbstractPlugin = function() {
        this._capabilities = null,
        this._loaders = {},
        this._audioSources = {},
        this._soundInstances = {},
        this._volume = 1,
        this._loaderClass,
        this._soundInstanceClass
    }
      , a = AbstractPlugin.prototype;
    AbstractPlugin._capabilities = null,
    AbstractPlugin.isSupported = function() {
        return !0
    }
    ,
    a.register = function(a) {
        var b = this._loaders[a.src];
        return b && !b.canceled ? this._loaders[a.src] : (this._audioSources[a.src] = !0,
        this._soundInstances[a.src] = [],
        b = new this._loaderClass(a),
        b.on("complete", createjs.proxy(this._handlePreloadComplete, this)),
        this._loaders[a.src] = b,
        b)
    }
    ,
    a.preload = function(a) {
        a.on("error", createjs.proxy(this._handlePreloadError, this)),
        a.load()
    }
    ,
    a.isPreloadStarted = function(a) {
        return null != this._audioSources[a]
    }
    ,
    a.isPreloadComplete = function(a) {
        return !(null == this._audioSources[a] || 1 == this._audioSources[a])
    }
    ,
    a.removeSound = function(a) {
        if (this._soundInstances[a]) {
            for (var b = this._soundInstances[a].length; b--; ) {
                var c = this._soundInstances[a][b];
                c.destroy()
            }
            delete this._soundInstances[a],
            delete this._audioSources[a],
            this._loaders[a] && this._loaders[a].destroy(),
            delete this._loaders[a]
        }
    }
    ,
    a.removeAllSounds = function() {
        for (var a in this._audioSources)
            this.removeSound(a)
    }
    ,
    a.create = function(a, b, c) {
        this.isPreloadStarted(a) || this.preload(this.register(a));
        var d = new this._soundInstanceClass(a,b,c,this._audioSources[a]);
        return void 0 == this._soundInstances[a] && (this._soundInstances[a] = []),
        d
    }
    ,
    a.setVolume = function(a) {
        return this._volume = a,
        this._updateVolume(),
        !0
    }
    ,
    a.getVolume = function() {
        return this._volume
    }
    ,
    a.setMute = function(a) {
        return this._updateVolume(),
        !0
    }
    ,
    a.toString = function() {
        return "[AbstractPlugin]"
    }
    ,
    a._handlePreloadComplete = function(a) {
        var b = a.target.getItem().src;
        this._audioSources[b] = a.result;
        for (var c = 0, d = this._soundInstances[b].length; d > c; c++) {
            var e = this._soundInstances[b][c];
            e.setPlaybackResource(this._audioSources[b])
        }
    }
    ,
    a._handlePreloadError = function(a) {}
    ,
    a._updateVolume = function() {}
    ,
    createjs.AbstractPlugin = AbstractPlugin
}(),
this.createjs = this.createjs || {},
function() {
    function a(a) {
        this.AbstractLoader_constructor(a, !0, createjs.AbstractLoader.SOUND)
    }
    var b = createjs.extend(a, createjs.AbstractLoader);
    a.context = null,
    b.toString = function() {
        return "[WebAudioLoader]"
    }
    ,
    b._createRequest = function() {
        this._request = new createjs.XHRRequest(this._item,!1),
        this._request.setResponseType("arraybuffer")
    }
    ,
    b._sendComplete = function(b) {
        a.context.decodeAudioData(this._rawResult, createjs.proxy(this._handleAudioDecoded, this), createjs.proxy(this._sendError, this))
    }
    ,
    b._handleAudioDecoded = function(a) {
        this._result = a,
        this.AbstractLoader__sendComplete()
    }
    ,
    createjs.WebAudioLoader = createjs.promote(a, "AbstractLoader")
}(),
this.createjs = this.createjs || {},
function() {
    function WebAudioSoundInstance(a, c, d, e) {
        this.AbstractSoundInstance_constructor(a, c, d, e),
        this.gainNode = b.context.createGain(),
        this.panNode = b.context.createPanner(),
        this.panNode.panningModel = b._panningModel,
        this.panNode.connect(this.gainNode),
        this.sourceNode = null,
        this._soundCompleteTimeout = null,
        this._sourceNodeNext = null,
        this._playbackStartTime = 0,
        this._endedHandler = createjs.proxy(this._handleSoundComplete, this)
    }
    var a = createjs.extend(WebAudioSoundInstance, createjs.AbstractSoundInstance)
      , b = WebAudioSoundInstance;
    b.context = null,
    b.destinationNode = null,
    b._panningModel = "equalpower",
    a.destroy = function() {
        this.AbstractSoundInstance_destroy(),
        this.panNode.disconnect(0),
        this.panNode = null,
        this.gainNode.disconnect(0),
        this.gainNode = null
    }
    ,
    a.toString = function() {
        return "[WebAudioSoundInstance]"
    }
    ,
    a._updatePan = function() {
        this.panNode.setPosition(this._pan, 0, -.5)
    }
    ,
    a._removeLooping = function(a) {
        this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext)
    }
    ,
    a._addLooping = function(a) {
        this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0))
    }
    ,
    a._setDurationFromSource = function() {
        this._duration = 1E3 * this.playbackResource.duration
    }
    ,
    a._handleCleanUp = function() {
        this.sourceNode && this.playState == createjs.Sound.PLAY_SUCCEEDED && (this.sourceNode = this._cleanUpAudioNode(this.sourceNode),
        this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext)),
        0 != this.gainNode.numberOfOutputs && this.gainNode.disconnect(0),
        clearTimeout(this._soundCompleteTimeout),
        this._playbackStartTime = 0
    }
    ,
    a._cleanUpAudioNode = function(a) {
        if (a) {
            try {
                a.stop(0)
            } catch (b) {}
            a.disconnect(0),
            a = null
        }
        return a
    }
    ,
    a._handleSoundReady = function(a) {
        this.gainNode.connect(b.destinationNode);
        var c = .001 * this._duration
          , d = .001 * this._position;
        d > c && (d = c),
        this.sourceNode = this._createAndPlayAudioNode(b.context.currentTime - c, d),
        this._playbackStartTime = this.sourceNode.startTime - d,
        this._soundCompleteTimeout = setTimeout(this._endedHandler, 1E3 * (c - d)),
        0 != this._loop && (this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0))
    }
    ,
    a._createAndPlayAudioNode = function(a, c) {
        var d = b.context.createBufferSource();
        d.buffer = this.playbackResource,
        d.connect(this.panNode);
        var e = .001 * this._duration;
        return d.startTime = a + e,
        d.start(d.startTime, c + .001 * this._startTime, e - c),
        d
    }
    ,
    a._pause = function() {
        this._position = 1E3 * (b.context.currentTime - this._playbackStartTime),
        this.sourceNode = this._cleanUpAudioNode(this.sourceNode),
        this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext),
        0 != this.gainNode.numberOfOutputs && this.gainNode.disconnect(0),
        clearTimeout(this._soundCompleteTimeout)
    }
    ,
    a._resume = function() {
        this._handleSoundReady()
    }
    ,
    a._updateVolume = function() {
        var a = this._muted ? 0 : this._volume;
        a != this.gainNode.gain.value && (this.gainNode.gain.value = a)
    }
    ,
    a._calculateCurrentPosition = function() {
        return 1E3 * (b.context.currentTime - this._playbackStartTime)
    }
    ,
    a._updatePosition = function() {
        this.sourceNode = this._cleanUpAudioNode(this.sourceNode),
        this._sourceNodeNext = this._cleanUpAudioNode(this._sourceNodeNext),
        clearTimeout(this._soundCompleteTimeout),
        this._paused || this._handleSoundReady()
    }
    ,
    a._handleLoop = function() {
        this._cleanUpAudioNode(this.sourceNode),
        this.sourceNode = this._sourceNodeNext,
        this._playbackStartTime = this.sourceNode.startTime,
        this._sourceNodeNext = this._createAndPlayAudioNode(this._playbackStartTime, 0),
        this._soundCompleteTimeout = setTimeout(this._endedHandler, this._duration)
    }
    ,
    a._updateDuration = function() {
        this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._pause(),
        this._resume())
    }
    ,
    createjs.WebAudioSoundInstance = createjs.promote(WebAudioSoundInstance, "AbstractSoundInstance")
}(),
this.createjs = this.createjs || {},
function() {
    function WebAudioPlugin() {
        this.AbstractPlugin_constructor(),
        this._panningModel = b._panningModel,
        this.context = b.context,
        this.dynamicsCompressorNode = this.context.createDynamicsCompressor(),
        this.dynamicsCompressorNode.connect(this.context.destination),
        this.gainNode = this.context.createGain(),
        this.gainNode.connect(this.dynamicsCompressorNode),
        createjs.WebAudioSoundInstance.destinationNode = this.gainNode,
        this._capabilities = b._capabilities,
        this._loaderClass = createjs.WebAudioLoader,
        this._soundInstanceClass = createjs.WebAudioSoundInstance,
        this._addPropsToClasses()
    }
    var a = createjs.extend(WebAudioPlugin, createjs.AbstractPlugin)
      , b = WebAudioPlugin;
    b._capabilities = null,
    b._panningModel = "equalpower",
    b.context = null,
    b.isSupported = function() {
        var a = createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry;
        return "file:" != location.protocol || a || this._isFileXHRSupported() ? (b._generateCapabilities(),
        null == b.context ? !1 : !0) : !1
    }
    ,
    b.playEmptySound = function() {
        if (null != b.context) {
            var a = b.context.createBufferSource();
            a.buffer = b.context.createBuffer(1, 1, 22050),
            a.connect(b.context.destination),
            a.start(0, 0, 0)
        }
    }
    ,
    b._isFileXHRSupported = function() {
        var a = !0
          , b = new XMLHttpRequest;
        try {
            b.open("GET", "WebAudioPluginTest.fail", !1)
        } catch (c) {
            return a = !1
        }
        b.onerror = function() {
            a = !1
        }
        ,
        b.onload = function() {
            a = 404 == this.status || 200 == this.status || 0 == this.status && "" != this.response
        }
        ;
        try {
            b.send()
        } catch (c) {
            a = !1
        }
        return a
    }
    ,
    b._generateCapabilities = function() {
        if (null == b._capabilities) {
            var a = document.createElement("audio");
            if (null == a.canPlayType)
                return null;
            if (null == b.context)
                if (window.AudioContext)
                    b.context = new AudioContext;
                else {
                    if (!window.webkitAudioContext)
                        return null;
                    b.context = new webkitAudioContext
                }
            b._compatibilitySetUp(),
            b.playEmptySound(),
            b._capabilities = {
                panning: !0,
                volume: !0,
                tracks: -1
            };
            for (var c = createjs.Sound.SUPPORTED_EXTENSIONS, d = createjs.Sound.EXTENSION_MAP, e = 0, f = c.length; f > e; e++) {
                var g = c[e]
                  , h = d[g] || g;
                b._capabilities[g] = "no" != a.canPlayType("audio/" + g) && "" != a.canPlayType("audio/" + g) || "no" != a.canPlayType("audio/" + h) && "" != a.canPlayType("audio/" + h)
            }
            b.context.destination.numberOfChannels < 2 && (b._capabilities.panning = !1)
        }
    }
    ,
    b._compatibilitySetUp = function() {
        if (b._panningModel = "equalpower",
        !b.context.createGain) {
            b.context.createGain = b.context.createGainNode;
            var a = b.context.createBufferSource();
            a.__proto__.start = a.__proto__.noteGrainOn,
            a.__proto__.stop = a.__proto__.noteOff,
            b._panningModel = 0
        }
    }
    ,
    a.toString = function() {
        return "[WebAudioPlugin]"
    }
    ,
    a._addPropsToClasses = function() {
        var a = this._soundInstanceClass;
        a.context = this.context,
        a.destinationNode = this.gainNode,
        a._panningModel = this._panningModel,
        this._loaderClass.context = this.context
    }
    ,
    a._updateVolume = function() {
        var a = createjs.Sound._masterMute ? 0 : this._volume;
        a != this.gainNode.gain.value && (this.gainNode.gain.value = a)
    }
    ,
    createjs.WebAudioPlugin = createjs.promote(WebAudioPlugin, "AbstractPlugin")
}(),
this.createjs = this.createjs || {},
function() {
    function HTMLAudioTagPool() {
        throw "HTMLAudioTagPool cannot be instantiated";
    }
    function a(a) {
        this._tags = []
    }
    var b = HTMLAudioTagPool;
    b._tags = {},
    b._tagPool = new a,
    b._tagUsed = {},
    b.get = function(a) {
        var c = b._tags[a];
        return null == c ? (c = b._tags[a] = b._tagPool.get(),
        c.src = a) : b._tagUsed[a] ? (c = b._tagPool.get(),
        c.src = a) : b._tagUsed[a] = !0,
        c
    }
    ,
    b.set = function(a, c) {
        c == b._tags[a] ? b._tagUsed[a] = !1 : b._tagPool.set(c)
    }
    ,
    b.remove = function(a) {
        var c = b._tags[a];
        return null == c ? !1 : (b._tagPool.set(c),
        delete b._tags[a],
        delete b._tagUsed[a],
        !0)
    }
    ,
    b.getDuration = function(a) {
        var c = b._tags[a];
        return null == c ? 0 : 1E3 * c.duration
    }
    ,
    createjs.HTMLAudioTagPool = HTMLAudioTagPool;
    var c = a.prototype;
    c.constructor = a,
    c.get = function() {
        var a;
        return a = 0 == this._tags.length ? this._createTag() : this._tags.pop(),
        null == a.parentNode && document.body.appendChild(a),
        a
    }
    ,
    c.set = function(a) {
        var b = createjs.indexOf(this._tags, a);
        -1 == b && (this._tags.src = null,
        this._tags.push(a))
    }
    ,
    c.toString = function() {
        return "[TagPool]"
    }
    ,
    c._createTag = function() {
        var a = document.createElement("audio");
        return a.autoplay = !1,
        a.preload = "none",
        a
    }
}(),
this.createjs = this.createjs || {},
function() {
    function HTMLAudioSoundInstance(a, b, c, d) {
        this.AbstractSoundInstance_constructor(a, b, c, d),
        this._audioSpriteStopTime = null,
        this._delayTimeoutId = null,
        this._endedHandler = createjs.proxy(this._handleSoundComplete, this),
        this._readyHandler = createjs.proxy(this._handleTagReady, this),
        this._stalledHandler = createjs.proxy(this._playFailed, this),
        this._audioSpriteEndHandler = createjs.proxy(this._handleAudioSpriteLoop, this),
        this._loopHandler = createjs.proxy(this._handleSoundComplete, this),
        c ? this._audioSpriteStopTime = .001 * (b + c) : this._duration = createjs.HTMLAudioTagPool.getDuration(this.src)
    }
    var a = createjs.extend(HTMLAudioSoundInstance, createjs.AbstractSoundInstance);
    a.setMasterVolume = function(a) {
        this._updateVolume()
    }
    ,
    a.setMasterMute = function(a) {
        this._updateVolume()
    }
    ,
    a.toString = function() {
        return "[HTMLAudioSoundInstance]"
    }
    ,
    a._removeLooping = function() {
        null != this._playbackResource && (this._playbackResource.loop = !1,
        this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
    }
    ,
    a._addLooping = function() {
        null == this._playbackResource || this._audioSpriteStopTime || (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1),
        this._playbackResource.loop = !0)
    }
    ,
    a._handleCleanUp = function() {
        var a = this._playbackResource;
        if (null != a) {
            a.pause(),
            a.loop = !1,
            a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1),
            a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1),
            a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1),
            a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1),
            a.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1);
            try {
                a.currentTime = this._startTime
            } catch (b) {}
            createjs.HTMLAudioTagPool.set(this.src, a),
            this._playbackResource = null
        }
    }
    ,
    a._beginPlaying = function(a) {
        return this._playbackResource = createjs.HTMLAudioTagPool.get(this.src),
        this.AbstractSoundInstance__beginPlaying(a)
    }
    ,
    a._handleSoundReady = function(a) {
        if (4 !== this._playbackResource.readyState) {
            var b = this._playbackResource;
            return b.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1),
            b.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1),
            b.preload = "auto",
            void b.load()
        }
        this._updateVolume(),
        this._playbackResource.currentTime = .001 * (this._startTime + this._position),
        this._audioSpriteStopTime ? this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1) : (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1),
        0 != this._loop && (this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1),
        this._playbackResource.loop = !0)),
        this._playbackResource.play()
    }
    ,
    a._handleTagReady = function(a) {
        this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY, this._readyHandler, !1),
        this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED, this._stalledHandler, !1),
        this._handleSoundReady()
    }
    ,
    a._pause = function() {
        this._playbackResource.pause()
    }
    ,
    a._resume = function() {
        this._playbackResource.play()
    }
    ,
    a._updateVolume = function() {
        if (null != this._playbackResource) {
            var a = this._muted || createjs.Sound._masterMute ? 0 : this._volume * createjs.Sound._masterVolume;
            a != this._playbackResource.volume && (this._playbackResource.volume = a)
        }
    }
    ,
    a._calculateCurrentPosition = function() {
        return 1E3 * this._playbackResource.currentTime - this._startTime
    }
    ,
    a._updatePosition = function() {
        this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1),
        this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, !1);
        try {
            this._playbackResource.currentTime = .001 * (this._position + this._startTime)
        } catch (a) {
            this._handleSetPositionSeek(null)
        }
    }
    ,
    a._handleSetPositionSeek = function(a) {
        null != this._playbackResource && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._handleSetPositionSeek, !1),
        this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
    }
    ,
    a._handleAudioSpriteLoop = function(a) {
        this._playbackResource.currentTime <= this._audioSpriteStopTime || (this._playbackResource.pause(),
        0 == this._loop ? this._handleSoundComplete(null) : (this._position = 0,
        this._loop--,
        this._playbackResource.currentTime = .001 * this._startTime,
        this._paused || this._playbackResource.play(),
        this._sendEvent("loop")))
    }
    ,
    a._handleLoop = function(a) {
        0 == this._loop && (this._playbackResource.loop = !1,
        this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED, this._loopHandler, !1))
    }
    ,
    a._updateStartTime = function() {
        this._audioSpriteStopTime = .001 * (this._startTime + this._duration),
        this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1),
        this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1))
    }
    ,
    a._updateDuration = function() {
        this._audioSpriteStopTime = .001 * (this._startTime + this._duration),
        this.playState == createjs.Sound.PLAY_SUCCEEDED && (this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED, this._endedHandler, !1),
        this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE, this._audioSpriteEndHandler, !1))
    }
    ,
    createjs.HTMLAudioSoundInstance = createjs.promote(HTMLAudioSoundInstance, "AbstractSoundInstance")
}(),
this.createjs = this.createjs || {},
function() {
    function HTMLAudioPlugin() {
        this.AbstractPlugin_constructor(),
        this.defaultNumChannels = 2,
        this._capabilities = b._capabilities,
        this._loaderClass = createjs.SoundLoader,
        this._soundInstanceClass = createjs.HTMLAudioSoundInstance
    }
    var a = createjs.extend(HTMLAudioPlugin, createjs.AbstractPlugin)
      , b = HTMLAudioPlugin;
    b.MAX_INSTANCES = 30,
    b._AUDIO_READY = "canplaythrough",
    b._AUDIO_ENDED = "ended",
    b._AUDIO_SEEKED = "seeked",
    b._AUDIO_STALLED = "stalled",
    b._TIME_UPDATE = "timeupdate",
    b._capabilities = null,
    b.isSupported = function() {
        return b._generateCapabilities(),
        null != b._capabilities
    }
    ,
    b._generateCapabilities = function() {
        if (null == b._capabilities) {
            var a = document.createElement("audio");
            if (null == a.canPlayType)
                return null;
            b._capabilities = {
                panning: !1,
                volume: !0,
                tracks: -1
            };
            for (var c = createjs.Sound.SUPPORTED_EXTENSIONS, d = createjs.Sound.EXTENSION_MAP, e = 0, f = c.length; f > e; e++) {
                var g = c[e]
                  , h = d[g] || g;
                b._capabilities[g] = "no" != a.canPlayType("audio/" + g) && "" != a.canPlayType("audio/" + g) || "no" != a.canPlayType("audio/" + h) && "" != a.canPlayType("audio/" + h)
            }
        }
    }
    ,
    a.register = function(a) {
        var b = createjs.HTMLAudioTagPool.get(a.src)
          , c = this.AbstractPlugin_register(a);
        return c.setTag(b),
        c
    }
    ,
    a.removeSound = function(a) {
        this.AbstractPlugin_removeSound(a),
        createjs.HTMLAudioTagPool.remove(a)
    }
    ,
    a.create = function(a, b, c) {
        var d = this.AbstractPlugin_create(a, b, c);
        return d.setPlaybackResource(null),
        d
    }
    ,
    a.toString = function() {
        return "[HTMLAudioPlugin]"
    }
    ,
    a.setVolume = a.getVolume = a.setMute = null,
    createjs.HTMLAudioPlugin = createjs.promote(HTMLAudioPlugin, "AbstractPlugin")
}();
function AnimationClip() {
    this.curves = [];
    this.events = [];
    this.name = "";
    this.length = 0;
    this.wrapMode = WrapMode.Default
}
function AnimationClipCurveData() {
    this.path = "";
    this.propertyName = "";
    this.type = "";
    this.curve = null
}
function AnimationEvent() {
    this.functionName = "";
    this.time = 0;
    this.param = ""
}
goog.provide("UHT.AnimationCurve");
function Keyframe(time, value, inTangent, outTangent) {
    var undefined;
    this.time = time;
    this.value = value;
    this.inTangent = inTangent !== undefined ? inTangent : 0;
    this.outTangent = outTangent ? outTangent : 0
}
Keyframe.prototype.__type_name_hack__ = "Keyframe";
function AnimationCurve(keys) {
    this._lastKey = 0;
    this.keys = [];
    var undefined;
    if (keys === undefined)
        return;
    this.addKeys(keys)
}
AnimationCurve.prototype.clearKeys = function() {
    this.keys = []
}
;
AnimationCurve.prototype.addKeys = function(keys) {
    var i = keys.length;
    while (i--)
        this.addKey(keys[i]);
    this.sortKeys()
}
;
AnimationCurve.prototype.addKey = function(key) {
    this.keys.push(key)
}
;
AnimationCurve.prototype.sortKeys = function() {
    this.keys.sort(function(a, b) {
        return a.time - b.time
    })
}
;
function _source() {
    this.times = {
        timesCount: 0,
        increase: 0
    };
    this.inTangents = null;
    this.outTangents = null
}
AnimationCurve.prototype.deserialize = function(source, helper, resolveReference) {
    var i = 0;
    var times = [];
    if (source.times.timesCount != undefined)
        for (i = 0; i < source.times.timesCount; i++)
            times.push(i * source.times.increase);
    else
        for (i = 0; i < source.times.length; i++)
            times.push(source.times[i]);
    var values = [];
    for (i = 0; i < source.values.length; i++)
        values.push(source.values[i]);
    var trimmed;
    trimmed = values[values.length - 1];
    while (values.length < times.length)
        values.push(trimmed);
    var inTs = [];
    for (i = 0; i < source.inTangents.length; i++)
        inTs.push(source.inTangents[i]);
    trimmed = inTs[inTs.length - 1];
    while (inTs.length < times.length)
        inTs.push(trimmed);
    var outTs = [];
    if (source.outTangents == "copy")
        for (i = 0; i < inTs.length; i++)
            outTs.push(inTs[i]);
    else {
        for (i = 0; i < source.outTangents.length; i++)
            outTs.push(source.outTangents[i]);
        trimmed = outTs[outTs.length - 1];
        while (outTs.length < times.length)
            outTs.push(trimmed)
    }
    for (i = 0; i < times.length; i++) {
        var key = new Keyframe(times[i],values[i],inTs[i],outTs[i]);
        this.addKey(key)
    }
}
;
AnimationCurve.prototype.Evaluate = function(animTime) {
    var undefined;
    var time = animTime;
    var len = this.keys.length;
    if (len === 1)
        return this.keys[0].value;
    var i, k0, k1;
    this._lastKey = Math.min(this._lastKey, len - 1);
    if (time <= this.keys[0].time)
        return this.keys[0].value;
    else if (time >= this.keys[len - 1].time)
        return this.keys[len - 1].value;
    var start = this.keys[this._lastKey].time <= time ? this._lastKey : 0;
    for (i = start; i < len - 1; i++)
        if (this.keys[i].time <= time && this.keys[i + 1].time > time) {
            k0 = this.keys[i];
            k1 = this.keys[i + 1];
            this._lastKey = i;
            break
        }
    if (!isFinite(k0.outTangent) || !isFinite(k1.inTangent))
        return k0.value;
    var t = UHTMath.inverseLerp(k0.time, k1.time, time);
    var dt = k1.time - k0.time;
    var m0 = k0.outTangent * dt;
    var m1 = k1.inTangent * dt;
    var t2 = t * t;
    var t3 = t2 * t;
    var a = 2 * t3 - 3 * t2 + 1;
    var b = t3 - 2 * t2 + t;
    var c = t3 - t2;
    var d = -2 * t3 + 3 * t2;
    return a * k0.value + b * m0 + c * m1 + d * k1.value
}
;
AnimationCurve.linear = function(timeStart, valueStart, timeEnd, valueEnd) {
    var k0 = new Keyframe(timeStart,valueStart,0,0);
    var k1 = new Keyframe(timeEnd,valueEnd,0,0);
    return new AnimationCurve([k0, k1])
}
;
goog.provide("UHT.AnimationUtils");
var AnimationUtils = {};
var WrapMode = {
    Default: 0,
    Once: 1,
    Clamp: 1,
    Loop: 2,
    PingPong: 4,
    ClampForever: 8
};
goog.provide("UHT.AudioClip");
function AudioClip(name, path) {
    this.name = name;
    this.path = path;
    this.soundjsObject = null;
    Object.defineProperties(this, {
        "length": {
            get: function() {
                if (this.soundjsObject != null)
                    return this.soundjsObject.duration / 1E3;
                return 0
            }
        }
    })
}
AudioClip.prototype.length = 0;
goog.provide("UHT.Component");
var __component_ctor_just_called = false;
function Component() {
    this.gameObject = null;
    this.enabled = true;
    this._rawData = null;
    this.transform = null;
    this.flags = ComponentStateFlags.onDisable_called;
    this.internalUpdateIdx = -1;
    this.internalLateUpdateIdx = -1;
    this.internalOnWillRenderIdx = -1;
    __component_ctor_just_called = true
}
Component.prototype.scriptUpdatePriority = 5;
Component.prototype.canReceiveMessage = true;
var ComponentStateFlags = {
    awake_called: 1,
    start_called: 2,
    onEnable_called: 4,
    onDisable_called: 8
};
Component.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference)
}
;
Component.prototype.copyFromSource = function(source, helper, resolveReference) {
    copyComponentHelper(source, this, helper, resolveReference)
}
;
Component.prototype.Awake = function() {}
;
Component.prototype.Start = function() {}
;
Component.prototype.OnEnable = function() {}
;
Component.prototype.OnDisable = function() {}
;
Component.prototype.GetComponent = function(componentType) {
    return this.gameObject.GetComponent(componentType)
}
;
Component.prototype.GetComponentsInChildren = function(type, includeInactive) {
    return this.gameObject.GetComponentsInChildren(type, includeInactive)
}
;
Component.prototype.GetComponentInChildren = function(type) {
    return this.gameObject.GetComponentInChildren(type)
}
;
Component.FindObjectOfType = function(type) {
    var objects = globalRuntime.sceneRoots;
    for (var i = 0; i < objects.length; ++i) {
        var component = objects[i].GetComponentInChildren(type);
        if (component != null && component.gameObject.activeInHierarchy)
            return component
    }
    return null
}
;
goog.require("UHT.Component");
var AudioVelocityUpdateMode = {
    Auto: 0,
    Fixed: 1,
    Dynamic: 2
};
UHTAudioListener.prototype = Object.create(Component.prototype);
UHTAudioListener.prototype.constructor = UHTAudioListener;
function UHTAudioListener() {
    Component.call(this)
}
UHTAudioListener.volume = 1;
goog.provide("UHT.Animation");
goog.require("UHT.Component");
Animation.prototype = Object.create(Component.prototype);
Animation.prototype.constructor = Animation;
function Animation() {
    Component.call(this);
    this._clip = null;
    this.playAutomatically = false;
    this.clips = [];
    this._isPlaying = false;
    this.animStates = [];
    this.currentAnimState = null;
    this.isInited = false;
    this._runtime_cache = null;
    this.isPlaying = false;
    this.clip = null;
    Object.defineProperties(this, {
        "isPlaying": {
            set: function(value) {},
            get: function() {
                return this._isPlaying
            }
        },
        "clip": {
            set: function(value) {
                var isok = false;
                for (var i = 0; i < this.clips.length; i++)
                    if (this.clips[i] == value) {
                        isok = true;
                        break
                    }
                if (isok && value != null)
                    this._clip = value;
                else {
                    this._clip = null;
                    console.log("Animation: Tried to set an invalid clip for animation")
                }
            },
            get: function() {
                return this._clip
            }
        }
    })
}
Animation.prototype.canReceiveMessage = false;
Animation.prototype.Start = function() {
    this.Init()
}
;
Animation.prototype.OnEnable = function() {
    if (this.playAutomatically)
        this.Play()
}
;
Animation.prototype.OnDisable = function() {
    this.Stop()
}
;
Animation.prototype.UpdateAnimation = function() {
    if (this._isPlaying)
        if (this.currentAnimState.Update() == false)
            this.Stop()
}
;
Animation.prototype.Init = function() {
    if (this.isInited == false) {
        for (var i = 0; i < this.clips.length; i++) {
            var c = this.clips[i];
            this.AddAnimStateForClip(c)
        }
        this.isInited = true
    }
}
;
Animation.prototype.GetAnimationState = function(clipName) {
    if (this.isInited == false)
        this.Init();
    for (var i = 0; i < this.animStates.length; i++)
        if (this.animStates[i].name == clipName)
            return this.animStates[i];
    return null
}
;
Animation.prototype.Play = function(clipName) {
    if (!this.gameObject.activeInHierarchy)
        console.error("Trying to start an animation on an inactive object (" + this.gameObject.name + "). This is undefined behaviour!");
    this.Stop();
    var name = "";
    var undefined;
    if (clipName === undefined)
        if (this.clip != null)
            name = this.clip.name;
        else
            return false;
    else
        name = clipName;
    this.currentAnimState = this.GetAnimationState(name);
    this.currentAnimState.enabled = true;
    this._isPlaying = true;
    globalRuntime.RegisterAnimation(this);
    return true
}
;
Animation.prototype.IsPlaying = function(clipName) {
    if (this._isPlaying) {
        var astate = this.GetAnimationState(clipName);
        if (astate != null)
            if (astate.enabled)
                return true
    }
    return false
}
;
Animation.prototype.Stop = function() {
    if (this._isPlaying && this.currentAnimState != null) {
        this.currentAnimState.Stop();
        this.currentAnimState.enabled = false;
        this.currentAnimState = null;
        this._isPlaying = false;
        globalRuntime.UnregisterAnimation(this)
    }
}
;
Animation.prototype.Sample = function() {
    for (var i = 0; i < this.animStates.length; i++)
        if (this.animStates[i].enabled)
            this.animStates[i].Sample()
}
;
Animation.prototype.AddClip = function(_clip, unusedName) {
    if (this.clips.indexOf(_clip) >= 0)
        return;
    this.clips.push(_clip);
    this.AddAnimStateForClip(_clip)
}
;
Animation.prototype.GetClip = function(clipName) {
    for (var i = 0; i < this.clips.length; i++)
        if (this.clips[i].name == clipName)
            return this.clips[i];
    return null
}
;
Animation.prototype.AddAnimStateForClip = function(_clip) {
    if (_clip != null) {
        var curState = new AnimationState(_clip);
        curState.Init(this.gameObject);
        this.animStates.push(curState)
    }
}
;
goog.provide("UHT.AudioSource");
goog.require("UHT.Component");
goog.require("UHT.AudioClip");
AudioSource.prototype = Object.create(Component.prototype);
AudioSource.prototype.constructor = AudioSource;
function AudioSource() {
    Component.call(this);
    this.audio = this;
    this.clip = null;
    this.playOnAwake = false;
    var volume = 1;
    var loop = false;
    this._MustPlayClipWhenSoundsAreLoaded = false;
    Object.defineProperties(this, {
        "volume": {
            set: function(value) {
                volume = value;
                if (this.clip != null && this.clip.soundjsObject != null)
                    this.clip.soundjsObject.volume = volume;
                for (var i = 0; i < this.oneShotInstances.length; ++i)
                    this.oneShotInstances[i].volume = volume
            },
            get: function() {
                return volume
            }
        },
        "loop": {
            set: function(value) {
                loop = value;
                if (this.clip != null && this.clip.soundjsObject != null)
                    this.clip.soundjsObject.loop = loop ? -1 : 0
            },
            get: function() {
                return loop
            }
        }
    });
    this.oneShotInstances = []
}
AudioSource.prototype.canReceiveMessage = false;
AudioSource.prototype.Play = function() {
    if (UHTEngine.SoundsAreLoaded() == false && this.loop) {
        this._MustPlayClipWhenSoundsAreLoaded = true;
        return
    }
    if (this.clip == null || this.clip.soundjsObject == null)
        return;
    this.clip.soundjsObject.volume = this.volume;
    this.clip.soundjsObject.loop = this.loop ? -1 : 0;
    this.clip.soundjsObject.stop();
    this.clip.soundjsObject.play()
}
;
AudioSource.prototype.Update = function() {
    if (this._MustPlayClipWhenSoundsAreLoaded && UHTEngine.SoundsAreLoaded()) {
        this._MustPlayClipWhenSoundsAreLoaded = false;
        this.Play()
    }
}
;
AudioSource.prototype.PlayOneShot = function(clip, volumeScale) {
    if (clip == null || clip.soundjsObject == null)
        return;
    var options = {
        interrupt: createjs.Sound.INTERRUPT_ANY,
        loop: 0
    };
    if (volumeScale != undefined)
        options.volume = volumeScale;
    var obj = createjs.Sound.play(clip.name, options);
    var self = this;
    var oneShotCallback = function() {
        self.OnOneShotComplete.apply(self, arguments)
    };
    obj.on("complete", oneShotCallback);
    obj.on("failed", oneShotCallback);
    obj.on("interrupted", oneShotCallback);
    this.oneShotInstances.push(obj)
}
;
AudioSource.prototype.Stop = function() {
    this._MustPlayClipWhenSoundsAreLoaded = false;
    if (this.clip == null || this.clip.soundjsObject == null)
        return;
    this.clip.soundjsObject.stop()
}
;
AudioSource.prototype.OnOneShotComplete = function(event) {
    var idx = this.oneShotInstances.indexOf(event.target);
    this.oneShotInstances.splice(idx, 1)
}
;
goog.require("UHT.Component");
goog.provide("UHT.Camera");
Camera.prototype = Object.create(Component.prototype);
Camera.prototype.constructor = Camera;
function Camera() {
    Component.call(this);
    this.cullingMask = 0;
    this.depth = 0;
    this.orthographicSize = 1;
    this.container = new PIXI.Container;
    this.clipRight = 0;
    this.oldSW = 0;
    this.oldSH = 0;
    this.cachedWTSP = new UHTMath.Vector3;
    this.mask = new PIXI.Graphics;
    this.scale = UHTScreen.height / 2 / this.orthographicSize;
    this.extraCameraSettings = undefined;
    this.ignoreInputBlocked = false
}
Camera.prototype.canReceiveMessage = false;
Camera.prototype.ComputeClipMask = function() {
    var TL = new UHTMath.Vector3(-this.extraCameraSettings.clipLeft,this.extraCameraSettings.clipUp,0);
    var BR = new UHTMath.Vector3(this.extraCameraSettings.clipRight,-this.extraCameraSettings.clipDown,0);
    var TLW = this.gameObject.transform.transformPoint(TL);
    var BRW = this.gameObject.transform.transformPoint(BR);
    var TLS = this.WorldToScreenPoint(TLW);
    var BRS = this.WorldToScreenPoint(BRW);
    var clipX = TLS.x;
    var clipY = TLS.y;
    var clipW = BRS.x - TLS.x;
    var clipH = BRS.y - TLS.y;
    clipX = Math.max(clipX, 0);
    clipY = Math.max(clipY, 0);
    clipW = Math.min(clipW, UHTScreen.width);
    clipH = Math.min(clipH, UHTScreen.height);
    this.mask.clear();
    this.mask.beginFill(16777215);
    this.mask.drawRect(clipX, clipY, clipW, clipH);
    this.mask.endFill()
}
;
Camera.allCameras = [];
Camera.prototype.Update = function() {
    this.scale = UHTScreen.height / 2 / this.orthographicSize
}
;
Camera.prototype.OnEnable = function() {
    this.Update()
}
;
Camera.prototype.OnWillRenderObject = function() {
    var c = this.container;
    var isClipping = this.IsClipping();
    if (this.gameObject.transform.IsDirtyUserFlag(Transform._DirtyFlagCamera) || UHTScreen.width != this.oldSW || UHTScreen.height != this.oldSH || isClipping && this.extraCameraSettings.dirtyFlag) {
        this.cachedWTSP = this.WorldToScreenPoint(new UHTMath.Vector3);
        this.gameObject.transform.ClearDirtyUserFlag(Transform._DirtyFlagCamera);
        this.oldSW = UHTScreen.width;
        this.oldSH = UHTScreen.height;
        if (isClipping) {
            this.ComputeClipMask();
            this.extraCameraSettings.dirtyFlag = false
        }
        this.container.dirtyWT = true
    }
    c.x = this.cachedWTSP.x;
    c.y = this.cachedWTSP.y;
    c.scale.x = this.scale;
    c.scale.y = this.scale;
    c.mask = isClipping ? this.mask : null
}
;
Camera.prototype.ScreenToWorldPoint = function(scrPoint) {
    var ret = new UHTMath.Vector3(scrPoint);
    ret.x -= UHTScreen.width / 2;
    ret.y -= UHTScreen.height / 2;
    ret.x *= 1 / this.scale;
    ret.y *= -1 / this.scale;
    ret.add(this.gameObject.transform.position());
    return ret
}
;
Camera.prototype.WorldToScreenPoint = function(worldPoint) {
    var ret = UHTMath.Vector3.sub(worldPoint, this.gameObject.transform.position());
    ret.x *= this.scale;
    ret.y *= -this.scale;
    ret.x += UHTScreen.width / 2;
    ret.y += UHTScreen.height / 2;
    return ret
}
;
Camera.prototype.IsClipping = function() {
    if (this.extraCameraSettings === undefined)
        this.extraCameraSettings = this.gameObject.GetComponent(ExtraCameraSettings);
    return this.extraCameraSettings != null && this.extraCameraSettings.enabled
}
;
Camera.prototype.IsClippingInput = function() {
    return this.IsClipping() && this.extraCameraSettings.clipInput
}
;
goog.provide("UHT.Collider");
goog.require("UHT.Component");
Collider.prototype = Object.create(Component.prototype);
Collider.prototype.constructor = Collider;
function Collider() {
    Component.call(this);
    this.center = new UHTMath.Vector3;
    this.size = new UHTMath.Vector3;
    this.isSphere = false;
    this.cachedTransformedCenter = new UHTMath.Vector3;
    this.cachedTransformedSize = new UHTMath.Vector3
}
Collider.prototype.canReceiveMessage = false;
Collider.prototype.Start = function() {
    globalColliderInputManager.registerCollider(this)
}
;
Collider.prototype.GetTransformedCenterAndSize = function() {
    if (this.gameObject.transform.IsDirtyUserFlag(Transform._DirtyFlagCollider)) {
        this.UpdateCachedMembers();
        this.gameObject.transform.ClearDirtyUserFlag(Transform._DirtyFlagCollider)
    }
    return {
        center: new UHTMath.Vector3(this.cachedTransformedCenter),
        size: new UHTMath.Vector3(this.cachedTransformedSize)
    }
}
;
Collider.prototype.UpdateCachedMembers = function() {
    this.cachedTransformedCenter = this.gameObject.transform.transformPoint(this.center);
    this.cachedTransformedSize = this.gameObject.transform.transformVector(this.size)
}
;
goog.provide("UHT.ClampVelocityModule");
function ClampVelocityModule(ps) {
    this.dampen = 0;
    this.magnitude = null;
    this.x = null;
    this.y = null;
    this.z = null;
    this.separateAxis = false;
    this.inWorldSpace = false;
    this.dampPos = 0;
    this.particleSystem = ps
}
ClampVelocityModule.prototype.deserialize = function(src) {
    this.reset();
    this.inWorldSpace = src.inWorldSpace === "True";
    this.separateAxis = src.separateAxis === "True";
    this.dampen = UHTMath.clamp(Number(src.dampen), 0, 1);
    if (this.separateAxis) {
        this.x = new ParticleSystemEvaluator;
        this.y = new ParticleSystemEvaluator;
        this.z = new ParticleSystemEvaluator;
        this.x.deserialize(src.x);
        this.y.deserialize(src.y);
        this.z.deserialize(src.z)
    } else {
        this.magnitude = new ParticleSystemEvaluator;
        this.magnitude.deserialize(src.magnitude)
    }
}
;
ClampVelocityModule.prototype.Evaluate = function(time, velocity) {
    var ret = new UHTMath.Vector3;
    if (this.separateAxis === true) {
        var coords = ["x", "y", "z"];
        var i = coords.length;
        var desiredMagnitude = new UHTMath.Vector3;
        while (i--)
            desiredMagnitude[coords[i]] = Math.max(0, this[coords[i]].Evaluate(time));
        if (!this.inWorldSpace) {
            desiredMagnitude = this.particleSystem.gameObject.transform.transformDirection(desiredMagnitude);
            i = coords.length;
            while (i--) {
                var c = coords[i];
                if (desiredMagnitude[c] < 0)
                    desiredMagnitude[c] = 0
            }
        }
        i = coords.length;
        while (i--) {
            var c = coords[i];
            var av = Math.abs(velocity[c]);
            var sign = velocity[c] / av;
            if (av > desiredMagnitude[c])
                ret[c] = UHTMath.lerp(av, desiredMagnitude[c], this.dampPos) * sign;
            else
                ret[c] = velocity[c]
        }
    } else {
        var curMagnitude = velocity.magnitude();
        if (Math.abs(curMagnitude) > 1E-5) {
            var unit = UHTMath.Vector3.scale(velocity, 1 / curMagnitude);
            var desiredMagnitude = this.magnitude.Evaluate(time);
            var delta = UHTMath.lerp(curMagnitude, desiredMagnitude, this.dampPos);
            ret.set(UHTMath.Vector3.scale(unit, delta))
        }
    }
    this.dampPos += this.dampen;
    return ret
}
;
ClampVelocityModule.prototype.reset = function() {
    if (this.magnitude != null)
        this.magnitude.reset();
    if (this.x != null)
        this.x.reset();
    if (this.y != null)
        this.y.reset();
    if (this.z != null)
        this.z.reset();
    this.dampPos = 0
}
;
goog.provide("UHT.ParticleSystemEvaluator");
function ParticleSystemEvaluator() {
    this.minMaxState = 0;
    this.scalar = 0;
    this.minCurve = new AnimationCurve;
    this.maxCurve = new AnimationCurve;
    this.random = 0
}
ParticleSystemEvaluator.prototype.Evaluate = function(time) {
    switch (this.minMaxState) {
    case 3:
    case 2:
        var min = this.minCurve.Evaluate(time);
        var max = this.maxCurve.Evaluate(time);
        return this.scalar * (min + (max - min) * this.random);
        break;
    case 1:
        return this.maxCurve.Evaluate(time) * this.scalar;
        break;
    default:
        return this.scalar
    }
}
;
ParticleSystemEvaluator.prototype.deserialize = function(src) {
    this.random = Math.random();
    this.minMaxState = Number(src.minMaxState);
    this.scalar = Number(src.scalar);
    this.fillFrom(this.minCurve, src.minCurve);
    this.fillFrom(this.maxCurve, src.maxCurve)
}
;
ParticleSystemEvaluator.prototype.ReRandomize = function() {
    this.random = Math.random()
}
;
ParticleSystemEvaluator.prototype.fillFrom = function(dest, src) {
    if (src.cachedKeys !== undefined) {
        dest.keys = src.cachedKeys;
        return
    }
    dest.clearKeys();
    var i = src.m_Curve.Array.size;
    while (i--) {
        var o = src.m_Curve.Array["data[" + i.toString() + "]"];
        var key = new Keyframe(Number(o.time),Number(o.value),Number(o.inSlope),Number(o.outSlope));
        dest.addKey(key)
    }
    dest.sortKeys();
    src.cachedKeys = dest.keys
}
;
ParticleSystemEvaluator.prototype.reset = function() {
    this.minCurve.clearKeys();
    this.maxCurve.clearKeys()
}
;
goog.provide("UHT.ParticleSystemEvaluatorBySpeed");
function ParticleSystemEvaluatorBySpeed(ev) {
    this.evaluator = ev;
    this.intervalMin = 0;
    this.intervalMax = 0;
    this.evaluator.scalar = 1
}
ParticleSystemEvaluatorBySpeed.prototype.Evaluate = function(time) {
    var v = UHTMath.inverseLerp(this.intervalMin, this.intervalMax, time);
    return this.evaluator.Evaluate(v)
}
;
ParticleSystemEvaluatorBySpeed.prototype.deserialize = function(src) {
    var undefined;
    this.evaluator.deserialize(src.curve !== undefined ? src.curve : src.gradient);
    this.intervalMin = Number(src.range.x);
    this.intervalMax = Number(src.range.y)
}
;
ParticleSystemEvaluatorBySpeed.prototype.reset = function() {
    this.evaluator.reset()
}
;
goog.provide("UHT.ParticleSystemEvaluatorColor");
function GradientColor() {
    this.r = 1;
    this.g = 1;
    this.b = 1;
    this.a = 1
}
GradientColor.prototype.fromString = function(str) {
    var n = Number(str) | 0;
    this.r = n & 255;
    this.g = n >> 8 & 255;
    this.b = n >> 16 & 255;
    this.a = n >> 24 & 255
}
;
GradientColor.prototype.toRGBHex = function() {
    return Math.floor((this.r << 16) + (this.g << 8) + this.b)
}
;
GradientColor.prototype.toARGBHex = function() {
    return Math.floor((this.a << 24) + (this.r << 16) + (this.g << 8) + this.b)
}
;
function GradientNEW() {
    this.numColorKeys = 0;
    this.numAlphaKeys = 0;
    this.keysColor = [];
    this.keysTimeAlpha = [];
    this.keysTimeColor = [];
    this._lastKeyColor = 0;
    this._lastKeyAlpha = 0
}
GradientNEW.prototype.fromString = function(str) {
    this.reset();
    this.numAlphaKeys = Number(str.m_NumAlphaKeys);
    this.numColorKeys = Number(str.m_NumColorKeys);
    for (var i = 0; i < 8; i++) {
        var c = new GradientColor;
        c.fromString(str["key" + i]["rgba"]);
        this.keysColor.push(c);
        this.keysTimeAlpha.push(Number(str["atime" + i]) / 65535);
        this.keysTimeColor.push(Number(str["ctime" + i]) / 65535)
    }
}
;
GradientNEW.prototype.searchNearestKey = function(keys, percent, maxNumKeys, cache) {
    var i;
    var start = cache || 0;
    if (!(keys[start] <= percent && keys[start + 1] > percent))
        start = 0;
    var n = maxNumKeys - 1;
    for (i = start; i < n; i++)
        if (keys[i] < percent && keys[i + 1] > percent)
            return i;
    return Math.max(0, n - 1)
}
;
GradientNEW.prototype.Evaluate = function(percent) {
    var ck;
    var pc;
    var ak;
    var pa;
    var gc = new GradientColor;
    if (percent < this.keysTimeColor[0]) {
        gc.r = this.keysColor[0].r;
        gc.g = this.keysColor[0].g;
        gc.b = this.keysColor[0].b
    } else if (percent > this.keysTimeColor[this.numColorKeys - 1]) {
        var k = this.numColorKeys - 1;
        gc.r = this.keysColor[k].r;
        gc.g = this.keysColor[k].g;
        gc.b = this.keysColor[k].b
    } else {
        ck = this.searchNearestKey(this.keysTimeColor, percent, this.numColorKeys, this._lastKeyColor);
        this._lastKeyColor = ck;
        pc = UHTMath.inverseLerp(this.keysTimeColor[ck], this.keysTimeColor[ck + 1], percent);
        gc.r = UHTMath.lerp(this.keysColor[ck].r, this.keysColor[ck + 1].r, pc);
        gc.g = UHTMath.lerp(this.keysColor[ck].g, this.keysColor[ck + 1].g, pc);
        gc.b = UHTMath.lerp(this.keysColor[ck].b, this.keysColor[ck + 1].b, pc)
    }
    if (percent < this.keysTimeAlpha[0])
        gc.a = this.keysColor[0].a;
    else if (percent > this.keysTimeAlpha[this.numAlphaKeys - 1]) {
        var k = this.numAlphaKeys - 1;
        gc.a = this.keysColor[k].a
    } else {
        ak = this.searchNearestKey(this.keysTimeAlpha, percent, this.numAlphaKeys, this._lastKeyAlpha);
        this._lastKeyAlpha = ak;
        pa = UHTMath.inverseLerp(this.keysTimeAlpha[ak], this.keysTimeAlpha[ak + 1], percent);
        gc.a = UHTMath.lerp(this.keysColor[ak].a, this.keysColor[ak + 1].a, pa)
    }
    return gc
}
;
GradientNEW.prototype.reset = function() {
    this.numColorKeys = 0;
    this.numAlphaKeys = 0;
    this.keysColor = [];
    this.keysTimeAlpha = [];
    this.keysTimeColor = [];
    this._lastKeyColor = 0;
    this._lastKeyAlpha = 0
}
;
function ParticleSystemEvaluatorColor() {
    this.minMaxState = 0;
    this.minGradient = new GradientNEW;
    this.maxGradient = new GradientNEW;
    this.random = 0;
    this.minColor = new GradientColor;
    this.maxColor = new GradientColor
}
ParticleSystemEvaluatorColor.prototype.Evaluate = function(time) {
    switch (this.minMaxState) {
    case 3:
        var min = this.minGradient.Evaluate(time);
        var max = this.maxGradient.Evaluate(time);
        var gc = new GradientColor;
        gc.r = min.r + (max.r - min.r) * this.random;
        gc.g = min.g + (max.g - min.g) * this.random;
        gc.b = min.b + (max.b - min.b) * this.random;
        gc.a = min.a + (max.a - min.a) * this.random;
        return gc;
        break;
    case 2:
        var min = this.minColor;
        var max = this.maxColor;
        var gc = new GradientColor;
        gc.r = min.r + (max.r - min.r) * this.random;
        gc.g = min.g + (max.g - min.g) * this.random;
        gc.b = min.b + (max.b - min.b) * this.random;
        gc.a = min.a + (max.a - min.a) * this.random;
        return gc;
        break;
    case 1:
        return this.maxGradient.Evaluate(time);
        break;
    case 0:
        return this.maxColor;
        break;
    default:
        return new GradientColor
    }
}
;
ParticleSystemEvaluatorColor.prototype.deserialize = function(src) {
    this.random = Math.random();
    this.minMaxState = Number(src.minMaxState);
    this.minGradient.fromString(src.minGradient);
    this.maxGradient.fromString(src.maxGradient);
    this.maxColor.fromString(src.maxColor.rgba);
    this.minColor.fromString(src.minColor.rgba)
}
;
goog.provide("UHT.ParticleSystemShape");
goog.provide("UHT.ParticleSystemShapeType");
var ParticleSystemShapeType = {
    sphere: 0,
    sphereShell: 1,
    hemisphere: 2,
    mesh: 3,
    cone: 4,
    box: 5,
    coneBaseShell: 7
};
function ParticleSystemShape() {}
ParticleSystemShape.prototype.generateNewPosition = function() {
    return new UHTMath.Vector3
}
;
ParticleSystemShape.prototype.getEmissionDirection = function() {
    return new UHTMath.Vector3
}
;
goog.provide("UHT.ParticleSystemShapeBox");
ParticleSystemShapeBox.prototype = Object.create(ParticleSystemShape.prototype);
ParticleSystemShapeBox.prototype.constructor = ParticleSystemShape;
function ParticleSystemShapeBox() {
    this.boxX = 1;
    this.boxY = 1;
    this.boxZ = 1
}
ParticleSystemShapeBox.prototype.generateNewPosition = function() {
    return new UHTMath.Vector3(this.boxX * (Math.random() - .5),this.boxY * (Math.random() - .5),this.boxZ * (Math.random() - .5))
}
;
ParticleSystemShapeBox.prototype.deserialize = function(src) {
    this.boxX = Number(src.boxX);
    this.boxY = Number(src.boxY);
    this.boxZ = Number(src.boxZ)
}
;
ParticleSystemShapeBox.prototype.getEmissionDirection = function(forPosition) {
    var undefined;
    if (forPosition !== undefined)
        return new UHTMath.Vector3(0,0,1);
    else {
        var d = new UHTMath.Vector3(2 * Math.random() - 1,2 * Math.random() - 1,2 * Math.random() - 1);
        d.normalize();
        return d
    }
}
;
goog.provide("UHT.ParticleSystemShapeCone");
ParticleSystemShapeCone.prototype = Object.create(ParticleSystemShape.prototype);
ParticleSystemShapeCone.prototype.constructor = ParticleSystemShape;
function ParticleSystemShapeCone() {
    this.angle = 0;
    this.radius = 1;
    this.type = 7
}
ParticleSystemShapeCone.prototype.generateNewPosition = function() {
    var alpha = Math.random() * 2 * UHTMath.PI;
    var x = this.type == ParticleSystemShapeType.coneBaseShell ? 1 : Math.random();
    var y = this.type == ParticleSystemShapeType.coneBaseShell ? 1 : Math.random();
    return new UHTMath.Vector3(x * this.radius * Math.cos(alpha),y * this.radius * Math.sin(alpha),0)
}
;
ParticleSystemShapeCone.prototype.deserialize = function(src) {
    this.angle = Number(src.angle);
    this.radius = Number(src.radius) / 2;
    this.type = Number(src.type)
}
;
ParticleSystemShapeCone.prototype.getEmissionDirection = function(forPosition) {
    var undefined;
    var percent = 1;
    var x, z;
    if (forPosition !== undefined) {
        var f = new UHTMath.Vector3(forPosition);
        f.z = 0;
        var l = f.magnitude();
        percent = l / this.radius;
        x = f.x;
        z = f.y
    } else {
        x = 2 * Math.random() - 1;
        z = 2 * Math.random() - 1
    }
    var c = Math.cos(UHTMath.toRad(this.angle * percent));
    var ssq = 1 - c * c;
    var lsq = x * x + z * z;
    var scale = Math.sqrt(ssq / lsq);
    x *= scale;
    z *= scale;
    var v = new UHTMath.Vector3(x,z,c);
    v.normalize();
    return v
}
;
goog.provide("UHT.ParticleSystemShapeSphere");
ParticleSystemShapeSphere.prototype = Object.create(ParticleSystemShape.prototype);
ParticleSystemShapeSphere.prototype.constructor = ParticleSystemShape;
function ParticleSystemShapeSphere() {
    this.radius = 1;
    this.type = 7
}
ParticleSystemShapeSphere.prototype.generateNewPosition = function() {
    var phi = Math.random() * 2 * UHTMath.PI;
    var cosTheta = Math.random() * 2 - 1;
    var u = this.type == ParticleSystemShapeType.sphereShell ? 1 : Math.random();
    var theta = Math.acos(cosTheta);
    var r = this.radius * Math.pow(u, 1 / 3);
    return new UHTMath.Vector3(r * Math.sin(theta) * Math.cos(phi),r * Math.sin(theta) * Math.sin(phi),r * Math.cos(theta))
}
;
ParticleSystemShapeSphere.prototype.deserialize = function(src) {
    this.radius = Number(src.radius);
    this.type = Number(src.type)
}
;
ParticleSystemShapeSphere.prototype.getEmissionDirection = function(forPosition) {
    var undefined;
    if (forPosition !== undefined) {
        var f = new UHTMath.Vector3(forPosition);
        f.normalize();
        return f
    } else {
        var x = 2 * Math.random() - 1;
        var y = 2 * Math.random() - 1;
        var z = 2 * Math.random() - 1;
        var f = new UHTMath.Vector3(x,y,z);
        f.normalize();
        return f
    }
}
;
goog.provide("UHT.FontLoader");
var FontDetect = function() {
    var _isInitialized = false;
    var _aFallbackFonts = ["serif", "sans-serif", "monospace", "cursive", "fantasy"];
    var span = null;
    var span_dots = null;
    function _init() {
        if (_isInitialized)
            return;
        _isInitialized = true;
        var body = document.body;
        var firstChild = document.body.firstChild;
        var div = document.createElement("div");
        div.id = "fontdetectHelper";
        span = document.createElement("span");
        span.innerText = "0123456789";
        div.appendChild(span);
        span_dots = document.createElement("span_dots");
        span_dots.innerText = "..........";
        div.appendChild(span_dots);
        body.insertBefore(div, firstChild);
        div.style.position = "absolute";
        div.style.visibility = "hidden";
        div.style.top = "-200px";
        div.style.left = "-100000px";
        div.style.width = "100000px";
        div.style.height = "200px";
        div.style.fontSize = "100px"
    }
    return {
        onFontLoaded: function(p_cssFontName, p_onLoad, p_onFail, p_options) {
            if (!p_cssFontName)
                return;
            var msInterval = p_options && p_options.msInterval ? p_options.msInterval : 100;
            var msTimeout = p_options && p_options.msTimeout ? p_options.msTimeout : 1E4;
            if (!p_onLoad && !p_onFail)
                return;
            if (!_isInitialized)
                _init();
            if (this.isFontLoaded(p_cssFontName, p_options)) {
                if (p_onLoad)
                    p_onLoad(p_cssFontName);
                return
            }
            var outerThis = this;
            var utStart = (new Date).getTime();
            var idInterval = setInterval(function() {
                if (outerThis.isFontLoaded(p_cssFontName, p_options)) {
                    clearInterval(idInterval);
                    p_onLoad(p_cssFontName);
                    return
                } else {
                    var utNow = (new Date).getTime();
                    if (utNow - utStart > msTimeout) {
                        clearInterval(idInterval);
                        if (p_onFail)
                            p_onFail(p_cssFontName)
                    }
                }
            }, msInterval)
        },
        isFontLoaded: function(p_cssFontName, p_options) {
            var wThisFont = 0;
            var wPrevFont = 0;
            span.innerText = p_options && p_options.text ? p_options.text : "0123456789";
            if (!_isInitialized)
                _init();
            for (var ix = 0; ix < _aFallbackFonts.length; ++ix) {
                span.style.fontFamily = p_cssFontName + "," + _aFallbackFonts[ix];
                span_dots.style.fontFamily = p_cssFontName + "," + _aFallbackFonts[ix];
                if (span.offsetWidth == span_dots.offsetWidth)
                    return false;
                wThisFont = span.offsetWidth;
                if (ix > 0 && wThisFont != wPrevFont)
                    return false;
                wPrevFont = wThisFont
            }
            return true
        }
    }
}();
var FontLoader = function() {
    var FontStatus = {
        Loading: 0,
        Loaded: 1,
        Failed: 2
    };
    var fontStatus = {};
    var handlers = {};
    function onFontFail(fontName) {
        var fn = SafeFontName(fontName);
        fontStatus[fn] = FontStatus.Failed;
        Trigger(fn, FontStatus.Failed)
    }
    function onFontLoad(fontName) {
        var fn = SafeFontName(fontName);
        fontStatus[fn] = FontStatus.Loaded;
        Trigger(fn, FontStatus.Loaded)
    }
    function AppendFontFace(fontFace) {
        var ss = document.createElement("style");
        if (ss.styleSheet)
            ss.styleSheet.cssText = fontFace;
        else
            ss.appendChild(document.createTextNode(fontFace));
        document.getElementsByTagName("head")[0].appendChild(ss)
    }
    function LoadFont(fontName, fontFace, options) {
        var fn = SafeFontName(fontName);
        var force = options && options.force ? options.force : false;
        if (force || fontStatus[fn] == undefined) {
            fontStatus[fn] = FontStatus.Loading;
            if (fontFace != null)
                AppendFontFace(fontFace);
            FontDetect.onFontLoaded(fontName, onFontLoad, onFontFail, options)
        }
    }
    function AddHandler(fontName, callback, object) {
        var fn = SafeFontName(fontName);
        if (fontStatus[fn] == FontStatus.Loaded || fontStatus[fn] == FontStatus.Failed) {
            callback.call(object, fontStatus[fn]);
            return
        }
        if (handlers[fn] == undefined)
            handlers[fn] = [];
        handlers[fn].push({
            obj: object,
            func: callback
        })
    }
    function IsLoaded(fontName) {
        var fn = SafeFontName(fontName);
        return fontStatus[fn] == FontStatus.Loaded
    }
    function Trigger(safeFontName, status) {
        if (handlers[safeFontName] == undefined)
            return;
        for (var i = 0; i < handlers[safeFontName].length; ++i)
            handlers[safeFontName][i].func.call(handlers[safeFontName][i].obj, status);
        delete handlers[safeFontName]
    }
    function SafeFontName(fontName) {
        return fontName.replace(/\s/g, "_")
    }
    return {
        LoadFont: LoadFont,
        AddHandler: AddHandler,
        IsLoaded: IsLoaded
    }
}();
goog.provide("UHT.GameObject");
goog.require("UHT.Collider");
goog.require("UHT.Animation");
function GameObject() {
    this.name = "";
    this.activeSelf = false;
    this.layer = 0;
    this.activeInHierarchy = false;
    this.components = [];
    this.transform = null;
    this.collider = null;
    this.animation = null
}
GameObject.prototype.GetComponent = function(componentType) {
    var realType = componentType;
    if (typeof realType == "string")
        realType = window[realType];
    for (var i = 0; i < this.components.length; i++)
        if (this.components[i]instanceof realType)
            return this.components[i];
    return null
}
;
GameObject.prototype.GetComponents = function(componentType) {
    var list = [];
    var realType = componentType;
    if (typeof realType == "string")
        realType = window[realType];
    for (var i = 0; i < this.components.length; i++)
        if (this.components[i]instanceof realType)
            list.push(this.components[i]);
    return list
}
;
GameObject.prototype.GetComponentsInChildren = function(componentType, includeInactive) {
    var list = [];
    if (this.activeInHierarchy || includeInactive) {
        for (var i = 0; i < this.components.length; i++)
            if (this.components[i]instanceof componentType)
                list.push(this.components[i]);
        for (var j = 0; j < this.transform.children.length; j++)
            list = list.concat(this.transform.children[j].gameObject.GetComponentsInChildren(componentType, includeInactive))
    }
    return list
}
;
GameObject.prototype.GetComponentInChildren = function(componentType) {
    if (this.activeInHierarchy) {
        for (var i = 0; i < this.components.length; i++)
            if (this.components[i]instanceof componentType)
                return this.components[i];
        for (var j = 0; j < this.transform.children.length; j++) {
            var component = this.transform.children[j].gameObject.GetComponentInChildren(componentType);
            if (component != null)
                return component
        }
    }
    return null
}
;
GameObject.prototype.SetActive = function(active) {
    if (this.activeSelf != active) {
        this.activeSelf = active;
        this.internalUpdateActive(true, true)
    }
}
;
GameObject.prototype.SendMessage = function(methodName, value) {
    if (!this.activeInHierarchy)
        return;
    for (var i = 0; i < this.components.length; i++) {
        var curComp = this.components[i];
        if (curComp.canReceiveMessage)
            if (curComp[methodName] != undefined)
                curComp[methodName](value)
    }
}
;
GameObject.prototype.AddComponent = function(componentName) {
    var newComp = createComponent(componentName, true);
    if (newComp != null) {
        this.components.push(newComp);
        newComp.gameObject = this;
        if (this.activeInHierarchy) {
            newComp.Awake();
            callOnEnable(newComp);
            newComp.Start();
            newComp.flags |= ComponentStateFlags.awake_called | ComponentStateFlags.start_called
        }
        this.internalCacheComponent(newComp);
        newComp.transform = this.transform
    }
    return newComp
}
;
GameObject.prototype.internalUpdateActive = function(onEnableCallAllowed, onDisableCallAllowed) {
    computeActiveState(this);
    callComponentCallback(this, "Awake", ComponentStateFlags.awake_called);
    if (onEnableCallAllowed)
        callComponentOnEnable(this);
    callComponentCallback(this, "Start", ComponentStateFlags.start_called);
    if (onDisableCallAllowed)
        callComponentOnDisable(this)
}
;
GameObject.prototype.internalCopyFromOther = function(source) {
    this.name = source.name;
    this.activeSelf = source.activeSelf;
    this.layer = source.layer
}
;
GameObject.prototype.internalCacheComponent = function(newComp) {
    if (newComp instanceof Transform)
        this.transform = newComp;
    else if (newComp instanceof Collider)
        this.collider = newComp;
    else if (newComp instanceof Animation)
        this.animation = newComp
}
;
goog.require("UHT.Component");
goog.require("UHT.GameObject");
function AnimationState(_clip) {
    this.name = _clip.name;
    this.enabled = false;
    this.weight = 0;
    this.length = _clip.length;
    this.speed = 1;
    this.normalizedTime = 0;
    this.time = 0;
    this.wrapMode = _clip.wrapMode;
    this.clip = _clip;
    this.applyData = [];
    this._rootGameObject = null;
    this.extraTime = 0;
    this.sortedEvents = []
}
AnimationState.CurveApplyData = function(_type, _obj) {
    this.type = _type;
    this.obj = _obj;
    this.comp = null;
    this.propertyName = "";
    this.curve1 = null;
    this.curve2 = null;
    this.curve3 = null;
    this.curve4 = null
}
;
AnimationState.CurveApplyType = {
    Invalid: 0,
    TransformPosition: 1,
    TransformRotation: 2,
    TransformScale: 3,
    GameObjectActive: 4,
    Custom: 5
};
AnimationState.prototype.Init = function(rootGameObject) {
    this._rootGameObject = rootGameObject;
    var isProcessed = _array.create(this.clip.curves.length, false);
    for (var i = 0; i < this.clip.curves.length; i++) {
        if (isProcessed[i])
            continue;
        var curData = this.clip.curves[i];
        var obj = rootGameObject.transform.Find(curData.path);
        if (obj != null) {
            isProcessed[i] = true;
            var t = this.ComputeApplyType(curData.propertyName);
            var curApplyData = new AnimationState.CurveApplyData(t.type,obj.gameObject);
            curApplyData["curve" + t.index] = curData.curve;
            if (t.type == AnimationState.CurveApplyType.Custom) {
                curApplyData.propertyName = curData.propertyName;
                curApplyData.comp = obj.gameObject.GetComponent(curData.type);
                this.applyData.push(curApplyData);
                continue
            }
            for (var k = i + 1; k < this.clip.curves.length; k++) {
                if (isProcessed[k])
                    continue;
                var nextData = this.clip.curves[k];
                if (curData.path != nextData.path)
                    continue;
                var obj2 = rootGameObject.transform.Find(nextData.path);
                if (obj2 != null && obj2 == obj) {
                    var t2 = this.ComputeApplyType(nextData.propertyName);
                    if (t2.type != t.type)
                        continue;
                    curApplyData["curve" + t2.index] = nextData.curve;
                    isProcessed[k] = true
                }
            }
            this.applyData.push(curApplyData)
        }
    }
    this.SortEvents()
}
;
AnimationState.prototype.Sample = function() {
    for (var i = 0; i < this.applyData.length; i++)
        this.Apply(this.applyData[i])
}
;
AnimationState.prototype.Update = function() {
    this.Sample();
    if (this.speed == 0)
        return true;
    for (var j = 0; j < this.sortedEvents.length; j++) {
        var event = this.sortedEvents[j];
        if (Math.abs(event.time - this.time) < 1E-6)
            this._rootGameObject.SendMessage(event.functionName, event.param)
    }
    var s = this.speed;
    var forward = s >= 0;
    if (forward && this.time > this.length || !forward && this.time < 0)
        if (this.wrapMode == WrapMode.Loop) {
            this.time += forward ? -this.length : this.length;
            return true
        } else
            return false;
    var timeIncrement = (Time.deltaTime + this.extraTime) * s;
    var d = Math.abs(this.ComputeTimeToNextEvent(forward) / s);
    if (d < Math.abs(timeIncrement)) {
        this.extraTime += Math.abs(timeIncrement / s) - Math.abs(d * s);
        this.time += forward ? d : -d
    } else {
        this.extraTime = 0;
        this.time += timeIncrement
    }
    return true
}
;
AnimationState.prototype.ComputeTimeToNextEvent = function(forward) {
    if (forward)
        for (var i = 0; i < this.sortedEvents.length; i++) {
            var d = this.sortedEvents[i].time - this.time;
            if (d > 0)
                return d
        }
    else
        for (var j = this.sortedEvents.length - 1; j >= 0; j--) {
            var d2 = this.time - this.sortedEvents[j].time;
            if (d2 > 0)
                return d2
        }
    return Number.MAX_VALUE
}
;
AnimationState.prototype.SortEvents = function() {
    this.sortedEvents = [];
    for (var i = 0; i < this.clip.events.length; i++)
        this.sortedEvents.push(this.clip.events[i]);
    this.sortedEvents.sort(function(a, b) {
        return a.time - b.time
    })
}
;
AnimationState.prototype.Stop = function() {
    this.time = 0
}
;
AnimationState.prototype.Apply = function(applyData) {
    var x;
    var y;
    var z;
    var w;
    switch (applyData.type) {
    case AnimationState.CurveApplyType.TransformPosition:
        x = applyData.curve1.Evaluate(this.time);
        y = applyData.curve2.Evaluate(this.time);
        z = applyData.curve3.Evaluate(this.time);
        applyData.obj.transform.fastSetLocalPosition(x, y, z);
        break;
    case AnimationState.CurveApplyType.TransformRotation:
        x = applyData.curve1.Evaluate(this.time);
        y = applyData.curve2.Evaluate(this.time);
        z = applyData.curve3.Evaluate(this.time);
        w = applyData.curve4.Evaluate(this.time);
        applyData.obj.transform.fastSetLocalRotation(x, y, z, w);
        break;
    case AnimationState.CurveApplyType.TransformScale:
        x = applyData.curve1.Evaluate(this.time);
        y = applyData.curve2.Evaluate(this.time);
        z = applyData.curve3.Evaluate(this.time);
        applyData.obj.transform.fastSetLocalScale(x, y, z);
        break;
    case AnimationState.CurveApplyType.GameObjectActive:
        if (applyData.curve1 != null) {
            var isActive = applyData.curve1.Evaluate(this.time);
            applyData.obj.SetActive(isActive > .5)
        }
        break;
    case AnimationState.CurveApplyType.Custom:
        if (applyData.curve1 != null && applyData.comp != null && applyData.propertyName != "") {
            var value = applyData.curve1.Evaluate(this.time);
            var path = applyData.propertyName.split(".");
            var field = applyData.comp;
            for (var i = 0; i < path.length - 1; i++) {
                if (field.hasOwnProperty(path[i]) == false) {
                    console.error("Animation: Property path '" + applyData.propertyName + "' is invalid!");
                    return
                }
                field = field[path[i]]
            }
            if (field.hasOwnProperty(path[path.length - 1]) == false) {
                console.error("Animation: Property path '" + applyData.propertyName + "' is invalid!");
                return
            }
            field[path[path.length - 1]] = value
        }
        break;
    default:
        break
    }
}
;
AnimationState.prototype.ComputeApplyType = function(propPath) {
    switch (propPath) {
    case "m_LocalPosition.x":
        return {
            type: AnimationState.CurveApplyType.TransformPosition,
            index: 1
        };
    case "m_LocalPosition.y":
        return {
            type: AnimationState.CurveApplyType.TransformPosition,
            index: 2
        };
    case "m_LocalPosition.z":
        return {
            type: AnimationState.CurveApplyType.TransformPosition,
            index: 3
        };
    case "m_LocalRotation.x":
        return {
            type: AnimationState.CurveApplyType.TransformRotation,
            index: 1
        };
    case "m_LocalRotation.y":
        return {
            type: AnimationState.CurveApplyType.TransformRotation,
            index: 2
        };
    case "m_LocalRotation.z":
        return {
            type: AnimationState.CurveApplyType.TransformRotation,
            index: 3
        };
    case "m_LocalRotation.w":
        return {
            type: AnimationState.CurveApplyType.TransformRotation,
            index: 4
        };
    case "m_LocalScale.x":
        return {
            type: AnimationState.CurveApplyType.TransformScale,
            index: 1
        };
    case "m_LocalScale.y":
        return {
            type: AnimationState.CurveApplyType.TransformScale,
            index: 2
        };
    case "m_LocalScale.z":
        return {
            type: AnimationState.CurveApplyType.TransformScale,
            index: 3
        };
    case "m_IsActive":
        return {
            type: AnimationState.CurveApplyType.GameObjectActive,
            index: 1
        };
    default:
        return {
            type: AnimationState.CurveApplyType.Custom,
            index: 1
        }
    }
}
;
function deserializeComponentRec(source, dest, helper, resolveReference) {
    var keys = Object.keys(source);
    for (var i = 0; i < keys.length; i++) {
        var name = keys[i];
        var cur = source[name];
        if (internalRawDataIsReference(cur))
            dest[name] = helper[resolveReference](source[name]);
        else if (internalProcessAsNestedClass(cur, dest, name, helper, resolveReference))
            ;
        else if (Array.isArray(cur)) {
            dest[name] = new Array(cur.length);
            for (var k = 0; k < cur.length; k++)
                if (cur[k] == null)
                    dest[name][k] = null;
                else if (cur[k]instanceof Object)
                    deserializeComponentRec(cur[k], dest[name][k], helper, resolveReference);
                else
                    dest[name][k] = cur[k]
        } else if (cur instanceof Object)
            dest[name] = JSON.parse(JSON.stringify(cur));
        else
            dest[name] = cur
    }
}
function internalRawDataIsReference(data) {
    var prop = "fileID";
    if (Array.isArray(data) && data.length > 0) {
        for (var i = 0; i < data.length; i++)
            if (data[i]instanceof Object && data[i].hasOwnProperty(prop))
                return true;
        return false
    } else if (data instanceof Object && data.hasOwnProperty(prop))
        return true;
    return false
}
function internalProcessAsNestedClass(source, dest, fieldName, helper, resolveReference) {
    var prop = "nestedFieldType";
    if (Array.isArray(source) && source.length > 0 && source[0]instanceof Object && source[0].hasOwnProperty(prop)) {
        dest[fieldName] = new Array(source.length);
        for (var i = 0; i < source.length; i++) {
            var typeName = source[i][prop];
            dest[fieldName][i] = createNestedObject(typeName);
            if (dest[fieldName][i]["deserialize"] != null)
                dest[fieldName][i]["deserialize"](source[i]["serializableData"], helper, resolveReference);
            else if (dest[fieldName][i] != null)
                deserializeComponentRec(source[i]["serializableData"], dest[fieldName][i], helper, resolveReference)
        }
        return true
    } else if (source instanceof Object && source.hasOwnProperty(prop)) {
        dest[fieldName] = createNestedObject(source[prop]);
        if (dest[fieldName]["deserialize"] != null)
            dest[fieldName]["deserialize"](source["serializableData"], helper, resolveReference);
        else if (dest[fieldName] != null)
            deserializeComponentRec(source["serializableData"], dest[fieldName], helper, resolveReference);
        return true
    }
    return false
}
function isReference(obj) {
    return obj instanceof GameObject || obj instanceof Component || obj instanceof TextAsset || obj instanceof AudioClip || obj instanceof AnimationClip
}
goog.provide("UHT.KeyboardManager");
var KeyCode = {
    Space: 32,
    Return: 13,
    Backspace: 8,
    Alpha0: 48,
    Alpha1: 49,
    Alpha2: 50,
    Alpha3: 51,
    Alpha4: 52,
    Alpha5: 53,
    Alpha6: 54,
    Alpha7: 55,
    Alpha8: 56,
    Alpha9: 57,
    Keypad0: 96,
    Keypad1: 97,
    Keypad2: 98,
    Keypad3: 99,
    Keypad4: 100,
    Keypad5: 101,
    Keypad6: 102,
    Keypad7: 103,
    Keypad8: 104,
    Keypad9: 105,
    DecimalPoint: 110,
    Comma: 188,
    Period: 190
};
var KeyboardManager = {
    _internalStates: {},
    _states: {}
};
KeyboardManager.KeyState = {
    Up: 0,
    JustDown: 1,
    Down: 2
};
KeyboardManager.focus = true;
KeyboardManager.Init = function() {
    if (UHT_DEVICE_TYPE.MOBILE)
        return;
    window.addEventListener("keyup", function(event) {
        KeyboardManager.onKeyUp(event)
    }, false);
    window.addEventListener("keydown", function(event) {
        KeyboardManager.onKeyDown(event)
    }, false);
    if (UHT_FRAME)
        document.body.addEventListener("mousedown", function() {
            window.focus()
        }, true);
    window.addEventListener("blur", function(event) {
        KeyboardManager.SetFocus(false)
    }, true);
    window.addEventListener("focus", function(event) {
        KeyboardManager.SetFocus(true)
    }, true)
}
;
KeyboardManager.SetFocus = function(isFocus) {
    KeyboardManager.focus = isFocus
}
;
KeyboardManager.Update = function() {
    if (UHT_DEVICE_TYPE.MOBILE)
        return;
    KeyboardManager._states = JSON.parse(JSON.stringify(KeyboardManager._internalStates));
    for (var i in KeyboardManager._internalStates)
        if (KeyboardManager._internalStates.hasOwnProperty(i)) {
            if (KeyboardManager._internalStates[i] == KeyboardManager.KeyState.JustDown)
                KeyboardManager._internalStates[i] = KeyboardManager.KeyState.Down;
            if (!KeyboardManager.focus)
                KeyboardManager._internalStates[i] = KeyboardManager.KeyState.Up
        }
}
;
KeyboardManager.onKeyUp = function(event) {
    KeyboardManager._internalStates[event.keyCode] = KeyboardManager.KeyState.Up;
    UHTEngine.RegisterUserInteraction()
}
;
KeyboardManager.onKeyDown = function(event) {
    var state = KeyboardManager._internalStates[event.keyCode];
    if (state == KeyboardManager.KeyState.Up || state == undefined)
        KeyboardManager._internalStates[event.keyCode] = KeyboardManager.KeyState.JustDown;
    else
        KeyboardManager._internalStates[event.keyCode] = KeyboardManager.KeyState.Down;
    UHTEngine.RegisterUserInteraction()
}
;
KeyboardManager.IsKeyDown = function(keyCode) {
    if (KeyboardManager._states.hasOwnProperty(keyCode))
        return KeyboardManager._states[keyCode] == KeyboardManager.KeyState.JustDown;
    return false
}
;
KeyboardManager.IsKey = function(keyCode) {
    if (KeyboardManager._states.hasOwnProperty(keyCode))
        return KeyboardManager._states[keyCode] == KeyboardManager.KeyState.Down;
    return false
}
;
goog.provide("UHT.Color");
function Color() {
    this._r = 0;
    this._g = 0;
    this._b = 0;
    this.a = 0;
    this.rgbAsHex = 0;
    Object.defineProperties(this, {
        "r": {
            get: function() {
                return this._r
            },
            set: function(nR) {
                this._r = nR;
                this.compute_rgbAsHex()
            }
        },
        "g": {
            get: function() {
                return this._g
            },
            set: function(nG) {
                this._g = nG;
                this.compute_rgbAsHex()
            }
        },
        "b": {
            get: function() {
                return this._b
            },
            set: function(nB) {
                this._b = nB;
                this.compute_rgbAsHex()
            }
        }
    })
}
Color.prototype.rgbAsString = function() {
    return "RGB(" + Math.floor(this._r * 255) + ", " + Math.floor(this._g * 255) + ", " + Math.floor(this._b * 255) + ")"
}
;
Color.prototype.compute_rgbAsHex = function() {
    this.rgbAsHex = Math.floor((this._r * 255 << 16) + (this._g * 255 << 8) + this._b * 255)
}
;
Color.prototype.argbAsHex = function() {
    return Math.floor((this.a * 255 << 24) + (this._r * 255 << 16) + (this._g * 255 << 8) + this._b * 255)
}
;
Color.Lerp = function(color1, color2, t) {
    var ret = new Color;
    var _t = UHTMath.clamp(t, 0, 1);
    ret.r = color1.r + (color2.r - color1.r) * _t;
    ret.g = color1.g + (color2.g - color1.g) * _t;
    ret.b = color1.b + (color2.b - color1.b) * _t;
    ret.a = color1.a + (color2.a - color1.a) * _t;
    return ret
}
;
Color.qLerp = function(target, color1, color2, t) {
    var _t = UHTMath.clamp(t, 0, 1);
    target.r = color1.r + (color2.r - color1.r) * _t;
    target.g = color1.g + (color2.g - color1.g) * _t;
    target.b = color1.b + (color2.b - color1.b) * _t;
    target.a = color1.a + (color2.a - color1.a) * _t
}
;
goog.provide("UHT.EventHandler");
function EventHandler(object, callback) {
    this.object = object;
    this.callback = callback
}
EventHandler.prototype.equals = function(object, callback) {
    return object == this.object && callback == this.callback
}
;
EventHandler.prototype.call = function() {
    this.callback.apply(this.object, arguments)
}
;
goog.provide("UHT.Gradient");
goog.require("UHT.Color");
function GradientColorKey() {
    this.color = null;
    this.time = 0
}
function GradientAlphaKey() {
    this.alpha = 0;
    this.time = 0
}
function Gradient() {
    this.colorKeys = [];
    this.alphaKeys = []
}
function LayerMask() {
    this.mask = 0
}
LayerMask.prototype.value = function() {
    var val = -1;
    var m = this.mask;
    while (m != 0) {
        val++;
        m = m / 2;
        m = Math.floor(m)
    }
    return val
}
;
goog.provide("UHT.Random");
var Random = {
    Range: function(min, max) {
        var rand = Math.random() * (max - min) + min;
        if (_number.isFloat(min) || _number.isFloat(max))
            return rand;
        else
            return Math.floor(rand)
    }
};
goog.provide("UHT.TextAsset");
function TextAsset(content) {
    this.text = content
}
var Time = {
    deltaTime: 0,
    time: 0,
    frameCount: 0
};
goog.provide("UHT.System.Misc.Utils");
var _string = {
    IsNullOrEmpty: function(str) {
        return !(typeof str == "string" && _string.Trim(str).length > 0)
    },
    Trim: function(str, trimChars) {
        if (trimChars == undefined)
            trimChars = "\\s";
        return String(str).replace(new RegExp("^[" + trimChars + "]+|[" + trimChars + "]+$","g"), "")
    }
};
_string.PadLeft = function(target, character, length) {
    var res = String(target);
    var count = length - res.length;
    for (var i = 0; i < count; ++i)
        res = character + res;
    return res
}
;
var _number = {
    otod: function(param) {
        var s = String(param);
        s = s.replace(/,/g, "");
        var rv = parseFloat(s);
        rv = isFinite(rv) && !isNaN(rv) ? rv : 0;
        return rv
    },
    otoi: function(param) {
        var rv = parseInt(param, 10);
        rv = isFinite(rv) && !isNaN(rv) ? rv : 0;
        return rv
    },
    otoui: function(param) {
        return _number.otoi(param)
    },
    isFloat: function(n) {
        return n === +n && n !== (n | 0)
    },
    isInt: function(n) {
        return n === +n && n === (n | 0)
    }
};
var _bool = {
    Parse: function(s) {
        var tmp = _string.Trim(s);
        return tmp == "true" || tmp == "True"
    }
};
var _window = {
    OnLoad: function(handler) {
        if (window.addEventListener)
            window.addEventListener("load", handler, false);
        else if (window.attachEvent)
            window.attachEvent("onload", handler)
    }
};
var _MonoBehaviour = {
    StartCoroutine: function(method, object, seconds, args) {
        setTimeout(function() {
            method.call(object, args)
        }, seconds * 1E3)
    }
};
var _array = {
    create: function(length, defaultValue) {
        var arr = [];
        arr.length = length;
        if (defaultValue != undefined)
            for (var i = 0; i < length; ++i)
                arr[i] = defaultValue;
        return arr
    },
    indexOf: function(element, arr) {
        for (var i = 0; i < arr.length; i++)
            if (arr[i] == element)
                return i;
        return -1
    },
    ConvertAll: function(array, converter) {
        var ret = [];
        for (var i = 0; i < array.length; ++i)
            if (!_string.IsNullOrEmpty(array[i]))
                ret.push(converter(array[i]));
        return ret
    }
};
function TimeSpan(h, m, s) {
    this.Hours = h;
    this.Minutes = m;
    this.Seconds = s
}
TimeSpan.prototype.ToString = function() {
    var res = [];
    res.push(_string.PadLeft(this.Hours, "0", 2));
    res.push(_string.PadLeft(this.Minutes, "0", 2));
    res.push(_string.PadLeft(this.Seconds, "0", 2));
    return res.join(":")
}
;
TimeSpan.FromSeconds = function(seconds) {
    var h = Math.floor(seconds / 3600);
    seconds %= 3600;
    var m = Math.floor(seconds / 60);
    var s = seconds % 60;
    return new TimeSpan(h,m,s)
}
;
var jsonParse = function() {
    var r = "(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)"
      , k = '(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
    k = '(?:"' + k + '*")';
    var s = new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|" + r + "|" + k + ")","g")
      , t = new RegExp("\\\\(?:([^u])|u(.{4}))","g")
      , u = {
        '"': '"',
        "/": "/",
        "\\": "\\",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "\t"
    };
    function v(h, j, e) {
        return j ? u[j] : String.fromCharCode(parseInt(e, 16))
    }
    var w = new String("")
      , x = Object.hasOwnProperty;
    return function(h, j) {
        h = h.match(s);
        var e, c = h[0], l = false;
        if ("{" === c)
            e = {};
        else if ("[" === c)
            e = [];
        else {
            e = [];
            l = true
        }
        for (var b, d = [e], m = 1 - l, y = h.length; m < y; ++m) {
            c = h[m];
            var a;
            switch (c.charCodeAt(0)) {
            default:
                a = d[0];
                a[b || a.length] = +c;
                b = void 0;
                break;
            case 34:
                c = c.substring(1, c.length - 1);
                if (c.indexOf("\\") !== -1)
                    c = c.replace(t, v);
                a = d[0];
                if (!b)
                    if (a instanceof Array)
                        b = a.length;
                    else {
                        b = c || w;
                        break
                    }
                a[b] = c;
                b = void 0;
                break;
            case 91:
                a = d[0];
                d.unshift(a[b || a.length] = []);
                b = void 0;
                break;
            case 93:
                d.shift();
                break;
            case 102:
                a = d[0];
                a[b || a.length] = false;
                b = void 0;
                break;
            case 110:
                a = d[0];
                a[b || a.length] = null;
                b = void 0;
                break;
            case 116:
                a = d[0];
                a[b || a.length] = true;
                b = void 0;
                break;
            case 123:
                a = d[0];
                d.unshift(a[b || a.length] = {});
                b = void 0;
                break;
            case 125:
                d.shift();
                break
            }
        }
        if (l) {
            if (d.length !== 1)
                throw new Error;
            e = e[0]
        } else if (d.length)
            throw new Error;
        if (j) {
            var p = function(n, o) {
                var f = n[o];
                if (f && typeof f === "object") {
                    var i = null;
                    for (var g in f)
                        if (x.call(f, g) && f !== n) {
                            var q = p(f, g);
                            if (q !== void 0)
                                f[g] = q;
                            else {
                                i || (i = []);
                                i.push(g)
                            }
                        }
                    if (i)
                        for (g = i.length; --g >= 0; )
                            delete f[i[g]]
                }
                return j.call(n, o, f)
            };
            e = p({
                "": e
            }, "")
        }
        return e
    }
}();
var UID = {};
UID.generated = [];
UID.Generate = function() {
    var uid = null;
    do
        uid = Math.random().toString(36).substring(2) + (new Date).getTime().toString(36);
    while (UID.generated.indexOf(uid) > -1);UID.generated.push(uid);
    return uid
}
;
goog.provide("UHT.Runtime");
function Runtime() {
    this.sceneRoots = [];
    this.animComponentList = null;
    this.updateList = [];
    for (var suo = 0; suo < 10; suo++)
        this.updateList.push({
            components: [],
            availableIndices: [],
            activeItems: 0
        });
    this.lateUpdateList = {
        components: [],
        availableIndices: [],
        activeItems: 0
    };
    this.onWillRenderList = {
        components: [],
        availableIndices: [],
        activeItems: 0
    }
}
function AnimListNode(_data) {
    this.data = _data;
    this.prev = null;
    this.next = null
}
Runtime.prototype.addNewSceneRoot = function(obj) {
    this.sceneRoots.push(obj);
    obj.internalUpdateActive(true, false)
}
;
Runtime.prototype.doFrame = function() {
    for (var suo = 0; suo < 10; suo++)
        this.CallOnGameObjectList(this.updateList[suo], "Update", "internalUpdateIdx");
    this.UpdateAnimations();
    this.CallOnGameObjectList(this.lateUpdateList, "LateUpdate", "internalLateUpdateIdx");
    this.CallOnGameObjectList(this.onWillRenderList, "OnWillRenderObject", "internalOnWillRenderIdx")
}
;
Runtime.prototype.RegisterAnimation = function(anim) {
    var n = new AnimListNode(anim);
    anim._runtime_cache = n;
    n.next = this.animComponentList;
    if (this.animComponentList != null)
        this.animComponentList.prev = n;
    this.animComponentList = n
}
;
Runtime.prototype.UnregisterAnimation = function(anim) {
    var o = anim._runtime_cache;
    var p = o.prev;
    var n = o.next;
    if (p == null)
        this.animComponentList = n;
    else
        p.next = n;
    if (n != null)
        n.prev = p;
    anim._runtime_cache = null
}
;
Runtime.prototype.UpdateAnimations = function() {
    var n = this.animComponentList;
    while (n != null) {
        n.data.UpdateAnimation();
        n = n.next
    }
}
;
Runtime.prototype.CallOnGameObjectList = function(listDesc, methodName, compIdxName) {
    this.DefragmentList(listDesc, compIdxName);
    var comps = listDesc.components;
    var l = comps.length;
    for (var i = 0; i < l; i++) {
        var c = comps[i];
        if (c != null)
            c[methodName]()
    }
}
;
Runtime.prototype.DefragmentList = function(listDesc, compIdxName) {
    if (listDesc.activeItems < .75 * listDesc.components.length) {
        var old = listDesc.components;
        listDesc.components = [];
        for (var i = 0; i < old.length; i++)
            if (old[i] != null) {
                old[i][compIdxName] = listDesc.components.length;
                listDesc.components.push(old[i])
            }
        listDesc.availableIndices = []
    }
}
;
Runtime.prototype.InternalAddToList = function(comp, listDesc, compIdxName) {
    if (comp[compIdxName] != -1)
        console.log("Bataie si mai mare de joc!");
    var newIdx = -1;
    if (listDesc.availableIndices.length > 0) {
        newIdx = listDesc.availableIndices.pop();
        listDesc.components[newIdx] = comp
    } else {
        newIdx = listDesc.components.length;
        listDesc.components.push(comp)
    }
    comp[compIdxName] = newIdx;
    listDesc.activeItems++
}
;
Runtime.prototype.InternalRemoveFromList = function(comp, listDesc, compIdxName) {
    var idx = comp[compIdxName];
    if (idx == -1)
        console.log("Bataie de joc!");
    listDesc.components[idx] = null;
    listDesc.availableIndices.push(idx);
    comp[compIdxName] = -1;
    listDesc.activeItems--
}
;
Runtime.prototype.AddToUpdateList = function(comp) {
    var suo = comp.scriptUpdatePriority;
    if (suo > 9)
        console.log("Bad script priority " + suo);
    this.InternalAddToList(comp, this.updateList[suo], "internalUpdateIdx")
}
;
Runtime.prototype.AddToLateUpdateList = function(comp) {
    this.InternalAddToList(comp, this.lateUpdateList, "internalLateUpdateIdx")
}
;
Runtime.prototype.AddToOnWillRenderList = function(comp) {
    this.InternalAddToList(comp, this.onWillRenderList, "internalOnWillRenderIdx")
}
;
Runtime.prototype.RemoveFromUpdateList = function(comp) {
    var suo = comp.scriptUpdatePriority;
    this.InternalRemoveFromList(comp, this.updateList[suo], "internalUpdateIdx")
}
;
Runtime.prototype.RemoveFromLateUpdateList = function(comp) {
    this.InternalRemoveFromList(comp, this.lateUpdateList, "internalLateUpdateIdx")
}
;
Runtime.prototype.RemoveFromOnWillRenderList = function(comp) {
    this.InternalRemoveFromList(comp, this.onWillRenderList, "internalOnWillRenderIdx")
}
;
goog.provide("UHT.UHTScreen");
var UHTScreen = {
    width: -1,
    height: -1
};
goog.provide("UHT.Tracking");
function Tracking() {
    this.trackedTimers = {};
    this.QueuedTimers = [];
    this.QueuedEvents = [];
    this.PauseTime = 0
}
Tracking.prototype.PauseTimers = function() {
    this.PauseTime = (new Date).getTime()
}
;
Tracking.prototype.ResumeTimers = function() {
    if (this.PauseTime != 0) {
        var diff = (new Date).getTime() - this.PauseTime;
        for (var timer in this.trackedTimers)
            this.trackedTimers[timer] += diff
    }
}
;
Tracking.prototype._internalUseStartTime = function(category, timer, time, type) {
    this.trackedTimers[type + "____" + category + "____" + timer] = time
}
;
Tracking.prototype.StartTimer = function(category, variable, type) {
    this.trackedTimers[type + "____" + category + "____" + variable] = (new Date).getTime()
}
;
Tracking.prototype.StopTimerAndSend = function(category, variable, type) {
    var time = this.GetTimerValue(category, variable, type);
    if (time > 0 && time < 1 * 60 * 60 * 1E3) {
        var qTimer = {
            category: category,
            variable: variable,
            time: time,
            type: type
        };
        globalTracking.QueuedTimers.push(qTimer)
    }
}
;
Tracking.prototype.GetTimerValue = function(category, timer, type) {
    if (this.trackedTimers[type + "____" + category + "____" + timer] === undefined) {
        console.log("[Tracking] Tried to stop timer " + type + "____" + category + "____" + timer + " before starting it");
        return 0
    }
    return (new Date).getTime() - this.trackedTimers[type + "____" + category + "____" + timer]
}
;
Tracking.prototype.SendEvent = function(category, action, value, type) {
    var qEvent = {
        category: category,
        action: action,
        value: value,
        type: type
    };
    globalTracking.QueuedEvents.push(qEvent)
}
;
Tracking.prototype.SendTimer = function(category, variable, time, type) {
    var qTimer = {
        category: category,
        variable: variable,
        time: time,
        type: type
    };
    globalTracking.QueuedTimers.push(qTimer)
}
;
var globalTracking = new Tracking;
var SendTrackingIfQueued = function() {
    if (globalTracking.QueuedTimers.length > 0) {
        var qTimer = globalTracking.QueuedTimers[0];
        globalTracking.QueuedTimers.splice(0, 1);
        ga(qTimer.type + ".send", "timing", qTimer.category, qTimer.variable, qTimer.time, ServerOptions.gameSymbol);
        if (UHT_LOCAL)
            console.log("GA (timer): C[" + qTimer.type + "." + qTimer.category + "] V[" + qTimer.variable + "] T[" + qTimer.time / 1E3 + "s] - " + ServerOptions.gameSymbol)
    }
    if (globalTracking.QueuedEvents.length > 0) {
        var qEvent = globalTracking.QueuedEvents[0];
        globalTracking.QueuedEvents.splice(0, 1);
        ga(qEvent.type + ".send", "event", qEvent.category, qEvent.action, ServerOptions.gameSymbol, qEvent.value);
        if (UHT_LOCAL)
            console.log("GA          (event): C[" + qEvent.type + "." + qEvent.category + "] A[" + qEvent.action + "] V[" + qEvent.value + "] - " + ServerOptions.gameSymbol)
    }
    setTimeout(SendTrackingIfQueued, 1250)
};
SendTrackingIfQueued();
goog.provide("UHT.UHTEngine");
var UHTEngine = {
    StartDownloadingMainGame: function(listener, callbackDownloadDone, callbackHide) {
        downloadMainGame(listener, callbackDownloadDone, callbackHide)
    },
    StartImportingMainGame: function() {
        importMainGame()
    },
    HideLoader: function() {
        loaderController[loaderCallbackHide]()
    },
    SignalLoaderIsHidden: function() {
        loaderIsVisible = false
    },
    LoadAssetBundle: function(data, path) {
        if (globalImporter.state == Importer.State.Idle) {
            globalImporter.StartImport(0, data);
            var ret = globalImporter.Advance(data, path);
            globalImporter.clear();
            return ret.objects[0]
        } else {
            console.error("Importer not ready!");
            return null
        }
    },
    StartLoadingSounds: function() {
        SoundLoader.LoadSounds()
    },
    SoundsAreLoaded: function() {
        return SoundLoader.soundsAreLoaded
    },
    SoundsAreLoading: function() {
        return !SoundLoader.soundsAreLoaded && SoundLoader.soundsAreBeingLoaded
    },
    WaitingForSounds: function() {
        return false
    },
    IsFullscreen: function() {
        return IsFullscreen()
    },
    RequestFullscreen: function() {
        return RequestFullscreen()
    },
    ExitFullscreen: function() {
        return ExitFullscreen()
    },
    CheckUserAgent: function(browserWarningShown, callback, object) {
        var msgMng = window["SystemMessageManager"] || null;
        if (msgMng == null) {
            setTimeout(function() {
                UHTEngine.CheckUserAgent(browserWarningShown, callback, object)
            }, 200);
            return
        }
        msgMng.CheckUserAgent(browserWarningShown, callback, object)
    },
    HideFirstLoader: function() {
        document.getElementById("wheelofpatience").style.display = "none"
    },
    RegisterUserInteraction: function() {
        var msgMng = window["SystemMessageManager"] || null;
        if (msgMng != null)
            window["SystemMessageManager"].UserInteraction()
    },
    SetBatterySaverState: function(isOn) {
        batterySaverIsOff = !isOn
    },
    SignalCanStartPrefetchingUnusedAtlasses: function() {
        timerToStartPrefetching = 5
    }
};
var UHTInterfaceBOSS = {};
UHTInterfaceBOSS.enabled = UHT_GAME_CONFIG["extend_events"];
UHTInterfaceBOSS.currentRoundID = "0";
UHTInterfaceBOSS.listener = window[UHT_GAME_CONFIG_SRC["extend_events_listener"]] || null;
UHTInterfaceBOSS.PostMessage = function(message) {
    if (message == "gameRoundEnded")
        if (GameConnection.I.requestState == RequestState.Collect || GameConnection.I.srvResponse.NextGameActions != null && GameConnection.I.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) > -1) {
            GameConnection.I.mustPostGameRoundEndedOnCollect = true;
            return
        }
    var args = {};
    if (UHTInterfaceBOSS.enabled && window.top != window) {
        args.sender = URLGameSymbol;
        args.lang = UHT_GAME_CONFIG["LANGUAGE"].toUpperCase();
        args.success = true;
        if (!/gameLoading/.test(message) && message != "post_updateBalance") {
            var balance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
            args.winAmount = XT.GetDouble(Vars.SpinCycleWinReceived);
            args.balanceAfter = balance;
            args.betAmount = CoinManager.GetNextTotalBet();
            args.balanceBefore = balance;
            args.amount = balance
        }
        if (message == "gameRoundStarted") {
            args.name = "gameRoundStart";
            UHTInterfaceBOSS.PostMessageRec(window.parent, args)
        }
        args.name = message;
        UHTInterfaceBOSS.PostMessageRec(window.parent, args);
        if (message == "gameRoundEnded") {
            args.name = "balanceChanged";
            UHTInterfaceBOSS.PostMessageRec(window.parent, args)
        }
    }
    if (UHTInterfaceBOSS.enabled && window.top != window) {
        if (message == "gameLoadingStarted") {
            args.event = "loaded";
            UHTInterfaceBOSS.PostMessageRec(window.parent, args)
        }
        if (message == "gameRoundEnded" || message == "post_updateBalance") {
            args.event = "updateBalance";
            args.params = {
                total: {
                    currency: ServerOptions.currency,
                    amount: (XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived)) * 100 | 0
                }
            };
            UHTInterfaceBOSS.PostMessageRec(window.parent, args)
        }
    }
}
;
UHTInterfaceBOSS.PostMessageRec = function(receiver, args) {
    if (UHTInterfaceBOSS.listener != null) {
        UHTInterfaceBOSS.listener.postMessage(args, "*");
        return
    }
    receiver.postMessage(args, "*");
    if (receiver != window.top)
        UHTInterfaceBOSS.PostMessageRec(receiver.parent, args)
}
;
UHTInterfaceBOSS.ReceiveMessage = function(event) {
    if (UHTInterfaceBOSS.enabled) {
        if (event.data == "updateBalance")
            EventManager.Trigger(BalanceEvents.evtUpdateBalanceForced, null);
        if (event.data.event == "refreshBalance")
            EventManager.Trigger(BalanceEvents.evtUpdateBalanceForced, null);
        if (event.data.event == "setVolume")
            if (event.data.params != undefined)
                if (event.data.params.muted == true) {
                    if (XT.GetObject(Vars.SoundState).gameSoundIsOn)
                        XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn);
                    SoundManager.forcedMute = true
                } else {
                    SoundManager.forcedMute = false;
                    if (!XT.GetObject(Vars.SoundState).gameSoundIsOn)
                        XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
                }
    }
}
;
UHTInterfaceBOSS.Init = function() {
    window.addEventListener("message", UHTInterfaceBOSS.ReceiveMessage, false)
}
;
UHTInterfaceBOSS.Init();
goog.provide("UHTMath");
var UHTMath = {
    PI: 3.1415926,
    numberError: 1E-6,
    angularError: 1
};
UHTMath.toDeg = function(r) {
    return r * 180 / UHTMath.PI
}
;
UHTMath.toRad = function(d) {
    return d / 180 * UHTMath.PI
}
;
UHTMath.clamp = function(n, min, max) {
    return Math.min(Math.max(n, min), max)
}
;
UHTMath.lerp = function(a, b, t) {
    var _t = UHTMath.clamp(t, 0, 1);
    return a + (b - a) * _t
}
;
UHTMath.inverseLerp = function(a, b, v) {
    if (a === b)
        return 0;
    var _v = UHTMath.clamp(v, a, b);
    return (v - a) / (b - a)
}
;
UHTMath.lerpUnclamped = function(a, b, t) {
    return a + (b - a) * t
}
;
goog.provide("UHTMath.Vector3");
UHTMath.Vector3 = function(_x, _y, _z) {
    this.set(_x, _y, _z)
}
;
UHTMath.Vector3.prototype = {
    constructor: UHTMath.Vector3,
    set: function(x, y, z) {
        var undefined;
        if (x === undefined) {
            x = 0;
            y = 0;
            z = 0
        } else if (y === undefined)
            if (x.x !== undefined) {
                y = x.y;
                z = x.z;
                x = x.x
            } else
                return undefined;
        this.x = x;
        this.y = y;
        this.z = z
    },
    equals: function(x, y, z) {
        var v = new UHTMath.Vector3(x,y,z);
        return Math.abs(this.x - v.x) < UHTMath.numberError && Math.abs(this.y - v.y) < UHTMath.numberError && Math.abs(this.z - v.z) < UHTMath.numberError
    },
    magnitude: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    sqrMagnitude: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    },
    normalize: function() {
        var l = this.magnitude();
        if (l < UHTMath.numberError)
            this.set(0, 0, 0);
        else {
            l = 1 / l;
            this.set(this.x * l, this.y * l, this.z * l)
        }
    },
    normalized: function() {
        var l = this.magnitude();
        var ret = new UHTMath.Vector3;
        if (l !== 0) {
            l = 1 / l;
            ret.x = this.x * l;
            ret.y = this.y * l;
            ret.z = this.z * l
        }
        return ret
    },
    add: function(u) {
        this.x += u.x;
        this.y += u.y;
        this.z += u.z;
        return this
    },
    toString: function() {
        return JSON.stringify(this)
    }
};
UHTMath.Vector3.dot = function(u, v) {
    var undefined;
    if (v === undefined || u === undefined)
        return 0;
    return u.x * v.x + u.y * v.y + u.z * v.z
}
;
UHTMath.Vector3.angle = function(u, v) {
    var d = UHTMath.Vector3.dot(u.normalized(), v.normalized());
    d = UHTMath.clamp(d, -1, 1);
    return UHTMath.toDeg(Math.acos(d))
}
;
UHTMath.Vector3.cross = function(u, v) {
    return new UHTMath.Vector3(u.y * v.z - u.z * v.y,u.z * v.x - u.x * v.z,u.x * v.y - u.y * v.x)
}
;
UHTMath.Vector3.distance = function(u, v) {
    var d = new UHTMath.Vector3(u.x - v.x,u.y - v.y,u.z - v.z);
    return d.magnitude()
}
;
UHTMath.Vector3.lerp = function(s, e, a) {
    var t = UHTMath.clamp(a, 0, 1);
    var ret = new UHTMath.Vector3(s.x + (e.x - s.x) * t,s.y + (e.y - s.y) * t,s.z + (e.z - s.z) * t);
    return ret
}
;
UHTMath.Vector3.nlerp = function(start, end, percent) {
    var t = UHTMath.clamp(percent, 0, 1);
    var v = UHTMath.Vector3.lerp(start, end, t);
    v.normalize();
    return v
}
;
UHTMath.Vector3.slerp = function(_start, _end, _percent) {
    var ls = _start.magnitude();
    var le = _end.magnitude();
    var start = Math.abs(ls) > 0 ? UHTMath.Vector3.scale(_start, 1 / ls) : UHTMath.Vector3.up;
    var end = Math.abs(le) > 0 ? UHTMath.Vector3.scale(_end, 1 / le) : UHTMath.Vector3.up;
    var t = UHTMath.clamp(_percent, 0, 1);
    var rot = UHTMath.Quaternion.fromToRotation(start, end);
    var interpolatedRot = UHTMath.Quaternion.slerp(UHTMath.Quaternion.identity, rot, t);
    var v = UHTMath.Quaternion.multiplyVec(interpolatedRot, start);
    var lp = UHTMath.lerp(ls, le, t);
    return UHTMath.Vector3.scale(v, lp)
}
;
UHTMath.Vector3.min = function(u, v) {
    return new UHTMath.Vector3(Math.min(u.x, v.x),Math.min(u.y, v.y),Math.min(u.z, v.z))
}
;
UHTMath.Vector3.max = function(u, v) {
    return new UHTMath.Vector3(Math.max(u.x, v.x),Math.max(u.y, v.y),Math.max(u.z, v.z))
}
;
UHTMath.Vector3.moveTowards = function(current, target, maxDistanceDelta) {
    var d = new UHTMath.Vector3(target.x - current.x,target.y - current.y,target.z - current.z);
    var m = d.magnitude();
    if (m < UHTMath.numberError)
        return target;
    var dl = Math.min(maxDistanceDelta, m) / m;
    return UHTMath.Vector3.lerp(current, target, dl)
}
;
UHTMath.Vector3.orthoNormalize = function(normal, tangent, binormal) {
    normal.normalize();
    binormal.set(UHTMath.Vector3.cross(normal, tangent));
    binormal.normalize();
    tangent.set(UHTMath.Vector3.cross(binormal, normal));
    tangent.normalize()
}
;
UHTMath.Vector3.scale = function(a, b) {
    var x, y, z;
    var undefined;
    if (b.x === undefined) {
        x = b;
        y = b;
        z = b
    } else {
        x = b.x;
        y = b.y;
        z = b.z
    }
    return new UHTMath.Vector3(a.x * x,a.y * y,a.z * z)
}
;
UHTMath.Vector3.add = function(a, b) {
    return new UHTMath.Vector3(a.x + b.x,a.y + b.y,a.z + b.z)
}
;
UHTMath.Vector3.sub = function(a, b) {
    return new UHTMath.Vector3(a.x - b.x,a.y - b.y,a.z - b.z)
}
;
UHTMath.Vector3.back = new UHTMath.Vector3(0,0,-1);
UHTMath.Vector3.down = new UHTMath.Vector3(0,-1,0);
UHTMath.Vector3.forward = new UHTMath.Vector3(0,0,1);
UHTMath.Vector3.left = new UHTMath.Vector3(-1,0,0);
UHTMath.Vector3.one = new UHTMath.Vector3(1,1,1);
UHTMath.Vector3.right = new UHTMath.Vector3(1,0,0);
UHTMath.Vector3.up = new UHTMath.Vector3(0,1,0);
UHTMath.Vector3.zero = new UHTMath.Vector3(0,0,0);
goog.require("UHTMath.Vector3");
goog.require("UHT.Component");
goog.require("UHT.ParticleSystemEvaluator");
goog.require("UHT.ParticleSystemEvaluatorBySpeed");
goog.require("UHT.ParticleSystemEvaluatorColor");
goog.require("UHT.ClampVelocityModule");
function Particle() {
    this.parent = null;
    this._angularVelocity = null;
    this._angularVelocityBySpeed = null;
    this.startColor = new GradientColor;
    this._color = null;
    this._colorBySpeed = null;
    this._lifetime = -1;
    this.position = new UHTMath.Vector3;
    this.randomSeed = 0;
    this.startSize = 1;
    this._size = null;
    this._sizeBySpeed = null;
    this.startLifetime = -1;
    this.rotation = 0;
    this.startSpeed = 0;
    this.speed = new UHTMath.Vector3;
    this._velocity = new UHTMath.Vector3;
    this._velocityX = null;
    this._velocityY = null;
    this._velocityZ = null;
    this._forceX = null;
    this._forceY = null;
    this._forceZ = null;
    this.velocityDirection = new UHTMath.Vector3(0,1,0);
    this.isOld = false;
    this.clampVelocity = null;
    this.sprite;
    this.velocityX = 0;
    this.velocityY = 0;
    this.velocityZ = 0;
    this.forceX = 0;
    this.forceY = 0;
    this.forceZ = 0;
    this.angularVelocity = 0;
    this.angularVelocityBySpeed = 0;
    this.sizeBySpeed = 0;
    Object.defineProperties(this, {
        "lifetime": {
            set: function(value) {
                var mustKill = false;
                if (value <= 0 && this._lifetime > 0)
                    mustKill = true;
                this._lifetime = value;
                if (mustKill) {
                    this.parent.particleCount--;
                    this.parent.killParticle(this)
                }
            },
            get: function() {
                return this._lifetime
            }
        },
        "color": {
            set: function(value) {
                if (this._color === null)
                    this._color = new ParticleSystemEvaluatorColor;
                this._color.deserialize(value)
            },
            get: function() {
                if (this._color === null)
                    return new GradientColor;
                var s = this.lifetime / this.startLifetime;
                var gc = this._color.Evaluate(1 - s);
                gc.r /= 255;
                gc.g /= 255;
                gc.b /= 255;
                gc.a /= 255;
                return gc
            }
        },
        "colorBySpeed": {
            set: function(value) {
                if (this._colorBySpeed === null)
                    this._colorBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluatorColor);
                this._colorBySpeed.deserialize(value)
            },
            get: function(value) {
                if (this._colorBySpeed === null)
                    return new GradientColor;
                var gc = this._colorBySpeed.Evaluate(this.speed.magnitude());
                gc.r /= 255;
                gc.g /= 255;
                gc.b /= 255;
                gc.a /= 255;
                return gc
            }
        },
        "isDead": {
            set: function(value) {
                if (value)
                    this.lifetime = 0;
                else if (this.lifetime <= 0)
                    this.lifetime = this.startLifetime
            },
            get: function() {
                return this.lifetime <= 0
            }
        },
        "velocityX": {
            set: function(value) {
                this._velocityX = value
            },
            get: function() {
                var s = this.lifetime / this.startLifetime;
                var v = this._velocityX.Evaluate(1 - s);
                return v
            }
        },
        "velocityY": {
            set: function(value) {
                this._velocityY = value
            },
            get: function() {
                var s = this.lifetime / this.startLifetime;
                var v = this._velocityY.Evaluate(1 - s);
                return v
            }
        },
        "velocityZ": {
            set: function(value) {
                this._velocityZ = value
            },
            get: function() {
                var s = this.lifetime / this.startLifetime;
                var v = this._velocityZ.Evaluate(1 - s);
                return v
            }
        },
        "forceX": {
            set: function(value) {
                this._forceX = value
            },
            get: function() {
                var s = this.lifetime / this.startLifetime;
                var v = this._forceX.Evaluate(1 - s);
                return v
            }
        },
        "forceY": {
            set: function(value) {
                this._forceY = value
            },
            get: function() {
                var s = this.lifetime / this.startLifetime;
                var v = this._forceY.Evaluate(1 - s);
                return v
            }
        },
        "forceZ": {
            set: function(value) {
                this._forceZ = value
            },
            get: function() {
                var s = this.lifetime / this.startLifetime;
                var v = this._forceZ.Evaluate(1 - s);
                return v
            }
        },
        "size": {
            set: function(value) {
                if (this._size === null)
                    this._size = new ParticleSystemEvaluator;
                if (value instanceof Number) {
                    this._size.minMaxState = 0;
                    this._size.scalar = value
                } else
                    this._size.deserialize(value)
            },
            get: function() {
                return this._size.Evaluate(1 - this.lifetime / this.startLifetime)
            }
        },
        "sizeBySpeed": {
            set: function(value) {
                if (this._sizeBySpeed === null)
                    this._sizeBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
                if (value instanceof Number) {
                    this._sizeBySpeed.minMaxState = 0;
                    this._sizeBySpeed.scalar = value
                } else
                    this._sizeBySpeed.deserialize(value)
            },
            get: function() {
                if (this._sizeBySpeed === null)
                    return 1;
                return this._sizeBySpeed.Evaluate(this.speed.magnitude())
            }
        },
        "angularVelocityBySpeed": {
            set: function(value) {
                if (this._angularVelocityBySpeed === null)
                    this._angularVelocityBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
                if (value instanceof Number) {
                    this._angularVelocityBySpeed.minMaxState = 0;
                    this._angularVelocityBySpeed.scalar = value
                } else
                    this._angularVelocityBySpeed.deserialize(value)
            },
            get: function(value) {
                if (this._angularVelocityBySpeed === null)
                    return 0;
                return this._angularVelocityBySpeed.Evaluate(this.speed.magnitude())
            }
        },
        "angularVelocity": {
            set: function(value) {
                if (value instanceof ParticleSystemEvaluator)
                    this._angularVelocity = value;
                else if (value instanceof Number) {
                    this._angularVelocity.minMaxState = 0;
                    this._angularVelocity.scalar = value
                } else
                    this._angularVelocity.deserialize(value)
            },
            get: function(value) {
                if (this._angularVelocity === null)
                    return 0;
                var s = this.lifetime / this.startLifetime;
                var v = this._angularVelocity.Evaluate(1 - s);
                return v
            }
        }
    })
}
Particle.prototype.Spawn = function() {
    this.lifetime = this.startLifetime;
    this.isDead = false;
    this._velocity.set(0, 0, 0);
    this.speed.set(0, 0, 0)
}
;
Particle.prototype.Update = function(dt) {
    var velocity = Particle.velocity;
    var force = Particle.force;
    var tppsc = this.parent.ParticleSystemComponent;
    var parentTransform = this.parent.gameObject.transform;
    this.lifetime -= dt;
    if (this.lifetime < 0)
        return;
    var g = this.parent.gravityModifier;
    this._velocity.y -= g * dt;
    if (this._velocityX !== null)
        velocity.set(this.velocityX, this.velocityY, this.velocityZ);
    else
        velocity.set(0, 0, 0);
    if (tppsc.VelocityModule.enabled === "True")
        if (tppsc.VelocityModule.inWorldSpace !== "True")
            velocity.set(parentTransform.transformDirection(velocity));
    if (this._forceX !== null)
        force.set(this.forceX, this.forceY, this.forceZ);
    else
        force.set(0, 0, 0);
    if (tppsc.ForceModule.enabled === "True")
        if (tppsc.ForceModule.inWorldSpace !== "True")
            force.set(parentTransform.transformDirection(force));
    this.speed.set(this._velocity.x + velocity.x + force.x, this._velocity.y + velocity.y + force.y, this._velocity.z + velocity.z + force.z);
    if (this.clampVelocity != null) {
        var s = 1 - this.lifetime / this.startLifetime;
        var c = UHTMath.Vector3.scale(this.clampVelocity.Evaluate(s, this.speed), 1);
        this.speed.set(c)
    }
    var p = UHTMath.Vector3.scale(this.speed, dt * this.parent.goodScale);
    this.position.add(p);
    this.rotation += (this.angularVelocityBySpeed + this.angularVelocity) * dt
}
;
Particle.prototype.setupSpritePosition = function(parent) {
    var sprite = this.sprite;
    var tsc = this.startColor;
    var tc = this.color;
    var tcbs = this.colorBySpeed;
    var gc = Particle.gradientColor;
    gc.r = tsc.r * tc.r * tcbs.r;
    gc.g = tsc.g * tc.g * tcbs.g;
    gc.b = tsc.b * tc.b * tcbs.b;
    gc.a = tsc.a * tc.a * tcbs.a;
    sprite.tint = gc.toRGBHex();
    sprite.alpha = gc.a / 255;
    sprite.x = this.position.x;
    sprite.y = -this.position.y;
    sprite.width = this.size * this.sizeBySpeed * this.startSize * this.parent.goodScale;
    sprite.height = sprite.width;
    sprite.rotation = this.rotation
}
;
Particle.velocity = new UHTMath.Vector3;
Particle.force = new UHTMath.Vector3;
Particle.gradientColor = new GradientColor;
goog.provide("UHT.ParticleSystemExtraData");
goog.require("UHT.Component");
goog.require("UHTMath.Vector3");
ParticleSystemExtraData.prototype = Object.create(Component.prototype);
ParticleSystemExtraData.prototype.constructor = ParticleSystemExtraData;
function ParticleSystemExtraData() {
    Component.call(this);
    this.SubEmitterBirth0 = null;
    this.SubEmitterBirth1 = null;
    this.SubEmitterCollision0 = null;
    this.SubEmitterCollision1 = null;
    this.SubEmitterDeath0 = null;
    this.SubEmitterDeath1 = null
}
ParticleSystemExtraData.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference)
}
;
ParticleSystemExtraData.prototype.Awake = function() {
    if (this.SubEmitterBirth0 != null) {
        this.SubEmitterBirth0.playOnAwake = false;
        this.SubEmitterBirth0.emissionRate = 0
    }
    if (this.SubEmitterBirth1 != null) {
        this.SubEmitterBirth1.playOnAwake = false;
        this.SubEmitterBirth1.emissionRate = 0
    }
    if (this.SubEmitterCollision0 != null) {
        this.SubEmitterCollision0.playOnAwake = false;
        this.SubEmitterCollision0.emissionRate = 0
    }
    if (this.SubEmitterCollision1 != null) {
        this.SubEmitterCollision1.playOnAwake = false;
        this.SubEmitterCollision1.emissionRate = 0
    }
    if (this.SubEmitterDeath0 != null) {
        this.SubEmitterDeath0.playOnAwake = false;
        this.SubEmitterDeath0.emissionRate = 0
    }
    if (this.SubEmitterDeath1 != null) {
        this.SubEmitterDeath1.playOnAwake = false;
        this.SubEmitterDeath1.emissionRate = 0
    }
}
;
goog.require("UHT.Component");
goog.require("UHT.ParticleSystemEvaluator");
goog.require("UHT.ParticleSystemEvaluatorBySpeed");
goog.require("UHT.ParticleSystemEvaluatorColor");
goog.require("UHT.ParticleSystemShape");
goog.require("UHT.ParticleSystemShapeBox");
goog.require("UHT.ParticleSystemShapeCone");
goog.require("UHT.ParticleSystemShapeSphere");
goog.require("UHT.ParticleSystemShapeType");
goog.require("UHT.ParticleSystemExtraData");
goog.require("UHT.ClampVelocityModule");
var ParticleSystemSimulationSpace = {
    Local: 0,
    World: 1
};
var ParticleSystemState = {
    isStopped: 0,
    isPaused: 1,
    isPlaying: 2
};
ParticleSystem.prototype = Object.create(Component.prototype);
ParticleSystem.prototype.constructor = ParticleSystem;
function ParticleSystem() {
    Component.call(this);
    this.depth = 1E4;
    this.goodScale = 1;
    this._emissionRate = new ParticleSystemEvaluator;
    this._enableEmission = true;
    this._gravityModifier = 0;
    this._loop = false;
    this._maxParticles = new ParticleSystemEvaluator;
    this._playbackSpeed = new ParticleSystemEvaluator;
    this._playOnAwake = new ParticleSystemEvaluator;
    this._randomSeed = new ParticleSystemEvaluator;
    this._simulationSpace = new ParticleSystemEvaluator;
    this._startColor = new ParticleSystemEvaluatorColor;
    this._startDelay = 0;
    this._startLifetime = new ParticleSystemEvaluator;
    this._startRotation = new ParticleSystemEvaluator;
    this._startSize = new ParticleSystemEvaluator;
    this._startSpeed = new ParticleSystemEvaluator;
    this.duration = 0;
    this._prewarm = false;
    this._shape = null;
    this.bursts = [];
    this.particles = [];
    this.particleCount = 0;
    this._state = ParticleSystemState.isStopped;
    this.time = 0;
    this._deadParticles = [];
    this._lest = 0;
    this.texturica = null;
    this.subEmitors = null;
    this.enableEmission = true;
    this.textureContent;
    this.ParticleSystemComponent;
    this.startColor;
    this.fastContainer = true;
    this.epm = [];
    Object.defineProperties(this, {
        "emissionRate": {
            set: function(value) {
                if (typeof value === "number") {
                    this._emissionRate.minMaxState = 0;
                    this._emissionRate.scalar = value
                } else
                    this._emissionRate = value
            },
            get: function() {
                return this._emissionRate.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "enableEmission": {
            set: function(value) {
                this._enableEmission = value
            },
            get: function() {
                return this._enableEmission
            }
        },
        "gravityModifier": {
            set: function(value) {
                this._gravityModifier = value
            },
            get: function() {
                return this._gravityModifier
            }
        },
        "state": {
            set: function(value) {
                this._state = value
            },
            get: function() {
                return this._state
            }
        },
        "loop": {
            set: function(value) {
                this._loop = value
            },
            get: function() {
                return this._loop
            }
        },
        "maxParticles": {
            set: function(value) {
                this._maxParticles = value
            },
            get: function() {
                return this._maxParticles.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "playbackSpeed": {
            set: function(value) {
                this._playbackSpeed = value
            },
            get: function() {
                return this._playbackSpeed.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "playOnAwake": {
            set: function(value) {
                if (typeof value === "boolean") {
                    this._playOnAwake.scalar = value ? 1 : 0;
                    this._playOnAwake.minMaxState = 0
                } else
                    this._playOnAwake = value
            },
            get: function() {
                return this._playOnAwake.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "randomSeed": {
            set: function(value) {
                this._randomSeed = value
            },
            get: function() {
                return this._randomSeed.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "simulationSpace": {
            set: function(value) {
                this._simulationSpace = value
            },
            get: function() {
                return this._simulationSpace.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "startColor": {
            set: function(value) {
                this._startColor = value
            },
            get: function() {
                return this._startColor.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "startDelay": {
            set: function(value) {
                this._startDelay = value
            },
            get: function() {
                return this._startDelay
            }
        },
        "startLifetime": {
            set: function(value) {
                this._startLifetime = value
            },
            get: function() {
                return this._startLifetime.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "startRotation": {
            set: function(value) {
                this._startRotation = value
            },
            get: function() {
                return this._startRotation.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "startSize": {
            set: function(value) {
                this._startSize = value
            },
            get: function() {
                return this._startSize.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "startSpeed": {
            set: function(value) {
                this._startSpeed = value
            },
            get: function() {
                return this._startSpeed.Evaluate((this.time - this.startDelay) / this.duration)
            }
        },
        "prewarm": {
            set: function(value) {
                this._prewarm = value
            },
            get: function() {
                return this._prewarm
            }
        }
    })
}
ParticleSystem.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference);
    this.fromSource(source, helper, resolveReference)
}
;
ParticleSystem.prototype.copyFromSource = function(source, helper, resolveReference) {
    copyComponentHelper(source, this, helper, resolveReference);
    this.fromSource(source, helper, resolveReference)
}
;
ParticleSystem.prototype.fromSource = function(source, helper, resolveReference) {
    var hasTexture = this.textureContent !== null;
    if (hasTexture) {
        this.texturica = PIXI.Texture.fromImage(this.textureContent, undefined, undefined, true);
        this.textureContent = {
            src: ""
        }
    }
    this.blendMode = source.blendMode;
    var em = source.ParticleSystemComponent.EmissionModule;
    this._burstCnt = em.m_BurstCount;
    var cnt = this._burstCnt;
    while (cnt--) {
        var t = "time" + cnt.toString();
        var c = "cnt" + cnt.toString();
        this.bursts.push({
            time: Number(em[t]),
            cnt: Number(em[c]),
            emited: false
        })
    }
    this._startColor = new ParticleSystemEvaluatorColor;
    this._startColor.deserialize(source.ParticleSystemComponent.InitialModule.startColor);
    this._enableEmission = this.valueFromString(em.enabled);
    this.gravityModifier = 9.81 * this.valueFromString(source.ParticleSystemComponent.InitialModule.gravityModifier) || 0;
    this.prewarm = this.valueFromString(source.ParticleSystemComponent.prewarm) || false;
    this.startDelay = this.valueFromString(source.ParticleSystemComponent.startDelay) || 0;
    this.duration = this.valueFromString(source.ParticleSystemComponent.lengthInSec) || 0;
    this.loop = this.valueFromString(source.ParticleSystemComponent.looping) || 0;
    this.emissionRate = this.CreateParticleSystemComponent(source.ParticleSystemComponent.EmissionModule.rate || 0);
    this.playOnAwake = this.CreateParticleSystemComponent(source.ParticleSystemComponent.playOnAwake || 0);
    this.startLifetime = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startLifetime || 0);
    this.startRotation = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startRotation || 0);
    this.startSize = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startSize || 0);
    this.startSpeed = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.startSpeed || 0);
    this.maxParticles = this.CreateParticleSystemComponent(source.ParticleSystemComponent.InitialModule.maxNumParticles || 0);
    this.InitializeEmissionShape(source.ParticleSystemComponent.ShapeModule);
    if (this.ParticleSystemComponent.ColorModule.enabled === undefined || this.ParticleSystemComponent.ColorModule.enabled === "False")
        this.fastContainer = false;
    if (!Renderer.IsWebGL)
        this.fastContainer = false
}
;
ParticleSystem.prototype.InitializeEmissionShape = function(src) {
    var undefined;
    if (src === undefined) {
        this._shape = new ParticleSystemShape;
        return
    }
    if (src.enabled === undefined || src.enabled === "False") {
        this._shape = new ParticleSystemShape;
        return
    }
    switch (Number(src.type)) {
    case ParticleSystemShapeType.box:
        this._shape = new ParticleSystemShapeBox;
        this._shape.deserialize(src);
        break;
    case ParticleSystemShapeType.cone:
    case ParticleSystemShapeType.coneBaseShell:
        this._shape = new ParticleSystemShapeCone;
        this._shape.deserialize(src);
        break;
    case ParticleSystemShapeType.sphere:
    case ParticleSystemShapeType.sphereShell:
        this._shape = new ParticleSystemShapeSphere;
        this._shape.deserialize(src);
        break;
    default:
        this._shape = new ParticleSystemShape;
        break
    }
}
;
ParticleSystem.prototype.valueFromString = function(source) {
    var n = Number(source);
    if (isNaN(n) == false)
        return n;
    else
        return source === "True"
}
;
ParticleSystem.prototype.CreateParticleSystemComponent = function(source) {
    var ret = new ParticleSystemEvaluator;
    var undefined;
    if (source.minMaxState !== undefined)
        ret.deserialize(source);
    else {
        ret.minMaxState = 0;
        ret.scalar = this.valueFromString(source)
    }
    return ret
}
;
ParticleSystem.prototype.OnEnable = function() {
    if (this.playOnAwake) {
        this.time = 0;
        this.Clear(false);
        this.resetBursts()
    }
    this.subEmitors = this.gameObject.GetComponent("ParticleSystemExtraData");
    if (this.playOnAwake)
        this.Play();
    if (this.prewarm) {
        var step = 1 / 15;
        var adunator = 0;
        while (adunator < this.duration) {
            this.internalUpdate(step);
            adunator += step
        }
    }
}
;
ParticleSystem.prototype.Start = function() {}
;
ParticleSystem.prototype.Awake = function() {
    this.epm = this.gameObject.GetComponents(ExtraParticleModule);
    for (var i = 0; i < this.epm.length; i++)
        if (!this.epm[i].SupportsFastParticleContainer())
            this.fastContainer = false;
    if (this.fastContainer) {
        this.pixiZOrderedContainer = new PIXI.ParticleContainer(500,{
            scale: true,
            position: true,
            rotation: true,
            uvs: false,
            alpha: true
        },500);
        this.pixiZOrderedContainer.blendMode = this.blendMode
    } else
        this.pixiZOrderedContainer = new PIXI.Container
}
;
ParticleSystem.prototype.OnDisable = function() {}
;
ParticleSystem.prototype.Play = function(withChildren) {
    this.state = ParticleSystemState.isPlaying;
    var undefined;
    if (withChildren === undefined || withChildren === false)
        return;
    this.callOnChildren("Play")
}
;
ParticleSystem.prototype.callOnChildren = function(func) {
    var g = this.gameObject;
    var l = g.GetComponentsInChildren(ParticleSystem, true);
    var i = l.length;
    while (i--)
        l[i][func](false)
}
;
ParticleSystem.prototype.Stop = function(withChildren) {
    this.state = ParticleSystemState.isStopped;
    this.time = 0;
    var undefined;
    if (withChildren === undefined || withChildren === false)
        return;
    this.callOnChildren("Stop")
}
;
ParticleSystem.prototype.Pause = function(withChildren) {
    this.state = ParticleSystemState.isPaused;
    var undefined;
    if (withChildren === undefined || withChildren === false)
        return;
    this.callOnChildren("Pause")
}
;
ParticleSystem.prototype.isPaused = function() {
    return this.state === ParticleSystemState.isPaused
}
;
ParticleSystem.prototype.isPlaying = function() {
    return this.state === ParticleSystemState.isPlaying
}
;
ParticleSystem.prototype.isStopped = function() {
    return this.state === ParticleSystemState.isStopped
}
;
ParticleSystem.prototype.spawnNewParticles = function(dt) {
    var c = this.emissionRate * dt + this._lest;
    var n = Math.floor(c);
    this._lest = c - n;
    var cnt = this._burstCnt;
    while (cnt--) {
        var b = this.bursts[cnt];
        if (b.emited === false && (b.time >= this.time - this.startDelay - dt && b.time <= this.time - this.startDelay + dt)) {
            b.emited = true;
            n += b.cnt;
            break
        }
    }
    this.Emit(Math.min(n, Math.max(0, this.maxParticles - Math.max(0, this.particleCount))))
}
;
ParticleSystem.prototype.Update = function() {}
;
ParticleSystem.prototype.OnWillRenderObject = function() {
    if (this.texturica === null)
        return;
    var dt = Time.deltaTime;
    if (this.state !== ParticleSystemState.isPlaying)
        return;
    if (this.time < this.startDelay && !this.prewarm)
        return;
    if (this.time - this.startDelay > this.duration && !this.loop)
        return;
    if (this.time - this.startDelay > this.duration) {
        this.time -= this.duration + this.startDelay;
        this.resetBursts()
    }
    this.internalUpdate(dt)
}
;
ParticleSystem.prototype.resetBursts = function() {
    var cnt = this._burstCnt;
    while (cnt--) {
        var b = this.bursts[cnt];
        b.emited = false
    }
}
;
ParticleSystem.prototype.killParticle = function(p) {
    if (p instanceof Particle) {
        p.isDead = true;
        this.pixiZOrderedContainer.removeChild(p.sprite);
        this._deadParticles.push(p);
        if (this.subEmitors != null) {
            if (this.subEmitors.SubEmitterDeath0 != null) {
                this.subEmitors.SubEmitterDeath0.Play(false);
                this.subEmitors.SubEmitterDeath0.time = 0;
                this.subEmitors.SubEmitterDeath0.resetBursts()
            }
            if (this.subEmitors.SubEmitterDeath1 != null) {
                this.subEmitors.SubEmitterDeath1.Play(false);
                this.subEmitors.SubEmitterDeath1.time = 0;
                this.subEmitors.SubEmitterDeath1.resetBursts()
            }
        }
    }
}
;
ParticleSystem.prototype.internalUpdate = function(dt) {
    this.time += dt;
    this.spawnNewParticles(dt);
    var i = this.particles.length;
    var cappedAspectRatio = Math.min(UHTScreen.width / UHTScreen.height, 1.44544);
    this.goodScale = cappedAspectRatio / 1.44544;
    this.pixiZOrderedContainer.scale.x = 1;
    this.pixiZOrderedContainer.scale.y = 1;
    if (this.ParticleSystemComponent.moveWithTransform === "True") {
        this.pixiZOrderedContainer.position.x = this.gameObject.transform.position().x;
        this.pixiZOrderedContainer.position.y = -this.gameObject.transform.position().y
    }
    this.particleCount = 0;
    while (i--) {
        var p = this.particles[i];
        if (!p.isDead) {
            this.particleCount++;
            p.Update(dt);
            if (!p.isDead)
                for (var j = 0; j < this.epm.length; j++)
                    this.epm[j].OnUpdateParticle(p);
            p.setupSpritePosition(this.gameObject);
            if (this.subEmitors != null) {
                var emitors = ["SubEmitterBirth0", "SubEmitterBirth1", "SubEmitterCollision0", "SubEmitterCollision1", "SubEmitterDeath0", "SubEmitterDeath1"];
                var id = emitors.length;
                while (id--)
                    if (this.subEmitors[emitors[id]] != null) {
                        var ps = this.subEmitors[emitors[id]];
                        ps.gameObject.transform.position(p.position);
                        ps.Update(dt)
                    }
            }
        }
    }
}
;
ParticleSystem.prototype.GetParticles = function() {
    return this.particles
}
;
ParticleSystem.prototype.SetParticles = function(p, size) {
    this.particles = p.splice(1, size)
}
;
ParticleSystem.prototype.Clear = function(withChildren) {
    var i = this.particles.length;
    while (i--)
        if (!this.particles[i].isDead)
            this.killParticle(this.particles[i]);
    var undefined;
    if (withChildren !== undefined && withChildren === true)
        this.GetComponentsInChildren(ParticleSystem, true).forEach(function(p) {
            p.Clear(false)
        })
}
;
ParticleSystem.prototype.setupParticleVelocity = function(p) {
    if (this.ParticleSystemComponent.ShapeModule.randomDirection == "False") {
        var pp;
        if (this.ParticleSystemComponent.moveWithTransform === "True")
            pp = p.position;
        else
            pp = UHTMath.Vector3.sub(p.position, this.gameObject.transform.position());
        p.velocityDirection.set(this.gameObject.transform.transformDirection(this._shape.getEmissionDirection(pp)))
    } else {
        var v = new UHTMath.Vector3(Math.random() * 2 - 1,Math.random() * 2 - 1,Math.random() * 2 - 1);
        v.normalize();
        p.velocityDirection.set(v)
    }
    p.startSpeed = this.startSpeed;
    p._velocity.set(UHTMath.Vector3.scale(p.velocityDirection, this.startSpeed))
}
;
ParticleSystem.prototype.generateNewParticlePosition = function() {
    var pp = this.gameObject.transform.transformVector(this._shape.generateNewPosition());
    if (this.ParticleSystemComponent.moveWithTransform === "True")
        return pp;
    else {
        var dp = UHTMath.Vector3.add(this.gameObject.transform.position(), pp);
        return dp
    }
}
;
ParticleSystem.prototype.generatePositionAndVelocityForParticle = function(p) {
    var g = this._shape.generateNewPosition();
    var pp = this.gameObject.transform.transformVector(g);
    if (this.ParticleSystemComponent.moveWithTransform !== "True")
        pp.set(UHTMath.Vector3.add(this.gameObject.transform.position(), pp));
    p.position.set(pp);
    if (this.ParticleSystemComponent.ShapeModule.randomDirection === "False")
        p.velocityDirection.set(this.gameObject.transform.transformDirection(this._shape.getEmissionDirection(g)).normalized());
    else
        p.velocityDirection.set(this.gameObject.transform.transformDirection(this._shape.getEmissionDirection()).normalized());
    p.startSpeed = this.startSpeed;
    p._velocity.set(UHTMath.Vector3.scale(p.velocityDirection, this.startSpeed))
}
;
ParticleSystem.prototype.Emit = function(countOrPositionOrParticle, velocity, size, lifetime, color) {
    if (this.enableEmission !== true)
        return;
    var undefined;
    if (typeof countOrPositionOrParticle === "number" && isFinite(countOrPositionOrParticle) && Math.floor(countOrPositionOrParticle) === countOrPositionOrParticle) {
        var requestedCount = countOrPositionOrParticle;
        var i = requestedCount;
        while (i--) {
            var p = this.getNewParticle();
            this.Emit(p);
            p.lifetime = this.startLifetime;
            p.startLifetime = this.startLifetime;
            p.startSize = this.startSize;
            if (p._size === null)
                p._size = new ParticleSystemEvaluator;
            if (this.ParticleSystemComponent.SizeModule.enabled !== undefined)
                p._size.deserialize(this.ParticleSystemComponent.SizeModule.curve);
            else {
                p._size.scalar = 1;
                p._size.minMaxState = 0
            }
            if (this.ParticleSystemComponent.SizeBySpeedModule.enabled !== undefined) {
                if (p._sizeBySpeed === null)
                    p._sizeBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
                p.sizeBySpeed = this.ParticleSystemComponent.SizeBySpeedModule
            }
            if (this.ParticleSystemComponent.ColorBySpeedModule.enabled !== undefined) {
                if (p._colorBySpeed === null)
                    p._colorBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluatorColor);
                p.colorBySpeed = this.ParticleSystemComponent.ColorBySpeedModule
            }
            if (this.ParticleSystemComponent.ClampVelocityModule.enabled !== undefined) {
                if (p.clampVelocity == null)
                    p.clampVelocity = new ClampVelocityModule(this);
                p.clampVelocity.deserialize(this.ParticleSystemComponent.ClampVelocityModule)
            }
            if (this.ParticleSystemComponent.ForceModule.enabled == "True") {
                if (p._forceX === null)
                    p._forceX = new ParticleSystemEvaluator;
                if (p._forceY === null)
                    p._forceY = new ParticleSystemEvaluator;
                if (p._forceZ === null)
                    p._forceZ = new ParticleSystemEvaluator;
                p._forceX.deserialize(this.ParticleSystemComponent.ForceModule.x);
                p._forceY.deserialize(this.ParticleSystemComponent.ForceModule.y);
                p._forceZ.deserialize(this.ParticleSystemComponent.ForceModule.z)
            }
            if (this.ParticleSystemComponent.VelocityModule.enabled == "True") {
                if (p._velocityX === null)
                    p._velocityX = new ParticleSystemEvaluator;
                if (p._velocityY === null)
                    p._velocityY = new ParticleSystemEvaluator;
                if (p._velocityZ === null)
                    p._velocityZ = new ParticleSystemEvaluator;
                p._velocityX.deserialize(this.ParticleSystemComponent.VelocityModule.x);
                p._velocityY.deserialize(this.ParticleSystemComponent.VelocityModule.y);
                p._velocityZ.deserialize(this.ParticleSystemComponent.VelocityModule.z)
            }
            this._startRotation.ReRandomize();
            this._startSize.ReRandomize();
            p.rotation = this.startRotation;
            if (this.ParticleSystemComponent.RotationModule.enabled != null) {
                if (p._angularVelocity === null)
                    p._angularVelocity = new ParticleSystemEvaluator;
                p.angularVelocity = this.ParticleSystemComponent.RotationModule.curve
            }
            if (this.ParticleSystemComponent.RotationBySpeedModule.enabled != null) {
                if (this._angularVelocityBySpeed === null)
                    p._angularVelocityBySpeed = new ParticleSystemEvaluatorBySpeed(new ParticleSystemEvaluator);
                p.angularVelocityBySpeed = this.ParticleSystemComponent.RotationBySpeedModule
            }
            p.startColor = this.startColor;
            if (this.ParticleSystemComponent.ColorModule.enabled != null)
                p.color = this.ParticleSystemComponent.ColorModule.gradient;
            this.generatePositionAndVelocityForParticle(p)
        }
    } else if (countOrPositionOrParticle instanceof Particle) {
        var p = countOrPositionOrParticle;
        if (!p.isOld) {
            this.particles.push(p);
            p.isOld = true
        }
        this.pixiZOrderedContainer.addChild(p.sprite);
        p.parent = this;
        p.Spawn();
        if (this.subEmitors != null) {
            if (this.subEmitors.SubEmitterBirth0 != null) {
                this.subEmitors.SubEmitterBirth0.Play(false);
                this.subEmitors.SubEmitterBirth0.time = 0;
                this.subEmitors.SubEmitterBirth0.resetBursts()
            }
            if (this.subEmitors.SubEmitterBirth1 != null) {
                this.subEmitors.SubEmitterBirth1.Play(false);
                this.subEmitors.SubEmitterBirth1.time = 0;
                this.subEmitors.SubEmitterBirth1.resetBursts()
            }
        }
    } else if (countOrPositionOrParticle instanceof UHTMath.Vector3) {
        var p = this.getNewParticle();
        this.Emit(p);
        p.position.set(countOrPositionOrParticle);
        p._velocity.set(velocity);
        if (size !== undefined)
            p.size = size;
        if (lifetime !== undefined)
            p.startLifetime = lifetime;
        if (color !== undefined)
            p.color = color
    }
}
;
ParticleSystem.prototype.getNewParticle = function() {
    var undefined;
    var p = this._deadParticles.pop();
    if (p === undefined) {
        p = new Particle;
        p.sprite = null;
        for (var i = 0; i < this.epm.length; i++)
            this.epm[i].OnNewParticle(p);
        if (p.sprite == null)
            p.sprite = new PIXI.Sprite(this.texturica);
        if (!this.fastContainer)
            p.sprite.blendMode = this.blendMode;
        p.sprite.anchor.x = .5;
        p.sprite.anchor.y = .5
    }
    return p
}
;
ParticleSystem.prototype.removeDuplicateParticles = function() {
    this.uniqueArray(this.particles);
    this.uniqueArray(this._deadParticles)
}
;
ParticleSystem.prototype.uniqueArray = function(a) {
    var seen = {};
    a.filter(function(p) {
        return seen.hasOwnProperty(p) ? false : seen[p] = true
    })
}
;
goog.provide("UHT.Input");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
var Input = {
    mousePosition: new UHTMath.Vector3(0,0,0),
    lastUsedInputDeviceIsTouch: true,
    _mousePressed: false,
    _mouseStateChangedThisFrame: false,
    GetMouseButton: function(unused) {
        return Input._mousePressed
    },
    GetMouseButtonDown: function(unused) {
        return Input._mousePressed && Input._mouseStateChangedThisFrame
    },
    GetKeyDown: function(keyCode) {
        return KeyboardManager.IsKeyDown(keyCode)
    },
    GetKey: function(keyCode) {
        return KeyboardManager.IsKey(keyCode)
    }
};
goog.provide("UHT.ColliderInputManager");
goog.require("UHT.Input");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
var ColliderEvent = {
    ButtonDown: "ButtonDown",
    ButtonUp: "ButtonUp",
    MouseMove: "MouseMove"
};
var MOUSE_EVENT_TYPE = {
    DOWN: 0,
    MOVE: 1,
    UP: 2
};
function QueuedMouseEvent(type, evt) {
    this.m_type = type;
    this.m_event = evt
}
function ColliderInputManager() {
    this.pixiObject = null;
    this.mouseIsInScreen = false;
    this.colliders = [];
    this.mousePosition = new UHTMath.Vector3(0,0,0);
    this._mousePressed = false;
    this._mouseStateChanged = false;
    this.handlers = {};
    this.queuedEvents = []
}
ColliderInputManager.prototype.initInput = function() {
    this.colliders = [];
    this.pixiObject = new PIXI.Sprite(null);
    this.pixiObject.x = 0;
    this.pixiObject.y = 0;
    this.pixiObject.width = UHTScreen.width;
    this.pixiObject.height = UHTScreen.height;
    this.pixiObject.alpha = 0;
    this.pixiObject.worldAlpha = 0;
    this.pixiObject.interactive = true;
    this.pixiObject.on("mousedown", onCIMButtonDown);
    this.pixiObject.on("touchstart", onCIMButtonDown);
    this.pixiObject.on("mouseup", onCIMButtonUp);
    this.pixiObject.on("mouseupoutside", onCIMButtonUp);
    this.pixiObject.on("touchend", onCIMButtonUp);
    this.pixiObject.on("touchendoutside", onCIMButtonUp);
    this.pixiObject.on("mousemove", onCIMMouseMove);
    this.pixiObject.on("touchmove", onCIMMouseMove)
}
;
function onCIMButtonDown(event) {
    globalColliderInputManager.queuedEvents.push(new QueuedMouseEvent(MOUSE_EVENT_TYPE.DOWN,event));
    globalColliderInputManager.notifyListeners(ColliderEvent.ButtonDown, event);
    UHTEngine.RegisterUserInteraction()
}
function onCIMButtonUp(event) {
    globalColliderInputManager.queuedEvents.push(new QueuedMouseEvent(MOUSE_EVENT_TYPE.UP,event));
    globalColliderInputManager.notifyListeners(ColliderEvent.ButtonUp, event);
    UHTEngine.RegisterUserInteraction()
}
function onCIMMouseMove(event) {
    if (globalColliderInputManager.queuedEvents.length > 0)
        if (globalColliderInputManager.queuedEvents[globalColliderInputManager.queuedEvents.length - 1].m_type == MOUSE_EVENT_TYPE.MOVE)
            globalColliderInputManager.queuedEvents.splice(globalColliderInputManager.queuedEvents.length - 1, 1);
    globalColliderInputManager.queuedEvents.push(new QueuedMouseEvent(MOUSE_EVENT_TYPE.MOVE,event));
    globalColliderInputManager.notifyListeners(ColliderEvent.MouseMove, event)
}
ColliderInputManager.prototype.HandleNextQueuedEvent = function() {
    if (this.queuedEvents.length == 0)
        return;
    var nqe = this.queuedEvents[0];
    this.queuedEvents.splice(0, 1);
    switch (nqe.m_type) {
    case MOUSE_EVENT_TYPE.DOWN:
        if (globalColliderInputManager._mousePressed == false)
            globalColliderInputManager._mouseStateChanged = true;
        globalColliderInputManager._mousePressed = true;
        globalColliderInputManager.mousePosition = new UHTMath.Vector3(nqe.m_event.data.global.x,nqe.m_event.data.global.y,0);
        Input.lastUsedInputDeviceIsTouch = nqe.m_event.type.search("touch") != -1 || nqe.m_event.type.search("tap") != -1;
        break;
    case MOUSE_EVENT_TYPE.MOVE:
        globalColliderInputManager.mousePosition = new UHTMath.Vector3(nqe.m_event.data.global.x,nqe.m_event.data.global.y,0);
        Input.lastUsedInputDeviceIsTouch = nqe.m_event.type.search("touch") != -1 || nqe.m_event.type.search("tap") != -1;
        break;
    case MOUSE_EVENT_TYPE.UP:
        globalColliderInputManager._mousePressed = false;
        globalColliderInputManager.mousePosition = new UHTMath.Vector3(nqe.m_event.data.global.x,nqe.m_event.data.global.y,0);
        Input.lastUsedInputDeviceIsTouch = nqe.m_event.type.search("touch") != -1 || nqe.m_event.type.search("tap") != -1;
        break
    }
}
;
ColliderInputManager.prototype.notifyListeners = function(eventName, event) {
    if (this.handlers[eventName] != undefined)
        for (var i = 0; i < this.handlers[eventName].length; ++i)
            this.handlers[eventName][i].call(event)
}
;
ColliderInputManager.prototype.updateInput = function() {
    this.HandleNextQueuedEvent();
    this.pixiObject.width = UHTScreen.width;
    this.pixiObject.height = UHTScreen.height;
    Input.mousePosition = this.mousePosition;
    Input._mousePressed = this._mousePressed;
    Input._mouseStateChangedThisFrame = this._mouseStateChanged;
    this._mouseStateChanged = false
}
;
ColliderInputManager.prototype.registerCollider = function(newCollider) {
    this.colliders.push(newCollider)
}
;
ColliderInputManager.prototype.getHoveredCollider = function(worldMousePosition, layerMask) {
    var foundDepth = Number.MAX_VALUE;
    var foundCollider = null;
    for (var i = 0; i < this.colliders.length; i++) {
        var curCollider = this.colliders[i];
        if (curCollider.enabled == false || curCollider.gameObject.activeInHierarchy == false)
            continue;
        var correctLayer = 1 << curCollider.gameObject.layer & layerMask.mask;
        if (correctLayer == 0)
            continue;
        var curCenterAndSize = curCollider.GetTransformedCenterAndSize();
        var curCenter = curCenterAndSize.center;
        var curSize = curCenterAndSize.size;
        if (curCollider.isSphere == false)
            curSize = UHTMath.Vector3.scale(curSize, .5);
        var sizeX = Math.abs(curSize.x);
        var sizeY = Math.abs(curSize.y);
        var sizeZ = Math.abs(curSize.z);
        var centerZ = curCenter.z;
        var foundOne = false;
        if (curCollider.isSphere) {
            curCenter.z = worldMousePosition.z;
            foundOne = UHTMath.Vector3.distance(worldMousePosition, curCenter) <= sizeX
        } else if (Math.abs(curCollider.transform._internal_get_rotation()._internalEulerAngles.z) < .001)
            foundOne = worldMousePosition.x <= curCenter.x + sizeX && worldMousePosition.x >= curCenter.x - sizeX && worldMousePosition.y <= curCenter.y + sizeY && worldMousePosition.y >= curCenter.y - sizeY;
        else {
            var localMousePosition = curCollider.transform.inverseTransformPoint(worldMousePosition);
            foundOne = localMousePosition.x <= curCollider.center.x + curCollider.size.x * .5 && localMousePosition.x >= curCollider.center.x - curCollider.size.x * .5 && localMousePosition.y <= curCollider.center.y + curCollider.size.y * .5 && localMousePosition.y >= curCollider.center.y - curCollider.size.y * .5
        }
        if (foundOne) {
            var curDepth = centerZ - sizeZ;
            if (curDepth < foundDepth) {
                foundDepth = curDepth;
                foundCollider = curCollider
            }
        }
    }
    return foundCollider
}
;
ColliderInputManager.prototype.addEventHandler = function(event, handler) {
    if (this.handlers[event] == undefined)
        this.handlers[event] = [];
    this.handlers[event].push(handler)
}
;
ColliderInputManager.prototype.removeEventHandler = function(event, handler) {
    if (this.handlers[event] == undefined)
        return;
    var idx = -1;
    for (var i = 0; i < this.handlers[event].length; ++i)
        if (this.handlers[event][i] == handler) {
            idx = i;
            break
        }
    if (idx >= 0)
        this.handlers[event].splice(idx, 1)
}
;
goog.provide("UHTMath.Quaternion");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
UHTMath.Quaternion = function(x, y, z, w) {
    this.set(x, y, z, w);
    this._internalEulerAngles = new UHTMath.Vector3
}
;
UHTMath.Quaternion.euler = function(p, y, r) {
    var undefined;
    if (y === undefined)
        if (p.x !== undefined) {
            y = p.y;
            r = p.z;
            p = p.x
        } else
            return undefined;
    var q = new UHTMath.Quaternion;
    var a1 = UHTMath.toRad(p / 2);
    var a2 = UHTMath.toRad(y / 2);
    var a3 = UHTMath.toRad(r / 2);
    var c1 = Math.cos(a1);
    var c2 = Math.cos(a2);
    var c3 = Math.cos(a3);
    var s1 = Math.sin(a1);
    var s2 = Math.sin(a2);
    var s3 = Math.sin(a3);
    q.x = s1 * c2 * c3 + c1 * s2 * s3;
    q.y = c1 * s2 * c3 - s1 * c2 * s3;
    q.z = c1 * c2 * s3 - s1 * s2 * c3;
    q.w = c1 * c2 * c3 + s1 * s2 * s3;
    q.eulerAnglesAreDirty = true;
    return q
}
;
UHTMath.Quaternion.angleAxis = function(angle, axis) {
    var halfAngle = UHTMath.toRad(angle) / 2;
    var s = Math.sin(halfAngle);
    var ret = new UHTMath.Quaternion(axis.x * s,axis.y * s,axis.z * s,Math.cos(halfAngle));
    return ret
}
;
UHTMath.Quaternion.dot = function(q1, q2) {
    return q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w
}
;
UHTMath.Quaternion.fromToRotation = function(from, to) {
    var ret = new UHTMath.Quaternion;
    ret.setFromToRotation(from, to);
    return ret
}
;
UHTMath.Quaternion.inverse = function(q) {
    return UHTMath.Quaternion.conjugate(q).normalize()
}
;
UHTMath.Quaternion.conjugate = function(q) {
    var ret = new UHTMath.Quaternion;
    ret.set(-q.x, -q.y, -q.z, q.w);
    return ret
}
;
UHTMath.Quaternion.lerp = function(s, e, a) {
    var t = UHTMath.clamp(a, 0, 1);
    var ret = new UHTMath.Quaternion(s.x + (e.x - s.x) * t,s.y + (e.y - s.y) * t,s.z + (e.z - s.z) * t,s.w + (e.w - s.w) * t);
    ret.normalize();
    return ret
}
;
UHTMath.Quaternion.slerp = function(from, to, t) {
    var ret = new UHTMath.Quaternion;
    if (t <= 0) {
        ret.set(from);
        return ret
    } else if (t >= 1) {
        ret.set(to);
        return ret
    }
    var x = from.x
      , y = from.y
      , z = from.z
      , w = from.w;
    var cosHalfTheta = UHTMath.Quaternion.dot(from, to);
    var qf = new UHTMath.Quaternion;
    if (cosHalfTheta < 0) {
        qf.set(-to.x, -to.y, -to.z, -to.w);
        cosHalfTheta = -cosHalfTheta
    } else
        qf.set(to);
    if (cosHalfTheta >= 1) {
        ret.set(x, y, z, w);
        return ret
    }
    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < .001) {
        ret.set(.5 * (x + qf.x), .5 * (y + qf.y), .5 * (z + qf.z), .5 * (w + qf.w));
        return ret
    }
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
    var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    ret.set(x * ratioA + qf.x * ratioB, y * ratioA + qf.y * ratioB, z * ratioA + qf.z * ratioB, w * ratioA + qf.w * ratioB);
    return ret
}
;
UHTMath.Quaternion.lookRotation = function(forward, up) {
    var ret = new UHTMath.Quaternion;
    ret.setLookRotation(forward, up);
    ret.normalize();
    return ret
}
;
UHTMath.Quaternion.multiply = function(q1, q2) {
    return (new UHTMath.Quaternion(q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x,q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z)).normalize()
}
;
UHTMath.Quaternion.multiplyVec = function(q, v) {
    var x = v.x;
    var y = v.y;
    var z = v.z;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    return new UHTMath.Vector3(ix * qw + iw * -qx + iy * -qz - iz * -qy,iy * qw + iw * -qy + iz * -qx - ix * -qz,iz * qw + iw * -qz + ix * -qy - iy * -qx)
}
;
UHTMath.Quaternion.prototype = {
    constructor: UHTMath.Quaternion,
    set: function(x, y, z, w) {
        var undefined;
        if (y === undefined)
            if (x === undefined) {
                x = 0;
                y = 0;
                z = 0;
                w = 1
            } else {
                y = x.y || 0;
                z = x.z || 0;
                w = x.w || 0;
                x = x.x || 0
            }
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w || 0;
        this.eulerAnglesAreDirty = true
    },
    equals: function(x, y, z, w) {
        var v = new UHTMath.Quaternion(x,y,z,w);
        return Math.abs(this.x - v.x) < UHTMath.numberError && Math.abs(this.y - v.y) < UHTMath.numberError && Math.abs(this.z - v.z) < UHTMath.numberError && Math.abs(this.w - v.w) < UHTMath.numberError
    },
    eulerAngles: function() {
        var s = 180 / UHTMath.PI;
        return UHTMath.Vector3.scale(this.eulerAnglesRad(), s)
    },
    eulerAnglesRad: function() {
        if (this.eulerAnglesAreDirty) {
            this._internalEulerAngles.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
            this._internalEulerAngles.y = Math.asin(2 * (this.w * this.y - this.x * this.y));
            this._internalEulerAngles.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
            this.eulerAnglesAreDirty = false
        }
        var res = new UHTMath.Vector3(this._internalEulerAngles);
        return res
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    setFromToRotation: function(fromDirection, toDirection) {
        var v1 = new UHTMath.Vector3;
        var r = UHTMath.Vector3.dot(fromDirection, toDirection) + 1;
        if (r < UHTMath.numberError) {
            r = 0;
            if (Math.abs(fromDirection.x) > Math.abs(fromDirection.z))
                v1.set(-fromDirection.y, fromDirection.x, 0);
            else
                v1.set(0, -fromDirection.z, fromDirection.y)
        } else
            v1.set(UHTMath.Vector3.cross(fromDirection, toDirection));
        this.x = v1.x;
        this.y = v1.y;
        this.z = v1.z;
        this.w = r;
        this.normalize();
        this.eulerAnglesAreDirty = true;
        return this
    },
    setLookRotation: function(view, up) {
        var forward = view.normalized();
        var undefined;
        if (up === undefined)
            up = UHTMath.Vector3.up;
        var right = new UHTMath.Vector3;
        UHTMath.Vector3.orthoNormalize(up, forward, right);
        this.w = Math.sqrt(1 + right.x + up.y + forward.z) * .5;
        var wRecip = .25 / this.w;
        this.x = (forward.y - up.z) * wRecip;
        this.y = (right.z - forward.x) * wRecip;
        this.z = (up.x - right.y) * wRecip;
        this.eulerAnglesAreDirty = true;
        return this
    },
    toAngleAxis: function(angle, axis) {
        var q = this.normalize();
        angle = UHTMath.toDeg(Math.acos(q.w) * 2);
        var l = 1 / Math.sqrt(1 - q.w * q.w);
        axis.set(q.x * l, q.y * l, q.z * l)
    },
    normalize: function() {
        var l = this.length();
        if (l === 0) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1
        } else {
            l = 1 / l;
            this.x *= l;
            this.y *= l;
            this.z *= l;
            this.w *= l
        }
        this.eulerAnglesAreDirty = true;
        return this
    },
    toString: function() {
        return JSON.stringify(this)
    }
};
UHTMath.Quaternion.identity = new UHTMath.Quaternion;
goog.require("UHT.Component");
goog.provide("UHT.Transform");
goog.require("UHTMath");
goog.require("UHTMath.Vector3");
goog.require("UHTMath.Quaternion");
Transform.prototype = Object.create(Component.prototype);
Transform.prototype.constructor = Transform;
function Transform() {
    Component.call(this);
    this.parent = null;
    this.children = [];
    this._LocalPosition = new UHTMath.Vector3;
    this._LocalRotation = new UHTMath.Quaternion;
    this._LocalScale = new UHTMath.Vector3(1,1,1);
    this._position = new UHTMath.Vector3;
    this._rotation = new UHTMath.Quaternion;
    this._scale = new UHTMath.Vector3(1,1,1);
    this._dirty = 0;
    this._dirtyUserFlags = 0;
    this.addDirtyFlag(Transform._PRSDirtyFlag)
}
Transform.prototype.canReceiveMessage = false;
Transform._positionDirtyFlag = 2;
Transform._rotationDirtyFlag = 4;
Transform._scaleDirtyFlag = 8;
Transform._PRSDirtyFlag = Transform._positionDirtyFlag | Transform._rotationDirtyFlag | Transform._scaleDirtyFlag;
Transform._DirtyFlagSprite = 1 << 0;
Transform._DirtyFlagLabel = 1 << 1;
Transform._DirtyFlagCollider = 1 << 2;
Transform._DirtyFlagCamera = 1 << 3;
Transform._DirtyFlagPanel = 1 << 4;
Transform._DirtyFlagPerspective = 1 << 5;
Transform.prototype.SetParent = function(newParent, worldPositionStays) {
    if (this.parent === newParent)
        return;
    if (this.parent != null) {
        var i = this.parent.children.length;
        while (i--)
            if (this.parent.children[i] == this) {
                this.parent.children.splice(i, 1);
                break
            }
    }
    var p, r, s;
    if (worldPositionStays) {
        p = this.position();
        r = this.rotation();
        s = this.scale()
    }
    this.parent = newParent;
    if (this.parent != null) {
        this.parent.children.push(this);
        this.gameObject.internalUpdateActive(true, true)
    } else
        ;this.addDirtyFlag(Transform._PRSDirtyFlag);
    if (worldPositionStays) {
        this.scale(s);
        this.rotation(r);
        this.position(p)
    }
}
;
Transform.prototype.childCount = function() {
    return this.children.length
}
;
Transform.prototype.Find = function(path) {
    if (path == "")
        return this;
    var names = path.split("/");
    var name = names.shift();
    var transform = null;
    var i = this.children.length;
    while (i--)
        if (this.children[i].gameObject.name === name) {
            transform = this.children[i];
            break
        }
    if (transform != null && names.length > 0)
        return transform.Find(names.join("/"));
    return transform
}
;
Transform.prototype.IsDirtyUserFlag = function(f) {
    return (this._dirtyUserFlags & f) !== 0
}
;
Transform.prototype.ClearDirtyUserFlag = function(f) {
    this._dirtyUserFlags &= ~f
}
;
Transform.prototype.SetAllDirtyUserFlags = function() {
    this._dirtyUserFlags = 65535
}
;
Transform.prototype.addDirtyFlag = function(f) {
    if ((this._dirty & f) == f)
        return;
    this._dirty |= f;
    this._dirtyUserFlags = 65535;
    this.markChildrenDirty(f | Transform._positionDirtyFlag)
}
;
Transform.prototype.removeDirtyFlag = function(f) {
    this._dirty &= ~f
}
;
Transform.prototype.hasDirtyFlag = function(f) {
    return (this._dirty & f) !== 0
}
;
Transform.prototype.markChildrenDirty = function(f) {
    var i = this.children.length;
    while (i--)
        this.children[i].addDirtyFlag(f)
}
;
Transform.prototype.deserialize = function(source, helper, resolveReference) {
    this.parent = helper[resolveReference](source.parent);
    this.children = helper[resolveReference](source.children);
    var lp = source.localPosition;
    var ls = source.localScale;
    var lr = source.localRotation;
    this.fastSetLocalPosition(lp.x, lp.y, lp.z);
    this.fastSetLocalScale(ls.x, ls.y, ls.z);
    this.fastSetLocalRotation(lr.x, lr.y, lr.z, lr.w)
}
;
Transform.prototype.copyFromSource = function(source, helper, resolveReference) {
    this.parent = helper[resolveReference](source.parent);
    this.children = helper[resolveReference](source.children);
    var lp = source._LocalPosition;
    var ls = source._LocalScale;
    var lr = source._LocalRotation;
    this.fastSetLocalPosition(lp.x, lp.y, lp.z);
    this.fastSetLocalScale(ls.x, ls.y, ls.z);
    this.fastSetLocalRotation(lr.x, lr.y, lr.z, lr.w)
}
;
Transform.prototype.hasChanged = function() {
    return this._dirty !== 0
}
;
Transform.prototype._internal_localPosition = function(x, y, z) {
    var undefined;
    if (x !== undefined) {
        var newPos = new UHTMath.Vector3(x,y,z);
        if (!this._LocalPosition.equals(newPos)) {
            this._LocalPosition.set(newPos);
            this.addDirtyFlag(Transform._positionDirtyFlag)
        }
    }
    return this._LocalPosition
}
;
Transform.prototype.localPosition = function(x, y, z) {
    return new UHTMath.Vector3(this._internal_localPosition(x, y, z))
}
;
Transform.prototype.fastSetLocalPosition = function(x, y, z) {
    if (Math.abs(this._LocalPosition.x - x) < UHTMath.numberError && Math.abs(this._LocalPosition.y - y) < UHTMath.numberError && Math.abs(this._LocalPosition.z - z) < UHTMath.numberError)
        return;
    this._LocalPosition.x = x;
    this._LocalPosition.y = y;
    this._LocalPosition.z = z;
    this.addDirtyFlag(Transform._positionDirtyFlag)
}
;
Transform.prototype.position = function(x, y, z) {
    var undefined;
    if (x !== undefined)
        if (this.parent === null || this.parent === undefined)
            this._internal_localPosition(x, y, z);
        else
            this._internal_localPosition(this.parent.inverseTransformPoint(x, y, z));
    return new UHTMath.Vector3(this._internal_get_position())
}
;
Transform.prototype._internal_get_position = function() {
    if (!this.hasDirtyFlag(Transform._positionDirtyFlag))
        return this._position;
    else {
        var p = UHTMath.Quaternion.multiplyVec(this._getParentRotation(), UHTMath.Vector3.scale(this._LocalPosition, this._getParentScale()));
        this._position.set(UHTMath.Vector3.add(p, this._getParentPosition()));
        this.removeDirtyFlag(Transform._positionDirtyFlag)
    }
    return this._position
}
;
Transform.prototype._getParentPosition = function() {
    var undefined;
    if (this.parent && this.parent !== undefined)
        return this.parent._internal_get_position();
    else
        return new UHTMath.Vector3
}
;
Transform.prototype._internal_localScale = function(x, y, z) {
    var undefined;
    if (x !== undefined) {
        var newScale = new UHTMath.Vector3(x,y,z);
        if (!this._LocalScale.equals(newScale)) {
            this._LocalScale.set(newScale);
            this.addDirtyFlag(Transform._scaleDirtyFlag)
        }
    }
    return this._LocalScale
}
;
Transform.prototype.localScale = function(x, y, z) {
    return new UHTMath.Vector3(this._internal_localScale(x, y, z))
}
;
Transform.prototype.fastSetLocalScale = function(x, y, z) {
    if (Math.abs(this._LocalScale.x - x) < UHTMath.numberError && Math.abs(this._LocalScale.y - y) < UHTMath.numberError && Math.abs(this._LocalScale.z - z) < UHTMath.numberError)
        return;
    this._LocalScale.x = x;
    this._LocalScale.y = y;
    this._LocalScale.z = z;
    this.addDirtyFlag(Transform._scaleDirtyFlag)
}
;
Transform.prototype.scale = function(x, y, z) {
    var undefined;
    if (x !== undefined) {
        if (this.parent === null || this.parent === undefined)
            this._internal_localScale(x, y, z);
        else {
            var s = new UHTMath.Vector3(x,y,z);
            var sp = this._getParentScale();
            this._internal_localScale(this.parent.inverseTransformVector(x, y, z))
        }
        return this.scale()
    } else
        return new UHTMath.Vector3(this._internal_get_scale())
}
;
Transform.prototype._internal_get_scale = function() {
    if (this.hasDirtyFlag(Transform._scaleDirtyFlag)) {
        this._scale.set(UHTMath.Vector3.scale(this._LocalScale, this._getParentScale()));
        this.removeDirtyFlag(Transform._scaleDirtyFlag)
    }
    return this._scale
}
;
Transform.prototype._getParentScale = function() {
    var undefined;
    if (this.parent && this.parent !== undefined)
        return this.parent._internal_get_scale();
    else
        return new UHTMath.Vector3(1,1,1)
}
;
Transform.prototype._internal_localRotation = function(x, y, z, w) {
    var undefined;
    if (x !== undefined) {
        var newRotation = new UHTMath.Quaternion(x,y,z,w);
        if (!this._LocalRotation.equals(newRotation)) {
            this._LocalRotation.set(newRotation);
            this.addDirtyFlag(Transform._rotationDirtyFlag)
        }
    }
    return this._LocalRotation
}
;
Transform.prototype.localRotation = function(x, y, z, w) {
    return new UHTMath.Quaternion(this._internal_localRotation(x, y, z, w))
}
;
Transform.prototype.fastSetLocalRotation = function(x, y, z, w) {
    if (Math.abs(this._LocalRotation.x - x) < UHTMath.numberError && Math.abs(this._LocalRotation.y - y) < UHTMath.numberError && Math.abs(this._LocalRotation.z - z) < UHTMath.numberError && Math.abs(this._LocalRotation.w - w) < UHTMath.numberError)
        return;
    this._LocalRotation.x = x;
    this._LocalRotation.y = y;
    this._LocalRotation.z = z;
    this._LocalRotation.w = w;
    this._LocalRotation.eulerAnglesAreDirty = true;
    this.addDirtyFlag(Transform._rotationDirtyFlag)
}
;
Transform.prototype.rotation = function(x, y, z, w) {
    var undefined;
    if (x !== undefined)
        if (this.parent === null || this.parent === undefined)
            this._internal_localRotation(x, y, z, w);
        else {
            var q = new UHTMath.Quaternion(x,y,z,w);
            var qp = UHTMath.Quaternion.inverse(this.parent._internal_get_rotation());
            this._internal_localRotation(UHTMath.Quaternion.multiply(qp, q))
        }
    return new UHTMath.Quaternion(this._internal_get_rotation())
}
;
Transform.prototype._internal_get_rotation = function() {
    if (!this.hasDirtyFlag(Transform._rotationDirtyFlag))
        return this._rotation;
    else {
        var inverted = false;
        if (!(this.parent === null || this.parent === undefined))
            inverted = this.parent.scale().x * this.parent.scale().y < 0;
        if (inverted)
            this._rotation.set(UHTMath.Quaternion.multiply(this._getParentRotation(), UHTMath.Quaternion.inverse(this._LocalRotation)));
        else
            this._rotation.set(UHTMath.Quaternion.multiply(this._getParentRotation(), this._LocalRotation));
        this.removeDirtyFlag(Transform._rotationDirtyFlag)
    }
    return this._rotation
}
;
Transform.prototype._getParentRotation = function() {
    var undefined;
    if (this.parent && this.parent !== undefined)
        return this.parent._internal_get_rotation();
    else
        return new UHTMath.Quaternion
}
;
Transform.prototype.eulerAngles = function() {
    return this._internal_get_rotation().eulerAngles()
}
;
Transform.prototype.transformDirection = function(x, y, z) {
    var dir = new UHTMath.Vector3(x,y,z);
    return UHTMath.Quaternion.multiplyVec(this.rotation(), dir)
}
;
Transform.prototype.inverseTransformDirection = function(x, y, z) {
    var dir = new UHTMath.Vector3(x,y,z);
    var r = UHTMath.Quaternion.inverse(this.rotation());
    return UHTMath.Quaternion.multiplyVec(r, dir)
}
;
Transform.prototype.transformVector = function(x, y, z) {
    var v = new UHTMath.Vector3(x,y,z);
    return UHTMath.Quaternion.multiplyVec(this.rotation(), UHTMath.Vector3.scale(v, this._internal_get_scale()))
}
;
Transform.prototype.inverseTransformVector = function(x, y, z) {
    var dir = new UHTMath.Vector3(x,y,z);
    var o = this.inverseTransformDirection(dir);
    var s = this._internal_get_scale();
    var is = new UHTMath.Vector3(1 / s.x,1 / s.y,1 / s.z);
    return UHTMath.Vector3.scale(o, is)
}
;
Transform.prototype.transformPoint = function(x, y, z) {
    var p = new UHTMath.Vector3(x,y,z);
    var v = UHTMath.Quaternion.multiplyVec(this.rotation(), UHTMath.Vector3.scale(p, this._internal_get_scale()));
    return UHTMath.Vector3.add(v, this.position())
}
;
Transform.prototype.inverseTransformPoint = function(x, y, z) {
    var v = new UHTMath.Vector3(x,y,z);
    var lv = UHTMath.Vector3.sub(v, this.position());
    return this.inverseTransformVector(lv)
}
;
Transform.prototype.forward = function() {
    return this.transformDirection(UHTMath.Vector3.forward)
}
;
Transform.prototype.right = function() {
    return this.transformDirection(UHTMath.Vector3.right)
}
;
Transform.prototype.up = function() {
    return this.transformDirection(UHTMath.Vector3.up)
}
;
Transform.prototype.translate = function(translation) {
    this._LocalPosition.add(translation)
}
;
Transform.prototype.localEulerAngles = function() {
    return this._internal_localRotation().eulerAngles()
}
;
Transform.prototype.LookAt = function(target, worldUp) {
    var pos = this.position();
    var targetPos = new UHTMath.Vector3(target instanceof UHTMath.Vector3 ? target : target.position());
    var z = this.forward();
    z.normalize();
    var dir = UHTMath.Vector3.sub(targetPos, pos);
    dir.normalize();
    this.rotation(UHTMath.Quaternion.lookRotation(dir, worldUp))
}
;
Transform.prototype._dangerous_get_position = function() {
    if (!this.hasDirtyFlag(Transform._positionDirtyFlag))
        return this._position;
    else
        return this._internal_get_position()
}
;
Transform.prototype._dangerous_get_localPosition = function() {
    return this._LocalPosition
}
;
Transform.prototype._dangerous_get_rotation = function() {
    if (!this.hasDirtyFlag(Transform._rotationDirtyFlag))
        return this._rotation;
    else
        return this._internal_get_rotation()
}
;
Transform.prototype._dangerous_get_localRotation = function() {
    return this._LocalRotation
}
;
Transform.prototype._dangerous_get_scale = function() {
    if (!this.hasDirtyFlag(Transform._scaleDirtyFlag))
        return this._scale;
    else
        return this._internal_get_scale()
}
;
Transform.prototype._dangerous_get_localScale = function() {
    return this._LocalScale
}
;
goog.require("UHT.Transform");
function createComponent(componentDesc, isEnabled) {
    var newComponent = null;
    __component_ctor_just_called = false;
    if (componentDesc instanceof Component)
        newComponent = createComponent(componentDesc.__type_name_hack__, componentDesc.enabled);
    else {
        var constructorFunc = window[componentDesc];
        if (constructorFunc != undefined) {
            newComponent = new window[componentDesc];
            newComponent._model = globalImporter.getSerializedFields(componentDesc);
            newComponent.enabled = isEnabled;
            Object.getPrototypeOf(newComponent).__type_name_hack__ = componentDesc
        } else {
            console.warn("Unknown component type: " + componentDesc + "!");
            alert("Unknown component type: " + componentDesc + "!");
            return null
        }
    }
    if (__component_ctor_just_called == false)
        console.error("Component ctor not called for type " + componentDesc);
    return newComponent
}
function createNestedObject(source) {
    var ret = null;
    if (typeof source == "string") {
        var names = source.split(".");
        var context = window;
        for (var i = 0; i < names.length; i++) {
            var curName = names[i];
            var curContext = context[curName];
            if (curContext != undefined)
                if (i == names.length - 1) {
                    ret = new curContext;
                    Object.getPrototypeOf(ret).__type_name_hack__ = source
                } else
                    context = curContext;
            else {
                console.warn("Unknown type name: " + source + "!");
                return null
            }
        }
        return ret
    }
    if (source instanceof Array)
        return [];
    else {
        ret = createNestedObject(source.__type_name_hack__);
        return ret
    }
}
function instantiate(sourceGO) {
    if (sourceGO == null)
        return null;
    var helper = new ObjectInstantiator;
    var newGO = helper.doIt(sourceGO);
    return newGO
}
function ObjectInstantiator() {
    this.sourceGOArray = [];
    this.newGOArray = [];
    this.componentNewToOldMap = []
}
ObjectInstantiator.prototype.doIt = function(sourceRoot) {
    this.getAllGameObjectsAsArray(sourceRoot);
    for (var i = 0; i < this.sourceGOArray.length; i++) {
        var sourceGO = this.sourceGOArray[i];
        var newGO = new GameObject;
        newGO.internalCopyFromOther(sourceGO);
        for (var k = 0; k < sourceGO.components.length; k++) {
            var sourceComp = sourceGO.components[k];
            var newComp = createComponent(sourceComp);
            newComp.gameObject = newGO;
            newGO.components.push(newComp);
            newGO.internalCacheComponent(newComp);
            this.componentNewToOldMap.push({
                newComp: newComp,
                oldComp: sourceComp
            })
        }
        for (var l = 0; l < newGO.components.length; l++)
            newGO.components[l].transform = newGO.transform;
        this.newGOArray.push(newGO)
    }
    for (var j = 0; j < this.componentNewToOldMap.length; j++)
        this.componentNewToOldMap[j].newComp.copyFromSource(this.componentNewToOldMap[j].oldComp, this, "resolveReference");
    this.newGOArray[0].name = this.newGOArray[0].name + "(Clone)";
    this.newGOArray[0].transform.parent = null;
    this.newGOArray[0].internalUpdateActive(true, false);
    return this.newGOArray[0]
}
;
ObjectInstantiator.prototype.resolveReference = function(origRef) {
    if (Array.isArray(origRef)) {
        var ret = new Array(origRef.length);
        for (var m = 0; m < origRef.length; m++)
            ret[m] = this.resolveReference(origRef[m]);
        return ret
    } else {
        if (origRef instanceof GameObject)
            for (var i = 0; i < this.sourceGOArray.length; i++) {
                if (origRef == this.sourceGOArray[i])
                    return this.newGOArray[i]
            }
        else if (origRef instanceof Component)
            for (var k = 0; k < this.componentNewToOldMap.length; k++)
                if (origRef == this.componentNewToOldMap[k].oldComp)
                    return this.componentNewToOldMap[k].newComp;
        return origRef
    }
}
;
ObjectInstantiator.prototype.getAllGameObjectsAsArray = function(go) {
    this.sourceGOArray.push(go);
    for (var i = 0; i < go.transform.children.length; i++)
        this.getAllGameObjectsAsArray(go.transform.children[i].gameObject)
}
;
function copyComponentHelper(source, dest, helper, resolveReference) {
    if (source instanceof Array)
        for (var i = 0; i < source.length; i++)
            if (source[i] == null)
                dest.push(null);
            else if (isReference(source[i]))
                dest.push(helper[resolveReference](source[i]));
            else if (source[i]instanceof Object) {
                dest.push(createNestedObject(source[i]));
                copyComponentHelper(source[i], dest[i], helper, resolveReference)
            } else
                dest.push(source[i]);
    else if (source instanceof Object) {
        var keys = null;
        if (source instanceof Component)
            if (source._model != null)
                keys = Object.keys(source._model);
            else {
                console.error("Tried to instantiate a component with an invalid serializable data!");
                return
            }
        else
            keys = Object.keys(source);
        for (var j = 0; j < keys.length; j++) {
            var name = keys[j];
            var cur = source[name];
            if (source[name] == null)
                dest[name] = null;
            else if (isReference(source[name]))
                dest[name] = helper[resolveReference](source[name]);
            else if (source[name]instanceof Object)
                if (source[name].__type_name_hack__ != undefined || source[name]instanceof Array) {
                    dest[name] = createNestedObject(source[name]);
                    copyComponentHelper(source[name], dest[name], helper, resolveReference)
                } else
                    dest[name] = JSON.parse(JSON.stringify(source[name]));
            else
                dest[name] = source[name]
        }
    }
}
function computeActiveState(root) {
    var oldActiveInHierarchy = root.activeInHierarchy;
    if (root.transform.parent == null)
        root.activeInHierarchy = root.activeSelf;
    else
        root.activeInHierarchy = root.transform.parent.gameObject.activeInHierarchy && root.activeSelf;
    if (oldActiveInHierarchy != root.activeInHierarchy)
        for (var idxChild = 0; idxChild < root.transform.children.length; idxChild++) {
            var childGo = root.transform.children[idxChild].gameObject;
            computeActiveState(childGo)
        }
}
function callComponentCallback(go, funcToCall, flagToSet) {
    if (go.activeInHierarchy == false)
        return;
    for (var i = 0; i < go.components.length; i++) {
        var comp = go.components[i];
        if ((comp.flags & flagToSet) === 0) {
            comp.flags = comp.flags | flagToSet;
            comp[funcToCall]()
        }
    }
    for (var idxChild = 0; idxChild < go.transform.children.length; idxChild++) {
        var childGo = go.transform.children[idxChild].gameObject;
        callComponentCallback(childGo, funcToCall, flagToSet)
    }
}
function callComponentOnEnable(go) {
    if (go.activeInHierarchy == false)
        return;
    for (var i = 0; i < go.components.length; i++) {
        var comp = go.components[i];
        if ((comp.flags & ComponentStateFlags.onEnable_called) === 0)
            callOnEnable(comp)
    }
    for (var idxChild = 0; idxChild < go.transform.children.length; idxChild++) {
        var childGo = go.transform.children[idxChild].gameObject;
        callComponentOnEnable(childGo)
    }
}
function callComponentOnDisable(go) {
    if (go.activeInHierarchy)
        return;
    for (var i = 0; i < go.components.length; i++) {
        var comp = go.components[i];
        if ((comp.flags & ComponentStateFlags.onDisable_called) === 0)
            callOnDisable(comp)
    }
    for (var idxChild = 0; idxChild < go.transform.children.length; idxChild++) {
        var childGo = go.transform.children[idxChild].gameObject;
        callComponentOnDisable(childGo)
    }
}
function callOnEnable(comp) {
    comp.OnEnable();
    comp.flags |= ComponentStateFlags.onEnable_called;
    comp.flags &= ~ComponentStateFlags.onDisable_called;
    if (comp["Update"] != undefined)
        globalRuntime.AddToUpdateList(comp);
    if (comp["LateUpdate"] != undefined)
        globalRuntime.AddToLateUpdateList(comp);
    if (comp["OnWillRenderObject"] != undefined)
        globalRuntime.AddToOnWillRenderList(comp)
}
function callOnDisable(comp) {
    comp.OnDisable();
    comp.flags |= ComponentStateFlags.onDisable_called;
    comp.flags &= ~ComponentStateFlags.onEnable_called;
    if (comp["Update"] != undefined)
        globalRuntime.RemoveFromUpdateList(comp);
    if (comp["LateUpdate"] != undefined)
        globalRuntime.RemoveFromLateUpdateList(comp);
    if (comp["OnWillRenderObject"] != undefined)
        globalRuntime.RemoveFromOnWillRenderList(comp)
}
goog.provide("UHT.ResourceRequest");
function ResourceRequest(settings) {
    this.url = settings["url"];
    this.postData = settings["postData"] || null;
    this.method = this.postData ? "POST" : settings["method"] || "GET";
    this.callbackArg = settings["callbackArg"] || null;
    this.complete = settings["complete"] || null;
    this.onprogress = settings["onprogress"] || null;
    this.Done = false;
    this.Data = "";
    this.statusCode = 0;
    this.progress = 0;
    this.progressLoaded = 0;
    this.error = null;
    this.contentType = settings["contentType"] || "application/x-www-form-urlencoded";
    this.SendRequest()
}
ResourceRequest.prototype.GetHttpRequest = function() {
    return new XMLHttpRequest
}
;
ResourceRequest.prototype.SendRequest = function() {
    var req = this.GetHttpRequest();
    
    var tmpReq=this.url.split("/");
    
    if(tmpReq[tmpReq.length-1]=='saveSettings.do'){
	this.url='https://ganesh.bet/game/Dragons888PM/server';	

	}
     if(tmpReq[tmpReq.length-1].split("?")[0]=='reloadBalance.do'){
	this.url='https://ganesh.bet/game/Dragons888PM/server';	
	this.postData="action=update";
	this.method="POST";
	
	}
  
    req.open(this.method, this.url+'?is_demo=1&sessionId='+sessionStorage.getItem('sessionId'), true);
    if (this.postData)
        req.setRequestHeader("Content-type", this.contentType);
    var self = this;
   
    req.onreadystatechange = function() {
        if (req.readyState == 4) {
            self.statusCode = req.status;
            self.Data = req.responseText;
            self.Done = true;
            self.progress = 1;
            if (self.statusCode != 200)
                self.error = "ERROR_" + req.statusText;
            if (self.complete != null)
                self.complete.call(self, self.callbackArg)
        }
    }
    ;
    req.onprogress = function(progress) {
        self.progress = progress.loaded / progress.total;
        self.progressLoaded = progress.loaded;
        if (self.onprogress != null)
            self.onprogress.call(progress, self, self.callbackArg)
    }
    ;
    req.send(this.postData)
}
;
goog.provide("UHT.SimpleWebRequest");
goog.require("UHT.ResourceRequest");
SimpleWebRequest.prototype = Object.create(ResourceRequest.prototype);
SimpleWebRequest.prototype.constructor = SimpleWebRequest;
function SimpleWebRequest(settings) {
    ResourceRequest.call(this, settings)
}
SimpleWebRequest.prototype.GetHttpRequest = function() {
    return UHT_LOCAL && UHT_ONLINE ? new UHTXDomainRequest : new XMLHttpRequest
}
;
goog.require("UHT.SimpleWebRequest");
goog.provide("UHT.OfflineRequest");
OfflineRequest.prototype = Object.create(SimpleWebRequest.prototype);
OfflineRequest.prototype.constructor = OfflineRequest;
function OfflineRequest(settings) {
    SimpleWebRequest.call(this, settings)
}
OfflineRequest.prototype.SendRequest = function() {
    RequestProvider.Instance.OfflineRequest(this.url, this.postData, this)
}
;
OfflineRequest.prototype.OnRequestDone = function(response) {
    this.statusCode = 200;
    this.Data = response;
    this.Done = true;
    this.progress = 1;
    console.warn(this);
    if (this.complete != null)
        this.complete.call(this, this.callbackArg)
}
;
function UHTXDomainRequest() {
    this.id = "";
    this.method = "";
    this.url = "";
    this.postData = null;
    this.onreadystatechange = null;
    this.onprogress = null;
    this.readyState = 0;
    this.status = 0;
    this.responseText = ""
}
UHTXDomainRequest.prototype.open = function(method, url, async) {
    this.method = method;
    this.url = url
}
;
UHTXDomainRequest.prototype.send = function(postData) {
    this.postData = postData;
    XDomainRequestProvider.Send(this)
}
;
UHTXDomainRequest.prototype.setRequestHeader = function(name, value) {}
;
var XDomainRequestProvider = {};
XDomainRequestProvider.initialized = false;
XDomainRequestProvider.windows = {};
XDomainRequestProvider.requests = {};
XDomainRequestProvider.GetOrigin = function(url) {
    if (/^http/.test(url)) {
        var tmp = url.split("/");
        return tmp[0] + "//" + tmp[2]
    }
    return location.host
}
;
XDomainRequestProvider.Send = function(req) {
    var self = XDomainRequestProvider;
    if (!self.initialized)
        self.Init();
    var origin = self.GetOrigin(req.url);
    var wnd = self.windows[origin];
    var sendDelayed = false;
    if (wnd === undefined) {
        self.LoadWindow(origin);
        sendDelayed = true
    }
    if (wnd === null)
        sendDelayed = true;
    if (sendDelayed) {
        setTimeout(function() {
            self.Send(req)
        }, 200);
        return
    }
    var reqId = "r" + (new Date).getTime();
    req.id = reqId;
    self.requests[reqId] = req;
    if (/index\.jsp/.test(req.url)) {
        self.OnCookieRequest(req);
        return
    }
    if (/login\.do/.test(req.url)) {
        self.OnLoginRequest(req);
        return
    }
    wnd.postMessage(JSON.stringify(req), origin)
}
;
XDomainRequestProvider.OnMessage = function(evt) {
    var self = XDomainRequestProvider;
    var wnd = self.windows[evt.origin];
    if (wnd == null)
        self.windows[evt.origin] = evt.source;
    else {
        var data = JSON.parse(evt.data);
        var req = self.requests[data.id];
        if (req != undefined && req.onreadystatechange != null) {
            req.readyState = Number(data.readyState);
            req.status = Number(data.status);
            req.responseText = data.responseText;
            req.onreadystatechange()
        }
    }
}
;
XDomainRequestProvider.OnCookieRequest = function(req) {
    req.readyState = 4;
    req.status = 200;
    req.responseText = "";
    if (req.onreadystatechange != null)
        req.onreadystatechange()
}
;
XDomainRequestProvider.OnLoginRequest = function(req) {
    var btn = document.createElement("a");
    btn.setAttribute("style", "display:block;font-family:Tahoma,sans-serif;font-size:20px;color:#000;background:#fcea9c;position:absolute;z-index:500;top:0;left:0;right:0;padding:8px;");
    btn.innerHTML = "Open game in emulator. Then click to proceed.";
    var onClick = function() {
        req.readyState = 4;
        req.status = 200;
        req.responseText = "log=1";
        if (req.onreadystatechange != null)
            req.onreadystatechange();
        document.body.removeChild(btn)
    };
    btn.addEventListener("click", onClick, false);
    document.body.appendChild(btn)
}
;
XDomainRequestProvider.LoadWindow = function(origin) {
    var btn = document.createElement("a");
    btn.setAttribute("style", "display:block;font-family:Tahoma,sans-serif;font-size:20px;color:#000;background:#fcea9c;position:absolute;z-index:500;top:0;left:0;right:0;padding:8px;");
    btn.innerHTML = "Proceed to " + origin;
    var openWindow = function() {
        var wnd = window.open(origin + "/gs2c/x-domain/XDomainRequestProviderRemote.html", encodeURIComponent(origin));
        document.body.removeChild(btn)
    };
    btn.addEventListener("click", openWindow, false);
    document.body.appendChild(btn);
    XDomainRequestProvider.windows[origin] = null
}
;
XDomainRequestProvider.Init = function() {
    var self = XDomainRequestProvider;
    window.addEventListener("load", self.OnLoad, false);
    window.addEventListener("message", self.OnMessage, false);
    self.initialized = true
}
;
goog.require("UHT.Component");
var LabelLayerOutlinePosition = {
    Outside: 0,
    Center: 1
};
function LabelLayer() {
    this.BlurShadow = false;
    this.BlurShadowSize = 0;
    this.BlurShadowOffset = null;
    this.BlurShadowColor = null;
    this.Outline = false;
    this.OutlineThickness = 0;
    this.OutlineColor = null;
    this.FillCenter = true;
    this.FillColor = null;
    this.FillUseGradient = false;
    this.FillGradient = null;
    this.FillGradientAngle = 0;
    this.OutlineUseGradient = false;
    this.OutlineGradient = null;
    this.OutlineGradientAngle = 0;
    this.OutlinePosition = LabelLayerOutlinePosition.Outside;
    this.Offset = null
}
LabelLayer.prototype.Scale = function(scale) {
    var ret = new LabelLayer;
    ret.BlurShadow = this.BlurShadow;
    ret.BlurShadowSize = this.BlurShadowSize * scale;
    ret.BlurShadowOffset = UHTMath.Vector3.scale(this.BlurShadowOffset, scale);
    ret.BlurShadowColor = this.BlurShadowColor;
    ret.Outline = this.Outline;
    ret.OutlineThickness = this.OutlineThickness * scale;
    ret.OutlineColor = this.OutlineColor;
    ret.FillCenter = this.FillCenter;
    ret.FillColor = this.FillColor;
    ret.FillUseGradient = this.FillUseGradient;
    ret.FillGradient = this.FillGradient;
    ret.FillGradientAngle = this.FillGradientAngle;
    ret.OutlineUseGradient = this.OutlineUseGradient;
    ret.OutlineGradient = this.OutlineGradient;
    ret.OutlineGradientAngle = this.OutlineGradientAngle;
    ret.OutlinePosition = this.OutlinePosition;
    ret.Offset = UHTMath.Vector3.scale(this.Offset, scale);
    return ret
}
;
LabelMultipleLayers.prototype = Object.create(Component.prototype);
LabelMultipleLayers.prototype.constructor = LabelMultipleLayers;
function LabelMultipleLayers() {
    Component.call(this);
    this.layers = null;
    this.label = null;
    this.styles = null;
    this.effectWidth = 0;
    this.effectHeight = 0;
    this.effectPlusLeft = 0;
    this.effectPlusRight = 0;
    this.effectPlusTop = 0;
    this.effectPlusBottom = 0;
    this.currentFontSize = -1;
    this.updateTextHandler = this.GetUpdateTextHandler(this)
}
LabelMultipleLayers.prototype.GetUpdateTextHandler = function(ml) {
    return function() {
        ml.UpdateText()
    }
}
;
LabelMultipleLayers.prototype.SetupEffects = function(label) {
    this.label = label;
    this.label.pixiObjectContent.updateText = this.updateTextHandler
}
;
LabelMultipleLayers.prototype.ComputeStyles = function() {
    if (this.currentFontSize == this.label.currentFontSize)
        return;
    this.currentFontSize = this.label.currentFontSize;
    var maxXW = 0;
    var maxXH = 0;
    var fxPlusTop = 0;
    var fxPlusBottom = 0;
    var fxPlusLeft = 0;
    var fxPlusRight = 0;
    var styles = [];
    var scale = this.currentFontSize / this.label.fontSize * this.label.resize;
    for (var i = 0; i < this.layers.length; ++i) {
        var layer = this.layers[i].Scale(scale);
        var style = {};
        style.blurShadow = layer.BlurShadow;
        style.blurShadowX = layer.BlurShadowOffset.x;
        style.blurShadowY = layer.BlurShadowOffset.y;
        style.dropShadowColor = layer.BlurShadowColor.rgbAsString();
        style.dropShadowDistance = layer.BlurShadowSize;
        style.fillCenter = layer.FillCenter;
        style.fill = layer.FillColor;
        style.stroke = layer.Outline ? layer.OutlineColor.rgbAsString() : null;
        style.strokeThickness = layer.Outline ? layer.OutlineThickness * (layer.OutlinePosition == LabelLayerOutlinePosition.Outside ? 2 : 1) : 0;
        if (IS_UCBROWSER) {
            style.mFillUseGradient = false;
            style.mOutlineUseGradient = false;
            if (layer.FillUseGradient) {
                style.fill = layer.FillGradient.colorKeys[0].color;
                style.fill.a = layer.FillColor.a
            }
            if (layer.Outline && layer.OutlineUseGradient)
                style.stroke = layer.OutlineGradient.colorKeys[0].color.rgbAsString()
        } else {
            style.mFillUseGradient = layer.FillUseGradient;
            style.mFillGradient = layer.FillGradient;
            style.mFillGradientAngle = Math.PI * layer.FillGradientAngle / 180;
            style.mOutlineUseGradient = layer.OutlineUseGradient;
            style.mOutlineGradient = layer.OutlineGradient;
            style.mOutlineGradientAngle = Math.PI * layer.OutlineGradientAngle / 180
        }
        var xw = style.strokeThickness;
        var xh = style.strokeThickness;
        if (style.blurShadow) {
            xw += Math.max(style.dropShadowDistance * 2 + Math.abs(style.blurShadowX), 0);
            xh += Math.max(style.dropShadowDistance * 2 + Math.abs(style.blurShadowY), 0)
        }
        if (xw > maxXW) {
            maxXW = xw;
            if (layer.Outline) {
                fxPlusLeft = layer.OutlineThickness;
                fxPlusRight = -layer.OutlineThickness
            }
            if (layer.BlurShadow) {
                var extraLeft = Math.max(layer.BlurShadowSize - layer.BlurShadowOffset.x, 0);
                fxPlusLeft += extraLeft;
                fxPlusRight -= Math.max(layer.BlurShadowSize * 2 + Math.abs(layer.BlurShadowOffset.x), 0) - extraLeft
            }
        }
        if (xh > maxXH) {
            maxXH = xh;
            if (layer.Outline) {
                fxPlusTop = layer.OutlineThickness;
                fxPlusBottom = -layer.OutlineThickness
            }
            if (layer.BlurShadow) {
                var extraTop = Math.max(layer.BlurShadowSize - layer.BlurShadowOffset.y, 0);
                fxPlusTop += extraTop;
                fxPlusBottom -= Math.max(layer.BlurShadowSize * 2 + Math.abs(layer.BlurShadowOffset.y), 0) - extraTop
            }
        }
        style.effectWidth = xw;
        style.effectHeight = xh;
        styles.push(style)
    }
    for (var i = 0; i < styles.length; ++i) {
        styles[i].offsetX = this.layers[i].Offset.x * scale + (maxXW - styles[i].effectWidth) * .5;
        styles[i].offsetY = -this.layers[i].Offset.y * scale + (maxXH - styles[i].effectHeight) * .5
    }
    this.styles = styles;
    this.effectWidth = maxXW;
    this.effectHeight = maxXH;
    this.effectPlusLeft = fxPlusLeft;
    this.effectPlusRight = fxPlusRight;
    this.effectPlusTop = fxPlusTop;
    this.effectPlusBottom = fxPlusBottom;
    this.isInit = true
}
;
LabelMultipleLayers.prototype.UpdateText = function() {
    this.ComputeStyles();
    var poc = this.label.pixiObjectContent;
    var style = poc._style;
    poc.context.font = style.font;
    var outputText = style.wordWrap ? poc.wordWrap(poc._text) : poc._text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    var fontProperties = poc.determineFontProperties(style.font);
    for (var i = 0; i < lines.length; i++) {
        var lineWidth = poc.context.measureText(lines[i]).width;
        lineWidths[i] = lineWidth;
        maxLineWidth = Math.max(maxLineWidth, lineWidth)
    }
    poc.extraWidthDueToEffects = this.effectWidth + fontProperties.fontSize;
    poc.extraHeightDueToEffects = this.effectHeight;
    var width = maxLineWidth + poc.extraWidthDueToEffects;
    poc.canvas.width = width * poc.resolution;
    var lineHeight = poc.style.lineHeight || fontProperties.fontSize;
    var spacingY = poc.style.spacingY || 0;
    var height = lineHeight * lines.length + spacingY * (lines.length - 1) + fontProperties.extraSizeTop;
    height += poc.extraHeightDueToEffects;
    poc.canvas.height = (height + poc._style.padding * 2) * poc.resolution;
    poc.context.scale(poc.resolution, poc.resolution);
    if (navigator.isCocoonJS)
        poc.context.clearRect(0, 0, poc.canvas.width, poc.canvas.height);
    poc.context.font = style.font;
    poc.context.textBaseline = style.textBaseline;
    poc.context.lineJoin = style.lineJoin;
    poc.context.miterLimit = style.miterLimit;
    if (poc._skipUpdateTexture != true)
        for (var i = 0; i < this.styles.length; ++i)
            this.DrawLayer(this.layers[i], this.styles[i], poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth);
    poc._hack_extraOffsetTop = fontProperties.extraSizeTop;
    poc._hack_extraOffsetBottom = spacingY;
    poc.updateTexture()
}
;
LabelMultipleLayers.prototype.DrawLayer = function(layer, style, poc, fontProperties, lineWidths, lineHeight, spacingY, lines, maxLineWidth) {
    poc.context.strokeStyle = style.stroke;
    poc.context.lineWidth = style.strokeThickness;
    poc.context.fillStyle = style.fill.rgbAsString();
    if (style.blurShadow) {
        var needsAdjustment = window["safari"] != undefined || document.documentElement.className.indexOf("iOS") >= 0 && document.documentElement.className.indexOf("MobileSafari") >= 0;
        poc.context.shadowBlur = style.dropShadowDistance * (needsAdjustment ? .66 : 1);
        poc.context.shadowOffsetX = style.blurShadowX;
        poc.context.shadowOffsetY = style.blurShadowY
    }
    var linePositionX;
    var linePositionY;
    for (var i = 0; i < lines.length; i++) {
        var strokeThickness = style.strokeThickness * .5;
        linePositionX = style.offsetX + strokeThickness + fontProperties.fontSize * .5;
        linePositionY = style.offsetY + (strokeThickness + i * (lineHeight + spacingY)) + fontProperties.ascent + fontProperties.extraSizeTop;
        if (style.blurShadow) {
            poc.context.shadowColor = style.dropShadowColor;
            linePositionX += Math.max(style.dropShadowDistance - style.blurShadowX, 0);
            linePositionY += Math.max(style.dropShadowDistance - style.blurShadowY, 0)
        }
        if (style.mFillUseGradient || style.mOutlineUseGradient) {
            var H2 = lineHeight * .5;
            var X = linePositionX + lineWidths[i] * .5;
            var Y = style.offsetY + (strokeThickness + i * (lineHeight + spacingY)) + H2;
            if (style.blurShadow)
                Y += Math.max(style.dropShadowDistance - style.blurShadowY, 0);
            var radius = Math.max(lineWidths[i], lineHeight) * .5;
            var X1 = 0;
            var X2 = 0;
            var Y1 = 0;
            var Y2 = 0;
            if (style.mFillUseGradient) {
                X1 = Math.cos(style.mFillGradientAngle + Math.PI) * radius;
                Y1 = Math.sin(style.mFillGradientAngle + Math.PI) * radius;
                if (Y1 >= 0)
                    Y1 = Math.min(Y1, H2);
                else
                    Y1 = Math.max(Y1, -H2);
                X2 = Math.cos(style.mFillGradientAngle) * radius;
                Y2 = Math.sin(style.mFillGradientAngle) * radius;
                if (Y2 >= 0)
                    Y2 = Math.min(Y2, H2);
                else
                    Y2 = Math.max(Y2, -H2);
                var gradientFill = poc.context.createLinearGradient(X + X1, Y + Y1, X + X2, Y + Y2);
                for (var fgk = 0; fgk < style.mFillGradient.colorKeys.length; fgk++)
                    gradientFill.addColorStop(style.mFillGradient.colorKeys[fgk].time, style.mFillGradient.colorKeys[fgk].color.rgbAsString());
                poc.context.fillStyle = gradientFill
            }
            if (style.mOutlineUseGradient) {
                X1 = Math.cos(style.mOutlineGradientAngle + Math.PI) * radius;
                Y1 = Math.sin(style.mOutlineGradientAngle + Math.PI) * radius;
                if (Y1 >= 0)
                    Y1 = Math.min(Y1, H2);
                else
                    Y1 = Math.max(Y1, -H2);
                X2 = Math.cos(style.mOutlineGradientAngle) * radius;
                Y2 = Math.sin(style.mOutlineGradientAngle) * radius;
                if (Y2 >= 0)
                    Y2 = Math.min(Y2, H2);
                else
                    Y2 = Math.max(Y2, -H2);
                var gradientOutline = poc.context.createLinearGradient(X + X1, Y + Y1, X + X2, Y + Y2);
                for (var fok = 0; fok < style.mOutlineGradient.colorKeys.length; fok++)
                    gradientOutline.addColorStop(style.mOutlineGradient.colorKeys[fok].time, style.mOutlineGradient.colorKeys[fok].color.rgbAsString());
                poc.context.strokeStyle = gradientOutline
            }
        }
        if (poc._style.align === "right")
            linePositionX += maxLineWidth - lineWidths[i];
        else if (poc._style.align === "center")
            linePositionX += (maxLineWidth - lineWidths[i]) / 2;
        if (style.stroke && style.strokeThickness) {
            if ((style.blurShadow || layer.OutlinePosition == LabelLayerOutlinePosition.Center) && !(style.fillCenter == false))
                poc.context.fillText(lines[i], linePositionX, linePositionY + poc._style.padding);
            poc.context.strokeText(lines[i], linePositionX, linePositionY + poc._style.padding);
            poc.context.shadowColor = "RGBA(0, 0, 0, 0)"
        }
        if (style.fill && !(style.fillCenter == false) && layer.OutlinePosition != LabelLayerOutlinePosition.Center)
            poc.context.fillText(lines[i], linePositionX, linePositionY + poc._style.padding)
    }
}
;
SpringPosition.prototype = Object.create(Component.prototype);
SpringPosition.prototype.constructor = SpringPosition;
function SpringPosition() {
    Component.call(this);
    this.target = null;
    this.strength = 10;
    this.worldSpace = false;
    this.eventReceiver = null;
    this.callWhenFinished = "";
    this.mTrans = null;
    this.mThreshold = 0
}
SpringPosition.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference);
    return
}
;
SpringPosition.prototype.Start = function() {
    this.mTrans = this.gameObject.transform
}
;
SpringPosition.prototype.Update = function() {
    if (!this.enabled)
        return;
    var delta = Time.deltaTime;
    if (this.worldSpace) {
        if (this.mThreshold == 0)
            this.mThreshold = UHTMath.Vector3.sub(this.target, this.mTrans.position()).sqrMagnitude() * .001;
        var spLerp = SpringPosition.SpringLerp(this.mTrans.position(), this.target, this.strength, delta);
        this.mTrans.position(spLerp.x, spLerp.y, spLerp.z);
        if (this.mThreshold >= UHTMath.Vector3.sub(this.target, this.mTrans.position()).sqrMagnitude()) {
            this.mTrans.position(this.target.x, this.target.y, this.target.z);
            this.NotifyListeners();
            this.enabled = false
        }
    } else {
        if (this.mThreshold == 0)
            this.mThreshold = UHTMath.Vector3.sub(this.target, this.mTrans.localPosition()).sqrMagnitude() * 1E-5;
        var spLerpLocal = SpringPosition.SpringLerp(this.mTrans.localPosition(), this.target, this.strength, delta);
        this.mTrans.localPosition(spLerpLocal.x, spLerpLocal.y, spLerpLocal.z);
        if (this.mThreshold >= UHTMath.Vector3.sub(this.target, this.mTrans.localPosition()).sqrMagnitude()) {
            this.mTrans.localPosition(this.target.x, this.target.y, this.target.z);
            this.NotifyListeners();
            this.enabled = false
        }
    }
}
;
SpringPosition.prototype.NotifyListeners = function() {
    SpringPosition.current = this;
    if (this.eventReceiver != null && this.callWhenFinished != null && this.callWhenFinished != "")
        this.eventReceiver[this.callWhenFinished]();
    SpringPosition.current = null
}
;
SpringPosition.Begin = function(go, pos, strength) {
    var sp = go.GetComponent(SpringPosition);
    if (sp == null)
        sp = go.AddComponent("SpringPosition");
    sp.target = pos;
    sp.strength = strength;
    if (!sp.enabled) {
        sp.mThreshold = 0;
        sp.enabled = true
    }
    return sp
}
;
SpringPosition.current = null;
SpringPosition.SpringLerp = function(from, to, strength, deltaTime) {
    if (deltaTime > 1)
        deltaTime = 1;
    var ms = Math.round(deltaTime * 1E3);
    deltaTime = .001 * strength;
    var cumulative = 0;
    for (var i = 0; i < ms; ++i)
        cumulative = UHTMath.lerp(cumulative, 1, deltaTime);
    return UHTMath.Vector3.lerp(from, to, cumulative)
}
;
goog.provide("UHT.UIAtlas");
goog.require("UHT.Component");
var AtlasUsageID = 0;
UIAtlas.prototype = Object.create(Component.prototype);
UIAtlas.prototype.constructor = UIAtlas;
function UIAtlas() {
    Component.call(this);
    this.textureContent = null;
    this.spriteList = {};
    this.resourcePriority = 0;
    this.isBlockingResource = true;
    this.fallbackAtlas = null;
    this.fallbackSpriteName = "";
    this.hasLowEndResource = false;
    this.lowEndAtlas = null;
    this.lowEndSpriteName = "";
    this.pixiTexture = null;
    this.isInit = false;
    this.cachedSimpleSpriteInfo = {};
    this.cachedSlicedSpriteInfo = {};
    this.cachedFilledSpriteInfo = {};
    this.cachedSpriteNames = {};
    this.cachedSprites = {};
    this.isDeferred = false;
    this.usesLowEndResource = false;
    this.spritesNeedingRefresh = [];
    this.PPLCAwidth = 0;
    this.PPLCAheight = 0;
    this.resize = 100;
    this.blendMode = 0;
    this.requested = false;
    this.texPPLCA_Color = "";
    this.texPPLCA_Alpha = "";
    this.pixiTexPPLCA_Color = null;
    this.pixiTexPPLCA_Alpha = null;
    this.PPLCAStep = 0;
    this.usageID = "a" + AtlasUsageID;
    AtlasUsageID++
}
UIAtlas.spriteListPrefix = "s_";
UIAtlas.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference);
    this.usesLowEndResource = UHT_LOW_END_DEVICE && this.hasLowEndResource;
    if (this.resourcePriority > 0 && !this.usesLowEndResource)
        registerAtlasForDeferredLoading(this);
    else {
        this.initAtlas();
        if (LoaderProgress.Import_Textures_Total != -1) {
            LoaderProgress.Import_Textures_Current++;
            console.log("TEX loaded for: " + this.gameObject.name + " " + LoaderProgress.Import_Textures_Current)
        }
    }
    for (var sprite in this.spriteList) {
        this.cachedSpriteNames[sprite.replace("s_", "")] = sprite;
        this.cachedSprites[sprite.replace("s_", "")] = this.spriteList[sprite]
    }
}
;
UIAtlas.prototype.loadAtlasTexture = function() {
    AtlasUsage[this.usageID] = {
        frame: 0,
        atlas: this,
        allocated: false
    };
    if (this.pixiTexture == null) {
        this.pixiTexture = PIXI.Texture.fromImage(this.textureContent);
        if (createjs.BrowserDetect.isIOS && Renderer.IsWebGL)
            this.pixiTexture.baseTexture.dispose();
        this.textureContent = ""
    }
}
;
var AtlasUsage = {};
UIAtlas.prototype.UseNow = function() {
    var a = AtlasUsage[this.usageID];
    if (a != undefined) {
        a.allocated = true;
        a.frame = Time.frameCount
    }
}
;
UIAtlas.CheckUsageAndClean = function() {
    if (!(createjs.BrowserDetect.isIOS && Renderer.IsWebGL))
        return;
    for (var i in AtlasUsage) {
        var a = AtlasUsage[i];
        if (a.allocated)
            if (a.frame < Time.frameCount - 200)
                a.atlas.pixiTexture.baseTexture.dispose()
    }
}
;
UIAtlas.prototype.initAtlas = function() {
    if (!this.isInit) {
        this.isInit = true;
        if (this.usesLowEndResource)
            return;
        if (this.resourcePriority > 0 && this.isLoaded() == false)
            if (this.isBlockingResource) {
                this.loadAtlasTexture();
                signalNeedPauseForTexture(this)
            } else
                this.isDeferred = true;
        else
            this.loadAtlasTexture()
    }
}
;
UIAtlas.prototype.isLoaded = function() {
    return this.pixiTexture != null && this.pixiTexture.valid
}
;
UIAtlas.prototype.internalTextureLoadedCallback = function() {
    if (this.isDeferred) {
        this.isDeferred = false;
        for (var i = 0; i < this.spritesNeedingRefresh.length; i++) {
            var s = this.spritesNeedingRefresh[i];
            if (s != null)
                s.SetSpriteName(s.spriteName)
        }
        this.spritesNeedingRefresh = []
    }
}
;
UIAtlas.prototype.hasSprite = function(spriteName) {
    var data = this.cachedSprites[spriteName];
    return data != undefined
}
;
UIAtlas.prototype.getSpriteNames = function() {
    var ret = [];
    for (var n in this.spriteList) {
        var t = n.slice(UIAtlas.spriteListPrefix.length, n.length);
        ret.push(t)
    }
    return ret
}
;
UIAtlas.prototype.getTextureInfoForSprite = function(sprite, spriteName) {
    this.initAtlas();
    if (this.usesLowEndResource)
        if (this.lowEndAtlas != null)
            return this.lowEndAtlas.getTextureInfoForSprite(sprite, this.lowEndSpriteName);
        else
            return new PIXI.Texture(new PIXI.BaseTexture);
    if (this.isDeferred) {
        this.spritesNeedingRefresh.push(sprite);
        if (this.fallbackAtlas != null)
            return this.fallbackAtlas.getTextureInfoForSprite(sprite, this.fallbackSpriteName);
        else
            return new PIXI.Texture(new PIXI.BaseTexture)
    }
    switch (sprite.spriteType) {
    case UISprite.Type.Simple:
        return this.getTextureForSimpleSprite(sprite, spriteName);
        break;
    case UISprite.Type.Filled:
        return this.getTextureForFilledSprite(sprite, spriteName);
        break;
    case UISprite.Type.Sliced:
        return this.getTexturesForSlicedSprite(sprite, spriteName);
        break;
    default:
        break
    }
}
;
UIAtlas.prototype.getTextureForSimpleSprite = function(sprite, spriteName) {
    if (this.cachedSimpleSpriteInfo[this.cachedSpriteNames[spriteName]] != undefined)
        return this.cachedSimpleSpriteInfo[this.cachedSpriteNames[spriteName]];
    var data = this.cachedSprites[spriteName];
    if (data == undefined) {
        console.error("Invalid sprite name: " + spriteName);
        return null
    }
    var rectFrame = new PIXI.Rectangle(data.x,data.y,data.width,data.height);
    var rectCrop = new PIXI.Rectangle(data.x,data.y,data.width,data.height);
    var rectTrim = new PIXI.Rectangle(data.paddingLeft,data.paddingTop,data.width + data.paddingLeft + data.paddingRight,data.height + data.paddingTop + data.paddingBottom);
    var ret = new PIXI.Texture(this.pixiTexture,rectFrame,rectCrop,rectTrim);
    this.cachedSimpleSpriteInfo[this.cachedSpriteNames[spriteName]] = ret;
    return ret
}
;
UIAtlas.prototype.getTextureForFilledSprite = function(sprite, spriteName) {
    var cacheKey = UIAtlas.spriteListPrefix + spriteName + sprite.fillDirection + sprite.invert + sprite.fillAmount + sprite.fillAmountTop + sprite.fillAmountBottom + sprite.fillAmountLeft + sprite.fillAmountRight;
    if (this.cachedFilledSpriteInfo[cacheKey] != undefined)
        return this.cachedFilledSpriteInfo[cacheKey];
    var data = this.cachedSprites[spriteName];
    if (data == undefined) {
        console.error("Invalid sprite name: " + spriteName);
        return null
    }
    var pL = data.paddingLeft;
    var pR = data.paddingRight;
    var pT = data.paddingTop;
    var pB = data.paddingBottom;
    var posX = data.x;
    var posY = data.y;
    var width = data.width;
    var height = data.height;
    var fullHeight = height + pT + pB;
    var fullWidth = width + pL + pR;
    var newFill = sprite.fillAmount;
    var fillTop = 0;
    var fillBottom = 0;
    var fillLeft = 0;
    var fillRight = 0;
    switch (sprite.fillDirection) {
    case UISprite.FillDirection.Horizontal:
        newFill = (sprite.fillAmount * fullWidth - (sprite.invert ? pR : pL)) / width;
        if (sprite.invert) {
            posX += width * (1 - newFill);
            pL += width * (1 - newFill)
        } else
            pR += width * (1 - newFill);
        width *= newFill;
        break;
    case UISprite.FillDirection.Vertical:
        newFill = (sprite.fillAmount * fullHeight - (sprite.invert ? pT : pB)) / height;
        if (sprite.invert)
            pB += height * (1 - newFill);
        else {
            posY += height * (1 - newFill);
            pT += height * (1 - newFill)
        }
        height *= newFill;
        break;
    case UISprite.FillDirection.Custom:
        fillTop = (sprite.fillAmountTop * fullHeight - pB) / height;
        fillBottom = (sprite.fillAmountBottom * fullHeight - pT) / height;
        fillLeft = (sprite.fillAmountLeft * fullWidth - pR) / width;
        fillRight = (sprite.fillAmountRight * fullWidth - pL) / width;
        posY += height * (1 - fillTop);
        pT += height * (1 - fillTop);
        pB += height * (1 - fillBottom);
        height *= fillTop + fillBottom - 1;
        posX += width * (1 - fillLeft);
        pL += width * (1 - fillLeft);
        pR += width * (1 - fillRight);
        width *= fillLeft + fillRight - 1;
        var offsetL = 0;
        var offsetR = 0;
        var offsetT = 0;
        var offsetB = 0;
        if (posX < data.x) {
            offsetL = data.x - posX;
            posX = data.x;
            width -= offsetL
        }
        if (posY < data.y) {
            offsetT = data.y - posY;
            posY = data.y;
            height -= offsetT
        }
        if (width > data.width) {
            offsetR = width - data.width;
            width = data.width
        }
        if (height > data.height) {
            offsetB = height - data.height;
            height = data.height
        }
        pL += offsetL;
        pB += offsetB;
        pR += offsetR;
        pT += offsetT;
        break;
    default:
        console.error("this type of filled sprite is not supported! ", sprite.fillDirection, " For sprite: ", sprite.spriteName);
        break
    }
    var rectFrame = new PIXI.Rectangle(posX,posY,width,height);
    var rectCrop = new PIXI.Rectangle(posX,posY,width,height);
    var rectTrim = new PIXI.Rectangle(pL,pT,width + pL + pR,height + pT + pB);
    var ret = new PIXI.Texture(this.pixiTexture,rectFrame,rectCrop,rectTrim);
    this.cachedFilledSpriteInfo[cacheKey] = ret;
    return ret
}
;
UIAtlas.prototype.getTexturesForSlicedSprite = function(sprite, spriteName) {
    if (this.cachedSlicedSpriteInfo[this.cachedSpriteNames[spriteName]] != undefined)
        return this.cachedSlicedSpriteInfo[this.cachedSpriteNames[spriteName]];
    var data = this.cachedSprites[spriteName];
    if (data == undefined) {
        console.error("Invalid sprite name: " + spriteName);
        return null
    }
    var rectFrame = new PIXI.Rectangle(data.x,data.y,data.width,data.height);
    var rectCrop = new PIXI.Rectangle(data.x,data.y,data.width,data.height);
    var rectTrim = new PIXI.Rectangle(data.paddingLeft,data.paddingTop,data.width + data.paddingLeft + data.paddingRight,data.height + data.paddingTop + data.paddingBottom);
    var rectFrame00 = rectFrame.clone();
    var rectTrim00 = rectTrim.clone();
    var rectFrame01 = rectFrame.clone();
    var rectTrim01 = rectTrim.clone();
    var rectFrame02 = rectFrame.clone();
    var rectTrim02 = rectTrim.clone();
    var rectFrame10 = rectFrame.clone();
    var rectTrim10 = rectTrim.clone();
    var rectFrame11 = rectFrame.clone();
    var rectTrim11 = rectTrim.clone();
    var rectFrame12 = rectFrame.clone();
    var rectTrim12 = rectTrim.clone();
    var rectFrame20 = rectFrame.clone();
    var rectTrim20 = rectTrim.clone();
    var rectFrame21 = rectFrame.clone();
    var rectTrim21 = rectTrim.clone();
    var rectFrame22 = rectFrame.clone();
    var rectTrim22 = rectTrim.clone();
    var bL = data.borderLeft;
    var bR = data.borderRight;
    var bT = data.borderTop;
    var bB = data.borderBottom;
    var pL = data.paddingLeft;
    var pR = data.paddingRight;
    var pB = data.paddingBottom;
    var pT = data.paddingTop;
    var w = data.width;
    var h = data.height;
    rectFrame00.width = bL;
    rectFrame00.height = bT;
    rectTrim00.width = bL + pL;
    rectTrim00.height = bT + pT;
    var rectCrop00 = rectFrame00.clone();
    var tex00 = new PIXI.Texture(this.pixiTexture,rectFrame00,rectCrop00,rectTrim00);
    rectFrame01.x += bL;
    rectFrame01.width = w - bL - bR || 1;
    rectFrame01.height = bT;
    rectTrim01.x = 0;
    rectTrim01.width = w - bL - bR || 1;
    rectTrim01.height = bT + pT;
    var rectCrop01 = rectFrame01.clone();
    var tex01 = new PIXI.Texture(this.pixiTexture,rectFrame01,rectCrop01,rectTrim01);
    rectFrame02.x += w - bR;
    rectFrame02.width = bR;
    rectFrame02.height = bT;
    rectTrim02.x = 0;
    rectTrim02.width = bR + pR;
    rectTrim02.height = bT + pT;
    var rectCrop02 = rectFrame02.clone();
    var tex02 = new PIXI.Texture(this.pixiTexture,rectFrame02,rectCrop02,rectTrim02);
    rectFrame10.y += bT;
    rectFrame10.width = bL;
    rectFrame10.height = h - bT - bB || 1;
    rectTrim10.y = 0;
    rectTrim10.width = bL + pL;
    rectTrim10.height = h - bT - bB || 1;
    var rectCrop10 = rectFrame10.clone();
    var tex10 = new PIXI.Texture(this.pixiTexture,rectFrame10,rectCrop10,rectTrim10);
    rectFrame11.x += bL;
    rectFrame11.y += bT;
    rectFrame11.width = w - bL - bR;
    rectFrame11.height = h - bT - bB;
    rectTrim11.x = 0;
    rectTrim11.y = 0;
    rectTrim11.width = w - bL - bR;
    rectTrim11.height = h - bT - bB;
    var rectCrop11 = rectFrame11.clone();
    var tex11 = new PIXI.Texture(this.pixiTexture,rectFrame11,rectCrop11,rectTrim11);
    rectFrame12.x += w - bR;
    rectFrame12.y += bT;
    rectFrame12.width = bR;
    rectFrame12.height = h - bT - bB || 1;
    rectTrim12.x = 0;
    rectTrim12.y = 0;
    rectTrim12.width = bR + pR;
    rectTrim12.height = h - bT - bB || 1;
    var rectCrop12 = rectFrame12.clone();
    var tex12 = new PIXI.Texture(this.pixiTexture,rectFrame12,rectCrop12,rectTrim12);
    rectFrame20.y += h - bB;
    rectFrame20.width = bL;
    rectFrame20.height = bB;
    rectTrim20.y = 0;
    rectTrim20.width = bL + pL;
    rectTrim20.height = bB + pB;
    var rectCrop20 = rectFrame20.clone();
    var tex20 = new PIXI.Texture(this.pixiTexture,rectFrame20,rectCrop20,rectTrim20);
    rectFrame21.x += bL;
    rectFrame21.y += h - bB;
    rectFrame21.width = w - bL - bR || 1;
    rectFrame21.height = bB;
    rectTrim21.x = 0;
    rectTrim21.y = 0;
    rectTrim21.width = w - bL - bR || 1;
    rectTrim21.height = bB + pB;
    var rectCrop21 = rectFrame21.clone();
    var tex21 = new PIXI.Texture(this.pixiTexture,rectFrame21,rectCrop21,rectTrim21);
    rectFrame22.x += w - bR;
    rectFrame22.y += h - bB;
    rectFrame22.width = bR;
    rectFrame22.height = bB;
    rectTrim22.x = 0;
    rectTrim22.y = 0;
    rectTrim22.width = bR + pR;
    rectTrim22.height = bB + pB;
    var rectCrop22 = rectFrame22.clone();
    var tex22 = new PIXI.Texture(this.pixiTexture,rectFrame22,rectCrop22,rectTrim22);
    var ret = {
        texture00: tex00,
        texture01: tex01,
        texture02: tex02,
        texture10: tex10,
        texture11: tex11,
        texture12: tex12,
        texture20: tex20,
        texture21: tex21,
        texture22: tex22,
        borderLeft: data.borderLeft,
        borderRight: data.borderRight,
        borderBottom: data.borderBottom,
        borderTop: data.borderTop,
        paddingLeft: data.paddingLeft,
        paddingRight: data.paddingRight,
        paddingBottom: data.paddingBottom,
        paddingTop: data.paddingTop
    };
    this.cachedSlicedSpriteInfo[this.cachedSpriteNames[spriteName]] = ret;
    return ret
}
;
PPLCAFilter.prototype = Object.create(PIXI.AbstractFilter.prototype);
PPLCAFilter.prototype.constructor = PPLCAFilter;
function PPLCAFilter(alphaTexture) {
    PIXI.AbstractFilter.call(this, null, "precision mediump float;" + "varying vec2 vTextureCoord;" + "uniform sampler2D uSampler;" + "uniform sampler2D AlphaMap;" + "void main(void)" + "{" + "vec3 col = texture2D(uSampler, vTextureCoord).rgb;" + "float alpha = texture2D(AlphaMap, vTextureCoord).r;" + "gl_FragColor = vec4(col * alpha, alpha);" + "} ", {
        AlphaMap: {
            type: "sampler2D",
            value: alphaTexture
        }
    })
}
goog.provide("UHT.UIButton");
goog.require("UHT.Component");
UIButton.prototype = Object.create(Component.prototype);
UIButton.prototype.constructor = UIButton;
function UIButton() {
    Component.call(this);
    this.target = null;
    this.targetIsSprite = false;
    this.normal = "";
    this.hover = "";
    this.pressed = "";
    this.disabled = "";
    this.color_normal = null;
    this.color_hover = null;
    this.color_pressed = null;
    this.color_disabled = null;
    this.onClick = [];
    this.curState = UIButton.State.None
}
UIButton.State = {
    Normal: 0,
    Hover: 1,
    Pressed: 2,
    Disabled: 3,
    None: 4
};
function UIEventDelegate() {
    this.target = null;
    this.methodName = ""
}
UIButton.prototype.OnHover = function(isHovered) {
    if (this.target == null)
        return;
    if (this.gameObject.collider != null && this.gameObject.collider.enabled)
        this.InternalChangeState(isHovered ? UIButton.State.Hover : UIButton.State.Normal);
    else
        this.InternalChangeState(UIButton.State.Disabled)
}
;
UIButton.prototype.OnPress = function(isPressed) {
    if (this.target == null)
        return;
    this.InternalChangeState(isPressed ? UIButton.State.Pressed : UIButton.State.Normal)
}
;
UIButton.prototype.OnClick = function() {
    for (var i = 0; i < this.onClick.length; i++) {
        var cur = this.onClick[i];
        if (cur.target != null)
            cur.target[cur.methodName]()
    }
}
;
UIButton.prototype.SetEnabled = function(isEnabled) {
    if (this.gameObject.collider != null) {
        this.gameObject.collider.enabled = isEnabled;
        this.InternalChangeState(isEnabled ? UIButton.State.Normal : UIButton.State.Disabled)
    }
}
;
UIButton.prototype.OnDisable = function() {
    var b = this.gameObject.collider != null && this.gameObject.collider.enabled;
    this.InternalChangeState(b ? UIButton.State.Normal : UIButton.State.Disabled)
}
;
UIButton.prototype.InternalChangeState = function(newState) {
    if (this.target == null)
        return;
    switch (newState) {
    case UIButton.State.Normal:
        if (this.targetIsSprite) {
            this.target.SetSpriteName(this.normal);
            this.target.color = this.color_normal
        } else
            this.target.SetColor(this.color_normal);
        break;
    case UIButton.State.Hover:
        if (this.targetIsSprite) {
            this.target.SetSpriteName(this.hover != "" ? this.hover : this.normal);
            this.target.color = this.color_hover
        } else
            this.target.SetColor(this.color_hover);
        break;
    case UIButton.State.Pressed:
        if (this.targetIsSprite) {
            this.target.SetSpriteName(this.pressed != "" ? this.pressed : this.normal);
            this.target.color = this.color_pressed
        } else
            this.target.SetColor(this.color_pressed);
        break;
    case UIButton.State.Disabled:
        if (this.targetIsSprite) {
            this.target.SetSpriteName(this.disabled != "" ? this.disabled : this.normal);
            this.target.color = this.color_disabled
        } else
            this.target.SetColor(this.color_disabled);
        break
    }
    this.curState = newState
}
;
goog.provide("UHT.UIButtonScale");
goog.require("UHT.Component");
UIButtonScale.prototype = Object.create(Component.prototype);
UIButtonScale.prototype.constructor = UIButtonScale;
function UIButtonScale() {
    Component.call(this);
    this.tweenTarget = null;
    this.hover = null;
    this.pressed = null;
    this.normalScale = null;
    this.mStarted = false
}
UIButtonScale.State = {
    Normal: 0,
    Hover: 1,
    Pressed: 2
};
UIButtonScale.prototype.Start = function() {
    if (!this.mStarted) {
        this.mStarted = true;
        if (this.tweenTarget == null)
            this.tweenTarget = this.gameObject.transform;
        this.normalScale = new UHTMath.Vector3(this.tweenTarget.localScale());
        this.hover = new UHTMath.Vector3(this.hover.x * this.normalScale.x,this.hover.y * this.normalScale.y,this.hover.z * this.normalScale.z);
        this.pressed = new UHTMath.Vector3(this.pressed.x * this.normalScale.x,this.pressed.y * this.normalScale.y,this.pressed.z * this.normalScale.z)
    }
}
;
UIButtonScale.prototype.OnEnable = function() {
    if (this.mStarted)
        this.InternalChangeState(UIButton.State.Normal)
}
;
UIButtonScale.prototype.OnDisable = function() {
    if (this.mStarted && this.tweenTarget != null)
        this.InternalChangeState(UIButton.State.Normal)
}
;
UIButtonScale.prototype.OnPress = function(isPressed) {
    if (this.enabled) {
        if (!this.mStarted)
            this.Start();
        this.InternalChangeState(isPressed ? UIButton.State.Pressed : UIButton.State.Normal)
    }
}
;
UIButtonScale.prototype.OnHover = function(isOver) {
    if (this.enabled) {
        if (!this.mStarted)
            this.Start();
        this.InternalChangeState(isOver ? UIButton.State.Hover : UIButton.State.Normal)
    }
}
;
UIButtonScale.prototype.InternalChangeState = function(newState) {
    if (this.tweenTarget == null)
        return;
    switch (newState) {
    case UIButtonScale.State.Normal:
        this.tweenTarget.localScale(this.normalScale);
        break;
    case UIButtonScale.State.Hover:
        this.tweenTarget.localScale(this.hover);
        break;
    case UIButtonScale.State.Pressed:
        this.tweenTarget.localScale(this.pressed);
        break;
    default:
        this.tweenTarget.localScale(this.normalScale)
    }
}
;
goog.provide("UHT.UIFont");
goog.require("UHT.Component");
UIFont.prototype = Object.create(Component.prototype);
UIFont.prototype.constructor = UIFont;
function UIFont() {
    Component.call(this);
    this.fontData = "";
    this.hasFontLoaded = false;
    this.texture = "";
    this.name = "";
    this.isLoading = false;
    this.callback = [];
    this.object = []
}
UIFont.prototype.deserialize = function(source, helper, resolveReference) {
    deserializeComponentRec(source, this, helper, resolveReference);
    this.SetBitmapFontName();
    this.LoadFont()
}
;
UIFont.prototype.SetBitmapFontName = function() {
    var startIndex = this.fontData.search("face=") + 6;
    var endIndex = this.fontData.search("size=") - 2;
    this.name = this.fontData.substring(startIndex, endIndex)
}
;
UIFont.prototype.AfterLoad = function() {
    if (this.callback.length > 0)
        for (var i = 0; i < this.callback.length; i++)
            this.callback[i].call(this.object[i]);
    this.hasFontLoaded = true
}
;
UIFont.prototype.LoadFont = function() {
    this.isLoading = true;
    var tex = PIXI.Texture.fromImage(this.texture, undefined, undefined, true);
    this.texture = "";
    var parser = new DOMParser;
    var xmlDoc = parser.parseFromString(this.fontData, "text/xml");
    PIXI.extras.BitmapText.parse(xmlDoc, tex);
    this.AfterLoad()
}
;
goog.provide("UHT.UIInput");
goog.require("UHT.Component");
UIInput.prototype = Object.create(Component.prototype);
UIInput.prototype.constructor = UIInput;
function UIInput() {
    Component.call(this);
    this.label = null;
    this.value = "";
    this.activeTextColor = null;
    this.inactiveTextColor = null;
    this.caretColor = null;
    this.validation = UIInput.Validation.None;
    this.characterLimit = 0;
    this.caretGameObject = null;
    this.onChange = [];
    this.isSelected = false;
    this.TextExtraHandler = null
}
UIInput.Validation = {
    None: 0,
    Integer: 1,
    Float: 2,
    Alphanumeric: 3,
    Username: 4,
    Name: 5
};
UIInput.curSelectedUIInput = null;
UIInput.prototype.Start = function() {
    this.SetValue(this.value);
    this.label.SetColor(this.activeTextColor)
}
;
UIInput.prototype.OnDisable = function() {
    this.Select(false)
}
;
UIInput.prototype.OnClick = function() {
    this.Select(true)
}
;
UIInput.prototype.Update = function() {
    if (!this.isSelected)
        return;
    if (Input.GetKeyDown(KeyCode.Alpha0) || Input.GetKeyDown(KeyCode.Keypad0))
        this.Insert("0");
    if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1))
        this.Insert("1");
    if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2))
        this.Insert("2");
    if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3))
        this.Insert("3");
    if (Input.GetKeyDown(KeyCode.Alpha4) || Input.GetKeyDown(KeyCode.Keypad4))
        this.Insert("4");
    if (Input.GetKeyDown(KeyCode.Alpha5) || Input.GetKeyDown(KeyCode.Keypad5))
        this.Insert("5");
    if (Input.GetKeyDown(KeyCode.Alpha6) || Input.GetKeyDown(KeyCode.Keypad6))
        this.Insert("6");
    if (Input.GetKeyDown(KeyCode.Alpha7) || Input.GetKeyDown(KeyCode.Keypad7))
        this.Insert("7");
    if (Input.GetKeyDown(KeyCode.Alpha8) || Input.GetKeyDown(KeyCode.Keypad8))
        this.Insert("8");
    if (Input.GetKeyDown(KeyCode.Alpha9) || Input.GetKeyDown(KeyCode.Keypad9))
        this.Insert("9");
    if (Input.GetKeyDown(KeyCode.Comma) || Input.GetKeyDown(KeyCode.DecimalPoint) || Input.GetKeyDown(KeyCode.Period))
        this.Insert(".");
    if (Input.GetKeyDown(KeyCode.Backspace))
        this.DoBackspace()
}
;
UIInput.prototype.Select = function(selected) {
    if (this.isSelected == selected)
        return;
    this.isSelected = selected;
    if (this.isSelected) {
        if (UIInput.curSelectedUIInput != null)
            UIInput.curSelectedUIInput.Select(false);
        UIInput.curSelectedUIInput = this
    } else
        UIInput.curSelectedUIInput = null;
    this.caretGameObject.SetActive(this.isSelected);
    this.InternalSetText()
}
;
UIInput.prototype.ValidateAndNotify = function(newValue) {
    var oldValue = this.value;
    this.Validate(newValue);
    if (oldValue != this.value)
        for (var i = 0; i < this.onChange.length; i++) {
            var cur = this.onChange[i];
            if (cur.target != null)
                cur.target[cur.methodName]()
        }
}
;
UIInput.prototype.Validate = function(newValue) {
    this.value = newValue;
    if (this.characterLimit > 0 && this.value.length > this.characterLimit)
        this.value = this.value.substring(0, this.characterLimit);
    if (this.validation == UIInput.Validation.Integer) {
        while (this.value.length > 0) {
            var rv = parseInt(this.value, 10);
            if (isFinite(rv) && !isNaN(rv)) {
                this.value = rv.toString();
                return
            } else
                this.value = this.value.substring(0, this.value.length - 1)
        }
        this.value = "0";
        return
    }
    if (this.validation == UIInput.Validation.Float)
        ;
    else
        console.log("Invalid Validation for UIInput! Only Integer supported!")
}
;
UIInput.prototype.SetValue = function(str) {
    this.ValidateAndNotify(str);
    this.InternalSetText()
}
;
UIInput.prototype.Insert = function(str) {
    if (str == ".") {
        if (/\./.test(this.value))
            return;
        if (_string.IsNullOrEmpty(this.value))
            this.value = "0"
    } else if (this.value == "0")
        this.value = "";
    this.ValidateAndNotify(this.value + str);
    this.InternalSetText()
}
;
UIInput.prototype.DoBackspace = function() {
    this.ValidateAndNotify(this.value.substring(0, this.value.length - 1));
    this.InternalSetText()
}
;
UIInput.prototype.Clear = function() {
    this.ValidateAndNotify("0");
    this.InternalSetText()
}
;
UIInput.prototype.InternalSetText = function() {
    this.label.text = this.TextExtraHandler != null ? this.TextExtraHandler(this.value) : this.value
}
;
goog.provide("UHT.UILabel");
goog.require("UHT.Component");
UILabel.prototype = Object.create(Component.prototype);
UILabel.prototype.constructor = UILabel;
var LabelUsageID = 0;
function UILabel() {
    Component.call(this);
    this.wasInitCalled = false;
    this.fontName = null;
    this.fontSize = 0;
    this.currentFontSize = 0;
    this._text = "";
    this.anchorX = 0;
    this.anchorY = 0;
    this.depth = 0;
    this.color = null;
    this.overflow = UILabel.Overflow.ShrinkContent;
    this.alignment = UILabel.Alignment.Automatic;
    this.effectStyle = UILabel.Effect.Outline;
    this.effectColor = null;
    this.effectWidth = 0;
    this.effectHeight = 0;
    this.dropShadowDistance = this.effectWidth * 1.5;
    this.maxLines = 0;
    this.width = 2;
    this.height = 2;
    this.spacingY = 0;
    this.multipleLayers = null;
    this.pixiObject = null;
    this.pixiObjectContent = null;
    this.panel = null;
    this.mask = null;
    this._pixiPosDirty = true;
    this.oldColor = -1;
    this.textIsUnprocessed = false;
    Object.defineProperties(this, {
        "text": {
            get: function() {
                return this._text
            },
            set: function(value) {
                this.InternalSetText(value, false)
            }
        },
        "mColor": {
            get: function() {
                return this.color
            }
        }
    });
    this.mBlurShadow = false;
    this.mBlurShadowSize = 1;
    this.mBlurShadowOffsetX = 1;
    this.mBlurShadowOffsetY = 1;
    this.mBlurShadowColor = null;
    this.mOutline = false;
    this.mOutlineThickness = 1;
    this.mOutlineColor = null;
    this.mFillCenter = true;
    this.mArcRadius = 0;
    this.circularChildren = [];
    this.circularChildrenWidth = [];
    this.fontNameExpectedFromCallback = "";
    this.zeroScale = false;
    this.isDOG = false;
    this.DOGchars = null;
    this.DOGmonospaceDigits = false;
    this.resize = 1;
    this.IOSresized = false;
    this.usageID = "l" + LabelUsageID;
    LabelUsageID++
}
UILabel.Overflow = {
    ShrinkContent: 0,
    ClampContent: 1,
    ResizeFreely: 2,
    ResizeHeight: 3
};
UILabel.Alignment = {
    Automatic: 0,
    Left: 1,
    Center: 2,
    Right: 3,
    Justified: 4
};
UILabel.Effect = {
    None: 0,
    Shadow: 1,
    Outline: 2,
    Outline8: 3,
    Custom: 4,
    Layered: 5
};
var LabelUsage = {};
UILabel.prototype.UseNow = function() {
    var a = LabelUsage[this.usageID];
    if (a != undefined) {
        a.allocated = true;
        a.frame = Time.frameCount
    }
}
;
UILabel.CheckUsageAndClean = function() {
    if (!createjs.BrowserDetect.isIOS)
        return;
    for (var i in LabelUsage) {
        var l = LabelUsage[i];
        if (l.allocated && !l.label.isDOG)
            if (l.frame < Time.frameCount - 3600) {
                l.label.pixiObjectContent["destroy"]({
                    texture: true,
                    baseTexture: true
                });
                l.label.pixiObject = null;
                l.label.pixiObjectContent = null;
                l.label.textIsUnprocessed = true;
                l.allocated = false
            }
    }
}
;
UILabel.prototype.InternalSetText = function(value, forced) {
    var t = String(value);
    if (this._text == t && !this.textIsUnprocessed)
        return;
    this._pixiPosDirty = true;
    this._text = t;
    if (!this.gameObject.activeInHierarchy && !forced) {
        this.textIsUnprocessed = true;
        return
    }
    this.textIsUnprocessed = false;
    if (t == "") {
        if (this.overflow == UILabel.Overflow.ResizeFreely)
            this.width = 0;
        this.pixiObject = null;
        return
    }
    if (this.pixiObject == null)
        this.init();
    else if (typeof this.fontName != "object")
        if (this.gameObject.activeInHierarchy || forced) {
            if (this.isDOG) {
                this.textIsUnprocessed = true;
                return
            }
            if (this.effectStyle == UILabel.Effect.Custom)
                this.init();
            this.pixiObjectContent.text = this._text;
            this.processPixiText()
        }
}
;
UILabel.prototype.Prepare = function() {
    if (createjs.BrowserDetect.isIOS && typeof this.fontName != "object")
        if (!this.IOSresized) {
            var REFERENCE_FONT_SIZE = 30;
            if (this.fontSize > REFERENCE_FONT_SIZE && this.resize > .9) {
                var RESIZE_FACTOR = (this.fontSize - (this.fontSize - REFERENCE_FONT_SIZE) * .75) / this.fontSize;
                this.resize *= RESIZE_FACTOR;
                this.fontSize *= RESIZE_FACTOR;
                this.fontSize = Math.max(this.fontSize, 2) | 0;
                this.width *= RESIZE_FACTOR;
                this.width = Math.max(this.width, 2) | 0;
                this.height *= RESIZE_FACTOR;
                this.height = Math.max(this.height, 2) | 0;
                this.effectWidth *= RESIZE_FACTOR;
                this.effectHeight *= RESIZE_FACTOR;
                this.spacingY *= RESIZE_FACTOR;
                this.mBlurShadowSize *= RESIZE_FACTOR;
                this.mBlurShadowOffsetX *= RESIZE_FACTOR;
                this.mBlurShadowOffsetY *= RESIZE_FACTOR;
                this.mOutlineThickness *= RESIZE_FACTOR;
                this.mArcRadius *= RESIZE_FACTOR
            }
            this.IOSresized = true
        }
    this.fontNameExpectedFromCallback = this.fontName;
    if (typeof this.fontName == "object") {
        this.fontName.callback.push(this.init);
        this.fontName.object.push(this)
    } else
        FontLoader.AddHandler(this.fontName, this.init, this)
}
;
UILabel.prototype.Start = function() {
    this.Prepare();
    this.panel = FindPanel(this.gameObject.transform)
}
;
UILabel.prototype.OnWillRenderObject = function() {
    if (this.textIsUnprocessed)
        this.InternalSetText(this._text, false);
    if (typeof this.fontName == "object") {
        if (!this.fontName.hasFontLoaded)
            return;
        if (this.fontName.isLoading && !this.wasInitCalled)
            this.init();
        if (this.pixiObject == null)
            return;
        this.pixiObject.mask = this.mask;
        var poc = this.pixiObjectContent;
        if (typeof poc.text != "string" || poc.text != this._text) {
            poc.text = this._text;
            poc.updateText();
            this.processPixiText();
            this._pixiPosDirty = true
        }
        this.pixiObject.visible = this.enabled;
        var c;
        if (this.isDOG)
            for (var i = 0; i < poc.children.length; i++) {
                c = poc.children[i];
                c.alpha = this.color.a * this.panel.alpha;
                c.worldAlpha = c.alpha
            }
        else
            for (var i = 0; i < poc.children.length; i++) {
                c = poc.children[i];
                c.alpha = 1 * this.panel.alpha;
                c.worldAlpha = c.alpha
            }
    } else {
        if (this.isDOG) {
            this.init();
            return
        }
        if (this.pixiObject == null)
            return;
        if (this.mArcRadius != 0)
            for (var oc = 0; oc < this.circularChildren.length; oc++) {
                var cLabel = this.circularChildren[oc].gameObject.GetComponent(UILabel);
                cLabel.enabled = true
            }
        this.pixiObject.mask = this.mask;
        var poc = this.pixiObjectContent;
        var tooTransparent = this.color.a < .05;
        this.pixiObject.visible = this.enabled && !tooTransparent;
        if (IS_UCBROWSER && this.mFillUseGradient) {
            var old_a = this.color.a;
            var c = this.mFillGradient.colorKeys[0].color;
            this.color = Color.Lerp(c, c, 0);
            this.color.a = old_a
        }
        var curColor = this.color.rgbAsHex;
        if (this.oldColor != curColor) {
            this.oldColor = curColor;
            poc.style.fill = this.color.rgbAsString();
            poc.dirty = true
        }
        poc.alpha = this.color.a * this.panel.alpha;
        poc.worldAlpha = poc.alpha;
        if (poc.text != this._text) {
            poc.text = this._text;
            this.processPixiText()
        } else
            poc.text = this._text
    }
    var hc = this.gameObject.transform;
    if (!this.pixiObject.visible)
        return;
    if (this.zeroScale)
        this.pixiObject.visible = false;
    else
        this.UseNow();
    if (!this._pixiPosDirty && !hc.IsDirtyUserFlag(Transform._DirtyFlagLabel))
        return;
    hc._internal_get_position();
    hc._internal_get_rotation();
    hc._internal_get_scale();
    hc.ClearDirtyUserFlag(Transform._DirtyFlagLabel);
    this._pixiPosDirty = false;
    this.pixiObject.dirtyWT = true;
    if (this.pixiObject == null)
        return;
    var parent = this.pixiObject;
    var child = this.pixiObjectContent;
    var hp = hc.parent.transform;
    parent.x = hp._dangerous_get_position().x;
    parent.y = -hp._dangerous_get_position().y;
    var offsets = this.ComputeOffsets(child);
    child.x = hc._dangerous_get_localPosition().x * this.resize - offsets.X;
    child.y = -hc._dangerous_get_localPosition().y * this.resize - offsets.Y;
    parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
    child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
    parent.scale.x = hp._dangerous_get_scale().x / this.resize;
    parent.scale.y = hp._dangerous_get_scale().y / this.resize;
    this.zeroScale = Math.abs(parent.scale.x * parent.scale.y) < 1E-16
}
;
UILabel.prototype.ComputeOffsets = function(child) {
    var offsetX = 0;
    var offsetY = 0;
    var fxPlusTop = 0;
    var fxPlusBottom = 0;
    var fxPlusLeft = 0;
    var fxPlusRight = 0;
    switch (this.effectStyle) {
    case UILabel.Effect.Outline:
    case UILabel.Effect.Outline8:
        fxPlusTop = this.mOutlineThickness;
        fxPlusBottom = -this.mOutlineThickness;
        fxPlusLeft = this.mOutlineThickness;
        fxPlusRight = -this.mOutlineThickness;
        break;
    case UILabel.Effect.Shadow:
        fxPlusBottom = -this.dropShadowDistance;
        fxPlusRight = -this.dropShadowDistance;
        break;
    case UILabel.Effect.Custom:
        if (this.mOutline) {
            fxPlusTop = this.mOutlineThickness;
            fxPlusBottom = -this.mOutlineThickness;
            fxPlusLeft = this.mOutlineThickness;
            fxPlusRight = -this.mOutlineThickness
        }
        if (this.mBlurShadow) {
            var extraTop = Math.max(this.mBlurShadowSize - this.mBlurShadowOffsetY, 0);
            fxPlusTop += extraTop;
            fxPlusBottom -= Math.max(this.mBlurShadowSize * 2 + Math.abs(this.mBlurShadowOffsetY), 0) - extraTop;
            var extraLeft = Math.max(this.mBlurShadowSize - this.mBlurShadowOffsetX, 0);
            fxPlusLeft += extraLeft;
            fxPlusRight -= Math.max(this.mBlurShadowSize * 2 + Math.abs(this.mBlurShadowOffsetX), 0) - extraLeft
        }
        break;
    case UILabel.Effect.Layered:
        fxPlusTop = this.multipleLayers.effectPlusTop;
        fxPlusBottom = this.multipleLayers.effectPlusBottom;
        fxPlusLeft = this.multipleLayers.effectPlusLeft;
        fxPlusRight = this.multipleLayers.effectPlusRight;
        break;
    default:
        break
    }
    if (typeof this.fontName == "object") {
        var offTop = 0;
        var offBottom = 0;
        var temp = {};
        temp.textHeight = 0;
        temp.textWidth = 0;
        temp = this.pixiObjectContent;
        if (this.anchorY < .1)
            offsetY = offTop + fxPlusTop;
        else if (this.anchorY > .9)
            offsetY = offBottom + fxPlusBottom + temp.textHeight;
        else
            offsetY = (offTop + offBottom + fxPlusTop + fxPlusBottom) / 2 + temp.textHeight / 2;
        if (this.anchorX < .1)
            offsetX = fxPlusLeft;
        else if (this.anchorX > .9)
            offsetX = fxPlusRight + temp.textWidth;
        else
            offsetX = (fxPlusLeft + fxPlusRight) / 2 + temp.textWidth / 2;
        return {
            X: offsetX,
            Y: offsetY
        }
    } else {
        var offTop = child["_hack_extraOffsetTop"];
        var offBottom = child["_hack_extraOffsetBottom"];
        var properties = child.determineFontProperties(child._style.font);
        var offPadding = properties.fontSize * .5;
        if (this.anchorY < .1)
            offsetY = offTop + fxPlusTop;
        else if (this.anchorY > .9)
            offsetY = offBottom + fxPlusBottom;
        else
            offsetY = (offTop + offBottom + fxPlusTop + fxPlusBottom) / 2;
        if (this.anchorX < .1)
            offsetX = offPadding + fxPlusLeft;
        else if (this.anchorX > .9)
            offsetX = -offPadding + fxPlusRight;
        else
            offsetX = (fxPlusLeft + fxPlusRight) / 2;
        return {
            X: offsetX,
            Y: offsetY
        }
    }
}
;
var DOG_Cache = [];
UILabel.prototype.init = function() {
    if (this._text == "") {
        if (this.overflow == UILabel.Overflow.ResizeFreely)
            this.width = 0;
        return
    }
    if (this.fontNameExpectedFromCallback != this.fontName)
        return;
    this._pixiPosDirty = true;
    if (this.isDOG && typeof this.fontName != "object") {
        if (this.DOGchars == null || !FontLoader.IsLoaded(this.fontName))
            return;
        if (this.pixiObjectContent != null)
            this.pixiObjectContent["destroy"]({
                texture: true,
                baseTexture: true
            });
        this.pixiObjectContent = new PIXI.Text("");
        var poc = this.pixiObjectContent;
        poc["_hack_NoCutFix"] = true;
        poc.style.font = "" + this.fontSize + "px " + this.fontName;
        poc.style.lineHeight = this.fontSize;
        poc.style.spacingY = this.spacingY;
        poc.style.fill = this.color.rgbAsString();
        poc.alpha = 1;
        poc.text = " ";
        poc.updateText();
        var spw = poc["_width"];
        this.SetupEffects();
        var cacheKey = JSON.stringify(poc.style) + this.DOGchars;
        var useCached = false;
        for (var dci = 0; dci < DOG_Cache.length; dci++)
            if (DOG_Cache[dci].key == cacheKey) {
                this.fontName = DOG_Cache[dci].uif;
                this.fontNameExpectedFromCallback = DOG_Cache[dci].uif;
                this.pixiObjectContent = null;
                DOG_Cache[dci].count++;
                useCached = true
            }
        if (!useCached) {
            var fxw;
            var fxh;
            if (this.effectStyle == UILabel.Effect.Layered) {
                fxw = this.multipleLayers.effectWidth;
                fxh = this.multipleLayers.effectHeight
            } else {
                fxw = poc.style.strokeThickness;
                fxh = poc.style.strokeThickness;
                if (poc.style.dropShadow) {
                    fxw += poc.style.dropShadowDistance;
                    fxh += poc.style.dropShadowDistance
                }
                if (poc.style.blurShadow) {
                    fxw += Math.max(poc.style.dropShadowDistance * 2 + Math.abs(poc.style.blurShadowX), 0);
                    fxh += Math.max(poc.style.dropShadowDistance * 2 + Math.abs(poc.style.blurShadowY), 0)
                }
            }
            var chsep = " ";
            if (fxw > 0) {
                var spn = Math.ceil(fxw / spw);
                for (var i = 0; i < spn; ++i)
                    chsep += " "
            }
            fxw *= this.anchorX;
            fxh *= this.anchorY;
            fxh += poc["_hack_extraOffsetTop"];
            if (this.effectStyle == UILabel.Effect.Layered) {
                if (this.anchorY < .1)
                    fxh -= this.multipleLayers.effectPlusTop;
                else if (this.anchorY > .9)
                    fxh -= this.multipleLayers.effectPlusBottom;
                else
                    fxh -= (this.multipleLayers.effectPlusTop + this.multipleLayers.effectPlusBottom) * .5;
                if (this.anchorX < .1)
                    fxw -= this.multipleLayers.effectPlusLeft;
                else if (this.anchorX > .9)
                    fxw -= this.multipleLayers.effectPlusRight;
                else
                    fxw -= (this.multipleLayers.effectPlusLeft + this.multipleLayers.effectPlusRight) * .5
            }
            var chars = this.DOGchars;
            var sp = chars.indexOf(" ") > -1;
            chars.replace(" ", "");
            var ch = [];
            for (var i = 0; i < chars.length; ++i)
                ch.push(chars[i]);
            chars = (sp ? " " : "") + chsep + ch.join(chsep) + chsep;
            var t = "";
            var ow = 0;
            var chw = 0;
            var add = false;
            var xa = -1;
            ch = [];
            var xml = '<?xml version="1.0"?><font>';
            xml += '<info face="{0}" size="{1}" bold="0" italic="0" charset="" unicode="1" stretchH="100" smooth="1" aa="1" padding="0,0,0,0" spacing="0,0" outline="0"/>';
            xml += '<common lineHeight="{1}" base="{1}" scaleW="{2}" scaleH="{1}" pages="1" packed="0" alphaChnl="0" redChnl="4" greenChnl="4" blueChnl="4"/>';
            xml += '<chars count="{3}">';
            for (var i = 0; i < chars.length; ++i) {
                add = ch.indexOf(chars[i]) < 0;
                if (add) {
                    poc.text = chars[i];
                    poc.updateText();
                    chw = poc["_width"]
                }
                t += chars[i];
                poc.text = t;
                poc.updateText();
                if (add) {
                    var w = poc["_width"] - ow;
                    var ox = w - chw;
                    var x = ow + ox;
                    var line = '<char id="{0}" x="{1}" y="0" width="{2}" height="{3}" xoffset="{6}" yoffset="{4}" xadvance="{5}" page="0" chnl="15" />';
                    line = line.replace(/\{0\}/g, String(chars[i].charCodeAt(0)));
                    line = line.replace(/\{1\}/g, String(x));
                    line = line.replace(/\{2\}/g, String(chw));
                    line = line.replace(/\{3\}/g, String(poc["_height"]));
                    line = line.replace(/\{4\}/g, String(-fxh));
                    line = line.replace(/\{6\}/g, String(-fxw));
                    if (!this.DOGmonospaceDigits || !/\d/.test(chars[i]))
                        line = line.replace(/\{5\}/g, String(w));
                    else if (xa < w)
                        xa = w;
                    xml += line;
                    ch.push(chars[i])
                }
                ow = poc["_width"]
            }
            if (Renderer.IsWebGL) {
                var gl = globalRenderer.renderer["gl"];
                var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                if (maxSize < ow) {
                    var resize = maxSize / (ow + 1) * .95;
                    this.fontSize *= resize;
                    this.resize *= resize;
                    this.init();
                    return
                }
            }
            xml += "</chars></font>";
            var fontName = UID.Generate();
            xml = xml.replace(/\{0\}/g, fontName);
            xml = xml.replace(/\{1\}/g, String(this.fontSize));
            xml = xml.replace(/\{2\}/g, String(poc["_width"]));
            xml = xml.replace(/\{3\}/g, String(chars.length));
            xml = xml.replace(/\{5\}/g, String(xa));
            var xmlDoc = (new DOMParser).parseFromString(xml, "text/xml");
            PIXI.extras.BitmapText.parse(xmlDoc, poc["_texture"]);
            var uif = new UIFont;
            uif.name = fontName;
            uif.isLoading = true;
            uif.hasFontLoaded = true;
            this.fontName = uif;
            this.fontNameExpectedFromCallback = uif;
            this.pixiObjectContent = null;
            DOG_Cache.push({
                key: cacheKey,
                uif: uif,
                count: 0
            })
        }
    }
    this.pixiObject = new PIXI.Container(null);
    if (typeof this.fontName == "object") {
        if (this.fontName.hasFontLoaded)
            this.pixiObjectContent = new PIXI.extras.BitmapText(this._text,{
                font: this.fontSize + "px " + this.fontName.name
            });
        else
            return;
        this.pixiObject.addChild(this.pixiObjectContent);
        var poc = this.pixiObjectContent;
        this.currentFontSize = this.fontSize
    } else {
        if (this.pixiObjectContent != null)
            this.pixiObjectContent["destroy"]({
                texture: true,
                baseTexture: true
            });
        this.pixiObjectContent = new PIXI.Text(this._text);
        this.pixiObject.addChild(this.pixiObjectContent);
        var poc = this.pixiObjectContent;
        this.currentFontSize = this.fontSize;
        poc.style.font = "" + this.fontSize + "px " + this.fontName;
        poc.style.lineHeight = this.fontSize;
        poc.style.spacingY = this.spacingY;
        poc.anchor.x = this.anchorX;
        poc.anchor.y = this.anchorY;
        if (IS_UCBROWSER && this.mFillUseGradient) {
            var old_a = this.color.a;
            var c = this.mFillGradient.colorKeys[0].color;
            this.color = Color.Lerp(c, c, 0);
            this.color.a = old_a
        }
        this.oldColor = this.color.rgbAsHex;
        poc.style.fill = this.color.rgbAsString();
        poc.alpha = this.color.a;
        this.SetupAlignment();
        this.SetupEffects();
        if (this.overflow == UILabel.Overflow.ShrinkContent || this.overflow == UILabel.Overflow.ResizeHeight) {
            poc.style.wordWrap = true;
            poc.style.wordWrapWidth = this.width
        }
    }
    this.processPixiText();
    this.wasInitCalled = true
}
;
UILabel.prototype.SetColor = function(newColor) {
    this.color = newColor
}
;
UILabel.prototype.GetColor = function() {
    return this.color
}
;
UILabel.prototype.SetupEffects = function() {
    this.dropShadowDistance = this.effectWidth * 1.5;
    switch (this.effectStyle) {
    case UILabel.Effect.Shadow:
        this.pixiObjectContent.style.dropShadow = true;
        this.pixiObjectContent.style.dropShadowAngle = Math.PI / 4;
        this.pixiObjectContent.style.dropShadowColor = this.effectColor.rgbAsString();
        this.pixiObjectContent.style.dropShadowDistance = this.dropShadowDistance;
        break;
    case UILabel.Effect.Outline:
    case UILabel.Effect.Outline8:
        this.mOutlineThickness = this.effectWidth;
        this.pixiObjectContent.style.stroke = this.effectColor.rgbAsString();
        this.pixiObjectContent.style.strokeThickness = this.mOutlineThickness * 2;
        break;
    case UILabel.Effect.Custom:
        this.pixiObjectContent.style.blurShadow = this.mBlurShadow;
        this.pixiObjectContent.style.blurShadowX = this.mBlurShadowOffsetX;
        this.pixiObjectContent.style.blurShadowY = this.mBlurShadowOffsetY;
        this.pixiObjectContent.style.dropShadowColor = this.mBlurShadowColor.rgbAsString();
        this.pixiObjectContent.style.dropShadowDistance = this.mBlurShadowSize;
        this.pixiObjectContent.style.fillCenter = this.mFillCenter;
        this.pixiObjectContent.style.stroke = this.mOutline ? this.mOutlineColor.rgbAsString() : null;
        if (this.mOutline)
            this.pixiObjectContent.style.strokeThickness = this.mOutlineThickness * 2;
        if (!IS_UCBROWSER) {
            this.pixiObjectContent.style.mFillUseGradient = this.mFillUseGradient;
            this.pixiObjectContent.style.mFillGradient = this.mFillGradient;
            this.pixiObjectContent.style.mFillGradientAngle = Math.PI * this.mFillGradientAngle / 180;
            this.pixiObjectContent.style.mOutlineUseGradient = this.mOutlineUseGradient;
            this.pixiObjectContent.style.mOutlineGradient = this.mOutlineGradient;
            this.pixiObjectContent.style.mOutlineGradientAngle = Math.PI * this.mOutlineGradientAngle / 180
        } else {
            if (this.mFillUseGradient) {
                var old_a = this.color.a;
                var c = this.mFillGradient.colorKeys[0].color;
                this.color = Color.Lerp(c, c, 0);
                this.color.a = old_a
            }
            if (this.mOutlineUseGradient)
                this.pixiObjectContent.style.stroke = this.mOutlineGradient.colorKeys[0].color.rgbAsString()
        }
        break;
    case UILabel.Effect.Layered:
        if (this.multipleLayers == null)
            this.multipleLayers = this.GetComponent(LabelMultipleLayers);
        this.multipleLayers.SetupEffects(this);
        break;
    default:
        break
    }
}
;
UILabel.prototype.SetupAlignment = function() {
    if (this.alignment == UILabel.Alignment.Automatic)
        if (this.anchorX == .5)
            this.pixiObjectContent.style.align = "center";
        else {
            if (this.anchorX == 1)
                this.pixiObjectContent.style.align = "right"
        }
    else
        switch (this.alignment) {
        case UILabel.Alignment.Center:
            this.pixiObjectContent.style.align = "center";
            break;
        case UILabel.Alignment.Right:
            this.pixiObjectContent.style.align = "right";
            break;
        default:
            break
        }
}
;
UILabel.prototype.processPixiText = function() {
    var poc = this.pixiObjectContent;
    poc.dirty = true;
    var ignored = poc.height;
    if (this.overflow == UILabel.Overflow.ShrinkContent)
        if (typeof this.fontName == "object") {
            if (this.currentFontSize < this.fontSize)
                while (poc.textHeight < this.height) {
                    poc.dirty = true;
                    this.currentFontSize++;
                    poc = new PIXI.extras.BitmapText(this._text,{
                        font: this.currentFontSize + "px " + this.fontName.name
                    })
                }
            while ((poc.textHeight > this.height || poc.textWidth > this.width) && this.currentFontSize > 1) {
                poc.dirty = true;
                this.currentFontSize--;
                poc = new PIXI.extras.BitmapText(this._text,{
                    font: this.currentFontSize + "px " + this.fontName.name
                })
            }
            this.pixiObjectContent.font.size = this.currentFontSize;
            this.pixiObjectContent.updateText()
        } else {
            var oldStyle = poc.style;
            poc.style = {};
            poc.style.lineHeight = this.currentFontSize;
            poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
            poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
            poc.style.wordWrap = true;
            poc.style.wordWrapWidth = oldStyle.wordWrapWidth;
            poc._skipUpdateTexture = true;
            if (this.currentFontSize < this.fontSize)
                if (poc.height < this.height) {
                    var found = false;
                    var min = this.currentFontSize;
                    var max = this.fontSize;
                    while (!found && this.currentFontSize != this.fontSize) {
                        this.currentFontSize = Math.ceil((min + max) / 2) | 0;
                        poc.dirty = true;
                        poc.style.lineHeight = this.currentFontSize;
                        poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
                        poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
                        var fit = poc.height < this.height;
                        found = !fit && min >= max - 1;
                        if (fit)
                            min = this.currentFontSize;
                        else
                            max = this.currentFontSize
                    }
                }
            if (this.maxLines > 0) {
                var defaultLines = this._text.split(/(?:\r\n|\r|\n)/);
                var outputText = poc.wordWrap(this._text);
                var lines = outputText.split(/(?:\r\n|\r|\n)/);
                if (lines.length - (defaultLines.length - 1) > this.maxLines) {
                    var found = false;
                    var min = 1;
                    var max = this.currentFontSize;
                    while (!found) {
                        this.currentFontSize = (min + max) / 2 | 0;
                        poc.dirty = true;
                        poc.style.lineHeight = this.currentFontSize;
                        poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
                        poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
                        ignored = poc.height;
                        outputText = poc.wordWrap(this._text);
                        lines = outputText.split(/(?:\r\n|\r|\n)/);
                        var fit = lines.length - (defaultLines.length - 1) <= this.maxLines;
                        found = fit && min >= max - 1;
                        if (fit)
                            min = this.currentFontSize;
                        else
                            max = this.currentFontSize
                    }
                }
            }
            if (poc.height > this.height || poc.width > this.width) {
                var found = false;
                var min = 1;
                var max = this.currentFontSize;
                while (!found) {
                    this.currentFontSize = (min + max) / 2 | 0;
                    poc.dirty = true;
                    poc.style.lineHeight = this.currentFontSize;
                    poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
                    poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
                    if (this.maxLines > 0) {
                        var defaultLines = this._text.split(/(?:\r\n|\r|\n)/);
                        var outputText = poc.wordWrap(this._text);
                        var lines = outputText.split(/(?:\r\n|\r|\n)/);
                        if (lines.length - (defaultLines.length - 1) > this.maxLines) {
                            var found2 = false;
                            var min2 = 1;
                            var max2 = this.currentFontSize;
                            while (!found2) {
                                this.currentFontSize = (min2 + max2) / 2 | 0;
                                poc.dirty = true;
                                poc.style.lineHeight = this.currentFontSize;
                                poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
                                poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
                                ignored = poc.height;
                                outputText = poc.wordWrap(this._text);
                                lines = outputText.split(/(?:\r\n|\r|\n)/);
                                var fit2 = lines.length - (defaultLines.length - 1) <= this.maxLines;
                                found2 = fit2 && min2 >= max2 - 1;
                                if (fit2)
                                    min2 = this.currentFontSize;
                                else
                                    max2 = this.currentFontSize
                            }
                        }
                    }
                    var fit = !(poc.height > this.height || poc.width > this.width);
                    found = fit && min >= max - 1;
                    if (fit)
                        min = this.currentFontSize;
                    else
                        max = this.currentFontSize
                }
            }
            poc._style = oldStyle;
            poc.style.lineHeight = this.currentFontSize;
            poc.style.spacingY = this.spacingY * this.currentFontSize / this.fontSize;
            poc.style.font = "" + this.currentFontSize + "px " + this.fontName;
            poc.dirty = true;
            poc._skipUpdateTexture = false;
            ignored = poc.height
        }
    if (this.overflow == UILabel.Overflow.ResizeFreely)
        if (typeof this.fontName == "object")
            this.width = poc.textWidth;
        else
            this.width = poc.width;
    if (this.mArcRadius != 0) {
        for (var oc = 0; oc < this.circularChildren.length; oc++) {
            this.circularChildren[oc].gameObject.SetActive(false);
            this.circularChildren[oc].transform.SetParent(null, false)
        }
        this.circularChildren = [];
        this.circularChildrenWidth = [];
        this._model.mArcRadius = 0;
        this._model.enabled = false;
        var oAR = this.mArcRadius;
        this.mArcRadius = 0;
        var oResize = this.resize;
        this.resize = 1;
        var oActive = this.gameObject.activeSelf;
        this.gameObject.SetActive(false);
        var letters = this._text.length;
        for (var l = 0; l < letters; l++) {
            var newGO = instantiate(this.gameObject);
            var newLabel = newGO.GetComponent(UILabel);
            newLabel.InternalSetText(this._text[l], true);
            newLabel.fontNameExpectedFromCallback = this.fontNameExpectedFromCallback;
            newLabel.overflow = UILabel.Overflow.ResizeFreely;
            newLabel.fontSize = this.currentFontSize;
            this.circularChildren.push(newLabel);
            this.circularChildrenWidth.push(0)
        }
        var allWidth = 0;
        for (var l2 = 0; l2 < letters; l2++) {
            var newLabel = this.circularChildren[l2];
            newLabel.transform.SetParent(this.gameObject.transform, false);
            newLabel.transform.localPosition(0, 0, 0);
            newLabel.transform.localScale(1, 1, 1);
            newLabel.gameObject.SetActive(true);
            newLabel.anchorX = .5;
            newLabel.anchorY = .5;
            newLabel.init();
            this.circularChildrenWidth[l2] = this.circularChildren[l2].width;
            allWidth += this.circularChildren[l2].width
        }
        this.mArcRadius = oAR;
        this.resize = oResize;
        this.gameObject.SetActive(oActive);
        this.enabled = false;
        var arcRadius = -this.mArcRadius;
        var circlePerimeter = 2 * UHTMath.PI * arcRadius;
        var currentpos = 0;
        for (var i = 0; i < letters; i++) {
            currentpos += this.circularChildrenWidth[i] * .5;
            var letterLabel = this.circularChildren[i];
            var letterGO = letterLabel.gameObject;
            var letterTransform = letterGO.transform;
            var distance = currentpos - allWidth / 2;
            var angleWithThisArcLength = distance / circlePerimeter * 2 * UHTMath.PI - .5 * UHTMath.PI;
            var newCenterx = Math.cos(angleWithThisArcLength) * arcRadius;
            var newCentery = Math.sin(angleWithThisArcLength) * arcRadius;
            letterTransform.localPosition(newCenterx, newCentery, 0);
            var rotAngle = (angleWithThisArcLength + .5 * UHTMath.PI) * 180 / UHTMath.PI;
            letterTransform.localRotation(UHTMath.Quaternion.euler(0, 0, rotAngle));
            currentpos += this.circularChildrenWidth[i] * .5
        }
        var scale = 1 / this.resize;
        this.transform.localScale(scale, scale, scale)
    } else if (typeof this.fontName != "object")
        LabelUsage[this.usageID] = {
            frame: Time.frameCount,
            label: this,
            allocated: true
        }
}
;
UILabel.prototype.GetWidth = function() {
    return this.width / this.resize
}
;
UILabel.prototype.GetHeight = function() {
    return this.height / this.resize
}
;
goog.provide("UHT.UIPanel");
goog.require("UHT.Component");
UIPanel.prototype = Object.create(Component.prototype);
UIPanel.prototype.constructor = UIPanel;
function UIPanel() {
    Component.call(this);
    this.container = null;
    this.depth = 0;
    this.alpha = 0;
    this.mask = null;
    this.container = new PIXI.Container;
    this.container.worldAlpha = 1;
    Object.defineProperties(this, {
        "mAlpha": {
            get: function() {
                return this.alpha
            },
            set: function(value) {
                this.alpha = value
            }
        }
    })
}
UIPanel.prototype.OnWillRenderObject = function() {
    var c = this.container;
    c.children = [];
    var tooTransparent = this.alpha < .05;
    c.visible = this.enabled && !tooTransparent;
    c.mask = this.mask;
    if (this.gameObject.transform.IsDirtyUserFlag(Transform._DirtyFlagPanel)) {
        this.gameObject.transform.ClearDirtyUserFlag(Transform._DirtyFlagPanel);
        this.container.dirtyWT = true
    }
}
;
UIPanel.prototype.SetPanelAlpha = function(strValue) {
    this.alpha = _number.otod(strValue)
}
;
goog.provide("UHT.UIRoot");
goog.require("UHT.Component");
UIRoot.prototype = Object.create(Component.prototype);
UIRoot.prototype.constructor = UIRoot;
function UIRoot() {
    Component.call(this);
    this.scalingStyle = 0;
    this.manualWidth = 0;
    this.manualHeight = 0;
    this.minimumHeight = 0;
    this.maximumHeight = 0;
    this.fitWidth = true;
    this.fitHeight = true;
    this.adjustByDPI = false;
    this.shrinkPortraitUI = false;
    this.oldscale = -1
}
UIRoot.prototype.Update = function() {
    var intendedRatio = this.manualWidth / this.manualHeight;
    var currentRatio = UHTScreen.width / UHTScreen.height;
    var s = this.gameObject.transform.scale();
    s.x = Math.min(intendedRatio, currentRatio) / intendedRatio * 2 / this.manualHeight;
    s.y = s.x;
    if (Math.abs(this.oldscale - s.x) > UHTMath.numberError) {
        this.oldscale = s.x;
        this.gameObject.transform.scale(s)
    }
}
;
goog.provide("UHT.UISprite");
goog.require("UHT.Component");
UISprite.prototype = Object.create(Component.prototype);
UISprite.prototype.constructor = UISprite;
function UISprite() {
    Component.call(this);
    this.spriteName = "";
    this.spriteType = UISprite.Type.Simple;
    this.fillCenter = true;
    this.depth = 0;
    this.atlas = null;
    this.width = 0;
    this.height = 0;
    this.anchorX = 0;
    this.anchorY = 0;
    this.color = null;
    this.autoResizeBoxCollider = false;
    this.pixiObject = null;
    this.pixiObjectContent = null;
    this.panel = null;
    this.mask = null;
    this._pixiPosDirty = true;
    this.oWidth = -1;
    this.oHeight = -1;
    this.fillDirection = UISprite.FillDirection.Horizontal;
    this.fillAmount = 1;
    this.fillAmountTop = 1;
    this.fillAmountBottom = 1;
    this.fillAmountLeft = 1;
    this.fillAmountRight = 1;
    this.invert = false;
    this.isAtlasLoaded = false;
    this.zeroScale = false;
    Object.defineProperties(this, {
        "mColor": {
            get: function() {
                return this.color
            }
        }
    })
}
UISprite.Type = {
    Simple: 0,
    Sliced: 1,
    Tiled: 2,
    Filled: 3,
    Advanced: 4
};
UISprite.FillDirection = {
    Horizontal: 0,
    Vertical: 1,
    Radial90: 2,
    Radial180: 3,
    Radial360: 4,
    Custom: 5
};
UISprite.prototype.Start = function() {
    this.SetSpriteName(this.spriteName);
    this.panel = FindPanel(this.gameObject.transform)
}
;
UISprite.prototype.OnWillRenderObject = function() {
    if (this.pixiObject == null)
        return;
    if (this.spriteType == UISprite.Type.Sliced)
        if (this.oWidth != this.width || this.oHeight != this.height)
            this.SetSpriteName(this.spriteName);
    var child = this.pixiObjectContent;
    var tooTransparent = this.color.a < .05 && this.atlas.blendMode == 0;
    this.pixiObject.visible = this.enabled && !tooTransparent;
    switch (this.spriteType) {
    case UISprite.Type.Simple:
    case UISprite.Type.Filled:
        child.tint = this.color.rgbAsHex;
        child.alpha = this.color.a * this.panel.alpha;
        child.worldAlpha = child.alpha;
        break;
    case UISprite.Type.Sliced:
        for (var i = 0; i < child.children.length; i++) {
            var c = child.children[i];
            c.tint = this.color.rgbAsHex;
            c.alpha = this.color.a * this.panel.alpha;
            c.worldAlpha = c.alpha
        }
        break;
    default:
        break
    }
    var hc = this.gameObject.transform;
    if (this.atlas.isLoaded() && !this.isAtlasLoaded) {
        this.isAtlasLoaded = true;
        this.pixiObject.dirtyWT = true
    }
    if (!this.pixiObject.visible)
        return;
    if (this.zeroScale)
        this.pixiObject.visible = false;
    else if (this.atlas != null)
        this.atlas.UseNow();
    if (!this._pixiPosDirty && !hc.IsDirtyUserFlag(Transform._DirtyFlagSprite))
        return;
    this.pixiObject.dirtyWT = true;
    hc._internal_get_position();
    hc._internal_get_rotation();
    hc._internal_get_scale();
    hc.ClearDirtyUserFlag(Transform._DirtyFlagSprite);
    this._pixiPosDirty = false;
    var parent = this.pixiObject;
    var hp = hc.parent.transform;
    parent.x = hp._dangerous_get_position().x;
    parent.y = -hp._dangerous_get_position().y;
    child.x = hc._dangerous_get_localPosition().x;
    child.y = -hc._dangerous_get_localPosition().y;
    parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
    child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
    switch (this.spriteType) {
    case UISprite.Type.Simple:
    case UISprite.Type.Filled:
        parent.scale.x = hp._dangerous_get_scale().x;
        parent.scale.y = hp._dangerous_get_scale().y;
        child.width = this.width * hc._dangerous_get_localScale().x;
        child.height = this.height * hc._dangerous_get_localScale().y;
        break;
    case UISprite.Type.Sliced:
        parent.scale.x = hp._dangerous_get_scale().x;
        parent.scale.y = hp._dangerous_get_scale().y;
        child.scale.x = hc._dangerous_get_localScale().x;
        child.scale.y = hc._dangerous_get_localScale().y;
        break;
    default:
        break
    }
    this.zeroScale = Math.abs(parent.scale.x * parent.scale.y) < 1E-16
}
;
UISprite.prototype.SetSpriteNameForAnimation = function(newName) {
    this.spriteName = newName;
    if (this.atlas != null)
        if (this.spriteType == UISprite.Type.Simple)
            if (this.pixiObject != null) {
                this.pixiObjectContent.texture = this.atlas.getTextureInfoForSprite(this, this.spriteName);
                var poc = this.pixiObjectContent;
                poc.width = this.width;
                poc.height = this.height;
                return
            }
    this.SetSpriteName(newName)
}
;
UISprite.prototype.SetSpriteName = function(newName) {
    this.spriteName = newName;
    this._pixiPosDirty = true;
    if (this.atlas != null)
        switch (this.spriteType) {
        case UISprite.Type.Simple:
            var texture = this.atlas.getTextureInfoForSprite(this, this.spriteName);
            this.pixiObject = new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Sprite(texture);
            var poc = this.pixiObjectContent;
            poc.anchor.x = this.anchorX;
            poc.anchor.y = this.anchorY;
            poc.width = this.width;
            poc.height = this.height;
            poc.blendMode = this.atlas.blendMode;
            this.pixiObject.addChild(poc);
            break;
        case UISprite.Type.Filled:
            var texture = this.atlas.getTextureInfoForSprite(this, this.spriteName);
            this.pixiObject = new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Sprite(texture);
            var poc = this.pixiObjectContent;
            poc.anchor.x = this.anchorX;
            poc.anchor.y = this.anchorY;
            poc.width = this.width;
            poc.height = this.height;
            poc.blendMode = this.atlas.blendMode;
            this.pixiObject.addChild(poc);
            break;
        case UISprite.Type.Sliced:
            this.pixiObject = new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Container(null);
            var poc = this.pixiObjectContent;
            var info = this.atlas.getTextureInfoForSprite(this, this.spriteName);
            var xOffset = (.5 - this.anchorX) * this.width;
            var yOffset = (.5 - this.anchorY) * this.height;
            var hackExtra = Renderer.IsWebGL ? 0 : 1;
            var bL = info.borderLeft;
            var bR = info.borderRight;
            var bT = info.borderTop;
            var bB = info.borderBottom;
            var pL = info.paddingLeft;
            var pR = info.paddingRight;
            var pB = info.paddingBottom;
            var pT = info.paddingTop;
            var rF = 100 / this.atlas.resize;
            bL *= rF;
            bR *= rF;
            bT *= rF;
            bB *= rF;
            pL *= rF;
            pR *= rF;
            pB *= rF;
            pT *= rF;
            var w = this.width;
            var h = this.height;
            var w2 = w / 2;
            var h2 = h / 2;
            var midw = w - bL - pL - bR - pR;
            var midh = h - bT - pT - bB - pB;
            var midw2 = midw / 2;
            var midh2 = midh / 2;
            if (bT > 0 && bL > 0) {
                var slice00 = new PIXI.Sprite(info.texture00);
                slice00.anchor.x = 1;
                slice00.anchor.y = 1;
                slice00.x = xOffset;
                slice00.y = yOffset;
                slice00.x -= w2 - bL - pL;
                slice00.y -= h2 - bT - pT;
                slice00.width = bL + pL;
                slice00.height = bT + pT;
                slice00.blendMode = this.atlas.blendMode;
                poc.addChild(slice00)
            }
            if (bT > 0) {
                var slice01 = new PIXI.Sprite(info.texture01);
                slice01.anchor.x = .5;
                slice01.anchor.y = 1;
                slice01.x = xOffset;
                slice01.y = yOffset;
                slice01.x += midw2 + bL + pL - w2;
                slice01.y -= h2 - bT - pT;
                slice01.width = midw + hackExtra;
                slice01.height = bT + pT;
                slice01.blendMode = this.atlas.blendMode;
                poc.addChild(slice01)
            }
            if (bT > 0 && bR > 0) {
                var slice02 = new PIXI.Sprite(info.texture02);
                slice02.anchor.x = 0;
                slice02.anchor.y = 1;
                slice02.x = xOffset;
                slice02.y = yOffset;
                slice02.x += w2 - bR - pR;
                slice02.y -= h2 - bT - pT;
                slice02.width = bR + pR;
                slice02.height = bT + pT;
                slice02.blendMode = this.atlas.blendMode;
                poc.addChild(slice02)
            }
            if (bL > 0) {
                var slice10 = new PIXI.Sprite(info.texture10);
                slice10.anchor.x = 1;
                slice10.anchor.y = .5;
                slice10.x = xOffset;
                slice10.y = yOffset;
                slice10.x -= w2 - bL - pL;
                slice10.y += midh2 + bT + pT - h2;
                slice10.width = bL + pL;
                slice10.height = midh + hackExtra;
                slice10.blendMode = this.atlas.blendMode;
                poc.addChild(slice10)
            }
            if (this.fillCenter) {
                var slice11 = new PIXI.Sprite(info.texture11);
                slice11.anchor.x = .5;
                slice11.anchor.y = .5;
                slice11.x = xOffset;
                slice11.y = yOffset;
                slice11.x += midw2 + bL + pL - w2;
                slice11.y += midh2 + bT + pT - h2;
                slice11.width = midw + hackExtra;
                slice11.height = midh + hackExtra;
                slice11.blendMode = this.atlas.blendMode;
                poc.addChild(slice11)
            }
            if (bR > 0) {
                var slice12 = new PIXI.Sprite(info.texture12);
                slice12.anchor.x = 0;
                slice12.anchor.y = .5;
                slice12.x = xOffset;
                slice12.y = yOffset;
                slice12.x += w2 - bR - pR;
                slice12.y += midh2 + bT + pT - h2;
                slice12.width = bR + pR;
                slice12.height = midh + hackExtra;
                slice12.blendMode = this.atlas.blendMode;
                poc.addChild(slice12)
            }
            if (bB > 0 && bL > 0) {
                var slice20 = new PIXI.Sprite(info.texture20);
                slice20.anchor.x = 1;
                slice20.anchor.y = 0;
                slice20.x = xOffset;
                slice20.y = yOffset;
                slice20.x -= w2 - bL - pL;
                slice20.y += h2 - bB - pB;
                slice20.width = bL + pL;
                slice20.height = bB + pB;
                slice20.blendMode = this.atlas.blendMode;
                poc.addChild(slice20)
            }
            if (bB > 0) {
                var slice21 = new PIXI.Sprite(info.texture21);
                slice21.anchor.x = .5;
                slice21.anchor.y = 0;
                slice21.x = xOffset;
                slice21.y = yOffset;
                slice21.x += midw2 + bL + pL - w2;
                slice21.y += h2 - bB - pB;
                slice21.width = midw + hackExtra;
                slice21.height = bB + pB;
                slice21.blendMode = this.atlas.blendMode;
                poc.addChild(slice21)
            }
            if (bB > 0 && bR > 0) {
                var slice22 = new PIXI.Sprite(info.texture22);
                slice22.anchor.x = 0;
                slice22.anchor.y = 0;
                slice22.x = xOffset;
                slice22.y = yOffset;
                slice22.x += w2 - bR - pR;
                slice22.y += h2 - bB - pB;
                slice22.width = bR + pR;
                slice22.height = bB + pB;
                slice22.blendMode = this.atlas.blendMode;
                poc.addChild(slice22)
            }
            this.pixiObject.addChild(poc);
            this.oWidth = this.width;
            this.oHeight = this.height;
            break;
        default:
            this.pixiObject = new PIXI.Container(null);
            this.pixiObjectContent = new PIXI.Sprite(null);
            this.pixiObject.addChild(this.pixiObjectContent);
            console.error("Unhandled sprite type " + this.spriteType);
            break
        }
    if (this.autoResizeBoxCollider && this.gameObject.collider != null) {
        this.gameObject.collider.size.x = this.width;
        this.gameObject.collider.size.y = this.height;
        if (this.anchorX < .4)
            this.gameObject.collider.center.x = this.width / 2;
        else if (this.anchorX > .6)
            this.gameObject.collider.center.x = -this.width / 2;
        else
            this.gameObject.collider.center.x = 0;
        if (this.anchorY < .4)
            this.gameObject.collider.center.y = -this.height / 2;
        else if (this.anchorY > .6)
            this.gameObject.collider.center.y = this.height / 2;
        else
            this.gameObject.collider.center.y = 0;
        this.gameObject.collider.UpdateCachedMembers()
    }
}
;
goog.provide("UHT.UIZoomSprite");
goog.require("UHT.UISprite");
UIZoomSprite.prototype = Object.create(UISprite.prototype);
UIZoomSprite.prototype.constructor = UIZoomSprite;
function UIZoomSprite() {
    UISprite.call(this);
    this.zoomAmmount = .5;
    this.zoomPivot = new UHTMath.Vector3;
    this.rectFrameO = null;
    this.rectCropO = null;
    this.rectTrimO = null
}
UIZoomSprite.prototype.GetClampedPivot = function() {
    var clampedZoomPivot = {
        x: this.zoomPivot.x,
        y: this.zoomPivot.y
    };
    var pivot_margin = .5 - Math.abs((1 - this.zoomAmmount) / 2 - .5);
    if (this.zoomPivot.x < pivot_margin)
        clampedZoomPivot.x = pivot_margin;
    if (this.zoomPivot.x > 1 - pivot_margin)
        clampedZoomPivot.x = 1 - pivot_margin;
    if (this.zoomPivot.y < pivot_margin)
        clampedZoomPivot.y = pivot_margin;
    if (this.zoomPivot.y > 1 - pivot_margin)
        clampedZoomPivot.y = 1 - pivot_margin;
    return clampedZoomPivot
}
;
UIZoomSprite.prototype.ComputeTexture = function() {
    var zoom = Math.max(.001, 1 - this.zoomAmmount);
    var rectFrame = this.rectFrameO.clone();
    var rectTrim = this.rectTrimO.clone();
    var borderW = rectTrim.width - rectFrame.width;
    var borderH = rectTrim.height - rectFrame.height;
    rectTrim.x *= zoom;
    rectTrim.y *= zoom;
    rectTrim.width *= zoom;
    rectTrim.height *= zoom;
    rectFrame.width *= zoom;
    rectFrame.height *= zoom;
    var pivot = this.GetClampedPivot();
    var offsetX = pivot.x * this.rectFrameO.width - rectFrame.width * .5;
    var offsetY = (1 - pivot.y) * this.rectFrameO.height - rectFrame.height * .5;
    rectFrame.x += offsetX;
    rectFrame.y += offsetY;
    var rectCrop = rectFrame.clone();
    var poc = this.pixiObjectContent;
    poc.texture.trim = rectTrim;
    poc.texture.crop = rectCrop;
    poc.texture.frame = rectFrame
}
;
UIZoomSprite.prototype.OnWillRenderObject = function() {
    UISprite.prototype.OnWillRenderObject.call(this);
    this.ComputeTexture();
    var poc = this.pixiObjectContent;
    var hc = this.gameObject.transform;
    poc.width = this.width * hc._dangerous_get_localScale().x;
    poc.height = this.height * hc._dangerous_get_localScale().y;
    this.pixiObject.dirtyWT = true
}
;
UIZoomSprite.prototype.SetSpriteName = function(newName) {
    UISprite.prototype.SetSpriteName.call(this, newName);
    var poc = this.pixiObjectContent;
    this.rectFrameO = poc.texture.crop.clone();
    this.rectCropO = poc.texture.crop.clone();
    this.rectTrimO = poc.texture.trim.clone();
    poc.texture = new PIXI.Texture(poc.texture,this.rectFrameO.clone(),this.rectCropO.clone(),this.rectTrimO.clone())
}
;
goog.provide("UHT.Renderer");
goog.require("UHT.UILabel");
goog.require("UHT.UISprite");
goog.require("UHT.UIZoomSprite");
goog.require("UHT.Camera");
goog.require("UHT.UHTScreen");
var UHT_DEBUG_TEXT = null;
var PRESERVE_RB_LIST = [{
    vendor: "Huawei",
    model: "ALE-L21"
}];
var FORCE_CANVAS_LIST = [];
var CachedFrameCount = -1;
function Renderer() {
    this.renderer = null;
    this.stage = null;
    this.orderedCameras = [];
    this.foundCameras = [];
    this.foundPanels = [];
    this.foundZOrderedObjects = [];
    this.fpsCounter = null;
    this.debugText = null
}
Renderer.IsWebGL = false;
var renderCanvas;
var rememberedWindowWidth = -1;
var rememberedWindowHeight = -1;
var canvasSizeDirty = false;
Renderer.prototype.checkWindowSize = function() {
    if (rememberedWindowWidth != window.innerWidth) {
        rememberedWindowWidth = window.innerWidth;
        canvasSizeDirty = true
    }
    if (rememberedWindowHeight != window.innerHeight) {
        rememberedWindowHeight = window.innerHeight;
        canvasSizeDirty = true
    }
}
;
Renderer.prototype.resizeUHTScreen = function() {
    var PixelRatio = window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI;
    if (UHT_DEVICE_TYPE.DESKTOP == true)
        if (PixelRatio > 1.5)
            PixelRatio = 1.5;
    if (PixelRatio > 2)
        PixelRatio = 2;
    UHTScreen.width = Math.floor(rememberedWindowWidth * PixelRatio);
    UHTScreen.height = Math.floor(rememberedWindowHeight * PixelRatio);
    if (createjs.BrowserDetect.isIOS) {
        document.body.style.width = rememberedWindowWidth + "px";
        if (UHT_UA_INFO.browser.name == "Chrome") {
            renderCanvas.style.width = rememberedWindowWidth + "px";
            renderCanvas.style.height = rememberedWindowHeight + "px"
        }
    }
    canvasSizeDirty = false
}
;
Renderer.prototype.init = function() {
    renderCanvas = document.createElement("canvas");
    renderCanvas.style.width = "100%";
    renderCanvas.style.height = "100%";
    this.checkWindowSize();
    this.resizeUHTScreen();
    var mustPreserveDrawingBuffer = false;
    var forceCanvas = navigator.userAgent.indexOf("forceCanvas") > -1;
    var parser = new UAParser2;
    var device = parser.getDevice();
    if (device.vendor != undefined && device.model != undefined) {
        var vendor = device.vendor;
        var model = device.model;
        for (var i = 0; i < PRESERVE_RB_LIST.length; i++)
            if (vendor.toUpperCase().indexOf(PRESERVE_RB_LIST[i].vendor.toUpperCase()) == 0)
                if (model.toUpperCase().indexOf(PRESERVE_RB_LIST[i].model.toUpperCase()) == 0)
                    mustPreserveDrawingBuffer = true;
        for (var j = 0; j < FORCE_CANVAS_LIST.length; j++)
            if (vendor.toUpperCase().indexOf(FORCE_CANVAS_LIST[j].vendor.toUpperCase()) == 0)
                if (model.toUpperCase().indexOf(FORCE_CANVAS_LIST[j].model.toUpperCase()) == 0)
                    forceCanvas = true
    }
    var renderOptions = {
        view: renderCanvas,
        resolution: 1,
        antialias: false,
        forceFXAA: false,
        autoResize: false,
        transparent: false,
        backgroundColor: 0,
        clearBeforeRender: false,
        preserveDrawingBuffer: mustPreserveDrawingBuffer
    };
    this.renderer = PIXI.autoDetectRenderer(UHTScreen.width, UHTScreen.height, renderOptions, forceCanvas);
    Renderer.IsWebGL = this.renderer instanceof PIXI.WebGLRenderer;
    console.log("[Init] Screen size: (" + UHTScreen.width + "x" + UHTScreen.height + ")");
    document.body.appendChild(this.renderer.view);
    var fpsTextStyle = {
        font: "30px Arial",
        fill: "#000000",
        stroke: "#FFFFFF",
        strokeThickness: 5
    };
    this.fpsCounter = new PIXI.Text("urs",fpsTextStyle);
    var debugTextStyle = {
        font: "100px Arial",
        fill: "#FFFFFF",
        stroke: "#000000",
        strokeThickness: 25
    };
    this.debugText = new PIXI.Text("dbg",debugTextStyle)
}
;
Renderer.prototype.doFrame = function() {
    CachedFrameCount = Time.frameCount;
    var dirtyStage = false;
    if (this.renderer.view.width != UHTScreen.width || this.renderer.view.height != UHTScreen.height) {
        this.renderer.resize(UHTScreen.width, UHTScreen.height);
        dirtyStage = true;
        console.log("[Resized] Screen size: (" + UHTScreen.width + "x" + UHTScreen.height + ")")
    }
    this.orderedCameras = [];
    this.foundCameras = [];
    this.foundPanels = [];
    this.foundZOrderedObjects = [];
    this.ParseRenderableComponents();
    this.orderedCameras = this.foundCameras.sort(function(a, b) {
        return a.depth - b.depth
    });
    for (var idxPanel = 0; idxPanel < this.foundPanels.length; idxPanel++)
        if (this.foundPanels[idxPanel].container.children.length > 0)
            this.registerPanel(this.foundPanels[idxPanel]);
    for (var j = 0; j < this.orderedCameras.length; j++)
        SortPixiChildren(this.orderedCameras[j].container);
    this.addZOrderedObjects();
    if (this.stage == null)
        this.stage = new PIXI.Container;
    if (dirtyStage)
        this.stage.dirtyWT = true;
    this.stage.children = [];
    this.stage.dirtyChildren = true;
    for (var ic = 0; ic < this.orderedCameras.length; ic++) {
        var cam = this.orderedCameras[ic];
        if (cam.container.children.length > 0)
            this.stage.addChild(cam.container)
    }
    if (UHT_DEBUG)
        this.stage.addChild(this.fpsCounter);
    if (window["UHT_DEBUG_TEXT"] != null) {
        this.debugText.text = UHT_DEBUG_TEXT;
        this.stage.addChild(this.debugText)
    }
    globalColliderInputManager.pixiObject.dirtyWT = true;
    this.stage.addChild(globalColliderInputManager.pixiObject);
    this.renderer.render(this.stage);
    Camera.allCameras = this.orderedCameras;
    UIAtlas.CheckUsageAndClean();
    UILabel.CheckUsageAndClean()
}
;
Renderer.prototype.ParseRenderableComponents = function() {
    var list = globalRuntime.onWillRenderList.components;
    for (var i = 0; i < list.length; i++) {
        var cur = list[i];
        if (cur == null)
            continue;
        if ((cur instanceof UISprite || cur instanceof UILabel || cur instanceof MovieController) && cur.pixiObject != null) {
            if (cur.panel != null)
                RegisterPixiChild(cur.panel.container, cur.pixiObject, cur.depth)
        } else if (cur instanceof UIPanel)
            this.foundPanels.push(cur);
        else if (cur instanceof Camera) {
            cur.container.children = [];
            this.foundCameras.push(cur)
        } else if (cur["pixiZOrderedContainer"] != undefined)
            this.foundZOrderedObjects.push(cur);
        if (cur["OnUpdateRenderTexture"] != undefined)
            cur.OnUpdateRenderTexture()
    }
    for (var j = 0; j < this.foundPanels.length; j++)
        SortPixiChildren(this.foundPanels[j].container)
}
;
Renderer.prototype.registerPanel = function(panel) {
    var cameraIndex = this.getCameraIndexForLayer(panel.gameObject.layer);
    if (cameraIndex >= 0) {
        var parentContainer = this.orderedCameras[cameraIndex].container;
        RegisterPixiChild(parentContainer, panel.container, panel.depth)
    }
}
;
Renderer.prototype.getCameraIndexForLayer = function(layer) {
    for (var i = 0; i < this.orderedCameras.length; i++) {
        var mask = this.orderedCameras[i].cullingMask;
        if (1 << layer == mask)
            return i
    }
    return -1
}
;
Renderer.prototype.addZOrderedObjects = function() {
    if (this.foundZOrderedObjects.length == 0)
        return;
    var zOrderedArr = new Array(this.orderedCameras.length);
    for (var j = 0; j < this.foundZOrderedObjects.length; j++) {
        var cur = this.foundZOrderedObjects[j];
        var camIndex = this.getCameraIndexForLayer(cur.gameObject.layer);
        if (zOrderedArr[camIndex] == undefined)
            zOrderedArr[camIndex] = [];
        zOrderedArr[camIndex].push(cur)
    }
    for (var k = 0; k < zOrderedArr.length; k++)
        if (zOrderedArr[k] != undefined) {
            var arr = zOrderedArr[k];
            arr.sort(function(a, b) {
                return a.gameObject.transform._dangerous_get_position().z > b.gameObject.transform._dangerous_get_position().z
            });
            var indexInCamera = 0;
            var camChildren = this.orderedCameras[k].container.children;
            for (var p = 0; p < camChildren.length; p++)
                if (camChildren[p][uhtDepth] < 0)
                    indexInCamera++;
            for (var m = arr.length - 1; m >= 0; m--) {
                arr[m].pixiZOrderedContainer.dirtyWT = true;
                this.orderedCameras[k].container.addChildAt(arr[m].pixiZOrderedContainer, indexInCamera)
            }
            this.orderedCameras[k].container.dirtyChildren = true
        }
}
;
Renderer.prototype.setFPSCount = function(newfps) {
    if (this.fpsCounter != null && UHT_DEBUG) {
        var build = [UHT_REVISION.common, UHT_REVISION.desktop, UHT_REVISION.mobile, UHT_BUILD_PATH].join(", ");
        build = [" (", build, ")"].join("");
        var configs = [" (configs: ", ServerOptions.configs || "-", ")"].join("");
        var rendererType = Renderer.IsWebGL ? "webgl" : "canvas";
        var parser = new UAParser2;
        var device = parser.getDevice();
        var browser = parser.getBrowser();
        var vendor_model = "";
        if (device.vendor != undefined && device.model != undefined && browser.name != undefined) {
            var vendor = device.vendor;
            var model = device.model;
            vendor_model = "[" + vendor + ":" + model + ":" + browser.name + "] ";
            for (var i = 0; i < PRESERVE_RB_LIST.length; i++)
                if (vendor.toUpperCase().indexOf(PRESERVE_RB_LIST[i].vendor.toUpperCase()) == 0)
                    if (model.toUpperCase().indexOf(PRESERVE_RB_LIST[i].model.toUpperCase()) == 0)
                        vendor_model = "[" + vendor + ":" + model + "(PRB)] "
        }
        this.fpsCounter.text = Number(newfps).toFixed(1) + " fps (" + rendererType + ") " + vendor_model + build + configs
    }
}
;
var uhtDepth = "uht_depth";
var uhtFC = "uht_fc";
function SortPixiChildren(container) {
    container.children.sort(SortByUhtDepth)
}
function SortByUhtDepth(a, b) {
    return a[uhtDepth] - b[uhtDepth]
}
function RegisterPixiChild(parent, child, depth) {
    if (!child.visible)
        return;
    if (child[uhtFC] != CachedFrameCount - 1)
        child.dirtyWT = true;
    child[uhtDepth] = depth;
    child.parent = parent;
    if (child.dirtyWT != false || child.dirtyChildren == true)
        parent.dirtyChildren = true;
    child[uhtFC] = CachedFrameCount;
    parent.children.push(child)
}
goog.provide("UHT.UIUtils");
function FindPanel(transform) {
    var tr = transform;
    while (tr != null) {
        var panel = tr.gameObject.GetComponent(UIPanel);
        if (panel != null)
            return panel;
        else
            tr = tr.parent
    }
    console.error("Panel not found for " + transform.gameObject.name);
    return null
}
goog.require("UHT.Component");
CATButton.prototype = Object.create(Component.prototype);
CATButton.prototype.constructor = CATButton;
function CATButton() {
    Component.call(this);
    this.catEventPress = null;
    this.catEventRelease = null;
    this.catEventClick = null;
    this.catEventHoverOn = null;
    this.catEventHoverOff = null;
    this.holdTimer = 1;
    this.catEventHold = null;
    this.holdTriggerDelay = 0;
    this.isHeld = false;
    this.wasHoldEvent = false;
    this.wasHover = false
}
CATButton.prototype.OnDisable = function() {
    this.OnPress(false)
}
;
CATButton.prototype.OnClick = function() {
    if (!this.wasHoldEvent && this.catEventClick != null && this.catEventClick.cat != null) {
        if (this.catEventClick.cat.IsEventRunning(this.catEventClick.id))
            return;
        var cd = this.gameObject.GetComponent(ClickDelay);
        if (cd == null || cd.CanClick())
            this.catEventClick.Start()
    }
}
;
CATButton.prototype.OnHover = function(isOver) {
    if (isOver) {
        if (this.catEventHoverOn != null && this.catEventHoverOn.cat != null) {
            if (this.catEventHoverOn.cat.IsEventRunning(this.catEventHoverOn.id))
                return;
            this.catEventHoverOn.Start()
        }
        this.wasHover = true
    } else {
        if (this.catEventHoverOff != null && this.catEventHoverOff.cat != null) {
            if (this.catEventHoverOff.cat.IsEventRunning(this.catEventHoverOff.id))
                return;
            this.catEventHoverOff.Start()
        }
        this.wasHover = false
    }
}
;
CATButton.prototype.OnPress = function(isPressed) {
    if (isPressed) {
        if (this.catEventPress != null && this.catEventPress.cat != null && !this.catEventPress.cat.IsEventRunning(this.catEventPress.id))
            this.catEventPress.Start();
        if (this.catEventHold != null && this.catEventHold.cat != null && !this.catEventHold.cat.IsEventRunning(this.catEventHold.id)) {
            this.isHeld = true;
            this.wasHoldEvent = false;
            this.holdTriggerDelay = this.holdTimer
        }
    } else {
        this.isHeld = false;
        if (this.catEventRelease != null && this.catEventRelease.cat != null && !this.catEventRelease.cat.IsEventRunning(this.catEventRelease.id))
            this.catEventRelease.Start();
        if (this.wasHover)
            this.OnHover(false)
    }
}
;
CATButton.prototype.Update = function() {
    if (this.isHeld)
        if (this.holdTriggerDelay > 0)
            this.holdTriggerDelay -= Time.deltaTime;
        else {
            this.catEventHold.Start();
            this.isHeld = false;
            this.wasHoldEvent = true
        }
}
;
function CATLink() {
    this.id = 0;
    this.cat = null
}
CATLink.prototype.Start = function() {
    if (this.cat != null)
        this.cat.StartEvent(this.id)
}
;
CATLink.prototype.Stop = function() {
    if (this.cat != null)
        this.cat.StopEvent(this.id)
}
;
CATLink.prototype.IsRunning = function() {
    if (this.cat != null)
        return this.cat.IsEventRunning(this.id);
    else
        return false
}
;
CATLink.prototype.RegisterCallback = function(newCallback, object) {
    if (this.cat != null)
        this.cat.RegisterCallback(this.id, newCallback, object)
}
;
CATLink.prototype.UnregisterCallback = function(toRemoveCallback, object) {
    if (this.cat != null)
        this.cat.UnregisterCallback(this.id, toRemoveCallback, object)
}
;
goog.provide("UHT.CAT_Event");
function CAT_Event() {
    this.id = 0;
    this.userFriendlyName = "";
    this.actions = [];
    this.playAutomatically = false;
    this.startTime = -1;
    this.curTime = -1;
    this.callback = [];
    this.isRunning = false;
    this.parent = null;
    this.isEnabled = true
}
CAT_Event.prototype.Start = function() {
    if (!this.isEnabled)
        return;
    if (this.isRunning) {
        console.log("xCAT: Trying to start an event twice! Aborting! (name = '" + this.userFriendlyName + "', running_time = " + (this.curTime - this.startTime) + ")");
        return
    }
    var finishedCount = 0;
    for (var i in this.actions) {
        var a = this.actions[i];
        if (a.isEnabled)
            if (a.delay <= .001) {
                a.ChangeState(CATState.Running);
                if (a.GetState() == CATState.Finished)
                    finishedCount++
            } else
                a.ChangeState(CATState.Waiting);
        else {
            a.ChangeState(CATState.Finished);
            finishedCount++
        }
    }
    this.startTime = this.curTime = Time.time;
    this.isRunning = true;
    this.parent.AddRunningEvent(this);
    this.InternalUpdateRunningState(finishedCount)
}
;
CAT_Event.prototype.Stop = function() {
    var finishedCount = 0;
    for (var i in this.actions) {
        var a = this.actions[i];
        if (a.GetState() == CATState.Running) {
            a.ChangeState(CATState.Stopping);
            if (a.GetState() == CATState.Finished)
                finishedCount++
        } else if (a.GetState() == CATState.Waiting) {
            a.ChangeState(CATState.Finished);
            finishedCount++
        } else if (a.GetState() == CATState.Finished)
            finishedCount++
    }
    this.InternalUpdateRunningState(finishedCount)
}
;
CAT_Event.prototype.Update = function() {
    var finishedCount = 0;
    this.curTime += Time.deltaTime;
    for (var i in this.actions) {
        var a = this.actions[i];
        switch (a.GetState()) {
        case CATState.Waiting:
            if (this.curTime > a.delay + this.startTime)
                a.ChangeState(CATState.Running);
            break;
        case CATState.Running:
        case CATState.Stopping:
            a.CATUpdate();
            break;
        case CATState.Finished:
            finishedCount++;
            break;
        case CATState.Stopped:
        default:
            break
        }
    }
    this.InternalUpdateRunningState(finishedCount)
}
;
CAT_Event.prototype.InternalUpdateRunningState = function(finishedActionsCount) {
    if (finishedActionsCount == this.actions.length) {
        for (var i in this.actions)
            this.actions[i].ChangeState(CATState.Stopped);
        for (var i = 0; i < this.callback.length; ++i) {
            var cb = this.callback[i];
            cb.callback.call(cb.object, CAT_Event.CallbackType.EndOfEvent, null)
        }
        this.isRunning = false;
        this.parent.RemoveRunningEvent(this)
    }
}
;
CAT_Event.prototype.RegisterCallback = function(newCallback, object) {
    this.callback.push({
        object: object,
        callback: newCallback
    })
}
;
CAT_Event.prototype.UnregisterCallback = function(toRemoveCallback, object) {
    for (var i = 0; i < this.callback.length; ++i) {
        var cb = this.callback[i];
        if (cb.object == object && cb.callback == toRemoveCallback) {
            this.callback.splice(i, 1);
            return
        }
    }
}
;
CAT_Event.CallbackType = {
    EndOfEvent: 0
};
CAT_Event.prototype.SetParent = function(parent) {
    this.parent = parent
}
;
goog.require("UHT.CAT_Event");
goog.provide("UHT.CAT_Action");
var CATState = {
    Waiting: 0,
    Running: 1,
    Finished: 2,
    Stopping: 3,
    Stopped: 4
};
function CAT_Action() {
    this.delay = 0;
    this.isExpanded = true;
    this.isEnabled = true;
    this.debugBreak = false;
    this.internalState = CATState.Stopped
}
CAT_Action.prototype.GetState = function() {
    return this.internalState
}
;
CAT_Action.prototype.ChangeState = function(newState) {
    if (this.internalState == newState) {
        console.log("xCAT: Trying to change state twice! Investigate!");
        return
    }
    this.internalState = newState;
    switch (newState) {
    case CATState.Waiting:
        break;
    case CATState.Running:
        this.OnStateChanged_Running();
        break;
    case CATState.Finished:
        break;
    case CATState.Stopping:
        this.OnStateChanged_Stopping();
        break;
    case CATState.Stopped:
        break;
    default:
        console.log("xCAT: Wait, what? How did i get here?");
        break
    }
}
;
CAT_Action.prototype.OnStateChanged_Running = function() {
    this.ChangeState(CATState.Finished)
}
;
CAT_Action.prototype.OnStateChanged_Stopping = function() {
    this.ChangeState(CATState.Finished)
}
;
CAT_Action.prototype.CATUpdate = function() {}
;
goog.require("UHT.CAT_Action");
CAT_Action_CATLink.prototype = Object.create(CAT_Action.prototype);
CAT_Action_CATLink.prototype.constructor = CAT_Action_CATLink;
function CAT_Action_CATLink() {
    CAT_Action.call(this);
    this.actionType = CAT_Action_CATLink.ActionType.StartEvent;
    this.eventId = null
}
CAT_Action_CATLink.prototype.OnStateChanged_Running = function() {
    var target = this.eventId.cat;
    if (target != null)
        switch (this.actionType) {
        case CAT_Action_CATLink.ActionType.StartEvent:
            target.RegisterCallback(this.eventId.id, this.Callback_EventEnded, this);
            target.StartEvent(this.eventId.id);
            break;
        case CAT_Action_CATLink.ActionType.StopEvent:
            target.StopEvent(this.eventId.id);
            this.ChangeState(CATState.Finished);
            break;
        case CAT_Action_CATLink.ActionType.StopAll:
            target.StopAllRunningEvents();
            this.ChangeState(CATState.Finished);
            break;
        case CAT_Action_CATLink.ActionType.StartEvent_NoWait:
            target.StartEvent(this.eventId.id);
            this.ChangeState(CATState.Finished);
            break
        }
    else
        this.ChangeState(CATState.Finished)
}
;
CAT_Action_CATLink.prototype.OnStateChanged_Stopping = function() {
    var target = this.eventId.cat;
    if (target != null && this.actionType == CAT_Action_CATLink.ActionType.StartEvent) {
        target.UnregisterCallback(this.eventId.id, this.Callback_EventEnded, this);
        target.StopEvent(this.eventId.id)
    }
    this.ChangeState(CATState.Finished)
}
;
CAT_Action_CATLink.prototype.Callback_EventEnded = function(type, data) {
    var target = this.eventId.cat;
    if (type == CAT_Event.CallbackType.EndOfEvent && this.actionType == CAT_Action_CATLink.ActionType.StartEvent) {
        target.UnregisterCallback(this.eventId.id, this.Callback_EventEnded, this);
        this.ChangeState(CATState.Finished)
    }
}
;
CAT_Action_CATLink.ActionType = {
    StartEvent: 0,
    StopEvent: 1,
    StopAll: 2,
    StartEvent_NoWait: 3
};
goog.require("UHT.CAT_Action");
CAT_Action_MusicController.prototype = Object.create(CAT_Action.prototype);
CAT_Action_MusicController.prototype.constructor = CAT_Action_MusicController;
function CAT_Action_MusicController() {
    CAT_Action.call(this);
    this.clipName = CAT_Action_MusicController.noClip;
    this.actionType = CAT_Action_MusicController.ActionType.PlayMusicClip;
    this.useFading = false;
    this.fadeInDuration = .5;
    this.fadeOutDuration = .5;
    this.duckingStep = 0;
    this.autoUnduck = false;
    this.delayToAutoUnduck = -1
}
CAT_Action_MusicController.noClip = "*none*";
CAT_Action_MusicController.ActionType = {
    PlayMusicClip: 0,
    StopMusicClip: 1,
    MuteMusicClip: 2,
    UnmuteMusicClip: 3,
    DuckMusicClip: 4,
    UnduckMusicClip: 5,
    MuteAllMusic: 6,
    UnmuteAllMusic: 7,
    MuteAllSoundFX: 8,
    UnmuteAllSoundFX: 9
};
CAT_Action_MusicController.prototype.OnStateChanged_Running = function() {
    var musicLogic = XT.GetObject(Vars.MusicLogicObject);
    if (this.HasValidClip() && musicLogic != null)
        switch (this.actionType) {
        case CAT_Action_MusicController.ActionType.PlayMusicClip:
            musicLogic.PlayMusicClip(this.clipName, this.useFading ? this.fadeInDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.StopMusicClip:
            musicLogic.StopMusicClip(this.clipName, this.useFading ? this.fadeOutDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.MuteMusicClip:
            musicLogic.MuteMusicClip(this.clipName, this.useFading ? this.fadeOutDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.UnmuteMusicClip:
            musicLogic.UnmuteMusicClip(this.clipName, this.useFading ? this.fadeInDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.DuckMusicClip:
            var duckFadeIn = this.useFading ? this.fadeInDuration : -1;
            var duckFadeOut = this.useFading ? this.fadeOutDuration : -1;
            musicLogic.DuckMusicClip(this.clipName, this.duckingStep, this.autoUnduck ? this.delayToAutoUnduck : -1, duckFadeIn, duckFadeOut);
            break;
        case CAT_Action_MusicController.ActionType.UnduckMusicClip:
            musicLogic.UnduckMusicClip(this.clipName, this.duckingStep, this.useFading ? this.fadeOutDuration : -1);
            break;
        case CAT_Action_MusicController.ActionType.MuteAllMusic:
            musicLogic.MuteMusic(true);
            break;
        case CAT_Action_MusicController.ActionType.UnmuteAllMusic:
            musicLogic.MuteMusic(false);
            break;
        case CAT_Action_MusicController.ActionType.MuteAllSoundFX:
            musicLogic.MuteSoundFX(true);
            break;
        case CAT_Action_MusicController.ActionType.UnmuteAllSoundFX:
            musicLogic.MuteSoundFX(false);
            break
        }
    this.ChangeState(CATState.Finished)
}
;
CAT_Action_MusicController.prototype.HasValidClip = function() {
    return !_string.IsNullOrEmpty(this.clipName) && this.clipName != CAT_Action_MusicController.noClip
}
;
goog.require("UHT.CAT_Action");
CAT_Action_ObjActivate.prototype = Object.create(CAT_Action.prototype);
CAT_Action_ObjActivate.prototype.constructor = CAT_Action_ObjActivate;
function CAT_Action_ObjActivate() {
    CAT_Action.call(this);
    this.ToEnableList = [];
    this.ToDisableList = []
}
CAT_Action_ObjActivate.prototype.OnStateChanged_Running = function() {
    for (var i in this.ToEnableList)
        if (this.ToEnableList[i] != null)
            this.ToEnableList[i].SetActive(true);
    for (var j in this.ToDisableList)
        if (this.ToDisableList[j] != null)
            this.ToDisableList[j].SetActive(false);
    this.ChangeState(CATState.Finished)
}
;
goog.require("UHT.CAT_Action");
goog.require("UHT.AudioClip");
CAT_Action_PlayAudioClip.prototype = Object.create(CAT_Action.prototype);
CAT_Action_PlayAudioClip.prototype.constructor = CAT_Action_PlayAudioClip;
function CAT_Action_PlayAudioClip() {
    CAT_Action.call(this);
    this.audioClip = null
}
CAT_Action_PlayAudioClip.prototype.OnStateChanged_Running = function() {
    var mgr = XT.GetObject(Vars.SoundManagerObject);
    mgr.PlaySimple(this.audioClip);
    this.ChangeState(CATState.Finished)
}
;
goog.require("UHT.CAT_Action");
CAT_Action_SetTransform.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SetTransform.prototype.constructor = CAT_Action_SetTransform;
function CAT_Action_SetTransform() {
    CAT_Action.call(this);
    this.objects = [];
    this.setLocalPosition = false;
    this.newLocalPosition = new UHTMath.Vector3(0,0,0);
    this.setLocalRotation = false;
    this.newLocalRotation = new UHTMath.Vector3(0,0,0);
    this.setLocalScale = false;
    this.newLocalScale = new UHTMath.Vector3(1,1,1)
}
CAT_Action_SetTransform.prototype.OnStateChanged_Running = function() {
    for (var i = 0; i < this.objects.length; i++) {
        if (this.setLocalPosition)
            this.objects[i].localPosition(this.newLocalPosition);
        if (this.setLocalRotation)
            this.objects[i].localRotation(UHTMath.Quaternion.euler(this.newLocalRotation));
        if (this.setLocalScale)
            this.objects[i].localScale(this.newLocalScale)
    }
    this.ChangeState(CATState.Finished)
}
;
goog.require("UHT.CAT_Action");
goog.require("UHT.AudioClip");
CAT_Action_StopAudioClip.prototype = Object.create(CAT_Action.prototype);
CAT_Action_StopAudioClip.prototype.constructor = CAT_Action_StopAudioClip;
function CAT_Action_StopAudioClip() {
    CAT_Action.call(this);
    this.audioClip = null
}
goog.require("UHT.CAT_Action");
CAT_Action_TriggerXTEvent.prototype = Object.create(CAT_Action.prototype);
CAT_Action_TriggerXTEvent.prototype.constructor = CAT_Action_TriggerXTEvent;
function CAT_Action_TriggerXTEvent() {
    CAT_Action.call(this);
    this.EventToCode = null
}
CAT_Action_TriggerXTEvent.prototype.OnStateChanged_Running = function() {
    XT.TriggerEvent(this.EventToCode.name);
    this.ChangeState(CATState.Finished)
}
;
function XTVar() {
    this.name = ""
}
function XT() {}
XT.RegisterAndInitDone = false;
XT.variablesBool = {};
XT.variablesInt = {};
XT.variablesFloat = {};
XT.variablesDouble = {};
XT.variablesString = {};
XT.variablesObject = {};
XT.variablesEvent = {};
XT.RegisterAndInit = function(go) {
    console.log("XT - InitElements root='" + go.name + "'", go);
    XT.variablesBool = {};
    XT.variablesInt = {};
    XT.variablesFloat = {};
    XT.variablesDouble = {};
    XT.variablesString = {};
    XT.variablesObject = {};
    XT.variablesEvent = {};
    var ges = go.GetComponentsInChildren(XTLink, true);
    var i;
    for (i = 0; i < ges.length; ++i)
        ges[i].XTRegisterCallbacksBase();
    for (i = 0; i < ges.length; ++i)
        ges[i].XTInitVariablesAndEvents();
    XT.RegisterAndInitDone = true
}
;
XT.UnregisterCallbackBool = function(callback, object) {
    for (var tmp in object[XTCache_Bool]) {
        var handlers = XT.variablesBool[tmp].OnValueChanged;
        if (handlers == null)
            continue;
        for (var i = 0; i < handlers.length; ++i)
            if (handlers[i].equals(object, callback))
                handlers.splice(i, 1)
    }
}
;
XT.UnregisterCallbackInt = function(callback, object) {
    for (var tmp in object[XTCache_Int]) {
        var handlers = XT.variablesInt[tmp].OnValueChanged;
        if (handlers == null)
            continue;
        for (var i = 0; i < handlers.length; ++i)
            if (handlers[i].equals(object, callback))
                handlers.splice(i, 1)
    }
}
;
XT.UnregisterCallbackFloat = function(callback, object) {
    for (var tmp in object[XTCache_Float]) {
        var handlers = XT.variablesFloat[tmp].OnValueChanged;
        if (handlers == null)
            continue;
        for (var i = 0; i < handlers.length; ++i)
            if (handlers[i].equals(object, callback))
                handlers.splice(i, 1)
    }
}
;
XT.UnregisterCallbackDouble = function(callback, object) {
    for (var tmp in object[XTCache_Double]) {
        var handlers = XT.variablesDouble[tmp].OnValueChanged;
        if (handlers == null)
            continue;
        for (var i = 0; i < handlers.length; ++i)
            if (handlers[i].equals(object, callback))
                handlers.splice(i, 1)
    }
}
;
XT.UnregisterCallbackString = function(callback, object) {
    for (var tmp in object[XTCache_String]) {
        var handlers = XT.variablesString[tmp].OnValueChanged;
        if (handlers == null)
            continue;
        for (var i = 0; i < handlers.length; ++i)
            if (handlers[i].equals(object, callback))
                handlers.splice(i, 1)
    }
}
;
XT.UnregisterCallbackObject = function(callback, object) {
    for (var tmp in object[XTCache_Object]) {
        var handlers = XT.variablesObject[tmp].OnValueChanged;
        if (handlers == null)
            continue;
        for (var i = 0; i < handlers.length; ++i)
            if (handlers[i].equals(object, callback))
                handlers.splice(i, 1)
    }
}
;
XT.UnregisterCallbackEvent = function(callback, object) {
    for (var tmp in object[XTCache_Event])
        for (var i = 0; i < XT.variablesEvent[tmp].length; ++i) {
            var handlers = XT.variablesEvent[tmp][i].OnValueChanged;
            if (handlers == null)
                continue;
            for (var j = 0; j < handlers.length; ++j)
                if (handlers[j].equals(object, callback))
                    handlers.splice(j, 1)
        }
}
;
XT.RegisterCallbackBool = function(name, callback, object) {
    if (XT.variablesBool[name] == undefined)
        XT.variablesBool[name] = new XTVariableHolderBase;
    XT.variablesBool[name].OnValueChanged.push(new EventHandler(object,callback));
    CacheXTData(object, name, XTCache_Bool)
}
;
XT.RegisterCallbackInt = function(name, callback, object) {
    if (XT.variablesInt[name] == undefined)
        XT.variablesInt[name] = new XTVariableHolderBase;
    XT.variablesInt[name].OnValueChanged.push(new EventHandler(object,callback));
    CacheXTData(object, name, XTCache_Int)
}
;
XT.RegisterCallbackFloat = function(name, callback, object) {
    if (XT.variablesFloat[name] == undefined)
        XT.variablesFloat[name] = new XTVariableHolderBase;
    XT.variablesFloat[name].OnValueChanged.push(new EventHandler(object,callback));
    CacheXTData(object, name, XTCache_Float)
}
;
XT.RegisterCallbackDouble = function(name, callback, object) {
    if (XT.variablesDouble[name] == undefined)
        XT.variablesDouble[name] = new XTVariableHolderBase;
    XT.variablesDouble[name].OnValueChanged.push(new EventHandler(object,callback));
    CacheXTData(object, name, XTCache_Double)
}
;
XT.RegisterCallbackString = function(name, callback, object) {
    if (XT.variablesString[name] == undefined)
        XT.variablesString[name] = new XTVariableHolderBase;
    XT.variablesString[name].OnValueChanged.push(new EventHandler(object,callback));
    CacheXTData(object, name, XTCache_String)
}
;
XT.RegisterCallbackObject = function(name, callback, object) {
    if (XT.variablesObject[name] == undefined)
        XT.variablesObject[name] = new XTVariableHolderBase;
    XT.variablesObject[name].OnValueChanged.push(new EventHandler(object,callback));
    CacheXTData(object, name, XTCache_Object)
}
;
function CompareVariableHolderEventByPriority(a, b) {
    return a.priority - b.priority
}
XT.RegisterCallbackEvent = function(name, callback, object, priority) {
    if (priority == undefined)
        priority = 0;
    if (XT.variablesEvent[name] == undefined)
        XT.variablesEvent[name] = [];
    var tmp = null;
    for (var i = 0; i < XT.variablesEvent[name].length; ++i)
        if (XT.variablesEvent[name][i].priority == priority)
            tmp = XT.variablesEvent[name][i];
    if (tmp == null) {
        tmp = new XTVariableHolderEvent;
        tmp.priority = priority;
        XT.variablesEvent[name].push(tmp);
        XT.variablesEvent[name] = XT.variablesEvent[name].sort(CompareVariableHolderEventByPriority)
    }
    tmp.OnValueChanged.push(new EventHandler(object,callback));
    CacheXTData(object, name, XTCache_Event)
}
;
XT.GetBool = function(varName) {
    var rv = false;
    if (XT.variablesBool[varName] != undefined)
        rv = XT.variablesBool[varName].value;
    else
        console.error("XT - does not have a variable (Bool) named " + varName + " !");
    return rv
}
;
XT.GetInt = function(varName) {
    var rv = -1;
    if (XT.variablesInt[varName] != undefined)
        rv = XT.variablesInt[varName].value;
    else
        console.error("XT - does not have a variable (Int) named " + varName + " !");
    return rv
}
;
XT.GetFloat = function(varName) {
    var rv = NaN;
    if (XT.variablesFloat[varName] != undefined)
        rv = XT.variablesFloat[varName].value;
    else
        console.error("XT - does not have a variable (Float) named " + varName + " !");
    return rv
}
;
XT.GetDouble = function(varName) {
    var rv = NaN;
    if (XT.variablesDouble[varName] != undefined)
        rv = XT.variablesDouble[varName].value;
    else
        console.error("XT - does not have a variable (Double) named " + varName + " !");
    return rv
}
;
XT.GetString = function(varName) {
    var rv = "RABAZZ";
    if (XT.variablesString[varName] != undefined)
        rv = XT.variablesString[varName].value;
    else
        console.error("XT - does not have a variable (String) named " + varName + " !");
    return rv
}
;
XT.GetObject = function(varName) {
    var rv = null;
    if (XT.variablesObject[varName] != undefined)
        rv = XT.variablesObject[varName].value;
    else
        console.error("XT - does not have a variable (Object) named " + varName + " !");
    return rv
}
;
XT.SetBool = function(varName, val) {
    if (XT.variablesBool[varName] == undefined)
        XT.variablesBool[varName] = new XTVariableHolderBase;
    var variable = XT.variablesBool[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null)
            XT.Invoke(handlers, variable.value)
    }
}
;
XT.SetInt = function(varName, val) {
    if (XT.variablesInt[varName] == undefined)
        XT.variablesInt[varName] = new XTVariableHolderBase;
    var variable = XT.variablesInt[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null)
            XT.Invoke(handlers, variable.value)
    }
}
;
XT.SetFloat = function(varName, val) {
    if (XT.variablesFloat[varName] == undefined)
        XT.variablesFloat[varName] = new XTVariableHolderBase;
    var variable = XT.variablesFloat[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null)
            XT.Invoke(handlers, variable.value)
    }
}
;
XT.SetDouble = function(varName, val) {
    if (XT.variablesDouble[varName] == undefined)
        XT.variablesDouble[varName] = new XTVariableHolderBase;
    var variable = XT.variablesDouble[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null)
            XT.Invoke(handlers, variable.value)
    }
}
;
XT.SetString = function(varName, val) {
    if (XT.variablesString[varName] == undefined)
        XT.variablesString[varName] = new XTVariableHolderBase;
    var variable = XT.variablesString[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null)
            XT.Invoke(handlers, variable.value)
    }
}
;
XT.SetObject = function(varName, val) {
    if (XT.variablesObject[varName] == undefined)
        XT.variablesObject[varName] = new XTVariableHolderBase;
    var variable = XT.variablesObject[varName];
    if (variable.value != val || variable.valueIsAssigned == false) {
        variable.valueIsAssigned = true;
        variable.value = val;
        var handlers = variable.OnValueChanged;
        if (handlers != null)
            XT.Invoke(handlers, variable.value)
    }
}
;
XT.TriggerEvent = function(eventName) {
    if (XT.variablesEvent[eventName] == undefined)
        XT.variablesEvent[eventName] = [];
    var tmp = XT.variablesEvent[eventName];
    for (var i = 0; i < tmp.length; ++i) {
        var handlers = tmp[i].OnValueChanged;
        if (handlers != null)
            XT.Invoke(handlers)
    }
}
;
XT.Invoke = function(list, args) {
    for (var i = 0; i < list.length; ++i) {
        var enabled = true;
        var xtl = list[i].object;
        if (xtl instanceof XTLink)
            enabled = xtl.xtEnabled;
        if (enabled)
            list[i].call(args)
    }
}
;
goog.require("UHT.EventHandler");
function XTVariableHolderBase() {
    this.OnValueChanged = [];
    this.valueIsAssigned = false;
    this.value = null
}
XTVariableHolderEvent.prototype = Object.create(XTVariableHolderBase.prototype);
XTVariableHolderEvent.prototype.constructor = XTVariableHolderEvent;
function XTVariableHolderEvent() {
    XTVariableHolderBase.call(this);
    this.priority = 0
}
var XTCache_Bool = "XTCache_Bool";
var XTCache_Int = "XTCache_Int";
var XTCache_Float = "XTCache_Float";
var XTCache_Double = "XTCache_Double";
var XTCache_String = "XTCache_String";
var XTCache_Object = "XTCache_Object";
var XTCache_Event = "XTCache_Event";
function CacheXTData(obj, varName, cacheName) {
    var d = obj[cacheName];
    if (d == undefined) {
        d = {};
        obj[cacheName] = d
    }
    d[varName] = 69
}
goog.require("UHT.Component");
CameraDepthController.prototype = Object.create(Component.prototype);
CameraDepthController.prototype.constructor = CameraDepthController;
function CameraDepthController() {
    Component.call(this);
    this.targetCamera = null;
    this.initialDepth = -1
}
CameraDepthController.prototype.Start = function() {
    this.initialDepth = this.targetCamera.depth
}
;
CameraDepthController.prototype.SetCameraDepth = function(depth) {
    this.targetCamera.depth = _number.otod(depth)
}
;
CameraDepthController.prototype.ResetCameraDepth = function() {
    this.targetCamera.depth = this.initialDepth
}
;
goog.require("UHT.Component");
ExtraCameraSettings.prototype = Object.create(Component.prototype);
ExtraCameraSettings.prototype.constructor = ExtraCameraSettings;
function ExtraCameraSettings() {
    Component.call(this);
    this._clipUp = -1;
    this._clipDown = -1;
    this._clipLeft = -1;
    this._clipRight = -1;
    this.dirtyFlag = false;
    this.clipInput = false;
    Object.defineProperties(this, {
        "clipUp": {
            get: function() {
                return this._clipUp
            },
            set: function(value) {
                if (value != this._clipUp) {
                    this._clipUp = value;
                    this.dirtyFlag = true
                }
            }
        },
        "clipDown": {
            get: function() {
                return this._clipDown
            },
            set: function(value) {
                if (value != this._clipDown) {
                    this._clipDown = value;
                    this.dirtyFlag = true
                }
            }
        },
        "clipLeft": {
            get: function() {
                return this._clipLeft
            },
            set: function(value) {
                if (value != this._clipLeft) {
                    this._clipLeft = value;
                    this.dirtyFlag = true
                }
            }
        },
        "clipRight": {
            get: function() {
                return this._clipRight
            },
            set: function(value) {
                if (value != this._clipRight) {
                    this._clipRight = value;
                    this.dirtyFlag = true
                }
            }
        }
    })
}
ExtraCameraSettings.prototype.clipUp = -1;
ExtraCameraSettings.prototype.clipDown = -1;
ExtraCameraSettings.prototype.clipLeft = -1;
ExtraCameraSettings.prototype.clipRight = -1;
goog.require("UHT.UHTEngine");
function ExtraCameraSettingsAnchorsHolder() {
    this.anchorUpLeft = null;
    this.anchorDownRight = null
}
ExtraCameraSettingsAnchors.prototype = Object.create(Component.prototype);
ExtraCameraSettingsAnchors.prototype.constructor = ExtraCameraSettingsAnchors;
function ExtraCameraSettingsAnchors() {
    Component.call(this);
    this.extraCameraSettings = null;
    this.anchorUpLeft = null;
    this.anchorDownRight = null;
    this.anchors = null;
    this.prevUL = null;
    this.prevDR = null
}
ExtraCameraSettingsAnchors.prototype.Update = function() {
    var UL = this.anchorUpLeft.position();
    var DR = this.anchorDownRight.position();
    if (this.prevUL == null || !this.prevUL.equals(UL) || this.prevDR == null || !this.prevDR.equals(DR)) {
        var ULI = this.gameObject.transform.inverseTransformPoint(UL);
        var DRI = this.gameObject.transform.inverseTransformPoint(DR);
        this.extraCameraSettings.clipUp = ULI.y;
        this.extraCameraSettings.clipDown = -DRI.y;
        this.extraCameraSettings.clipLeft = -ULI.x;
        this.extraCameraSettings.clipRight = DRI.x;
        this.prevUL = UL;
        this.prevDR = DR
    }
}
;
ExtraCameraSettingsAnchors.prototype.SwitchToAnchors = function(index) {
    index = Number(index);
    this.anchorUpLeft = this.anchors[index].anchorUpLeft;
    this.anchorDownRight = this.anchors[index].anchorDownRight;
    this.Update()
}
;
var LMVars = {
    Evt_Internal_SwitchToLandscapeLayout: "Evt_Internal_SwitchToLandscapeLayout",
    Evt_Internal_SwitchToLandscapeLayoutWide: "Evt_Internal_SwitchToLandscapeLayoutWide",
    Evt_Internal_SwitchToLandscapeLayoutWideFull: "Evt_Internal_SwitchToLandscapeLayoutWideFull",
    Evt_Internal_SwitchToPortraitLayout: "Evt_Internal_SwitchToPortraitLayout",
    Evt_Internal_SwitchToPortraitLayoutIPhone: "Evt_Internal_SwitchToPortraitLayoutIPhone",
    Evt_Internal_SwitchToPortraitLayoutIPad: "Evt_Internal_SwitchToPortraitLayoutIPad"
};
goog.provide("UHT.ModificationsManager_XChange");
goog.require("UHTMath.Vector3");
function AtlasChange() {
    this.Target = null;
    this.NewAtlas = null;
    this.oldPath = "";
    this.isSet = false
}
function TransformInfo() {
    this.Position = null;
    this.Scale = null;
    this.Rotation = 0
}
TransformInfo.prototype.SetPosition = function(_pos) {
    this.Position = new UHTMath.Vector3(_pos.x,_pos.y,_pos.z)
}
;
TransformInfo.prototype.SetScale = function(_scale) {
    this.Scale = new UHTMath.Vector3(_scale.x,_scale.y,_scale.z)
}
;
TransformInfo.prototype.SetRotation = function(_rot) {
    this.Rotation = _rot
}
;
function TransformChange() {
    this.Target = null;
    this.path = "";
    this.TransformData = null;
    this.isSet = false;
    this.active = true
}
TransformChange.prototype.SetValuesToElement = function(editmode) {
    if (!this.isSet)
        return;
    this.Target.localPosition(new UHTMath.Vector3(this.TransformData[0].Position.x,this.TransformData[0].Position.y,this.TransformData[0].Position.z));
    this.Target.localScale(new UHTMath.Vector3(this.TransformData[0].Scale.x,this.TransformData[0].Scale.y,this.TransformData[0].Scale.z));
    this.Target.localRotation(UHTMath.Quaternion.euler(this.Target.localEulerAngles().x, this.Target.localEulerAngles().y, this.TransformData[0].Rotation));
    this.Target.gameObject.SetActive(this.active)
}
;
function LabelChange() {
    this.Target = null;
    this.path = "";
    this.newContent = null;
    this.oldContent = "";
    this.hasDynamicContent = false;
    this.isSet = false;
    this.hasCustomEffects = true
}
LabelChange.prototype.SetValuesToLabel = function() {
    if (!this.isSet || this.Target == null)
        return;
    var label = this.Target.GetComponent(UILabel);
    this.SetValues(label)
}
;
LabelChange.prototype.SetValues = function(label) {
    ModificationsManager.CopyFromLabelToLabel(this.newContent, label, !this.hasDynamicContent, this.hasCustomEffects)
}
;
LabelChange.prototype.ReadValues = function(label) {}
;
LabelChange.prototype.RevertValue = function() {
    this.newContent.text = "<<<<<<" + this.oldContent
}
;
goog.require("UHT.Component");
RoutineQueue.prototype = Object.create(Component.prototype);
RoutineQueue.prototype.constructor = RoutineQueue;
function RoutineQueue() {
    Component.call(this);
    this.rqiList = [];
    this.isStarted = false
}
RoutineQueue.prototype.AddRoutineQueueItem = function(rqi) {
    this.rqiList.push(rqi)
}
;
RoutineQueue.prototype.Update = function() {
    if (this.isStarted)
        if (this.rqiList.length > 0)
            while (!this.rqiList[0].RQIUpdate()) {
                this.rqiList[0].RQIStop();
                this.rqiList.splice(0, 1);
                if (this.rqiList.length > 0)
                    this.rqiList[0].RQIStart();
                else
                    break
            }
}
;
RoutineQueue.prototype.StartRoutines = function() {
    if (this.rqiList.length > 0) {
        this.rqiList[0].RQIStart();
        this.isStarted = true
    } else
        console.error("RoutineQueue - Trying to start and empty Routine Queue")
}
;
RoutineQueue.prototype.StopRoutines = function() {
    if (this.rqiList.length > 0)
        this.rqiList[0].RQIStop();
    this.rqiList = [];
    this.isStarted = false
}
;
goog.provide("UHT.RoutineQueueItem");
function RoutineQueueItem() {}
RoutineQueueItem.prototype.RQIStart = function() {}
;
RoutineQueueItem.prototype.RQIUpdate = function() {
    return false
}
;
RoutineQueueItem.prototype.RQIStop = function() {}
;
goog.require("UHT.RoutineQueueItem");
RQIMarker.prototype = Object.create(RoutineQueueItem.prototype);
RQIMarker.prototype.constructor = RQIMarker;
function RQIMarker(t) {
    RoutineQueueItem.call(this);
    this.type = t
}
RQIMarker.MarkerType = {
    StartLineByLine: 0,
    EndLineByLine: 1
};
RQIMarker.prototype.RQIStart = function() {}
;
RQIMarker.prototype.RQIUpdate = function() {
    return false
}
;
RQIMarker.prototype.RQIStop = function() {}
;
goog.require("UHT.RoutineQueueItem");
RQITriggerCallback.prototype = Object.create(RoutineQueueItem.prototype);
RQITriggerCallback.prototype.constructor = RQITriggerCallback;
function RQITriggerCallback(_callback, _param, _object) {
    RoutineQueueItem.call(this);
    this.callback = _callback;
    this.param = _param;
    this.object = _object
}
RQITriggerCallback.prototype.RQIStart = function() {
    this.callback.call(this.object, this.param)
}
;
RQITriggerCallback.prototype.RQIUpdate = function() {
    return false
}
;
RQITriggerCallback.prototype.RQIStop = function() {}
;
goog.require("UHT.RoutineQueueItem");
RQITriggerEvent.prototype = Object.create(RoutineQueueItem.prototype);
RQITriggerEvent.prototype.constructor = RQITriggerEvent;
function RQITriggerEvent(eventToTrigger) {
    RoutineQueueItem.call(this);
    this.eventName = eventToTrigger
}
RQITriggerEvent.prototype.RQIStart = function() {
    XT.TriggerEvent(this.eventName)
}
;
RQITriggerEvent.prototype.RQIUpdate = function() {
    return false
}
;
RQITriggerEvent.prototype.RQIStop = function() {}
;
goog.require("UHT.RoutineQueueItem");
RQIWaitForSeconds.prototype = Object.create(RoutineQueueItem.prototype);
RQIWaitForSeconds.prototype.constructor = RQIWaitForSeconds;
function RQIWaitForSeconds(timeToWait) {
    RoutineQueueItem.call(this);
    this.waitTime = timeToWait;
    this.curTime = 0
}
RQIWaitForSeconds.prototype.RQIStart = function() {
    this.curTime = 0
}
;
RQIWaitForSeconds.prototype.RQIUpdate = function() {
    var firstUpdate = this.curTime == 0;
    this.curTime += Time.deltaTime;
    if (this.curTime > this.waitTime - .001 && !firstUpdate)
        return false;
    return true
}
;
RQIWaitForSeconds.prototype.RQIStop = function() {}
;
goog.require("UHT.RoutineQueueItem");
RQIWaitForXTEvent.prototype = Object.create(RoutineQueueItem.prototype);
RQIWaitForXTEvent.prototype.constructor = RQIWaitForXTEvent;
function RQIWaitForXTEvent(eventToWaitFor) {
    RoutineQueueItem.call(this);
    this.eventName = eventToWaitFor;
    this.eventReceived = false
}
RQIWaitForXTEvent.prototype.RQIStart = function() {
    this.eventReceived = false;
    XT.RegisterCallbackEvent(this.eventName, this.OnEventTriggered, this)
}
;
RQIWaitForXTEvent.prototype.RQIUpdate = function() {
    if (this.eventReceived == true)
        return false;
    return true
}
;
RQIWaitForXTEvent.prototype.RQIStop = function() {
    XT.UnregisterCallbackEvent(this.OnEventTriggered, this)
}
;
RQIWaitForXTEvent.prototype.OnEventTriggered = function() {
    this.eventReceived = true
}
;
goog.provide("UHT.BalanceData");
function BalanceData(balance, bonusbalance, time) {
    var b;
    var bb;
    var t;
    if (balance instanceof BalanceData) {
        b = balance.Balance;
        bb = balance.BonusBalance;
        t = balance.Time
    } else {
        if (typeof balance == "number")
            b = balance;
        if (typeof bonusbalance == "number")
            bb = bonusbalance;
        if (typeof time == "number")
            t = time
    }
    this.Balance = b || 0;
    this.BonusBalance = bb || 0;
    this.Time = t || 0
}
goog.provide("UHT.BaseDataStructures");
var Cloneable = function() {};
Cloneable.prototype.Clone = function() {}
;
function CasinoSoundState() {
    this.state = 0
}
CasinoSoundState.GlobalSoundOff = -1;
CasinoSoundState.SoundOff = 0;
CasinoSoundState.SoundOn = 1;
goog.require("UHT.BaseDataStructures");
function GameSettings(settings) {
    this.GameId = "";
    this.Error = false;
    var s;
    switch (typeof settings) {
    case "object":
        s = settings;
        break;
    case "string":
        s = this.FromString(settings);
        break
    }
    this.Settings = s || {}
}
GameSettings.prototype.FromString = function(settings) {
    this.Settings = this.BuildDictionaryFromString(settings, ";", "=")
}
;
GameSettings.prototype.ToString = function() {
    return this.DictionaryToString(this.Settings, ";", "=")
}
;
GameSettings.prototype.DictionaryToString = function(dict, pairSeparator, fieldSeparator) {
    var rv = [];
    for (var key in dict)
        rv.push([key, dict[key]].join(fieldSeparator));
    return rv.join(pairSeparator)
}
;
GameSettings.prototype.Clone = function() {
    var clone = new GameSettings;
    clone.GameId = this.GameId;
    clone.Error = this.Error;
    for (var key in this.Settings)
        clone.Settings[key] = this.Settings[key];
    return clone
}
;
GameSettings.prototype.BuildDictionaryFromString = function(str, pairSeparator, fieldSeparator) {
    var rv = {};
    if (!_string.IsNullOrEmpty(str)) {
        var pairs = str.split(pairSeparator);
        for (var i = 0; i < pairs.length; ++i) {
            var fields = pairs[i].split(fieldSeparator);
            if (fields.length == 2)
                rv[fields[0]] = fields[1]
        }
    }
    return rv
}
;
var GambleV2Protocol = {};
GambleV2Protocol.GambleResult = function() {
    this.level = -1;
    this.selectedIndex = -1;
    this.winIndex = -1;
    this.winAmount = 0;
    this.winMultiplier = 0;
    this.isWin = false;
    this.isEnd = false
}
;
GambleV2Protocol.GambleData = function() {
    this.riskAmount = 0;
    this.options = null;
    this.optionIndex = -1;
    this.result = null;
    this.totalWin = 0
}
;
GambleV2Protocol.Parser = {};
GambleV2Protocol.Parser.data = null;
GambleV2Protocol.Parser.ParseGambleData = function(dict) {
    var data = GambleV2Protocol.Parser.data;
    var key = "g_ra";
    if (dict[key] == undefined) {
        GambleV2Protocol.Parser.data = null;
        return null
    }
    if (data == null)
        data = GambleV2Protocol.Parser.data = new GambleV2Protocol.GambleData;
    data.riskAmount = _number.otod(dict[key]);
    key = "tw";
    if (dict[key] != undefined)
        data.totalWin = _number.otod(dict[key]);
    var collected = true;
    key = "go_i";
    if (dict[key] != undefined) {
        collected = false;
        data.options = _array.ConvertAll(dict[key].split(","), _number.otod)
    }
    key = "g_o";
    if (dict[key] != undefined) {
        collected = false;
        data.optionIndex = _number.otoi(dict[key])
    }
    data.result = GambleV2Protocol.Parser.ParseResult(dict);
    if (data.result != null)
        collected = false;
    else {
        var actions = ["g", "go"];
        key = "na";
        if (dict[key] != undefined && actions.indexOf(dict[key]) < 0)
            collected = true
    }
    if (collected) {
        data.options = null;
        data.optionIndex = -1;
        data.result = null
    }
    return data
}
;
GambleV2Protocol.Parser.ParseResult = function(dict) {
    var key = "g_w";
    if (dict[key] == undefined)
        return null;
    var ret = new GambleV2Protocol.GambleResult;
    ret.winAmount = _number.otod(dict[key]);
    ret.winIndex = _number.otoi(dict["g_wi"]);
    ret.winMultiplier = _number.otod(dict["g_mul"]);
    ret.level = _number.otoi(dict["g_l"]);
    ret.isWin = dict["g_r"] == "1";
    ret.isEnd = dict["g_end"] == "1";
    key = "g_si";
    if (dict[key] != undefined)
        ret.selectedIndex = _number.otoi(dict[key]);
    return ret
}
;
goog.require("UHT.BaseDataStructures");
function VsGamblingButtonState(gamblingSpinWin, gamblingFreeSpinWin, gamblingBonusWin) {
    this.GamblingOnSpinAvailable = gamblingSpinWin;
    this.GamblingOnFreespinWinAvailable = gamblingFreeSpinWin;
    this.GamblingOnBonusWinAvailable = gamblingBonusWin
}
VsGamblingButtonState.prototype.ToString = function() {
    return ["[VsGamblingButtonState gamblingSpinWin=", this.GamblingOnSpinAvailable, ", gamblingFreeSpinWin=", this.GamblingOnFreespinWinAvailable, ", gamblingBonusWin=", this.GamblingOnBonusWinAvailable, "]"].join("")
}
;
VsGamblingButtonState.prototype.Clone = function() {
    return new VsGamblingButtonState(this.GamblingOnSpinAvailable,this.GamblingOnFreespinWinAvailable,this.GamblingOnBonusWinAvailable)
}
;
goog.require("UHT.BaseDataStructures");
function VsGamblingHistory(winAmount) {
    this.History = [];
    this.WinAmount = typeof winAmount == "number" ? winAmount : 0
}
VsGamblingHistory.prototype.AddHistoryItem = function(item) {
    this.History.push(item)
}
;
VsGamblingHistory.prototype.Clone = function() {
    var cloned = new VsGamblingHistory;
    cloned.WinAmount = this.WinAmount;
    cloned.History = [];
    for (var i = 0; i < this.History.length; ++i)
        cloned.History[i] = this.History[i].Clone();
    return cloned
}
;
function VsGamblingRequest() {
    this.Choice = VsGamblingRequest.GamblingChoices.None
}
VsGamblingRequest.prototype.GetTypeOfChoice = function() {
    switch (this.Choice) {
    case VsGamblingRequest.GamblingChoices.Red:
        return GamblingType.CardColor;
    case VsGamblingRequest.GamblingChoices.Black:
        return GamblingType.CardColor;
    case VsGamblingRequest.GamblingChoices.Clubs:
        return GamblingType.Suit;
    case VsGamblingRequest.GamblingChoices.Spades:
        return GamblingType.Suit;
    case VsGamblingRequest.GamblingChoices.Diamond:
        return GamblingType.Suit;
    case VsGamblingRequest.GamblingChoices.Heart:
        return GamblingType.Suit;
    case VsGamblingRequest.GamblingChoices.Dices:
        return GamblingType.Dices
    }
    return GamblingType.None
}
;
VsGamblingRequest.GamblingChoices = {
    Red: 0,
    Black: 1,
    Clubs: 2,
    Spades: 3,
    Diamond: 4,
    Heart: 5,
    Dices: 6,
    None: -1
};
goog.require("UHT.BaseDataStructures");
var GamblingType = {
    CardColor: 0,
    Suit: 1,
    Dices: 2,
    None: 3
};
var GamblingState = {
    Lose: 0,
    Win: 1,
    WinLimit: 2
};
function VsGamblingResponse() {
    this.GamblingType = GamblingType.None;
    this.Card = -1;
    this.Dice1 = 0;
    this.Dice2 = 0;
    this.Balance = 0;
    this.State = GamblingState.Lose;
    this.NoMoney = false
}
VsGamblingResponse.prototype.GetGamblingType = function() {
    return this.GamblingType
}
;
VsGamblingResponse.prototype.SetGamblingType = function(gamblingType) {
    this.GamblingType = gamblingType
}
;
VsGamblingResponse.prototype.GetCard = function() {
    return this.Card
}
;
VsGamblingResponse.prototype.SetCard = function(card) {
    this.Card = card
}
;
VsGamblingResponse.prototype.GetDice1 = function() {
    return this.Dice1
}
;
VsGamblingResponse.prototype.SetDice1 = function(dice) {
    this.Dice1 = dice
}
;
VsGamblingResponse.prototype.GetDice2 = function() {
    return this.Dice2
}
;
VsGamblingResponse.prototype.SetDice2 = function(dice) {
    this.Dice2 = dice
}
;
VsGamblingResponse.prototype.GetBalance = function() {
    return this.Balance
}
;
VsGamblingResponse.prototype.SetBalance = function(balance) {
    this.Balance = balance
}
;
VsGamblingResponse.prototype.GetState = function() {
    return this.State
}
;
VsGamblingResponse.prototype.SetState = function(state) {
    this.State = state
}
;
VsGamblingResponse.prototype.IsNoMoney = function() {
    return this.NoMoney
}
;
VsGamblingResponse.prototype.SetNoMoney = function(isNoMoney) {
    this.NoMoney = isNoMoney
}
;
VsGamblingResponse.prototype.Clone = function() {
    var clone = new VsGamblingResponse;
    clone.GamblingType = this.GamblingType;
    clone.Card = this.Card;
    clone.Dice1 = this.Dice1;
    clone.Dice2 = this.Dice2;
    clone.Balance = this.Balance;
    clone.State = this.State;
    clone.NoMoney = this.NoMoney;
    return clone
}
;
goog.require("UHT.BaseDataStructures");
var GamblingOccasions = {
    Spin: 0,
    FreeSpin: 1,
    Bonus: 2
};
function VsGamblingSettings() {
    this.occasionsMap = {};
    this.GamblingSettings = {};
    this.SkipGambleOnInit = false;
    this.InitGamblingOccasion = GamblingOccasions.Spin
}
VsGamblingSettings.prototype.GetGamblingSettings = function(type) {
    if (this.GamblingSettings[type])
        return this.GamblingSettings[type];
    return null
}
;
VsGamblingSettings.prototype.SetGamblingSettings = function(type, multiplier) {
    this.GamblingSettings[type] = multiplier
}
;
VsGamblingSettings.prototype.SetOccasionStatus = function(occasion, enable) {
    this.occasionsMap[occasion] = enable
}
;
VsGamblingSettings.prototype.IsOccasionEnable = function(occasion) {
    if (this.occasionsMap[occasion])
        return this.occasionsMap[occasion];
    return false
}
;
VsGamblingSettings.prototype.Clone = function() {
    var cloned = new VsGamblingSettings;
    cloned.SkipGambleOnInit = this.SkipGambleOnInit;
    cloned.InitGamblingOccasion = this.InitGamblingOccasion;
    cloned.occasionsMap = {};
    for (var o in this.occasionsMap)
        cloned.occasionsMap[o] = this.occasionsMap[o];
    cloned.GamblingSettings = {};
    for (var s in this.GamblingSettings)
        cloned.GamblingSettings[s] = this.GamblingSettings[s];
    return cloned
}
;
goog.require("UHT.BaseDataStructures");
function VsBetLevel() {
    this.betLevelIndex = 0;
    this.betLevelScale = [];
    this.paytables = []
}
VsBetLevel.prototype.Clone = function() {
    var cloned = new VsBetLevel;
    cloned.betLevelIndex = this.betLevelIndex;
    cloned.betLevelScale = this.betLevelScale.slice();
    cloned.paytables = this.paytables.slice();
    return cloned
}
;
goog.require("UHT.BaseDataStructures");
function VsBonusGameData() {
    this.Level = -1;
    this.Life = -1;
    this.WinPoints = 0;
    this.RealWin = 0;
    this.Coef = 0;
    this.GameOver = false;
    this.IWins = null;
    this.BonusTable = new VsBonusGameDataTable;
    this.MultipliersTable = new VsBonusGameDataTable;
    this.MultiplierStep = false;
    this.numberOfLevels = -1;
    this.lifeWins = null;
    this.currentBonusRespin = 0;
    this.maxBonusRespins = 0;
    this.respinSymbols = null;
    this.initialized = false;
    this.PremultipliedWin = 0;
    this.RespinsTotalMultiplier = -1;
    this.ExtraRespinsWon = -1;
    this.MultipliedSymbolPositions = null;
    this.id = -1;
    this.type = -1;
    this.wheelOfFortune = null;
    this.map = null
}
VsBonusGameData.prototype.Clone = function() {
    var cloned = new VsBonusGameData;
    cloned.Level = this.Level;
    cloned.Life = this.Life;
    cloned.WinPoints = this.WinPoints;
    cloned.RealWin = this.RealWin;
    cloned.Coef = this.Coef;
    cloned.GameOver = this.GameOver;
    cloned.MultiplierStep = this.MultiplierStep;
    cloned.currentBonusRespin = this.currentBonusRespin;
    cloned.maxBonusRespins = this.maxBonusRespins;
    cloned.PremultipliedWin = this.PremultipliedWin;
    cloned.RespinsTotalMultiplier = this.RespinsTotalMultiplier;
    cloned.ExtraRespinsWon = this.ExtraRespinsWon;
    if (this.MultipliedSymbolPositions != null) {
        cloned.MultipliedSymbolPositions = [];
        for (var i = 0; i < this.MultipliedSymbolPositions.length; i++)
            cloned.MultipliedSymbolPositions.push(this.MultipliedSymbolPositions[i])
    }
    if (this.BonusTable != null)
        cloned.BonusTable = this.BonusTable.Clone();
    if (this.MultipliersTable != null)
        cloned.MultipliersTable = this.MultipliersTable.Clone();
    if (this.IWins != null)
        cloned.IWins = this.IWins.slice();
    if (this.lifeWins != null)
        cloned.lifeWins = this.lifeWins.slice();
    if (this.respinSymbols != null)
        cloned.respinSymbols = this.respinSymbols.slice();
    return cloned
}
;
VsBonusGameData.WheelOfFortune = function() {
    this.items = null;
    this.itemsStatus = null;
    this.stopPosition = -1;
    this.spinsLeft = -1;
    this.multiplier = -1;
    this.initialWin = -1
}
;
VsBonusGameData.WheelOfFortune.Item = function() {
    this.amount = 0;
    this.spinsNumber = 0;
    this.status = -1;
    this.selectedAtLevel = -1
}
;
VsBonusGameData.Map = function() {
    this.WOF_MultiplierIndex = -1;
    this.WOF_StopPosition = -1;
    this.WOF_Values = null;
    this.WOF_Mask = null;
    this.WOF_Map = null
}
;
goog.require("UHT.BaseDataStructures");
function VsBonusGameDataTable() {
    this.Status = null;
    this.Markers = null;
    this.Wins = null;
    this.WinsMask = null;
    this.BGItemValues = null;
    this.BGItemMasks = null
}
VsBonusGameDataTable.prototype.Clone = function() {
    var cloned = new VsBonusGameDataTable;
    cloned.Status = [];
    cloned.Markers = null;
    cloned.Wins = [];
    cloned.WinsMask = null;
    if (this.Status != null)
        cloned.Status = this.Status.slice();
    if (this.Wins != null)
        cloned.Wins = this.Wins.slice();
    if (this.Markers != null)
        cloned.Markers = this.Markers.slice();
    if (this.WinsMask != null)
        cloned.WinsMask = this.WinsMask.slice();
    if (this.BGItemValues != null)
        cloned.BGItemValues = this.BGItemValues.slice();
    if (this.BGItemMasks != null)
        cloned.BGItemMasks = this.BGItemMasks.slice();
    return cloned
}
;
function VsBonusGamePlayerChoice(index) {
    this.Index = index;
    this.PickType = 0
}
function VsExpandingSymbolData() {
    this.ExpandingSymbolId = 0;
    this.SourcePositions = [];
    this.TargetPositions = []
}
VsExpandingSymbolData.prototype.Clone = function() {
    var clone = new VsExpandingSymbolData;
    clone.ExpandingSymbolId = this.ExpandingSymbolId;
    clone.SourcePositions = this.SourcePositions.slice();
    clone.TargetPositions = this.TargetPositions.slice();
    return clone
}
;
VsExpandingSymbolData.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VsFreeRound() {
    this.RoundsLeft = 0;
    this.TotalWin = 0
}
VsFreeRound.prototype.ToString = function() {
    return "{RoundsLeft:" + this.RoundsLeft + ", TotalWin:" + this.TotalWin + "]}"
}
;
VsFreeRound.prototype.Clone = function() {
    var clone = new VsFreeRound;
    clone.RoundsLeft = this.RoundsLeft;
    clone.TotalWin = this.TotalWin;
    return clone
}
;
VsFreeRound.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VsFreeRoundEvent() {
    this.Type = VsFreeRoundEvent.EventType.Start;
    this.Bet = 0;
    this.Lines = 0;
    this.RoundsLeft = 0
}
VsFreeRoundEvent.EventType = {
    Start: 0,
    Finish: 1,
    Error: 2
};
VsFreeRoundEvent.prototype.ToString = function() {
    return "{Type:" + this.Type + ", Bet:" + this.Bet + ", Lines:" + this.Lines + ", RoundsLeft:" + this.RoundsLeft + "}"
}
;
VsFreeRoundEvent.prototype.Clone = function() {
    var clone = new VsFreeRoundEvent;
    clone.Type = this.Type;
    clone.Bet = this.Bet;
    clone.Lines = this.Lines;
    clone.RoundsLeft = this.RoundsLeft;
    return clone
}
;
VsFreeRoundEvent.prototype.CloneHelper = function() {
    return this.Clone()
}
;
goog.provide("UHT.VsFreeSpinBonusGame");
goog.require("UHT.BaseDataStructures");
function VsFreeSpinBonusGame() {
    this.BonusItems = [];
    this.GameOver = false;
    this.Level = 0;
    this.Lifes = -1;
    this.SpinsWin = 0;
    this.MultipliersWin = 0
}
VsFreeSpinBonusGame.prototype.Clone = function() {
    var cloned = new VsFreeSpinBonusGame;
    cloned.GameOver = this.GameOver;
    cloned.Level = this.Level;
    cloned.Lifes = this.Lifes;
    cloned.SpinsWin = this.SpinsWin;
    cloned.MultipliersWin = this.MultipliersWin;
    if (this.BonusItems != null)
        cloned.BonusItems = this.BonusItems.slice();
    return cloned
}
;
VsFreeSpinBonusGame.BonusItem = function(value, status, type) {
    this.Value = value;
    this.Status = status;
    this.Type = type
}
;
VsFreeSpinBonusGame.BonusItem.BonusItemStatus = {
    Available: 0,
    Selected: 1
};
VsFreeSpinBonusGame.BonusItem.BonusItemType = {
    Spin: 0,
    Multiplier: 1
};
VsFreeSpinBonusGame.BonusItem.prototype.ToString = function() {
    return "BonusItem {" + "Status=" + this.Status + ", Type=" + this.Type + ", Value=" + this.Value + "}"
}
;
goog.require("UHT.VsFreeSpinBonusGame");
goog.require("UHT.BaseDataStructures");
function VsFreeSpin() {
    this._currentNumber = 0;
    this._maxNumber = 0;
    this._totalNumber = 0;
    this._currentWin = 0;
    this._totalWin = 0;
    this._totalMultipl = 0;
    this._currentWinMultiplied = 0;
    this._totalWinMultiplied = 0;
    this.PickedOptionIndex = -1;
    this.BonusGame = null;
    this._mysteryScatter = null;
    this._needGetMysteryScatter = false;
    this.fstype = -1
}
VsFreeSpin.prototype.SetCurrentNumber = function(currentNumber) {
    this._currentNumber = currentNumber
}
;
VsFreeSpin.prototype.GetCurrentNumber = function() {
    return this._currentNumber
}
;
VsFreeSpin.prototype.SetMaxNumber = function(maxNumber) {
    this._maxNumber = maxNumber
}
;
VsFreeSpin.prototype.GetMaxNumber = function() {
    return this._maxNumber
}
;
VsFreeSpin.prototype.SetTotalNumber = function(totalNumber) {
    this._totalNumber = totalNumber
}
;
VsFreeSpin.prototype.GetTotalNumber = function() {
    return this._totalNumber
}
;
VsFreeSpin.prototype.SetTotalWin = function(totalWin) {
    this._totalWin = totalWin
}
;
VsFreeSpin.prototype.GetTotalWin = function() {
    return this._totalWin
}
;
VsFreeSpin.prototype.SetTotalMultipl = function(totalMultipl) {
    this._totalMultipl = totalMultipl
}
;
VsFreeSpin.prototype.GetTotalMultipl = function() {
    return this._totalMultipl
}
;
VsFreeSpin.prototype.IsLastFreeSpin = function() {
    return this._totalNumber > 0
}
;
VsFreeSpin.prototype.IsFirstFreeSpin = function() {
    return this._currentNumber == 1
}
;
VsFreeSpin.prototype.GetCurrentWin = function() {
    return this._currentWin
}
;
VsFreeSpin.prototype.SetCurrentWin = function(currentWin) {
    this._currentWin = currentWin
}
;
VsFreeSpin.prototype.GetCurrentWinMultiplied = function() {
    return this._currentWinMultiplied
}
;
VsFreeSpin.prototype.SetCurrentWinMultiplied = function(value) {
    this._currentWinMultiplied = value
}
;
VsFreeSpin.prototype.SetTotalWinMultiplied = function(value) {
    this._totalWinMultiplied = value
}
;
VsFreeSpin.prototype.GetTotalWinMultiplied = function() {
    return this._totalWinMultiplied
}
;
VsFreeSpin.prototype.GetMysteryScatter = function() {
    return this._mysteryScatter
}
;
VsFreeSpin.prototype.SetMysteryScatter = function(mysteryScatter) {
    this._mysteryScatter = mysteryScatter
}
;
VsFreeSpin.prototype.IsNeedGetMysteryScatter = function() {
    return this._needGetMysteryScatter
}
;
VsFreeSpin.prototype.SetNeedGetMysteryScatter = function(needGetMysteryScatter) {
    this._needGetMysteryScatter = needGetMysteryScatter
}
;
VsFreeSpin.prototype.Clone = function() {
    var cloned = new VsFreeSpin;
    cloned._currentNumber = this._currentNumber;
    cloned._maxNumber = this._maxNumber;
    cloned._totalNumber = this._totalNumber;
    cloned._currentWin = this._currentWin;
    cloned._totalWin = this._totalWin;
    cloned._totalMultipl = this._totalMultipl;
    cloned._currentWinMultiplied = this._currentWinMultiplied;
    cloned._totalWinMultiplied = this._totalWinMultiplied;
    cloned.PickedOptionIndex = this.PickedOptionIndex;
    cloned._mysteryScatter = this._mysteryScatter;
    cloned._needGetMysteryScatter = this._needGetMysteryScatter;
    if (this.BonusGame != null)
        cloned.BonusGame = this.BonusGame.Clone();
    return cloned
}
;
function VsFreeSpinOption() {
    this.FreeSpinsCount = 0;
    this.FreeSpinsMultiplier = 0;
    this.FreeSpinsStackedSymbol = 0;
    this.WildSymbolIndex = -1;
    this.SpecialFeatureName = "";
    this.ReelSymbolsToBeReplaced = [];
    this.RSTBSymbolId = -1;
    this.TriggerSymbolRandomMultiplier = -1;
    this.TSRandomMultipliers = [];
    this.WildWinMultipliers = []
}
VsFreeSpinOption.prototype.Clone = function() {
    var clone = new VsFreeSpinOption;
    clone.FreeSpinsCount = this.FreeSpinsCount;
    clone.FreeSpinsMultiplier = this.FreeSpinsMultiplier;
    clone.FreeSpinsStackedSymbol = this.FreeSpinsStackedSymbol;
    clone.WildSymbolIndex = this.WildSymbolIndex;
    clone.SpecialFeatureName = this.SpecialFeatureName;
    clone.WildWinMultipliers = [];
    for (var i = 0; i < this.WildWinMultipliers.length; ++i)
        clone.WildWinMultipliers.push(this.WildWinMultipliers[i]);
    clone.ReelSymbolsToBeReplaced = [];
    for (var i = 0; i < this.ReelSymbolsToBeReplaced.length; ++i)
        clone.ReelSymbolsToBeReplaced.push(this.ReelSymbolsToBeReplaced[i]);
    clone.RSTBSymbolId = this.RSTBSymbolId;
    clone.TriggerSymbolRandomMultiplier = this.TriggerSymbolRandomMultiplier;
    clone.TSRandomMultipliers = [];
    for (var i = 0; i < this.TSRandomMultipliers.length; ++i)
        clone.TSRandomMultipliers.push(this.TSRandomMultipliers[i]);
    return clone
}
;
VsFreeSpinOption.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VsFreeSpinsChainData() {
    this.FSCSpins = [];
    this.FSCMultipliers = [];
    this.FSCSpinsTotal = [];
    this.FSCMultipliersTotal = [];
    this.FSCWinsTotal = [];
    this.FSCMultipliedWinsTotal = [];
    this.FSCSessionsWonThisSpin = 0;
    this.FSCSessionsWonSymbolsCount = []
}
VsFreeSpinsChainData.prototype.HasChainInformation = function() {
    return this.HasNextChainInformation() || this.HasPreviousChainInformation()
}
;
VsFreeSpinsChainData.prototype.HasNextChainInformation = function() {
    return this.FSCSpins != null || this.FSCMultipliers != null || this.FSCSessionsWonSymbolsCount != null || this.FSCSessionsWonThisSpin > 0
}
;
VsFreeSpinsChainData.prototype.HasPreviousChainInformation = function() {
    return this.FSCSpinsTotal != null && this.FSCMultipliersTotal != null && this.FSCWinsTotal != null && this.FSCMultipliedWinsTotal != null
}
;
VsFreeSpinsChainData.prototype.Clone = function() {
    var cloned = new VsFreeSpinsChainData;
    if (this.FSCSpins != null)
        cloned.FSCSpins = this.FSCSpins.slice();
    if (this.FSCMultipliers != null)
        cloned.FSCMultipliers = this.FSCMultipliers.slice();
    if (this.FSCSpinsTotal != null)
        cloned.FSCSpinsTotal = this.FSCSpinsTotal.slice();
    if (this.FSCMultipliersTotal != null)
        cloned.FSCMultipliersTotal = this.FSCMultipliersTotal.slice();
    if (this.FSCWinsTotal != null)
        cloned.FSCWinsTotal = this.FSCWinsTotal.slice();
    if (this.FSCMultipliedWinsTotal != null)
        cloned.FSCMultipliedWinsTotal = this.FSCMultipliedWinsTotal.slice();
    cloned.FSCSessionsWonThisSpin = this.FSCSessionsWonThisSpin;
    if (this.FSCSessionsWonSymbolsCount != null)
        cloned.FSCSessionsWonSymbolsCount = this.FSCSessionsWonSymbolsCount.slice();
    return cloned
}
;
VsFreeSpinsChainData.prototype.CloneHelper = function() {
    return this.Clone()
}
;
goog.require("UHT.BaseDataStructures");
function VsFSPurchaseData() {
    this.freeSpinsBought = 0
}
VsFSPurchaseData.prototype.Clone = function() {
    var cloned = new VsFSPurchaseData;
    cloned.freeSpinsBought = this.freeSpinsBought;
    return cloned
}
;
function VsFSPurchaseConfig() {
    this.purchaseOptions = [];
    this.optionIndex = -2
}
VsFSPurchaseConfig.PurchaseOption = function() {
    this.bet = 0;
    this.fsCount = 0;
    this.betLevel = 0
}
;
VsFSPurchaseConfig.prototype.Clone = function() {
    var cloned = new VsFSPurchaseConfig;
    cloned.optionIndex = this.optionIndex;
    cloned.purchaseOptions = [];
    for (var i = 0; i < this.purchaseOptions.length; i++) {
        cloned.purchaseOptions.push(new VsFSPurchaseConfig.PurchaseOption);
        cloned.purchaseOptions[i].bet = this.purchaseOptions[i].bet;
        cloned.purchaseOptions[i].fsCount = this.purchaseOptions[i].fsCount;
        cloned.purchaseOptions[i].betLevel = this.purchaseOptions[i].betLevel
    }
    return cloned
}
;
function VsGoldSymbol() {
    this.reels = null;
    this.symbols = null;
    this.awards = null
}
VsGoldSymbol.prototype.Clone = function() {
    var cloned = new VsGoldSymbol;
    if (this.reels != null)
        cloned.reels = this.reels.slice();
    if (this.symbols != null)
        cloned.symbols = this.symbols.slice();
    if (this.awards != null)
        cloned.awards = this.awards.slice();
    return cloned
}
;
goog.require("UHT.BaseDataStructures");
function VsInitData() {
    this.Bets = [];
    this._reelSymbols = [];
    this.ReelSets = null;
    this.NextReelSymbols = [];
    this.Bet = 0;
    this.DefaultBet = 0;
    this.Line = 0;
    this.Scatters = null;
    this.Paytable = null;
    this.Wilds = null;
    this.WildScatters = null;
    this.Bonuses = null;
    this.GamblingSettings = null;
    this.GamblingHistory = null;
    this.WildRandomLineMpConfig = null;
    this.RandomAwardConfig = null;
    this.ProgressiveConfig = null;
    this.MoneySymbolConfig = null;
    this.BetLevelSettings = null;
    this.FreeSpinsPurchaseConfig = null;
    this.ReelSetIndex = -1;
    this.ReelSetIndexCurrent = -1;
    this.StackedSymbolIndex = -1;
    this.StackedSymbolIndexCurrent = -1;
    this.InitialMysterySymbolId = -1;
    this.BGItemValues = [];
    this.BGItemMasks = [];
    this.naSymbolId = -1;
    Object.defineProperties(this, {
        "ReelSymbols": {
            set: function(value) {
                this._reelSymbols = value
            },
            get: function() {
                if (this.ReelSets != null) {
                    if (this.ReelSetIndexCurrent >= 0)
                        return this.ReelSets[this.ReelSetIndexCurrent];
                    return this.ReelSets[this.ReelSetIndex]
                }
                return this._reelSymbols
            }
        }
    })
}
VsInitData.prototype.CombinePaytable = function() {
    if (this.Paytable != null) {
        var i;
        if (this.Scatters != null)
            if (this.Scatters[0].Pays != null) {
                this.Paytable[1] = [];
                for (i = 0; i < this.Scatters[0].Pays.length; i++)
                    this.Paytable[1].push(this.Scatters[0].Pays[i])
            }
        if (this.Wilds != null)
            if (this.Wilds[0].Pays != null) {
                this.Paytable[2] = [];
                for (i = 0; i < this.Wilds[0].Pays.length; i++)
                    this.Paytable[2].push(this.Wilds[0].Pays[i])
            }
    }
}
;
VsInitData.prototype.Clone = function() {
    var cloned = new VsInitData;
    cloned.Bet = this.Bet;
    cloned.Line = this.Line;
    cloned.ReelSetIndex = this.ReelSetIndex;
    cloned.ReelSetIndexCurrent = this.ReelSetIndexCurrent;
    cloned.StackedSymbolIndex = this.StackedSymbolIndex;
    cloned.StackedSymbolIndexCurrent = this.StackedSymbolIndexCurrent;
    cloned.InitialMysterySymbolId = this.InitialMysterySymbolId;
    if (this.Bets != null)
        cloned.Bets = this.Bets.slice();
    var i;
    if (this._reelSymbols != null) {
        cloned._reelSymbols = [];
        for (i = 0; i < this._reelSymbols.length; ++i)
            cloned._reelSymbols[i] = this._reelSymbols[i].slice()
    }
    if (this.ReelSets != null) {
        cloned.ReelSets = [];
        for (i = 0; i < this.ReelSets.length; i++) {
            cloned.ReelSets[i] = [];
            for (var j = 0; j < this.ReelSets[i].length; j++)
                cloned.ReelSets[i][j] = this.ReelSets[i][j].slice()
        }
    }
    if (this.NextReelSymbols != null) {
        cloned.NextReelSymbols = [];
        for (i = 0; i < this.NextReelSymbols.length; ++i)
            cloned.NextReelSymbols[i] = this.NextReelSymbols[i].slice()
    }
    if (this.Scatters != null) {
        cloned.Scatters = [];
        for (i = 0; i < this.Scatters.length; ++i)
            cloned.Scatters[i] = this.Scatters[i].Clone()
    }
    if (this.Paytable != null) {
        cloned.Paytable = [];
        for (i = 0; i < this.Paytable.length; ++i)
            cloned.Paytable[i] = this.Paytable[i].slice()
    }
    if (this.Wilds != null) {
        cloned.Wilds = [];
        for (i = 0; i < this.Wilds.length; ++i)
            cloned.Wilds[i] = this.Wilds[i].Clone()
    }
    if (this.WildScatters != null) {
        cloned.WildScatters = [];
        for (i = 0; i < this.WildScatters.length; ++i)
            cloned.WildScatters[i] = this.WildScatters[i].Clone()
    }
    if (this.Bonuses != null)
        cloned.Bonuses = this.Bonuses.slice();
    if (this.GamblingSettings != null)
        cloned.GamblingSettings = this.GamblingSettings.Clone();
    if (this.GamblingHistory != null)
        cloned.GamblingHistory = this.GamblingHistory.Clone();
    if (this.RandomAwardConfig != null)
        cloned.RandomAwardConfig = this.RandomAwardConfig.Clone();
    if (this.ProgressiveConfig != null)
        cloned.ProgressiveConfig = this.ProgressiveConfig.CloneHelper();
    if (this.MoneySymbolConfig != null)
        cloned.MoneySymbolConfig = this.MoneySymbolConfig.Clone();
    if (this.BetLevelSettings != null)
        cloned.BetLevelSettings = this.BetLevelSettings.Clone();
    if (this.FreeSpinsPurchaseConfig != null)
        cloned.FreeSpinsPurchaseConfig = this.FreeSpinsPurchaseConfig.Clone();
    return cloned
}
;
goog.require("UHT.BaseDataStructures");
function VsJackpotConfiguration() {
    this.LineCombinationToWin = [];
    this.MinBetToWin = 0;
    this.MinLineNumberToWin = 0
}
VsJackpotConfiguration.prototype.Clone = function() {
    var clone = new VsJackpotConfiguration;
    clone.MinBetToWin = this.MinBetToWin;
    clone.MinLineNumberToWin = this.MinLineNumberToWin;
    if (this.LineCombinationToWin != null)
        clone.LineCombinationToWin = this.LineCombinationToWin.slice();
    return clone
}
;
goog.require("UHT.BaseDataStructures");
function VsJackpotData(active, wonID, wonOrder, wonAmount) {
    this.IsActive = active || false;
    this.JackpotID = wonID || 0;
    this.JackpotOrder = wonOrder || 0;
    this.WinJackpotAmount = wonAmount || 0;
    Object.defineProperty(this, "IsWin", {
        get: function() {
            return this.WinJackpotAmount > 0
        }
    })
}
VsJackpotData.prototype.IsWin = false;
VsJackpotData.prototype.Clone = function() {
    return new VsJackpotData(this.IsActive,this.JackpotID,this.JackpotOrder,this.WinJackpotAmount)
}
;
function VsJackpotVisualization() {
    this.jpvType = VsJackpotVisualization.JpType.badges;
    this.positions = null
}
VsJackpotVisualization.JpType = {
    badges: 0
};
VsJackpotVisualization.prototype.Clone = function() {
    var cloned = new VsJackpotVisualization;
    cloned.jpvType = this.jpvType;
    if (this.positions != null)
        cloned.positions = this.positions.slice();
    return cloned
}
;
function VsMergingSymbol() {
    this.mergingPosition = -1;
    this.mergedSymbolId = -1
}
VsMergingSymbol.prototype.Clone = function() {
    var cloned = new VsMergingSymbol;
    cloned.mergingPosition = this.mergingPosition;
    cloned.mergedSymbolId = this.mergedSymbolId;
    return cloned
}
;
VsMergingSymbol.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VsMoneySymbolConfig() {
    this.symbolID = -1;
    this.possibleValues = null;
    this.jackpotValues = null;
    this.jackpotMasks = null
}
VsMoneySymbolConfig.prototype.Clone = function() {
    var cloned = new VsMoneySymbolConfig;
    cloned.symbolID = this.symbolID;
    if (this.possibleValues != null)
        cloned.possibleValues = this.possibleValues.slice();
    if (this.jackpotValues != null)
        cloned.jackpotValues = this.jackpotValues.slice();
    if (this.jackpotMasks != null)
        cloned.jackpotMasks = this.jackpotMasks.slice();
    return cloned
}
;
function VsMoneySymbolData() {
    this.currentValues = null;
    this.currentSymbolsLook = null
}
VsMoneySymbolData.prototype.Clone = function() {
    var cloned = new VsMoneySymbolData;
    if (this.currentValues != null)
        cloned.currentValues = this.currentValues.slice();
    if (this.currentSymbolsLook != null)
        cloned.currentSymbolsLook = this.currentSymbolsLook.slice();
    return cloned
}
;
goog.require("UHT.BaseDataStructures");
function VsNudgedSymbolsData(reelID, startingSymbolsIDs, nudgedSymbolsIDs, nudgedStopPosition, nudgeDirection) {
    this.reelID = reelID;
    this.startingSymbolsIDs = startingSymbolsIDs;
    this.nudgedSymbolsIDs = nudgedSymbolsIDs;
    this.nudgedStopPosition = nudgedStopPosition;
    this.nudgeDirection = nudgeDirection
}
VsNudgedSymbolsData.prototype.Clone = function() {
    var cloned = new VsNudgedSymbolsData(this.reelID,this.startingSymbolsIDs,this.nudgedSymbolsIDs,this.nudgedStopPosition,this.nudgeDirection);
    if (this.startingSymbolsIDs != null)
        cloned.startingSymbolsIDs = this.startingSymbolsIDs.slice();
    if (this.nudgedSymbolsIDs != null)
        cloned.nudgedSymbolsIDs = this.nudgedSymbolsIDs.slice();
    return cloned
}
;
function VsOpeningSymbolsData() {
    this.Positions = [];
    this.OSFreeSpinsWon = 0;
    this.OSMultiplierWon = 0
}
VsOpeningSymbolsData.prototype.Clone = function() {
    var cloned = new VsOpeningSymbolsData;
    if (this.Positions != null)
        cloned.Positions = this.Positions.slice();
    cloned.OSFreeSpinsWon = this.OSFreeSpinsWon;
    cloned.OSMultiplierWon = this.OSMultiplierWon;
    return cloned
}
;
VsOpeningSymbolsData.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VsPossibleRandomSymbolMultipliers() {
    this.symbolId = -1;
    this.symbolMultipliers = []
}
VsPossibleRandomSymbolMultipliers.prototype.Clone = function() {
    var clone = new VsPossibleRandomSymbolMultipliers;
    clone.symbolId = this.symbolId;
    for (var i = 0; i < this.symbolMultipliers.length; i++)
        clone.symbolMultipliers.push(this.symbolMultipliers[i]);
    return clone
}
;
VsPossibleRandomSymbolMultipliers.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VSProgressiveFeatureConfig() {
    this.pickedSymbolPosition = -1;
    this.progressSymbolIDs = null
}
VSProgressiveFeatureConfig.prototype.CloneHelper = function() {
    return this.Clone()
}
;
VSProgressiveFeatureConfig.prototype.Clone = function() {
    var cloned = new VSProgressiveFeatureConfig;
    cloned.pickedSymbolPosition = this.pickedSymbolPosition;
    if (this.progressSymbolIDs != null)
        cloned.progressSymbolIDs = this.progressSymbolIDs.slice();
    return cloned
}
;
function VsProgressiveFeatureData() {
    this.needsReset = false;
    this.level = 0;
    this.progress = 0;
    this.targetProgress = 0;
    this.currentAttempt = 0;
    this.attempts = 0;
    this.accumulatedWin = 0;
    this.prizeWin = 0;
    this.prizeMultiplier = 0;
    this.winMultiplier = 0
}
VsProgressiveFeatureData.prototype.Clone = function() {
    var cloned = new VsProgressiveFeatureData;
    cloned.needsReset = this.needsReset;
    cloned.level = this.level;
    cloned.progress = this.progress;
    cloned.targetProgress = this.targetProgress;
    cloned.currentAttempt = this.currentAttempt;
    cloned.attempts = this.attempts;
    cloned.accumulatedWin = this.accumulatedWin;
    cloned.prizeWin = this.prizeWin;
    cloned.prizeMultiplier = this.prizeMultiplier;
    cloned.winMultiplier = this.winMultiplier;
    return cloned
}
;
VsProgressiveFeatureData.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VsRandomAwardConfig() {
    this.awardReelsCount = 0;
    this.awardReels = null;
    this.awardSymbolsNormal = null;
    this.awardSymbolsFreeSpins = null;
    this.possibleAwards = null
}
VsRandomAwardConfig.prototype.GetAwardIndex = function(award) {
    for (var i = 0; i < this.possibleAwards.length; i++)
        if (award.Type == this.possibleAwards[i].Type && award.Value == this.possibleAwards[i].Value)
            return i;
    return -1
}
;
VsRandomAwardConfig.prototype.GetAwardAtIndex = function(index) {
    return this.possibleAwards[index]
}
;
VsRandomAwardConfig.prototype.GetSmallestAwardOnReel = function(reelIdx) {
    var min = this.GetAwardIndex(this.awardReels[reelIdx][0]);
    for (var i = 0; i < this.awardReels[reelIdx].length; i++)
        if (min > this.GetAwardIndex(this.awardReels[reelIdx][i]))
            min = this.GetAwardIndex(this.awardReels[reelIdx][i]);
    return min
}
;
VsRandomAwardConfig.prototype.ProcessPossibleAwards = function() {
    var i;
    var j;
    var tmp;
    this.possibleAwards = [];
    for (i = 0; i < this.awardReelsCount; i++)
        for (j = 0; j < this.awardReels[i].length; j++)
            if (!this.ListContains(this.possibleAwards, this.awardReels[i][j]))
                this.possibleAwards.push(this.awardReels[i][j]);
    for (i = 0; i < this.possibleAwards.length; i++)
        for (j = 0; j < this.possibleAwards.length - 1; j++)
            if (this.possibleAwards[j].Type == VsRandomAward.AwardType.Multiplier && this.possibleAwards[j + 1].Type == VsRandomAward.AwardType.Multiplier) {
                if (this.possibleAwards[j + 1].Value < this.possibleAwards[j].Value) {
                    tmp = this.possibleAwards[j];
                    this.possibleAwards[j] = this.possibleAwards[j + 1];
                    this.possibleAwards[j + 1] = tmp
                }
            } else if (this.possibleAwards[j].Type == VsRandomAward.AwardType.Trigger && this.possibleAwards[j + 1].Type == VsRandomAward.AwardType.Multiplier) {
                tmp = this.possibleAwards[j];
                this.possibleAwards[j] = this.possibleAwards[j + 1];
                this.possibleAwards[j + 1] = tmp
            }
}
;
VsRandomAwardConfig.prototype.ListContains = function(_list, award) {
    for (var i = 0; i < _list.length; i++)
        if (_list[i].Type == award.Type && _list[i].Value == award.Value)
            return true;
    return false
}
;
VsRandomAwardConfig.prototype.Clone = function() {
    var clone = new VsRandomAwardConfig;
    clone.awardReelsCount = this.awardReelsCount;
    if (this.awardReels != null) {
        clone.awardReels = [];
        for (var i = 0; i < this.awardReels.length; i++)
            clone.awardReels.push(this.awardReels[i].slice())
    }
    if (this.awardSymbolsNormal != null)
        clone.awardSymbolsNormal = this.awardSymbolsNormal.slice();
    if (this.awardSymbolsFreeSpins != null)
        clone.awardSymbolsFreeSpins = this.awardSymbolsFreeSpins.slice();
    if (this.possibleAwards != null)
        clone.possibleAwards = this.possibleAwards.slice();
    return clone
}
;
function VsRandomAward() {
    this.Type = VsRandomAward.AwardType.None;
    this.Value = 0;
    this.FeatureID = -1
}
VsRandomAward.AwardType = {
    None: 0,
    Trigger: 1,
    Multiplier: 2,
    FeatureTrigger: 3
};
function VsRandomSymbolMultiplier() {
    this.symbolId = -1;
    this.symbolPositions = [];
    this.multiplierValue = -1
}
VsRandomSymbolMultiplier.prototype.Clone = function() {
    var clone = new VsRandomSymbolMultiplier;
    clone.symbolId = this.symbolId;
    for (var i = 0; i < this.symbolPositions.length; i++)
        clone.symbolPositions.push(this.symbolPositions[i]);
    clone.multiplierValue = this.multiplierValue;
    return clone
}
;
VsRandomSymbolMultiplier.prototype.CloneHelper = function() {
    return this.Clone()
}
;
function VsRandomWildsData() {
    this.RandomSymbolID = 0;
    this.TargetPositions = null
}
VsRandomWildsData.prototype.Clone = function() {
    var cloned = new VsRandomWildsData;
    cloned.RandomSymbolID = this.RandomSymbolID;
    cloned.TargetPositions = null;
    if (this.TargetPositions != null) {
        cloned.TargetPositions = [];
        for (var i = 0; i < this.TargetPositions.length; i++)
            cloned.TargetPositions.push(this.TargetPositions[i])
    }
    return cloned
}
;
VsRandomWildsData.prototype.CloneHelper = function() {
    return this.Clone()
}
;
goog.require("UHT.BaseDataStructures");
function VsRequest() {
    this.Bet = 0;
    this.Line = 0;
    this.Symbol = "";
    this.BonusGameChoice = "";
    this.TryMeOnce = false;
    this.ProgressPick = -1
}
VsRequest.prototype.Clone = function() {
    var clone = new VsRequest;
    clone.Bet = this.Bet;
    clone.Line = this.Line;
    clone.Symbol = this.Symbol;
    clone.BonusGameChoice = this.BonusGameChoice;
    clone.TryMeOnce = this.TryMeOnce;
    clone.ProgressPick = this.ProgressPick;
    return clone
}
;
function VsRespinLine() {
    this.id = 0;
    this.respinsCount = 0;
    this.positions = null
}
function VsRespin() {
    this.RespinType = "";
    this.Indices = [];
    this.CurrentRespin = -1;
    this.MaxRespins = -1;
    this.TotalRespins = -1;
    this.IsDone = false;
    this.RespinsPlayed = -1;
    this.RespinsAdded = -1;
    this.Lines = null
}
VsRespin.prototype.Clone = function() {
    var cloned = new VsRespin;
    cloned.RespinType = this.RespinType;
    if (this.Indices != null) {
        cloned.Indices = [];
        for (var i = 0; i < this.Indices.length; ++i)
            cloned.Indices[i] = this.Indices[i].slice()
    }
    cloned.CurrentRespin = this.CurrentRespin;
    cloned.MaxRespins = this.MaxRespins;
    cloned.TotalRespins = this.TotalRespins;
    cloned.IsDone = this.IsDone;
    cloned.RespinsPlayed = this.RespinsPlayed;
    cloned.RespinsAdded = this.RespinsAdded;
    cloned.Lines = this.Lines;
    return cloned
}
;
VsRespin.prototype.CloneHelper = function() {
    return this.Clone()
}
;
goog.require("UHT.BaseDataStructures");
var NextGameAction = {
    None: 0,
    Spin: 1,
    Collect: 2,
    Gamble: 3,
    Bonus: 4,
    CollectBonus: 5,
    FSOption: 6,
    MysteryScatter: 7,
    FSBonus: 8,
    GambleCollect: 9,
    JackpotCollect: 10,
    GambleOption: 11
};
function VsResponse() {
    this.SlotHeight = 3;
    this.SlotLines = 0;
    this.Balance = 0;
    this.BonusBalance = 0;
    this.Win = 0;
    this.ExtraAwardWin = 0;
    this.RespinCycleWin = 0;
    this.RandomWildsData = null;
    this.UpSymbols = null;
    this.ExpandingSymbolsData = null;
    this.SymbolsBeforeExpanding = [];
    this.WinScreenSymbols = [];
    this.ReelPositions = [];
    this.VsWinLines = [];
    this.VsBonusGame = null;
    this.FreeSpinsOptions = null;
    this.WildRandomMultipliers = null;
    this.VsFreeSpin = null;
    this.FreeRound = null;
    this.FreeRoundEvents = null;
    this.VsInitData = null;
    this.JackpotVisualisation = null;
    this.GoldSymbol = null;
    this.SymbolReplacementData = null;
    this.WRLMResponse = null;
    this.WRLMCurrentSets = null;
    this.VsGamblingButtonState = new VsGamblingButtonState(false,false,false);
    this.VsJackpotData = null;
    this.Respin = null;
    this.ProgressiveData = null;
    this.MoneySymbolData = null;
    this.StickySymbols = null;
    this.MergingSymbols = null;
    this.RandomAwardResponse = null;
    this.RandomSymbolMultipliers = null;
    this.PossibleRandomSymbolMultipliers = null;
    this.FreeSpinsChainData = null;
    this.TruncatedVsFreeSpin = null;
    this.OpeningSymbolsData = null;
    this.SpinOneReelData = null;
    this.TumblingData = null;
    this.FreeSpinsPurchaseData = null;
    this.RandomMysterySymbolId = -1;
    this.PatternedMysterySymbols = null;
    this.SymbolsAbove = null;
    this.SymbolsBelow = null;
    this.NextReelsSymbolsList = null;
    this.NextGameActions = null;
    this.SpinCycleWin = 0;
    this.ReturnToPlayer = -1;
    this.ReturnToPlayerMin = -1;
    this.ReelSetIndex = -1;
    this.ReelSetIndexCurrent = -1;
    this.StackedSymbolIndex = -1;
    this.StackedSymbolIndexCurrent = -1;
    this.gambleV2Data = null;
    this.NudgedSymbolsData = null
}
VsResponse.prototype.GetVsFreeSpin = function() {
    return this.VsFreeSpin
}
;
VsResponse.prototype.SetVsFreeSpin = function(vsFreeSpin) {
    this.VsFreeSpin = vsFreeSpin
}
;
VsResponse.prototype.SetVsJackpotData = function(vsJackpotData) {
    this.VsJackpotData = vsJackpotData
}
;
VsResponse.prototype.SetVsBonusGameData = function(vsBonusGame) {
    this.VsBonusGame = vsBonusGame
}
;
VsResponse.prototype.GetVsBonusGameData = function() {
    return this.VsBonusGame
}
;
VsResponse.prototype.HasExpandingSymbols = function() {
    return this.ExpandingSymbolsData != null && this.ExpandingSymbolsData.length > 0
}
;
VsResponse.prototype.IsWin = function() {
    return this.Win > 0
}
;
VsResponse.prototype.IsBonus = function() {
    return this.VsBonusGame != null
}
;
VsResponse.prototype.IsBonusGameOver = function() {
    return this.VsBonusGame != null && this.VsBonusGame.GameOver == true
}
;
VsResponse.prototype.IsBonusRespin = function() {
    if (this.VsBonusGame != undefined)
        return this.VsBonusGame.maxBonusRespins > 0;
    else
        return false
}
;
VsResponse.prototype.IsBonusFSPick = function() {
    if (this.VsBonusGame != null)
        return this.VsBonusGame.MultipliedSymbolPositions != null;
    else
        return false
}
;
VsResponse.prototype.IsBonusOptions = function() {
    if (this.VsBonusGame != null && this.VsBonusGame.BonusTable != null)
        return this.VsBonusGame.BonusTable.WinsMask != null;
    return false
}
;
VsResponse.prototype.IsOpeningSymbols = function() {
    return XT.GetObject(Vars.OpeningSymbolsData) != null
}
;
VsResponse.prototype.HasFreeSpinOptions = function() {
    return this.FreeSpinsOptions != null
}
;
VsResponse.prototype.IsFreeSpins = function() {
    return this.VsFreeSpin != null
}
;
VsResponse.prototype.IsFreeSpinBonusGame = function() {
    return this.VsFreeSpin != null && this.VsFreeSpin.BonusGame != null
}
;
VsResponse.prototype.IsInit = function() {
    return this.VsInitData != null
}
;
VsResponse.prototype.WasDoBonus = function() {
    if (!this.IsBonus())
        return false;
    return this.VsBonusGame.initialized
}
;
VsResponse.prototype.WasDoFSBonus = function() {
    if (!this.IsFreeSpinBonusGame())
        return false;
    return this.VsFreeSpin.BonusGame.Level > 0
}
;
VsResponse.prototype.IsJackpotWin = function() {
    return this.VsJackpotData != null && this.VsJackpotData.IsWin
}
;
VsResponse.prototype.IsJackpotEnable = function() {
    return this.VsJackpotData != null && this.VsJackpotData.IsActive
}
;
VsResponse.prototype.IsRespin = function() {
    return this.Respin != null
}
;
VsResponse.prototype.Clone = function() {
    var cloned = new VsResponse;
    cloned.SlotHeight = this.SlotHeight;
    cloned.SlotLines = this.SlotLines;
    cloned.Balance = this.Balance;
    cloned.BonusBalance = this.BonusBalance;
    cloned.Win = this.Win;
    cloned.ReelSetIndex = this.ReelSetIndex;
    cloned.ReelSetIndexCurrent = this.ReelSetIndexCurrent;
    cloned.StackedSymbolIndex = this.StackedSymbolIndex;
    cloned.StackedSymbolIndexCurrent = this.StackedSymbolIndexCurrent;
    var i;
    cloned.RandomWildsData = null;
    if (this.RandomWildsData != null) {
        cloned.RandomWildsData = [];
        for (i = 0; i < this.RandomWildsData.length; i++)
            cloned.RandomWildsData.push(this.RandomWildsData[i].CloneHelper())
    }
    cloned.UpSymbols = null;
    if (this.UpSymbols != null) {
        cloned.UpSymbols = [];
        for (i = 0; i < this.UpSymbols.length; i++)
            cloned.UpSymbols.push(this.UpSymbols[i])
    }
    cloned.ExpandingSymbolsData = null;
    if (this.ExpandingSymbolsData != null) {
        cloned.ExpandingSymbolsData = [];
        for (i = 0; i < this.ExpandingSymbolsData.length; i++)
            cloned.ExpandingSymbolsData.push(this.ExpandingSymbolsData[i].CloneHelper())
    }
    cloned.SymbolsBeforeExpanding = [];
    for (i = 0; i < this.SymbolsBeforeExpanding.length; ++i)
        cloned.SymbolsBeforeExpanding[i] = this.SymbolsBeforeExpanding[i].slice();
    cloned.WinScreenSymbols = [];
    for (i = 0; i < this.WinScreenSymbols.length; ++i)
        cloned.WinScreenSymbols[i] = this.WinScreenSymbols[i].slice();
    cloned.ReelPositions = this.ReelPositions == null ? [] : this.ReelPositions.slice();
    cloned.VsWinLines = [];
    for (i = 0; i < this.VsWinLines.length; ++i)
        cloned.VsWinLines[i] = this.VsWinLines[i].Clone();
    if (this.VsBonusGame != null)
        cloned.VsBonusGame = this.VsBonusGame.Clone();
    if (this.VsFreeSpin != null)
        cloned.VsFreeSpin = this.VsFreeSpin.Clone();
    if (this.TruncatedVsFreeSpin != null)
        cloned.TruncatedVsFreeSpin = this.TruncatedVsFreeSpin.Clone();
    if (this.VsInitData != null)
        cloned.VsInitData = this.VsInitData.Clone();
    if (this.VsJackpotData != null)
        cloned.VsJackpotData = this.VsJackpotData.Clone();
    cloned.VsGamblingButtonState = this.VsGamblingButtonState.Clone();
    cloned.FreeSpinsOptions = null;
    if (this.FreeSpinsOptions != null) {
        cloned.FreeSpinsOptions = [];
        for (i = 0; i < this.FreeSpinsOptions.length; i++)
            cloned.FreeSpinsOptions.push(this.FreeSpinsOptions[i].CloneHelper())
    }
    cloned.FreeRound = null;
    if (this.FreeRound != null)
        cloned.FreeRound = this.FreeRound.CloneHelper();
    cloned.FreeRoundEvents = null;
    if (this.FreeRoundEvents != null) {
        cloned.FreeRoundEvents = [];
        for (var j = 0; j < this.FreeRoundEvents.length; j++)
            cloned.FreeRoundEvents.push(this.FreeRoundEvents[j].CloneHelper())
    }
    if (this.RandomAwardResponse != null)
        cloned.RandomAwardResponse = this.RandomAwardResponse.Clone();
    if (this.RandomSymbolMultipliers != null)
        cloned.RandomSymbolMultipliers = this.RandomSymbolMultipliers.slice();
    if (this.PossibleRandomSymbolMultipliers != null) {
        cloned.PossibleRandomSymbolMultipliers = [];
        for (i = 0; i < this.PossibleRandomSymbolMultipliers.length; i++)
            cloned.PossibleRandomSymbolMultipliers.push(this.PossibleRandomSymbolMultipliers[i].Clone())
    }
    if (this.FreeSpinsChainData != null)
        cloned.FreeSpinsChainData = this.FreeSpinsChainData.Clone();
    if (this.OpeningSymbolsData != null)
        cloned.OpeningSymbolsData = this.OpeningSymbolsData.Clone();
    if (this.SpinOneReelData != null)
        cloned.SpinOneReelData = this.SpinOneReelData.Clone();
    if (this.TumblingData != null)
        cloned.TumblingData = this.TumblingData.Clone();
    if (this.FreeSpinsPurchaseData != null)
        cloned.FreeSpinsPurchaseData = this.FreeSpinsPurchaseData.Clone();
    cloned.RandomMysterySymbolId = this.RandomMysterySymbolId;
    cloned.PatternedMysterySymbols = null;
    if (this.PatternedMysterySymbols != null) {
        cloned.PatternedMysterySymbols = [];
        for (i = 0; i < this.PatternedMysterySymbols.length; i++)
            cloned.PatternedMysterySymbols.push(this.PatternedMysterySymbols[i])
    }
    if (this.SymbolsAbove != null)
        cloned.SymbolsAbove = this.SymbolsAbove.slice();
    if (this.SymbolsBelow != null)
        cloned.SymbolsBelow = this.SymbolsBelow.slice();
    if (this.NextReelsSymbolsList != null)
        cloned.NextReelsSymbolsList = this.NextReelsSymbolsList.slice();
    if (this.MoneySymbolData != null)
        cloned.MoneySymbolData = this.MoneySymbolData.Clone();
    if (this.NudgedSymbolsData != null) {
        cloned.NudgedSymbolsData = [];
        for (i = 0; i < this.NudgedSymbolsData.length; i++)
            cloned.NudgedSymbolsData.push(this.NudgedSymbolsData[i].Clone())
    }
    return cloned
}
;
VsResponse.prototype.ToString = function() {
    return "VsResponse { SlotHeight = " + this.SlotHeight + ", IsWin = " + this.IsWin() + ", IsBonus = " + this.IsBonus() + ", IsBonusRespin = " + this.IsBonusRespin() + ", IsFreeSpins = " + this.IsFreeSpins() + (this.IsFreeSpins() ? ", IsLastFreeSpin = " + this.VsFreeSpin.IsLastFreeSpin() : "") + ", IsFreeSpinBonusGame = " + this.IsFreeSpinBonusGame() + "}"
}
;
VsResponse.prototype.HasFreeRoundEvents = function() {
    return this.FreeRoundEvents != null
}
;
VsResponse.prototype.IsFreeRounds = function() {
    return this.FreeRound != null
}
;
VsResponse.prototype.isGambleV2 = function() {
    return this.gambleV2Data != null && this.gambleV2Data.optionIndex > -1
}
;
goog.require("UHT.BaseDataStructures");
function VsScatterData(symbol, pays, freespins, multipliers) {
    this.Symbol = symbol;
    this.Pays = pays;
    this.Freespins = freespins;
    this.Multipliers = multipliers
}
VsScatterData.prototype.Clone = function() {
    var cloned = new VsScatterData(this.Symbol,this.Pays,this.Freespins,this.Multipliers);
    if (this.Pays != null)
        cloned.Pays = this.Pays.slice();
    if (this.Freespins != null)
        cloned.Freespins = this.Freespins.slice();
    if (this.Multipliers != null)
        cloned.Multipliers = this.Multipliers.slice();
    return cloned
}
;
goog.require("UHT.BaseDataStructures");
function VSSpinOneReelSymbolsData(reelID, reelsToBeSpun, reelCoefs) {
    this.reelID = reelID;
    this.reelsToBeSpun = reelsToBeSpun;
    this.reelCoefs = reelCoefs
}
VSSpinOneReelSymbolsData.prototype.Clone = function() {
    var cloned = new VSSpinOneReelSymbolsData(this.reelID,this.reelsToBeSpun,this.reelCoefs);
    if (this.reelsToBeSpun != null)
        cloned.reelsToBeSpun = this.reelsToBeSpun.slice();
    if (this.reelCoefs != null)
        cloned.reelCoefs = this.reelCoefs.slice();
    return cloned
}
;
function VsStickySymbol() {
    this.currentPosition = -1;
    this.endPosition = -1
}
VsStickySymbol.prototype.Clone = function() {
    var cloned = new VsStickySymbol;
    cloned.currentPosition = this.currentPosition;
    cloned.endPosition = this.endPosition;
    return cloned
}
;
VsStickySymbol.prototype.CloneHelper = function() {
    return this.Clone()
}
;
VsStickySymbol.prototype.IsMoving = function() {
    return this.currentPosition != this.endPosition && this.endPosition >= 0
}
;
VsStickySymbol.prototype.IsSticky = function() {
    return this.currentPosition == this.endPosition
}
;
VsStickySymbol.prototype.WillDisappear = function() {
    return this.endPosition < 0
}
;
function VsSymbolReplacement() {
    this.FromSymbolId = -1;
    this.ToSymbolId = -1;
    this.ReplacementPositions = []
}
VsSymbolReplacement.prototype.Clone = function() {
    var cloned = new VsSymbolReplacement;
    cloned.FromSymbolId = this.FromSymbolId;
    cloned.ToSymbolId = this.ToSymbolId;
    if (this.ReplacementPositions != null)
        cloned.ReplacementPositions = this.ReplacementPositions.slice();
    return cloned
}
;
function VsTumblingData() {
    this.tumblingSymbols = []
}
VsTumblingData.TumblingSymbol = function() {
    this.id = 0;
    this.position = 0
}
;
VsTumblingData.prototype.Clone = function() {
    var cloned = new VsTumblingData;
    cloned.tumblingSymbols = [];
    for (var i = 0; i < this.tumblingSymbols.length; i++) {
        cloned.tumblingSymbols.push(new VsTumblingData.TumblingSymbol);
        cloned.tumblingSymbols[i].id = this.tumblingSymbols[i].id;
        cloned.tumblingSymbols[i].position = this.tumblingSymbols[i].position
    }
    return cloned
}
;
VsTumblingData.prototype.CloneHelper = function() {
    return this.Clone()
}
;
goog.require("UHT.BaseDataStructures");
function VsWildData(symbol, pays, multipliers) {
    this.Symbol = symbol;
    this.Pays = pays;
    this.Multipliers = multipliers
}
VsWildData.prototype.Clone = function() {
    var cloned = new VsWildData(this.Symbol,this.Pays,this.Multipliers);
    if (this.Pays != null)
        cloned.Pays = this.Pays.slice();
    if (this.Multipliers != null)
        cloned.Multipliers = this.Multipliers.slice();
    return cloned
}
;
function MultiplierSet() {
    this.setIndex = 0;
    this.multipliers = null
}
MultiplierSet.prototype.Clone = function() {
    var clone = new MultiplierSet;
    clone.setIndex = this.setIndex;
    if (this.multipliers != null)
        clone.multipliers = this.multipliers.slice();
    return clone
}
;
function VsWildRandomLineMultiplier() {}
VsWildRandomLineMultiplier.Configuration = function() {
    this.wildSymbolId = 0;
    this.multiplierSets = null
}
;
VsWildRandomLineMultiplier.Configuration.prototype.GetCurrentSet = function(_setIndex) {
    for (var i = 0; i < this.multiplierSets.length; i++)
        if (this.multiplierSets[i].setIndex == _setIndex)
            return this.multiplierSets[i].multipliers;
    return null
}
;
VsWildRandomLineMultiplier.Configuration.prototype.Clone = function() {
    var clone = new VsWildRandomLineMultiplier.Configuration;
    clone.wildSymbolId = this.wildSymbolId;
    if (this.multiplierSets != null) {
        clone.multiplierSets = [];
        for (var i = 0; i < this.multiplierSets.length; i++)
            clone.multiplierSets.push(this.multiplierSets[i].Clone())
    }
    return clone
}
;
VsWildRandomLineMultiplier.SpinResponse = function() {
    this.wildSymbolId = 0;
    this.multiplier = 0;
    this.positions = null
}
;
VsWildRandomLineMultiplier.SpinResponse.prototype.Clone = function() {
    var clone = new VsWildRandomLineMultiplier.SpinResponse;
    clone.wildSymbolId = this.wildSymbolId;
    clone.multiplier = this.multiplier;
    if (this.positions != null)
        clone.positions = this.positions.slice();
    return clone
}
;
VsWildRandomLineMultiplier.CurrentSet = function() {
    this.wildSymbolId = 0;
    this.currentSetIndex = 0
}
;
VsWildRandomLineMultiplier.CurrentSet.prototype.Clone = function() {
    var clone = new VsWildRandomLineMultiplier.CurrentSet;
    clone.wildSymbolId = this.wildSymbolId;
    clone.currentSetIndex = this.currentSetIndex;
    return clone
}
;
function VsWildRandomMultiplier() {
    this.SymbolIndex = 0;
    this.Position = 0;
    this.Multiplier = 1
}
VsWildRandomMultiplier.prototype.Clone = function() {
    var clone = new VsWildRandomMultiplier;
    clone.SymbolIndex = this.SymbolIndex;
    clone.Position = this.Position;
    clone.Multiplier = this.Multiplier;
    return clone
}
;
VsFreeSpinOption.prototype.CloneHelper = function() {
    return this.Clone()
}
;
goog.require("UHT.BaseDataStructures");
function VsWinLine() {
    this.LineNumber = 0;
    this.WinAmount = 0;
    this.WinPositions = [];
    this.Combination = -1;
    this.Multiplier = 1
}
VsWinLine.prototype.Clone = function() {
    var cloned = new VsWinLine;
    cloned.LineNumber = this.LineNumber;
    cloned.WinAmount = this.WinAmount;
    cloned.WinPositions = this.WinPositions.slice();
    cloned.Combination = this.Combination;
    cloned.Multiplier = this.Multiplier;
    return cloned
}
;
var AdapterEvents = {
    evtCloseGame: "EVT_CLOSE_GAME",
    evtCloseGameCancel: "EVT_CLOSE_GAME_CANCEL",
    evtGameStatus: "EVT_GAME_STATUS",
    evtSound: "EVT_SOUND",
    evtGameLoadComplited: "EVT_GAME_LOAD_COMPLITED",
    evtServerRequest: "EVT_SERVER_REQUEST",
    evtUpdateBalance: "EVT_UPDATE_BALANCE",
    evtUpdateConnectionQuality: "EVT_UPDATE_CONNECTION_QUALITY",
    evtOpenCashier: "EVT_OPEN_CASHIER",
    evtSetTickerPromo: "EVT_SET_TICKER_PROMO",
    evtGetConfiguration: "EVT_GET_CONFIGURATION",
    evtUpdateLoadingProgress: "EVT_UPDATE_LOADING_PROGRESS",
    evtPlayForReal: "EVT_PLAY_FOR_REAL",
    evtChatMessage: "EVT_CHAT_MESSAGE",
    evtChatInit: "EVT_CHAT_INIT",
    evtChatState: "EVT_CHAT_STATE",
    evtGetGameMenu: "EVT_GET_GAME_MENU",
    evtSetGameMenu: "EVT_SET_GAME_MENU",
    evtGameMenuItemSelected: "EVT_GAME_MENU_ITEM_SELECTED",
    evtLogoff: "EVT_LOGOFF",
    evtLogoffOk: "EVT_LOGOFF_OK",
    evtReload: "EVT_RELOAD",
    evtMaximumTabsReached: "EVT_MAXIMUM_TABS_REACHED",
    evtAutoLogout: "EVT_AUTO_LOGOUT",
    evtAutoLogoutUserResponse: "EVT_AUTO_LOGOUT_USER_RESPONSE",
    evtDownloadCasinoClient: "EVT_DOWNLOAD_CLIENT",
    evtClientScreenMode: "EVT_CLIENT_SCREEN_MODE",
    evtUpdateJackpot: "EVT_UPDATE_JACKPOT",
    evtCloseExternalGame: "EVT_CLOSE_EXTERNAL_GAME",
    evtJackpotAmountToFlash: "EVT_NEW_JACKPOT_AMOUNT",
    evtRealityCheck: "EVT_REALITY_CHECK_MESSAGE",
    evtRealityLogoff: "EVT_REALITY_LOGOFF",
    evtRealityClose: "EVT_REALITY_CLOSE",
    evtGameReady: "EVT_UNITY_GAME_READY",
    evtServerResponse: "EVT_HTTP_RESPONSE",
    evtMessageOpened: "EVT_MESSAGE_OPENED",
    evtMessageClosed: "EVT_MESSAGE_CLOSED",
    evtFullscreenOverlayShown: "EVT_FULLSCREEN_OVERLAY_SHOWN",
    evtFullscreenOverlayHidden: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
    evtShowMessage: "EVT_SHOW_MESSAGE"
};
var AdapterParameters = {
    Notify: "common",
    Arguments: "args",
    GameSymbol: "symbol",
    GameActive: "active",
    MethodType: "type",
    Balance: "balance",
    BalanceUpdateTime: "stime",
    ConnectionQuality: "level",
    TickerMessage: "message",
    TickerStyle: "style",
    TabName: "tabName",
    Config: "config",
    Progress: "progress",
    SoundState: "sound",
    ChatMessages: "history",
    ChatInit: "init",
    ChatState: "state",
    ReloadLink: "link",
    MaxTabsCount: "maxcount",
    AutoLogout: "autologout",
    ClientScreenMode: "clientScreenMode",
    JackpotTotalAmount: "totaljackpot",
    Jackpots: "jackpots",
    JackpotAmountToFlash: "newJackpotAmount",
    RealityTime: "time",
    RealitySumm: "summ",
    RealityBalance: "balance",
    ResponseData: "data",
    ResponseStatusCode: "httpCode",
    messageType: "message",
    type: "type",
    unity: "unity",
    sendToAdapterMethod: "sendToAdapter",
    gameActionParameter: "action",
    sendToWrapperEvent: "unityToWrapperMsg"
};
var AdapterMessages = {
    settingsNotSaved: "ALERT_CANT_SAVE_SETTINGS",
    connectionLost: "ALERT_CONNECTION_LOST"
};
var FrameworkConfiguration = {
    resourceUri: "RESOURCES",
    menuUri: "MENU",
    wakeupUri: "WAKEUP",
    getSessionUri: "RETRIEVESESSION",
    settingsUri: "SETTINGS",
    gameServiceUri: "GAMESERVICE",
    clientLogUri: "CLIENTLOG",
    clientLogLevel: "CLIENTLOGLEVEL",
    loginUri: "LOGIN",
    logoutUri: "LOGOUT",
    sessionTimeout: "sessionTimeout",
    facebookUri: "FACEBOOK",
    external: "EXTERNAL",
    casinoName: "CASINONAME",
    externalChat: "EXTERNALCHAT",
    mobileAuthorize: "MOBILE_AUTHORIZE",
    externalAuthorize: "EXTERNAL_AUTHORIZE",
    chatServerPort: "CHAT_PORT",
    isSecure: "SECURE",
    stylename: "STYLENAME",
    currency: "CURRENCY",
    isDefaultBrand: "DEFAULTC",
    shortcutName: "SHORTCUT_NAME",
    shortcutLink: "SHORTCUT_LINK",
    shortcutIconName: "SHORTCUT_ICON_NAME",
    shortcutUrlToCasinoRes: "SHORTCUT_URL_TO_RES",
    cacheAutorizeName: "CACHE_NAME",
    bundleDomain: "BUNDLE_DOMAIN",
    cacheAutorizeSize: "CACHE_SIZE",
    cacheAutorizeExpiration: "CACHE_EXPIRATION",
    cacheAutorizeSignature: "CACHE_SIGNATURE",
    reloadBalanceUri: "RELOAD_BALANCE",
    reloadJackpotUri: "RELOAD_JACKPOT",
    appVersion: "VERSION",
    applicationStoreUrl: "STORE_URL",
    locale: "LANGUAGE",
    gameSymbol: "GAME_SYMBOL",
    versionInfo: "VERSION_INFO",
    updateAndroidApp: "UPDATE_ANDROID_APP",
    updateAndroidProp: "UPDATE_ANDROID_PROP",
    webLobbyUrl: "WEB_LOBBY",
    extWebLobbyUrl: "EXT_WEB_LOBBY",
    displayClockInFullScreen: "DISPLAY_CLOCK_FULL_MODE",
    gameUrl: "GAME_URL",
    mgckey: "MAGIC_KEY",
    noRating: "NO_RATING",
    gameHistory: "HISTORY",
    jurisdiction: "jurisdiction",
    jurisdictionRequirements: "jurisdictionRequirements",
    promotionurl: "promotionurl",
    rcSettings: "rcSettings",
    amountType: "amountType"
};
var DefaultValues = {
    LanguageSettings: {
        defaultLanguage: "en"
    },
    CurrencySettings: {
        defaultCurrency: "USD"
    },
    DefaultParameters: {
        defaultStylename: "premiumgames",
        defaultGameSymbol: "LobbyComponent"
    },
    ServerProtocol: {
        Login: {
            loginResult: "log",
            loginResultSuccess: "1",
            loginResultFail: "0",
            responseURL: "Url",
            accountType: "acctype",
            memberID: "memberID",
            errorMsg: "msg",
            accountTypeFun: "F",
            accountTypeReal: "R",
            aid: "aid",
            authStatusOk: "OK",
            authStatusUnlogged: "UNLOGGED"
        },
        InitSession: {
            language: "lang",
            type: "type",
            unityType: "UnityClient",
            sessionID: "sessionid"
        },
        SessionManagement: {
            unloggedResponse: "unlogged",
            newSessionResponse: "new session"
        }
    },
    GameParams: {
        gameRequestTimeout: 15,
        gamePnowRequestDelay: 3,
        gameRequestDelay: 2,
        gameConnectionTimeout: 120,
        resourceBrandPath: "brands/",
        resourceGamePath: "games/"
    },
    RetryParams: {
        disableRetry: 0,
        unlimitedRetryCount: -1,
        retryTimeout: 15,
        resRetryTimeout: 3
    },
    NoNetwork: {
        retryCountToShowText: 2,
        wakeUpFailInRow: 2
    },
    ResourceManagerCfg: {
        resourceInfoFileNameSuffix: ".ResInfo.xml",
        componentInfoFileName: "component.info",
        componentStringList: "string.list",
        componentFolder: "components/",
        sharedComponentName: "shared",
        packageExtention: ".zip"
    },
    PackageInfoCfg: {
        packageTypeCommon: "common",
        packageTypeLocalized: "localized",
        sharedComponent: "shared"
    },
    ComponentInfoFormat: {
        componentName: "name",
        componentLocalization: "localization",
        componentDefaultLanguage: "default",
        componentLanguageList: "languages",
        componentPackagesList: "packages",
        componentPackageName: "name",
        componentPackageType: "type"
    },
    Resources: {
        bundlesInfoHead: "languages",
        bundlesLanuageTitle: "language",
        bundlesHead: "bundles",
        bundleName: "name",
        bundleVersion: "version",
        bundlesCommon: "common",
        defaultLanguage: "",
        locolizationFileName: "localization.info",
        resourceInfoFileName: "packages.info",
        versionsInfoFileName: "versions.info",
        versionsInfoHead: "versions"
    },
    StringListFormat: {
        languageID: "language",
        keys: "keys"
    },
    AuthServicesPath: {
        facebook: "/facebook.do"
    },
    AuthServicesDefines: {
        language: "lang",
        action: "method",
        login: "login",
        id: "id",
        token: "token",
        guestId: "gid",
        Facebook: {
            tokenParam: "token",
            successResult: "ok",
            failedResult: "failed"
        }
    },
    UnityGameObjects: {
        casinoSDK: "Casino SDK",
        FBBridgeObject: "FBBridgeObject"
    },
    FBPluginConstants: {
        androidFBPluginClassName: "com.igs.fbplugin.FBPlugin",
        androidFBPluginFunction: "FacebookConnect"
    },
    Settings: {
        settingsPath: "https://ganesh.bet/game/Dragons888PM/server",
        action: "method",
        load: "load",
        idParam: "id",
        settingsParam: "settings",
        symbolKey: "symbol",
        settingsKey: "settings"
    },
    ApplicationSettings: {
        settingSeparator: "\n",
        settingIDSeparator: "\t",
        gameSettingsFilename: "game.settings",
        clientSettingsFilename: "client.settings"
    },
    UnityVars: {
        language: "lang",
        gameSymbol: "gs",
        session: "sp",
        styleName: "sn",
        configurationUri: "conf",
        currency: "currency",
        accountType: "accountType",
        gameServerDomain: "gsd",
        bundleVersion: "ver"
    },
    FrameworkConfigurationXml: {
        items: "items",
        authStatus: "/root/auth_status",
        aid: "/root/member/aid",
        type: "/root/member/type",
        item: "item",
        key: "key",
        value: "value"
    },
    LogTransferSetting: {
        defaultTimerDelaySeconds: 5
    },
    Chat: {
        maxMessageLength: 250,
        pingDelay: 5,
        malDelay: 3,
        ImmidiatlyAfterLoginRetryLogic: {
            timeToLostConnect: 10,
            timeToLostConnectShow: 10
        },
        ChatInProcessRetryLogic: {
            timeToLimitedFunctionality: 10
        }
    },
    GameMenu: {
        ItemId: {
            reports: "reports",
            withdraw: "withdraw",
            language: "language"
        }
    },
    Socket: {
        endOfCommand: "\x00",
        bufferLength: 256,
        readTimeout: 500
    },
    ScreenMode: {
        fullScreenMode: "fullScreenMode",
        windowMode: "windowMode"
    },
    TokenInfo: {
        tokenKey: "token",
        domainKey: "domain",
        gameIdKey: "gameId",
        expiresKey: "expires",
        externalLinkKey: "extLink",
        externalKey: "ext",
        tokenFile: "info.dat",
        tokenCookieName: "AUTHTOKEN",
        tokenExpDateCookieName: "AUTHTOKEN_STORE_PERIOD"
    },
    ExternalDataProtocol: {
        tokenKey: "token",
        domainKey: "domain",
        ticketKey: "PathAndQuery",
        protocolKey: "protocol",
        gameIdKey: "symbol",
        protocol: "fungame",
        deviceId: "id",
        uriDelimeter: "?",
        paramSeparator: ":",
        pairSeparator: "&",
        backToLobby: "btl",
        mobileLobbyCategory: "mlc",
        defaultMobileLobbyCategory: "1"
    },
    JackpotXml: {
        jackpot_list: "/jackpot_list",
        list_total_amount: "total_amount",
        jackpot_item: "jackpot",
        jackpotId: "id",
        jackpotAmount: "amount",
        jackpotStyle: "style",
        jackpotGames: "gsymbols"
    },
    JackpotGamesListXml: {
        jackpot_list: "/casino",
        jackpotItem: "jackpot",
        jackpotId: "jackpotid",
        jackpotName: "name",
        gameItem: "game",
        newgame: "newgame",
        premiumgame: "premiumgame",
        gamename: "name",
        gamepic: "pic",
        gamelink: "link"
    },
    BalanceXml: {
        cash: "/CASH",
        balance: "BALANCE"
    },
    JackpotGamesRequest: {
        action: "method",
        actionType: "jackpotList",
        actionParam: "categorySymbol",
        actionParamValue: "jp"
    },
    Timing: {
        wakeupRequestDelayInSeconds: 15,
        wakeupRequestDelayInMiliseconds: 15E3,
        wakeupServiceTotalWorkInMinutes: 10
    },
    ShortcutRes: {
        path: "",
        iconName: ""
    },
    ClientSettingNames: {
        shortcutSettings: "shortcutSettings"
    },
    PossibleOpenGames: {
        maxOpenedCount: 2
    },
    PlayOnRealMoney: {
        paramName: "msg_code",
        allow: "1",
        denied: "0"
    },
    UpdateVersion: {
        updateFolder: "updates/",
        appVersionKey: "version",
        updateImportanceKey: "importance",
        configAppVersionKey: "apk",
        updateFileKey: "file",
        updateInfoFileName: "UpdateInfo.dat"
    },
    GuestId: {
        guestIdFile: "gid.info",
        guestIdKey: "guestId",
        guestIdCookieKey: "GID"
    },
    InbuildDomain: {
        notUse: "default"
    },
    LogTransfer: {
        tmpSwapFile: "tmpLog.log",
        cashFile: "unsent.log",
        sendDataLimit: 1E4
    }
};
DefaultValues.Resources.defaultLanguage = DefaultValues.LanguageSettings.defaultLanguage;
goog.require("UHT.EventHandler");
goog.provide("UHT.EventManager");
var GameEvents = {
    evtConnectionReady: "evtConnectionReady",
    evtInitResponse: "evtInitResponse",
    evtSpinResponse: "evtSpinResponse",
    evtNoMoneySpinResponse: "evtNoMoneySpinResponse",
    evtConfigSwitchedResponse: "evtConfigSwitchedResponse",
    evtInitRequest: "evtInitRequest",
    evtSpinRequest: "evtSpinRequest",
    evtFreespinsFinished: "evtFreespinsFinished",
    evtGambleRequest: "evtGambleRequest",
    evtGambleClose: "evtGambleClose",
    evtGambleResponse: "evtGambleResponse",
    evtBonusInitResponse: "evtBonusInitResponse",
    evtBonusPickRequest: "evtBonusPickRequest",
    evtBonusPickResponse: "evtBonusPickResponse",
    evtBonusRespinRequest: "evtBonusRespinRequest",
    evtBonusRespinResponse: "evtBonusRespinResponse",
    evtBonusFinishRequest: "evtBonusFinishRequest",
    evtSoundState: "evtSoundState",
    evtGetSettingsRequest: "evtGetSettingsRequest",
    evtUpdateSettingsRequest: "evtUpdateSettingsRequest",
    evtSettingsUpdated: "evtSettingsUpdated",
    evtSettingsNotSaved: "evtSettingsNotSaved",
    evtGameStatus: "evtGameStatus",
    evtFSBGInitRequest: "evtFSBGInitRequest",
    evtFSBGInitResponse: "evtFSBGInitResponse",
    evtFSBGPickRequest: "evtFSBGPickRequest",
    evtFSBGPickResponse: "evtFSBGPickResponse",
    evtMysteryScatterRequest: "evtMysteryScatterRequest",
    evtMysteryScatterResponse: "evtMysteryScatterResponse",
    evtCreateConnectionRequest: "evtCreateConnectionRequest",
    evtFreeRoundsUpdate: "evtFreeRoundsUpdate",
    evtFSOptionsUpdate: "evtFSOptionsUpdate",
    evtFSOptionPickRequest: "evtFSOptionPickRequest",
    evtServerTimeUpdate: "evtServerTimeUpdate"
};
var ApplicationEvents = {
    evtRequestInitApplication: "evtRequestInitApplication",
    evtRequestAppConfiguration: "evtRequestAppConfiguration",
    evtAppConfigurationReceived: "evtAppConfigurationReceived",
    evtServerOptionsParsed: "evtServerOptionsParsed",
    evtFlashRPCRequest: "evtFlashRPCRequest",
    evtGameLoadingFinished: "evtGameLoadingFinished",
    evtFlashWrapperRPCRequest: "evtFlashWrapperRPCRequest",
    evtServerResponse: "evtServerResponse"
};
var EventManager = {
    handlers: {},
    queuedEvts: [],
    queuedArgs: [],
    Init: function() {},
    AddHandler: function(eventName, callback, object) {
        if (EventManager.handlers[eventName] == undefined)
            EventManager.handlers[eventName] = [];
        EventManager.handlers[eventName].push(new EventHandler(object,callback))
    },
    ClearCallback: function(callback, object) {
        for (var eventName in EventManager.handlers) {
            if (!EventManager.handlers.hasOwnProperty(eventName))
                continue;
            for (var i = 0; i < EventManager.handlers[eventName].length; ++i)
                if (EventManager.handlers[eventName][i].equals(object, callback))
                    EventManager.handlers[eventName].splice(i, 1)
        }
    },
    optionalEvents: ["EVT_UHT_UPDATE", "EVT_UHT_BEFOREUPDATE"],
    Trigger: function(eventName, param) {
        if (EventManager.optionalEvents.indexOf(eventName) < 0)
            console.log("Trigger", eventName, param);
        if (EventManager.handlers[eventName] != undefined)
            for (var i = 0; i < EventManager.handlers[eventName].length; ++i)
                EventManager.handlers[eventName][i].call(param)
    },
    Queue: function(eventName, param) {
        EventManager.queuedEvts.push(eventName);
        EventManager.queuedArgs.push(param)
    },
    TriggerQueued: function() {
        for (var i = 0; i < EventManager.queuedEvts.length; ++i)
            EventManager.Trigger(EventManager.queuedEvts[i], EventManager.queuedArgs[i]);
        EventManager.queuedEvts.splice(0);
        EventManager.queuedArgs.splice(0)
    }
};
goog.provide("UHT.JackpotHelpers");
var JackpotEvents = {
    evtJackpotStateChanged: "evtJackpotStateChanged",
    evtJackpotsUpdated: "evtJackpotsUpdated"
};
var JackpotDictionary = {
    jackpotAmount: "amount",
    jackpotName: "name",
    jackpotId: "jackpotID",
    jackpotOrder: "order",
    jackpotGroupType: "groupKind",
    jackpotStatus: "status",
    jackpotMinBet: "minBet",
    jackpotMinBetUSD: "minBetUSD",
    jackpotRTP: "rtp"
};
goog.require("UHT.JackpotHelpers");
goog.provide("UHT.JackpotsManager");
function JackpotsManager() {
    this.jackpots = null;
    this.reloadJpInterval = 10;
    this.reloadJpTimer = 0;
    this.hasActiveJp = false;
    this.enforceJackpots = false;
    this.requestInProgress = false
}
JackpotsManager.prototype.Init = function() {
    EventManager.AddHandler(JackpotEvents.evtJackpotStateChanged, this.OnJackpotStateChanged, this)
}
;
JackpotsManager.prototype.OnJackpotStateChanged = function(jpData) {
    if (jpData == null) {
        this.hasActiveJp = false;
        return
    }
    if (!this.hasActiveJp && jpData.IsActive)
        this.reloadJpTimer = this.reloadJpInterval;
    this.hasActiveJp = jpData.IsActive || this.enforceJackpots;
    if (!this.hasActiveJp) {
        this.jackpots = null;
        EventManager.Queue(JackpotEvents.evtJackpotsUpdated, this.jackpots)
    }
    if (this.enforceJackpots) {
        this.PatchJackpots();
        EventManager.Queue(JackpotEvents.evtJackpotsUpdated, this.jackpots)
    }
}
;
JackpotsManager.prototype.Update = function() {
    if (!this.hasActiveJp)
        return;
    this.reloadJpTimer += Time.deltaTime;
    if (!this.requestInProgress)
        if (this.reloadJpTimer > this.reloadJpInterval) {
            this.requestInProgress = true;
            ServerHelpers.ReloadJackpot(ServerOptions.gameSymbol, new EventHandler(this,this.JackpotReloadCallback))
        }
}
;
JackpotsManager.prototype.JackpotReloadCallback = function(param, statusCode) {
    var oldJackpots = this.jackpots;
    this.jackpots = this.ParseJackpots(param);
    if (oldJackpots != null && this.jackpots != null)
        for (var i = 0; i < oldJackpots.length; i++) {
            var found = false;
            for (var j = 0; j < this.jackpots.length; j++)
                if (oldJackpots[i].JackpotOrder == this.jackpots[j].JackpotOrder)
                    found = true;
            if (!found) {
                oldJackpots[i].JackpotStatus = "S";
                this.jackpots.push(oldJackpots[i])
            }
        }
    if (this.jackpots == null)
        this.hasActiveJp = false;
    if (this.enforceJackpots)
        this.PatchJackpots();
    this.jackpots.sort(function(jp1, jp2) {
        return jp1.JackpotOrder - jp2.JackpotOrder
    });
    this.reloadJpTimer = 0;
    this.requestInProgress = false;
    EventManager.Queue(JackpotEvents.evtJackpotsUpdated, this.jackpots)
}
;
JackpotsManager.prototype.ParseJackpots = function(param) {
    if (_string.IsNullOrEmpty(param))
        return null;
    var objList = null;
    try {
        objList = JSON.parse(param)
    } catch (e) {}
    if (objList == null) {
        console.error("JPManager::ParseJackpots - cannot parse jp list");
        return null
    }
    var jpList = [];
    for (var i = 0; i < objList.length; ++i) {
        var dict = objList[i];
        if (dict[JackpotDictionary.jackpotId] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp id");
            continue
        }
        if (dict[JackpotDictionary.jackpotAmount] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp amount");
            continue
        }
        if (dict[JackpotDictionary.jackpotName] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp name");
            continue
        }
        if (dict[JackpotDictionary.jackpotStatus] == undefined) {
            console.error("JPManager::ParseJackpots - cannot parse jp status");
            continue
        }
        var jp = new JackpotInformation;
        jp.JackpotID = Number(dict[JackpotDictionary.jackpotId]);
        jp.JackpotOrder = Number(dict[JackpotDictionary.jackpotOrder]);
        jp.JackpotAmount = Number(dict[JackpotDictionary.jackpotAmount]);
        jp.JackpotName = String(dict[JackpotDictionary.jackpotName]);
        jp.JackpotStatus = String(dict[JackpotDictionary.jackpotStatus]);
        if (dict[JackpotDictionary.jackpotGroupType] != undefined)
            jp.JackpotGroupType = String(dict[JackpotDictionary.jackpotGroupType]);
        if (dict[JackpotDictionary.jackpotMinBet] != undefined)
            jp.JackpotMinBet = Number(dict[JackpotDictionary.jackpotMinBet]);
        if (dict[JackpotDictionary.jackpotMinBetUSD] != undefined)
            jp.JackpotMinBetUSD = Number(dict[JackpotDictionary.jackpotMinBetUSD]);
        if (dict[JackpotDictionary.jackpotRTP] != undefined)
            jp.JackpotRTP = Number(dict[JackpotDictionary.jackpotRTP]);
        jpList.push(jp)
    }
    return jpList
}
;
JackpotsManager.prototype.PatchJackpots = function() {
    if (this.jackpots == null)
        this.jackpots = [];
    var order = [0, 1, 2, 3];
    for (var i = 0; i < this.jackpots.length; i++)
        if (order.indexOf(this.jackpots[i].JackpotOrder) != -1)
            order.splice(order.indexOf(this.jackpots[i].JackpotOrder), 1);
    while (4 - this.jackpots.length != 0) {
        var jp = new JackpotInformation;
        jp.JackpotOrder = order[0];
        order.shift();
        jp.JackpotAmount++;
        this.jackpots.push(jp)
    }
}
;
var GameProtocolBonusGameParser = {};
GameProtocolBonusGameParser.ParseBonusGame = function(nameValues) {
    if (nameValues[GameProtocolDictionary.BonusGame.bonusGameExists] == undefined && nameValues[GameProtocolDictionary.BonusGame.level] == undefined && nameValues[GameProtocolDictionary.BonusGame.currentBonusRespin] == undefined && nameValues[GameProtocolDictionary.BonusGame.status] == undefined && nameValues["wof_status"] == undefined)
        return null;
    var level = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.level);
    var bonusType = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.bonusGameType);
    var result = new VsBonusGameData;
    result.BonusTable.Status = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.status);
    result.BonusTable.Wins = GameProtocolCommonParser.ParseDoubleList(nameValues, GameProtocolDictionary.BonusGame.wins);
    result.BonusTable.WinsMask = GameProtocolBonusGameParser.ParseWinsMask(nameValues, GameProtocolDictionary.BonusGame.winsMask);
    result.BonusTable.BGItemValues = GameProtocolCommonParser.ParseDoubleList(nameValues, GameProtocolDictionary.BonusGame.BGItemValues);
    result.BonusTable.BGItemMask = GameProtocolCommonParser.ParseStringList(nameValues, GameProtocolDictionary.BonusGame.BGItemMasks);
    if (level == null)
        result.Level = -1;
    else
        result.Level = level;
    result.Life = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.life);
    result.WinPoints = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.BonusGame.winPoints);
    result.RealWin = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.BonusGame.realWin);
    result.Coef = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.BonusGame.coef);
    result.GameOver = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.BonusGame.gameOver) == 1;
    result.BonusTable.Markers = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.markers);
    result.lifeWins = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.lWins);
    result.currentBonusRespin = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.BonusGame.currentBonusRespin);
    result.maxBonusRespins = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.BonusGame.maxBonusRespins);
    result.respinSymbols = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.respinSymbols);
    result.PremultipliedWin = GameProtocolBonusGameParser.ParsePremultipliedWin(nameValues, GameProtocolDictionary.BonusGame.premultipliedWinData);
    result.MultipliedSymbolPositions = GameProtocolBonusGameParser.ParseMultiplierSymbolPositions(nameValues, GameProtocolDictionary.BonusGame.premultipliedWinData);
    var respinsTotalMultiplier = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.respinsTotalMultiplier);
    result.RespinsTotalMultiplier = respinsTotalMultiplier == null ? -1 : respinsTotalMultiplier;
    var extraRespinsWon = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.BonusGame.extraRespinsWon);
    result.ExtraRespinsWon = extraRespinsWon == null ? -1 : extraRespinsWon;
    var iWins = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.iWins);
    if (iWins != null && iWins.length > 0)
        if (result.BonusTable.Markers == null || result.BonusTable.Markers.length <= 0)
            iWins = GameProtocolCommonParser.SortIntList(iWins);
        else {
            var lengthOfLevel = GameProtocolCommonParser.FindElementPositionsIgnoreSign(1, result.BonusTable.Markers).length;
            result.numberOfLevels = iWins.length / lengthOfLevel;
            for (var i = 0; i < result.numberOfLevels; i++)
                iWins = GameProtocolCommonParser.SortIntList(iWins, i * lengthOfLevel, lengthOfLevel)
        }
    result.IWins = iWins;
    if (bonusType == 6) {
        result.Level = Math.floor(level / 2);
        result.MultiplierStep = level % 2 == 0;
        result.MultipliersTable.Status = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.Multipliers.status);
        result.MultipliersTable.Markers = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.BonusGame.Multipliers.markers);
        result.MultipliersTable.Wins = GameProtocolCommonParser.ParseDoubleList(nameValues, GameProtocolDictionary.BonusGame.Multipliers.wins)
    }
    var key = "bgid";
    if (nameValues[key] != undefined)
        result.id = _number.otoi(nameValues[key]);
    key = "bgt";
    if (nameValues[key] != undefined)
        result.type = _number.otoi(nameValues[key]);
    result.wheelOfFortune = GameProtocolBonusGameParser.ParseWheelOfFortune(nameValues);
    result.initialized = nameValues[GameProtocolDictionary.BonusGame.realWin] != undefined;
    result.map = GameProtocolBonusGameParser.ParseMap(nameValues);
    return result
}
;
GameProtocolBonusGameParser.ParsePremultipliedWin = function(nameValues, key) {
    var result = 0;
    var buf = nameValues[key];
    if (buf != undefined) {
        var data = buf.split("~");
        if (data.length > 0 && !_string.IsNullOrEmpty(data[0]))
            result = _number.otod(data[0])
    }
    return result
}
;
GameProtocolBonusGameParser.ParseMultiplierSymbolPositions = function(nameValues, key) {
    var result = null;
    var buf = nameValues[key];
    if (buf != undefined) {
        var data = buf.split("~");
        if (data.length > 1 && !_string.IsNullOrEmpty(data[1])) {
            result = [];
            var values = data[1].split(",");
            for (var i = 0; i < values.length; i++)
                result.push(_number.otoi(values[i]))
        }
    }
    return result
}
;
GameProtocolBonusGameParser.ParseWinsMask = function(nameValues, key) {
    if (nameValues[key] == undefined)
        return null;
    var buf = nameValues[key];
    var values = buf.split(",");
    var result = [];
    for (var i = 0; i < values.length; i++)
        if (!_string.IsNullOrEmpty(values[i])) {
            values[i] = values[i].replace("_fn", "");
            result.push(GameProtocolBonusGameParser.ParseWinMask(values[i]))
        }
    return result
}
;
GameProtocolBonusGameParser.ParseWinMask = function(value) {
    var masks = [];
    masks[0] = "w";
    masks[1] = "swf";
    masks[2] = "rwf";
    masks[3] = "l";
    masks[4] = "nff";
    masks[5] = "sff";
    masks[6] = "pf";
    masks[7] = "m";
    masks[8] = "ms";
    masks[9] = "prf";
    masks[10] = "psf";
    masks[11] = "rs";
    masks[12] = "wof";
    masks[13] = "rrf";
    masks[14] = "msf";
    masks[15] = "nlf";
    masks[16] = "oswr";
    masks[17] = "cmp";
    masks[18] = "srww";
    masks[19] = "gsf";
    masks[20] = "psm";
    masks[21] = "mbf";
    masks[22] = "pbf";
    return masks.indexOf(value)
}
;
GameProtocolBonusGameParser.ParseWheelOfFortune = function(dict) {
    var ret = new VsBonusGameData.WheelOfFortune;
    var key = "wof_set";
    if (dict[key] == undefined)
        return null;
    var itemsSplit = dict[key].split(",");
    key = "wof_mask";
    if (dict[key] == undefined)
        return null;
    var masksSplit = dict[key].split(",");
    ret.items = [];
    var i = 0;
    for (i = 0; i < itemsSplit.length; ++i) {
        var itemSplit = itemsSplit[i].split("~");
        var item = new VsBonusGameData.WheelOfFortune.Item;
        switch (masksSplit[i]) {
        case "w":
            item.amount = _number.otod(itemSplit[0]);
            break;
        case "wrs":
            item.amount = _number.otod(itemSplit[0]);
            item.spinsNumber = _number.otoi(itemSplit[1]);
            break;
        case "m":
            item.status = 1;
            break;
        case "go":
            item.status = 0;
            break
        }
        ret.items.push(item)
    }
    key = "wof_status";
    if (dict[key] != undefined) {
        var statusSplit = dict[key].split(",");
        var itemsStatus = [];
        for (i = 0; i < ret.items.length; ++i)
            itemsStatus.push(_number.otoi(statusSplit[i]));
        ret.itemsStatus = itemsStatus
    }
    key = "wof_wi";
    if (dict[key] != undefined)
        ret.stopPosition = _number.otoi(dict[key]);
    key = "lifes";
    if (dict[key] != undefined)
        ret.spinsLeft = _number.otoi(dict[key]);
    key = "iw";
    if (dict[key] != undefined)
        ret.initialWin = GameProtocolCommonParser.ParseDouble(dict, key);
    key = "wm";
    if (dict[key] != undefined)
        ret.multiplier = _number.otoi(dict[key]);
    return ret
}
;
GameProtocolBonusGameParser.ParseMap = function(dict) {
    var ret = new VsBonusGameData.Map;
    var wof_set = GameProtocolCommonParser.ParseIfExist(dict, "wof_set");
    var wof_mask = GameProtocolCommonParser.ParseIfExist(dict, "wof_mask");
    var wof_mi = GameProtocolCommonParser.ParseIfExist(dict, "wof_mi");
    var wof_p = GameProtocolCommonParser.ParseIfExist(dict, "wof_p");
    var wof_map = GameProtocolCommonParser.ParseIfExist(dict, "wof_map");
    ret.WOF_Values = [];
    ret.WOF_Mask = [];
    ret.WOF_Map = [];
    if (!_string.IsNullOrEmpty(wof_mi))
        if (wof_mi.length > 0)
            ret.WOF_MultiplierIndex = _number.otoi(wof_mi);
    if (!_string.IsNullOrEmpty(wof_p))
        if (wof_p.length > 0)
            ret.WOF_StopPosition = _number.otoi(wof_p);
    if (!_string.IsNullOrEmpty(wof_set)) {
        wof_set = _string.Trim(wof_set);
        if (wof_set.length > 0) {
            var temp = wof_set.split(",");
            for (var i = 0; i < temp.length; i++)
                ret.WOF_Values.push(temp[i])
        }
    }
    if (!_string.IsNullOrEmpty(wof_mask)) {
        wof_mask = _string.Trim(wof_mask);
        if (wof_mask.length > 0) {
            var temp = wof_mask.split(",");
            for (var i = 0; i < temp.length; i++)
                ret.WOF_Mask.push(temp[i])
        }
    }
    if (!_string.IsNullOrEmpty(wof_map)) {
        wof_map = _string.Trim(wof_map);
        if (wof_map.length > 0) {
            var temp = wof_map.split(",");
            for (var i = 0; i < temp.length; i++)
                ret.WOF_Map.push(_number.otoi(temp[i]))
        }
    }
    return ret
}
;
var GameProtocolCommonParser = {};
GameProtocolCommonParser.SplitResponseContent = function(nameValues) {
    var mapNameValues = {};
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=");
        if (nameValueSplitted.length == 2)
            if (mapNameValues[nameValueSplitted[0]] == undefined)
                mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
    }
    return mapNameValues
}
;
GameProtocolCommonParser.ParseDouble = function(nameValues, paramName) {
    return _number.otod(nameValues[paramName])
}
;
GameProtocolCommonParser.ParseDoubleIfExists = function(nameValues, paramName) {
    if (nameValues[paramName] == undefined)
        return -1;
    return _number.otod(nameValues[paramName])
}
;
GameProtocolCommonParser.ParseNulableDouble = function(nameValues, paramName) {
    var result = null;
    var buf = nameValues[paramName];
    if (buf != undefined)
        if (_string.Trim(buf).length > 0 && buf != "null")
            result = _number.otod(buf);
    return result
}
;
GameProtocolCommonParser.ParseInt = function(nameValues, paramName) {
    return _number.otoi(nameValues[paramName])
}
;
GameProtocolCommonParser.ParseUInt = function(nameValues, paramName) {
    return _number.otoui(nameValues[paramName])
}
;
GameProtocolCommonParser.ParseLong = function(nameValues, paramName) {
    return GameProtocolCommonParser.ParseInt(nameValues, paramName)
}
;
GameProtocolCommonParser.ParseNulableFloat = function(nameValues, paramName) {
    return GameProtocolCommonParser.ParseNulableDouble(nameValues, paramName)
}
;
GameProtocolCommonParser.ParseNulableInt = function(nameValues, paramName) {
    var result = null;
    var tmp = parseInt(nameValues[paramName], 10);
    if (isFinite(tmp) && !isNaN(tmp))
        result = tmp;
    return result
}
;
GameProtocolCommonParser.ParseIntList = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined)
        return null;
    var values = buf.split(",");
    var result = [];
    for (var i = 0; i < values.length; ++i) {
        var tmp = parseInt(values[i], 10);
        if (isFinite(tmp) && !isNaN(tmp))
            result.push(tmp)
    }
    return result
}
;
GameProtocolCommonParser.ParseDoubleList = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined)
        return null;
    var values = buf.split(",");
    var result = [];
    for (var i = 0; i < values.length; ++i) {
        var tmp = parseFloat(values[i]);
        if (isFinite(tmp) && !isNaN(tmp))
            result.push(tmp)
    }
    return result
}
;
GameProtocolCommonParser.ParseStringList = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined)
        return null;
    return buf.split(",")
}
;
GameProtocolCommonParser.ParseText = function(response, key) {
    var result = null;
    if (_string.IsNullOrEmpty(response))
        return result;
    var mapNameValues = {};
    var nameValues = response.split("&");
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=");
        if (nameValueSplitted.length == 2)
            if (mapNameValues[nameValueSplitted[0]] == undefined)
                mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
    }
    if (mapNameValues[key] != undefined)
        result = mapNameValues[key];
    return result
}
;
GameProtocolCommonParser.ParseIfExist = function(nameValues, key) {
    if (nameValues[key] != undefined)
        return nameValues[key];
    return null
}
;
GameProtocolCommonParser.ParseBalance = function(nameValues) {
    var data = null;
    if (nameValues[GameProtocolDictionary.balance] != undefined) {
        data = new BalanceData;
        if (nameValues[GameProtocolDictionary.bonusBalance] != undefined && XT.GetBool(Vars.Jurisdiction_SplitBalance)) {
            data.Balance = _number.otod(nameValues[GameProtocolDictionary.cashBalance]);
            data.BonusBalance = _number.otod(nameValues[GameProtocolDictionary.bonusBalance])
        } else
            data.Balance = _number.otod(nameValues[GameProtocolDictionary.balance]);
        if (nameValues[GameProtocolDictionary.time] != undefined)
            data.Time = _number.otod(nameValues[GameProtocolDictionary.time]);
        else if (BalanceManager.I != null && BalanceManager.I.data != null)
            data.Time = BalanceManager.I.data.Time + 1
    }
    return data
}
;
GameProtocolCommonParser.BuildBalanceData = function(value, bonusvalue, time) {
    var data = new BalanceData;
    data.Balance = value;
    data.BonusBalance = bonusvalue;
    data.Time = time;
    return data
}
;
GameProtocolCommonParser.SortAscCompare = function(a, b) {
    return a - b
}
;
GameProtocolCommonParser.SortIntList = function(unsortedList, startPos, count) {
    if (startPos != undefined && count != undefined) {
        var tmpList = unsortedList.slice(startPos, startPos + count);
        tmpList.sort(GameProtocolCommonParser.SortAscCompare);
        for (var i = 0; i < count; ++i)
            unsortedList[startPos + i] = tmpList[i];
        return unsortedList
    } else {
        unsortedList.sort(GameProtocolCommonParser.SortAscCompare);
        return unsortedList
    }
}
;
GameProtocolCommonParser.FindElementPositionsIgnoreSign = function(element, theList) {
    var rv = [];
    for (var i = 0; i < theList.length; ++i)
        if (Math.abs(theList[i]) == element)
            rv.push(i);
    return rv
}
;
var GameProtocolDictionary = {
    line: "l",
    coin: "c",
    defaultBet: "defc",
    coinID: "cid",
    tryMeOnceCoin: "tmc",
    tryMeOnceLine: "tml",
    winAmountShort: "w",
    extraAwardWin: "e_aw",
    randomWildsData: "rwd",
    upSymbols: "ups",
    expandingSymbolsData: "ep",
    symbolsBeforeExpanding: "is",
    winSymbols: "s",
    balance: "balance",
    cashBalance: "balance_cash",
    bonusBalance: "balance_bonus",
    time: "stime",
    reelsPosition: "pos",
    index: "index",
    counter: "counter",
    repeat: "repeat",
    respin: "rs",
    respinCycleWin: "rs_win",
    currentRespin: "rs_c",
    maxRespins: "rs_m",
    totalRespins: "rs_t",
    progressiveFeature: "progressive",
    stickySymbols: "sty",
    mergingSymbols: "mrg",
    freeSpinsOptions: "fs_opt",
    freeSpinsOptionsMask: "fs_opt_mask",
    randomWildWinSymbolId: "rws",
    freeSpinsPickedOptionIndex: "fsopt_i",
    freeSpinCurrentNumber: "fs",
    freeSpinMaxNumber: "fsmax",
    freeSpinTotalNumber: "fs_total",
    freeSpinCurrentWin: "fswin",
    freeSpinTotalWin: "fswin_total",
    freeSpinCurrentMultiplier: "fsmul",
    freeSpinTotalMultipl: "fsmul_total",
    bets: "sc",
    paytable: "paytable",
    scatters: "scatters",
    wilds: "wilds",
    bonuses: "bonuses",
    symbol: "symbol",
    clientVersion: "cver",
    freeSpinCurrentWinMultiplied: "fsres",
    freeSpinTotalWinMultiplied: "fsres_total",
    mgckey: "mgckey",
    noRating: "noRating",
    stackedSymbolIndex: "n_rss",
    stackedSymbolIndexCurrent: "rss",
    reelSetIndex: "n_reel_set",
    reelSetIndexCurrent: "reel_set",
    numberOfReelSets: "reel_set_size",
    wildRandomMultipliers: "wdrm_v",
    wildRandomMultiplierMask: "wdrm_m",
    randomSymbolMultiplier: "rmul",
    randomMysterySymbol: "msr",
    initialMysterySymbol: "msi",
    patternedMysterySymbols: "msi_p",
    possibleRandomSymbolMultipliers: "prm",
    naSymbolId: "nas",
    nudgedSymbols: "sn",
    symbolReplacementData: "srf",
    ReelsAllowedToRotateSeparately: "sor_ra",
    ReelsCoeficients: "sor_coefs",
    ReelToBeSpun: "sor_ri",
    Tumbling: "tmb",
    NextReelsSymbolsList: "n_rsl",
    FreeSpinsPurchase: {
        purchaseOptions: "fspps",
        purchaseOptionsMask: "fspps_mask",
        optionIndex: "fsp",
        fsBought: "fs_bought"
    },
    BetLevel: {
        betLevelScale: "bls",
        betLevelIndex: "bl",
        betLevelPaytable: "bl_paytable"
    },
    OpeningSymbols: {
        positions: "i_pos",
        freeSpinsWon: "win_fs",
        multiplierWon: "win_mul"
    },
    TopBottomSymbols: {
        symbolsAbove: "sa",
        symbolsBelow: "sb"
    },
    FreeSpinsChain: {
        spins: "fscs",
        multipliers: "fscm",
        spinsTotal: "fsc_total",
        multipliersTotal: "fsc_mul_total",
        winsTotal: "fsc_win_total",
        multipliedWinTotal: "fsc_res_total",
        sessionsWonThisSpin: "fsc_sw",
        sessionsWonSymbolsCount: "fsc_sessions"
    },
    winLines: function(i) {
        return "l" + i
    },
    reel: function(i) {
        return "reel" + i
    },
    n_reel: function(i) {
        return "n_reel" + i
    },
    reelSet: function(i) {
        return "reel_set" + i
    },
    frozen: "frozen",
    techbreak: "techbreak",
    noMoney: "nomoney",
    reload: "reload",
    link: "link",
    pnow: "pnow:1",
    winAmountLong: "win",
    mysteryScatterGame: "mb",
    mysteryScatterSymbol: "ms",
    mysteryScatterSymbolGameHistory: "msgh",
    wildScatters: "msc",
    slotHeight: "sh",
    undefined: "undefined",
    unlogged: "unlogged",
    configs: "cfgs",
    spinCycleWin: "tw",
    returnToPlayer: "rtp",
    WildRandomLineMultiplier: {
        configuration: "wrlm_sets",
        response: "wrlm_res",
        currentSet: "wrlm_cs"
    },
    RandomAward: {
        Configuration: {
            normal: "base_aw",
            freeSpins: "fs_aw",
            reelConfigCount: "aw_reel_count",
            reelConfig: "aw_reel",
            nextReelConfig: "n_aw_reel"
        },
        Type: {
            trigger: "t",
            multiplier: "m",
            featureTrigger: "tt"
        },
        index: "aw",
        awardPosition: "aw_p"
    },
    ProgressiveFeature: {
        progressivePick: "prg_i",
        Status: {
            stateValues: "prg",
            stateMasks: "prg_m"
        },
        Config: {
            configValues: "prg_cfg",
            configMasks: "prg_cfg_m"
        }
    },
    MoneySymbol: {
        symbolID: "mo_s",
        possibleValues: "mo_v",
        symbolsValues: "mo",
        symbolsTypes: "mo_t",
        jackpotValues: "mo_jp",
        jackpotMasks: "mo_jp_mask",
        MOSymbolTypes: {
            regular: "r",
            instantValue: "v",
            multiplierValue: "m",
            retriggerSymbol: "rt",
            jp2: "jp2",
            jp3: "jp3",
            mo1: "mo1",
            mo2: "mo2"
        }
    },
    BonusGame: {
        status: "status",
        wins: "wins",
        winsMask: "wins_mask",
        level: "level",
        life: "lifes",
        winPoints: "wp",
        realWin: "rw",
        coef: "coef",
        bonusGameExists: "bw",
        bonusGameType: "bt",
        gameOver: "end",
        bonusGameChoice: "ind",
        iWins: "i_wins",
        markers: "markers",
        lWins: "lWins",
        lInd: "lInd",
        currentBonusRespin: "rsb_c",
        maxBonusRespins: "rsb_m",
        respinSymbols: "rsb_s",
        premultipliedWinData: "rwm",
        extraRespinsWon: "rsb_more",
        respinsTotalMultiplier: "rsb_mu",
        BGItemValues: "bg_i",
        BGItemMasks: "bg_i_mask",
        Multipliers: {
            status: "mstatus",
            markers: "mmarkers",
            wins: "mwins"
        }
    },
    FreeSpinBonusGame: {
        gameExsist: "fsb_bw",
        status: "fsb_status",
        wins: "fsb_wins",
        multiplierMarkers: "fsb_mm",
        level: "fsb_level",
        life: "fsb_lives",
        gameOver: "fsb_end",
        totalSpinsWins: "fsb_s",
        totalMultiplilersWins: "fsb_m"
    },
    Gambling: {
        gambling: "gmb",
        history: "gmbhist",
        result: "gmbr",
        state: "gmbs",
        win: "gmbw",
        skipGamble: "gmbskip",
        currentGambleOccasion: "gmbp",
        option: "opt"
    },
    Actions: {
        action: "action",
        doInit: "doInit",
        doSpin: "doSpin",
        doCollect: "doCollect",
        doBonus: "doBonus",
        doFSOption: "doFSOption",
        doFSBonus: "doFSBonus",
        doMysteryScatter: "doMysteryScatter",
        doCollectBonus: "doCollectBonus",
        doGamble: "doGamble",
        doGambleCollect: "doGambleCollect",
        doJackpotCollect: "doJackpotCollect"
    },
    NextActions: {
        nextAction: "na",
        Spin: "s",
        Collect: "c",
        Gamble: "g",
        Bonus: "b",
        CollectBonus: "cb",
        FSOption: "fso",
        MysteryScatter: "m",
        FSBonus: "fsb",
        GambleCollect: "gc",
        JackpotCollect: "cj"
    },
    Jakpot: {
        jackpotActive: "jp",
        jackpotWinID: "jwid",
        jackpotWinOrder: "jwo",
        jackpotWinAmount: "jw"
    },
    FreeRound: {
        Events: "ev",
        RoundsLeft: "frn",
        TotalWin: "fra",
        Event: {
            Start: "FR0",
            Finish: "FR1",
            Error: "FR2"
        }
    },
    JackpotVisualization: {
        JPVMask: "jpv_m",
        JPVValues: "jpv_v",
        JPVType: "t",
        JPVPositions: "p",
        Type: {
            badges: "b"
        }
    },
    GoldSymbol: {
        goldSymbolReels: "gsf_r",
        goldSymbols: "gsf",
        goldSymbolAwards: "gsf_a"
    },
    ClassicPaytable: {
        combinations: "com"
    }
};
var GameProtocolFreeSpinBonusGameParser = {};
GameProtocolFreeSpinBonusGameParser.ParseFreeSpinBonusGame = function(nameValues) {
    if (nameValues[GameProtocolDictionary.FreeSpinBonusGame.gameExsist] == undefined && nameValues[GameProtocolDictionary.FreeSpinBonusGame.wins] == undefined)
        return null;
    var result = new VsFreeSpinBonusGame;
    result.GameOver = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.gameOver) == 1;
    result.Level = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.level);
    result.Lifes = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.life);
    result.SpinsWin = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.totalSpinsWins);
    result.MultipliersWin = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeSpinBonusGame.totalMultiplilersWins);
    var multiplierMarkers = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.FreeSpinBonusGame.multiplierMarkers);
    var statuses = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.FreeSpinBonusGame.status);
    var wins = GameProtocolCommonParser.ParseIntList(nameValues, GameProtocolDictionary.FreeSpinBonusGame.wins);
    if (multiplierMarkers != null && statuses != null && wins != null && multiplierMarkers.length > 0 && multiplierMarkers.length == statuses.length && statuses.length == wins.length) {
        var bonusItems = [];
        for (var i = 0; i < wins.length; i++) {
            var selected = statuses[i] != 0;
            bonusItems.push(new VsFreeSpinBonusGame.BonusItem(selected || result.GameOver ? wins[i] : 0,selected ? VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Selected : VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Available,multiplierMarkers[i] == 0 ? VsFreeSpinBonusGame.BonusItem.BonusItemType.Spin : VsFreeSpinBonusGame.BonusItem.BonusItemType.Multiplier))
        }
        result.BonusItems = bonusItems
    }
    return result
}
;
var GameProtocolGamblingParser = {};
GameProtocolGamblingParser.ParseVsGamblingResponse = function(nameValue) {
    var result = new VsGamblingResponse;
    if (nameValue[GameProtocolDictionary.noMoney] != undefined) {
        result.NoMoney = true;
        return result
    }
    result.Balance = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.Gambling.win);
    result.State = GameProtocolGamblingParser.ParseState(GameProtocolCommonParser.ParseInt(nameValue, GameProtocolDictionary.Gambling.state));
    GameProtocolGamblingParser.Populate(result, nameValue[GameProtocolDictionary.Gambling.result]);
    return result
}
;
GameProtocolGamblingParser.ParseGamblingSettings = function(nameValue) {
    var settings = new VsGamblingSettings;
    settings.SkipGambleOnInit = GameProtocolCommonParser.ParseInt(nameValue, GameProtocolDictionary.Gambling.skipGamble) == 1;
    settings.InitGamblingOccasion = GameProtocolGamblingParser.ParseCurrentGamblingOccasion(GameProtocolCommonParser.ParseIfExist(nameValue, GameProtocolDictionary.Gambling.currentGambleOccasion));
    var gambling = GameProtocolCommonParser.ParseIfExist(nameValue, GameProtocolDictionary.Gambling.gambling);
    if (gambling == null)
        return settings;
    var settingSplit = gambling.split("~");
    var occassionsSplit = settingSplit[0].split(",");
    settings.SetOccasionStatus(GamblingOccasions.Spin, occassionsSplit[0] == "1");
    settings.SetOccasionStatus(GamblingOccasions.Bonus, occassionsSplit[1] == "1");
    settings.SetOccasionStatus(GamblingOccasions.FreeSpin, occassionsSplit[2] == "1");
    for (var i = 1; i < settingSplit.length; i++) {
        var typeMultiplierPair = settingSplit[i].split(",");
        if (typeMultiplierPair.length != 2)
            continue;
        settings.SetGamblingSettings(GameProtocolGamblingParser.ParseType(_number.otoi(typeMultiplierPair[0])), _number.otod(typeMultiplierPair[1]))
    }
    return settings
}
;
GameProtocolGamblingParser.ParseGamblingHistory = function(history, win) {
    var gamblingHistory = null;
    if (history != null) {
        gamblingHistory = new VsGamblingHistory(win);
        var historySplit = history.split("~");
        for (var i = 0; i < historySplit.length; i++) {
            var response = new VsGamblingResponse;
            GameProtocolGamblingParser.Populate(response, historySplit[i]);
            gamblingHistory.AddHistoryItem(response)
        }
    }
    return gamblingHistory
}
;
GameProtocolGamblingParser.ParseState = function(state) {
    switch (state) {
    case 2:
        return GamblingState.WinLimit;
    case 1:
        return GamblingState.Win;
    default:
        return GamblingState.Lose
    }
}
;
GameProtocolGamblingParser.ParseType = function(type) {
    switch (type) {
    case 2:
        return GamblingType.Dices;
    case 1:
        return GamblingType.Suit;
    default:
        return GamblingType.CardColor
    }
}
;
GameProtocolGamblingParser.ParseCurrentGamblingOccasion = function(symbol) {
    switch (symbol) {
    case "b":
        return GamblingOccasions.Bonus;
    case "f":
        return GamblingOccasions.FreeSpin;
    default:
        return GamblingOccasions.Spin
    }
}
;
GameProtocolGamblingParser.ParseResult = function(gameResult) {
    var result = [];
    var split = gameResult.split(";");
    if (split.length != 2)
        return null;
    result.push(_number.otoi(split[0]));
    if (GamblingType.Dices == GameProtocolGamblingParser.ParseType(result[0])) {
        var tmpSplit = split[1].split(",");
        if (tmpSplit.length != 2)
            return null;
        result.push(_number.otoi(tmpSplit[0]));
        result.push(_number.otoi(tmpSplit[1]))
    } else
        result.push(_number.otoi(split[1]));
    return result
}
;
GameProtocolGamblingParser.Populate = function(response, result) {
    var gamblingResult = GameProtocolGamblingParser.ParseResult(result);
    if (gamblingResult == null)
        return;
    var type = GameProtocolGamblingParser.ParseType(gamblingResult[0]);
    response.GamblingType = type;
    if (type == GamblingType.Dices) {
        response.Dice1 = gamblingResult[1];
        response.Dice2 = gamblingResult[2]
    } else
        response.Card = gamblingResult[1]
}
;
function ServerGameResponse() {
    this.Index = 0;
    this.Counter = 0;
    this.Repeat = 0;
    this.DoSpin = false;
    this.DoCollect = false;
    this.ValuesMap = null;
    this.NextGameActions = null;
    this.ServerTime = -1
}
var GameProtocolParser = {};
GameProtocolParser.lastCounter = -1;
GameProtocolParser.ParseResponse = function(nameValues) {
    var serverGameResponse = new ServerGameResponse;
    if (nameValues.length == 0)
        return serverGameResponse;
    var hasDoSpin = false;
    var hasDoCollect = false;
    var mapNameValues = {};
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=", 2);
        if (nameValueSplitted.length == 2) {
            if (nameValueSplitted[0] == "action")
                if (nameValueSplitted[1] == "doCollect")
                    hasDoCollect = true;
                else if (nameValueSplitted[1] == "doSpin")
                    hasDoSpin = true;
            if (mapNameValues[nameValueSplitted[0]] == undefined)
                mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
        }
    }
    serverGameResponse.Index = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.index);
    serverGameResponse.Counter = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.counter);
    if (serverGameResponse.Counter == 0)
        serverGameResponse.Counter = GameProtocolParser.lastCounter + 2;
    GameProtocolParser.lastCounter = serverGameResponse.Counter;
    serverGameResponse.DoSpin = hasDoSpin;
    serverGameResponse.DoCollect = hasDoCollect;
    serverGameResponse.ValuesMap = mapNameValues;
    serverGameResponse.NextGameActions = GameProtocolParser.ParseNextGameActions(mapNameValues);
    if (mapNameValues[GameProtocolDictionary.time] != undefined)
        serverGameResponse.ServerTime = _number.otoi(mapNameValues[GameProtocolDictionary.time]);
    return serverGameResponse
}
;
GameProtocolParser.ParseNextGameActions = function(nameValues) {
    if (nameValues[GameProtocolDictionary.NextActions.nextAction] != undefined) {
        var na = [];
        var str_na = nameValues[GameProtocolDictionary.NextActions.nextAction].split(",");
        for (var i = 0; i < str_na.length; ++i)
            if (str_na[i] == GameProtocolDictionary.NextActions.Bonus)
                na.push(NextGameAction.Bonus);
            else if (str_na[i] == GameProtocolDictionary.NextActions.Collect)
                na.push(NextGameAction.Collect);
            else if (str_na[i] == GameProtocolDictionary.NextActions.CollectBonus)
                na.push(NextGameAction.CollectBonus);
            else if (str_na[i] == GameProtocolDictionary.NextActions.FSOption)
                na.push(NextGameAction.FSOption);
            else if (str_na[i] == GameProtocolDictionary.NextActions.Gamble)
                na.push(NextGameAction.Gamble);
            else if (str_na[i] == "go")
                na.push(NextGameAction.GambleOption);
            else if (str_na[i] == GameProtocolDictionary.NextActions.Spin)
                na.push(NextGameAction.Spin);
            else if (str_na[i] == GameProtocolDictionary.NextActions.MysteryScatter)
                na.push(NextGameAction.MysteryScatter);
            else if (str_na[i] == GameProtocolDictionary.NextActions.FSBonus)
                na.push(NextGameAction.FSBonus);
            else if (str_na[i] == GameProtocolDictionary.NextActions.GambleCollect)
                na.push(NextGameAction.GambleCollect);
            else if (str_na[i] == GameProtocolDictionary.NextActions.JackpotCollect)
                na.push(NextGameAction.JackpotCollect);
            else
                na.push(NextGameAction.None);
        return na
    }
    return null
}
;
var VSProtocolParser = {};
VSProtocolParser.ParseResponse = function(response) {
    var serverGameResponse = new ServerGameResponse;
    if (_string.IsNullOrEmpty(response))
        return serverGameResponse;
    var hasDoSpin = false;
    var hasDoCollect = false;
    var mapNameValues = {};
    var nameValues = response.split("&");
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=");
        if (nameValueSplitted.length == 2) {
            if (nameValueSplitted[0] == "action")
                if (nameValueSplitted[1] == "doCollect")
                    hasDoCollect = true;
                else if (nameValueSplitted[1] == "doSpin")
                    hasDoSpin = true;
            if (mapNameValues[nameValueSplitted[0]] == undefined)
                mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
        }
    }
    serverGameResponse.Index = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.index);
    serverGameResponse.Counter = GameProtocolCommonParser.ParseInt(mapNameValues, GameProtocolDictionary.counter);
    serverGameResponse.DoSpin = hasDoSpin;
    serverGameResponse.DoCollect = hasDoCollect;
    return serverGameResponse
}
;
VSProtocolParser.ParseVsGamblingResponse = function(response) {
    var result = new VsGamblingResponse;
    if (_string.IsNullOrEmpty(response))
        return result;
    var mapNameValues = {};
    var nameValues = response.split("&");
    for (var i = 0; i < nameValues.length; ++i) {
        var nameValueSplitted = nameValues[i].split("=");
        if (nameValueSplitted.length == 2)
            if (mapNameValues[nameValueSplitted[0]] == undefined)
                mapNameValues[nameValueSplitted[0]] = nameValueSplitted[1]
    }
    return GameProtocolGamblingParser.ParseVsGamblingResponse(mapNameValues)
}
;
VSProtocolParser.ParseVsInitData = function(nameValue) {
    var result = new VsInitData;
    result.Bets = GameProtocolCommonParser.ParseDoubleList(nameValue, GameProtocolDictionary.bets);
    result.Bet = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.coin);
    result.DefaultBet = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.defaultBet);
    result.Line = GameProtocolCommonParser.ParseInt(nameValue, GameProtocolDictionary.line);
    result.ReelSymbols = VSProtocolParser.ParseReelsSymbols(nameValue);
    result.ReelSets = VSProtocolParser.ParseReelSets(nameValue);
    result.NextReelSymbols = VSProtocolParser.ParseNextReelsSymbols(nameValue);
    result.Paytable = VSProtocolParser.ParsePaytable(nameValue, GameProtocolDictionary.paytable);
    result.Scatters = VSProtocolParser.ParseScatters(nameValue);
    result.Bonuses = VSProtocolParser.ParseBonuses(nameValue);
    result.Wilds = VSProtocolParser.ParseWilds(nameValue, GameProtocolDictionary.wilds);
    result.WildScatters = VSProtocolParser.ParseWilds(nameValue, GameProtocolDictionary.wildScatters);
    result.InitialMysterySymbolId = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.initialMysterySymbol);
    result.BGItemValues = GameProtocolCommonParser.ParseDoubleList(nameValue, GameProtocolDictionary.BonusGame.BGItemValues);
    result.BGItemMasks = GameProtocolCommonParser.ParseStringList(nameValue, GameProtocolDictionary.BonusGame.BGItemMasks);
    result.CombinePaytable();
    var tryMeOnceLine = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.tryMeOnceLine);
    var tryMeOnceBet = GameProtocolCommonParser.ParseNulableDouble(nameValue, GameProtocolDictionary.tryMeOnceCoin);
    var reelSetIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndex);
    result.ReelSetIndex = reelSetIndex != null ? reelSetIndex : -1;
    var stackedSymbolIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndex);
    result.StackedSymbolIndex = stackedSymbolIndex != null ? stackedSymbolIndex : -1;
    var reelSetIndexCurrent = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndexCurrent);
    result.ReelSetIndexCurrent = reelSetIndexCurrent != null ? reelSetIndexCurrent : -1;
    var stackedSymbolIndexCurrent = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndexCurrent);
    result.StackedSymbolIndexCurrent = stackedSymbolIndexCurrent != null ? stackedSymbolIndexCurrent : -1;
    var naSymbolId = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.naSymbolId);
    result.naSymbolId = naSymbolId != null ? naSymbolId : -1;
    if (tryMeOnceLine != null && tryMeOnceBet != null && tryMeOnceLine > 0 && tryMeOnceBet > 0) {
        result.Bet = tryMeOnceBet;
        result.Line = tryMeOnceLine
    }
    result.GamblingSettings = GameProtocolGamblingParser.ParseGamblingSettings(nameValue);
    result.GamblingHistory = GameProtocolGamblingParser.ParseGamblingHistory(GameProtocolCommonParser.ParseIfExist(nameValue, GameProtocolDictionary.Gambling.history), GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.Gambling.win));
    result.WildRandomLineMpConfig = VSProtocolParser.ParseVsWildRandomLineMultiplier(nameValue);
    result.RandomAwardConfig = VSProtocolParser.ParseVsRandomAwardsConfig(nameValue);
    result.ProgressiveConfig = VSProtocolParser.ParseProgressiveFeatureConfig(nameValue);
    result.MoneySymbolConfig = VSProtocolParser.ParseMoneySymbolConfig(nameValue);
    result.FreeSpinsPurchaseConfig = VSProtocolParser.ParseFSPurchaseConfig(nameValue);
    result.BetLevelSettings = VSProtocolParser.ParseBetLevelSettings(nameValue);
    return result
}
;
VSProtocolParser.ParseVsResponse = function(nameValue) {
    var result = new VsResponse;
    result.SlotHeight = GameProtocolCommonParser.ParseInt(nameValue, GameProtocolDictionary.slotHeight);
    if (result.SlotHeight == 0)
        result.SlotHeight = GameConnection.prototype.SlotHeight;
    if (nameValue[GameProtocolDictionary.bonusBalance] == undefined || !XT.GetBool(Vars.Jurisdiction_SplitBalance)) {
        result.Balance = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.balance);
        result.BonusBalance = 0
    } else {
        result.Balance = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.cashBalance);
        result.BonusBalance = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.bonusBalance)
    }
    result.Win = VSProtocolParser.ParseWinAmountShort(nameValue);
    result.ExtraAwardWin = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.extraAwardWin);
    result.RespinCycleWin = GameProtocolCommonParser.ParseDouble(nameValue, GameProtocolDictionary.respinCycleWin);
    result.ReelPositions = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.reelsPosition);
    result.ExpandingSymbolsData = VSProtocolParser.ParseExpandingSymbolsData(nameValue);
    result.SymbolsBeforeExpanding = VSProtocolParser.ParseSymbolsBeforeExpanding(nameValue, result.SlotHeight);
    result.RandomWildsData = VSProtocolParser.ParseRandomWildsData(nameValue, result.SlotHeight);
    result.UpSymbols = VSProtocolParser.ParseUpSymbols(nameValue);
    result.WinScreenSymbols = VSProtocolParser.ParseWinScreenSymbols(nameValue, result.SlotHeight);
    result.SymbolsAbove = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.TopBottomSymbols.symbolsAbove);
    result.SymbolsBelow = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.TopBottomSymbols.symbolsBelow);
    result.NextReelsSymbolsList = GameProtocolCommonParser.ParseIntList(nameValue, GameProtocolDictionary.NextReelsSymbolsList);
    result.VsWinLines = VSProtocolParser.ParseWinLines(nameValue);
    result.SetVsBonusGameData(GameProtocolBonusGameParser.ParseBonusGame(nameValue));
    result.FreeSpinsOptions = VSProtocolParser.ParseFreeSpinsOptions(nameValue);
    result.WildRandomMultipliers = VSProtocolParser.ParseWildRandomMultipliers(nameValue);
    result.Respin = VSProtocolParser.ParseRespin(nameValue);
    if (XT.GetBool(Vars.TruncateFSResponseDuringRespin) && result.Respin != null && result.Respin.TotalRespins == null)
        result.TruncatedVsFreeSpin = VSProtocolParser.ParseVsFreeSpin(nameValue);
    else
        result.SetVsFreeSpin(VSProtocolParser.ParseVsFreeSpin(nameValue));
    result.VsInitData = VSProtocolParser.ParseVsInitData(nameValue);
    result.VsJackpotData = VSProtocolParser.ParseVsJackpotData(nameValue);
    result.JackpotVisualisation = VSProtocolParser.ParseJPVisualization(nameValue);
    result.GoldSymbol = VSProtocolParser.ParseGoldSymbol(nameValue);
    result.SymbolReplacementData = VSProtocolParser.ParseSymbolReplacementData(nameValue);
    result.SpinOneReelData = VSProtocolParser.ParseSpinOneReelData(nameValue);
    result.TumblingData = VSProtocolParser.ParseTumblingData(nameValue);
    result.NudgedSymbolsData = VSProtocolParser.ParseNudgedSymbolsData(nameValue);
    result.FreeRoundEvents = VSProtocolParser.ParseVsFreeRoundEvents(nameValue);
    result.FreeRound = VSProtocolParser.ParseVsFreeRound(nameValue);
    result.ProgressiveData = VSProtocolParser.ParseProgressiveFeatureData(nameValue);
    result.MoneySymbolData = VSProtocolParser.ParseMoneySymbolData(nameValue);
    result.StickySymbols = VSProtocolParser.ParseStickySymbols(nameValue);
    result.MergingSymbols = VSProtocolParser.ParseMergingSymbols(nameValue);
    result.WRLMResponse = VSProtocolParser.ParseWRLMResponse(nameValue);
    result.WRLMCurrentSets = VSProtocolParser.ParseWRLMCurrentSets(nameValue);
    result.RandomAwardResponse = VSProtocolParser.ParseRandomAwardsResponse(nameValue);
    result.RandomSymbolMultipliers = VSProtocolParser.ParseRandomSymbolMultipliers(nameValue);
    result.PossibleRandomSymbolMultipliers = VSProtocolParser.ParsePossibleRandomSymbolMultipliers(nameValue);
    result.FreeSpinsChainData = VSProtocolParser.ParseFreeSpinsChainedData(nameValue);
    result.OpeningSymbolsData = VSProtocolParser.ParseOpeningSymbolsData(nameValue);
    result.FreeSpinsPurchaseData = VSProtocolParser.ParseFSPurchaseData(nameValue);
    result.RandomMysterySymbolId = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.randomMysterySymbol);
    result.PatternedMysterySymbols = VSProtocolParser.ParsePatternedMysterySymbols(nameValue);
    result.SpinCycleWin = GameProtocolCommonParser.ParseDoubleIfExists(nameValue, GameProtocolDictionary.spinCycleWin);
    var rtp = GameProtocolCommonParser.ParseDoubleList(nameValue, GameProtocolDictionary.returnToPlayer);
    if (rtp != null)
        if (rtp.length > 1) {
            result.ReturnToPlayerMin = rtp[0];
            result.ReturnToPlayer = rtp[1]
        } else
            result.ReturnToPlayer = rtp[0];
    var reelSetIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndex);
    result.ReelSetIndex = reelSetIndex != null ? reelSetIndex : -1;
    var stackedSymbolIndex = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndex);
    result.StackedSymbolIndex = stackedSymbolIndex != null ? stackedSymbolIndex : -1;
    var reelSetIndexCurrent = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.reelSetIndexCurrent);
    result.ReelSetIndexCurrent = reelSetIndexCurrent != null ? reelSetIndexCurrent : -1;
    var stackedSymbolIndexCurrent = GameProtocolCommonParser.ParseNulableInt(nameValue, GameProtocolDictionary.stackedSymbolIndexCurrent);
    result.StackedSymbolIndexCurrent = stackedSymbolIndexCurrent != null ? stackedSymbolIndexCurrent : -1;
    result.gambleV2Data = GambleV2Protocol.Parser.ParseGambleData(nameValue);
    XT.SetBool(Vars.OpenFSBGForMysteryScatter, nameValue[GameProtocolDictionary.mysteryScatterGame] != undefined && XT.GetBool(Vars.SendSeparateMysteryScatter));
    return result
}
;
VSProtocolParser.ParseWinAmountShort = function(nameValues) {
    if (nameValues[GameProtocolDictionary.winAmountShort] != undefined)
        return GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.winAmountShort);
    else
        return -1
}
;
VSProtocolParser.ParseVsFreeSpin = function(nameValues) {
    if (nameValues[GameProtocolDictionary.freeSpinCurrentNumber] == undefined && nameValues[GameProtocolDictionary.freeSpinTotalNumber] == undefined && nameValues[GameProtocolDictionary.FreeSpinBonusGame.gameExsist] == undefined && nameValues[GameProtocolDictionary.FreeSpinBonusGame.wins] == undefined && nameValues[GameProtocolDictionary.mysteryScatterSymbol] == undefined && nameValues[GameProtocolDictionary.mysteryScatterSymbolGameHistory] == undefined)
        return null;
    var result = new VsFreeSpin;
    result.SetCurrentNumber(GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinCurrentNumber));
    result.SetMaxNumber(GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinMaxNumber));
    result.SetTotalNumber(GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinTotalNumber));
    result.SetTotalWin(GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinTotalWin));
    result.SetTotalWinMultiplied(GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinTotalWinMultiplied));
    var ppoi = GameProtocolCommonParser.ParseIfExist(nameValues, GameProtocolDictionary.freeSpinsPickedOptionIndex);
    if (!_string.IsNullOrEmpty(ppoi))
        result.PickedOptionIndex = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.freeSpinsPickedOptionIndex);
    else
        result.PickedOptionIndex = -1;
    if (nameValues[GameProtocolDictionary.freeSpinCurrentMultiplier] != undefined)
        result.SetTotalMultipl(GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinCurrentMultiplier));
    else
        result.SetTotalMultipl(GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinTotalMultipl));
    if (nameValues[GameProtocolDictionary.freeSpinCurrentWin] != undefined) {
        var currentWin = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinCurrentWin);
        currentWin = Math.round(currentWin * 100) / 100;
        result.SetCurrentWin(currentWin)
    } else
        result.SetCurrentWin(result.GetTotalWin());
    result.SetCurrentWinMultiplied(nameValues[GameProtocolDictionary.freeSpinCurrentWinMultiplied] != undefined ? GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.freeSpinCurrentWinMultiplied) : result.GetTotalWinMultiplied());
    result.BonusGame = GameProtocolFreeSpinBonusGameParser.ParseFreeSpinBonusGame(nameValues);
    var mysteryScatterSymbol = null;
    var mysteryScatterSymbolGameHistory = null;
    if (nameValues[GameProtocolDictionary.mysteryScatterSymbol] != undefined)
        mysteryScatterSymbol = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.mysteryScatterSymbol);
    if (nameValues[GameProtocolDictionary.mysteryScatterSymbolGameHistory] != undefined)
        mysteryScatterSymbolGameHistory = GameProtocolCommonParser.ParseNulableInt(nameValues, GameProtocolDictionary.mysteryScatterSymbolGameHistory);
    result.SetMysteryScatter(mysteryScatterSymbol != null ? mysteryScatterSymbol : mysteryScatterSymbolGameHistory);
    result.SetNeedGetMysteryScatter(nameValues[GameProtocolDictionary.mysteryScatterGame] != undefined && result.GetMysteryScatter() == null);
    var key = "fstype";
    if (nameValues[key] != undefined)
        result.fstype = GameProtocolBonusGameParser.ParseWinMask(nameValues[key]);
    return result
}
;
VSProtocolParser.ParseRespin = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.respin);
    var currentRespin = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.currentRespin);
    var totalRespins = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.totalRespins);
    var isTriggeredType = data == "t";
    var untilWinType = data == "uw";
    if (!isTriggeredType && !untilWinType && !_string.IsNullOrEmpty(data)) {
        data = _string.Trim(data);
        if (data.length > 0) {
            var dataSplit = data.split("~");
            result = new VsRespin;
            result.RespinType = dataSplit[0];
            result.Indices = [];
            if (result.RespinType == "l") {
                var lines = [];
                for (var i = 1; i < dataSplit.length; ++i) {
                    var lineSplit = dataSplit[i].split(";");
                    if (lineSplit.length > 2) {
                        var line = new VsRespinLine;
                        line.respinsCount = _number.otoi(lineSplit[0]);
                        line.id = _number.otoi(lineSplit[1]);
                        line.positions = _array.ConvertAll(lineSplit[2].split(","), _number.otoi);
                        lines.push(line)
                    }
                }
                result.Lines = lines.length > 0 ? lines : null
            } else {
                var indicesLists = dataSplit[1].split(";");
                for (var i = 0; i < indicesLists.length; i++) {
                    result.Indices[i] = [];
                    var indices = indicesLists[i].split(",");
                    for (var j = 0; j < indices.length; j++)
                        result.Indices[i].push(_number.otoi(indices[j]))
                }
            }
        }
    }
    if (!_string.IsNullOrEmpty(currentRespin) || !_string.IsNullOrEmpty(totalRespins)) {
        if (result == null)
            result = new VsRespin;
        result.CurrentRespin = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.currentRespin);
        result.MaxRespins = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.maxRespins);
        result.TotalRespins = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.totalRespins)
    }
    if (source["rs_p"] != undefined)
        result.RespinsPlayed = _number.otoi(source["rs_p"]);
    if (source["rs_more"] != undefined)
        result.RespinsAdded = _number.otoi(source["rs_more"]);
    return result
}
;
VSProtocolParser.ParseProgressiveFeatureConfig = function(dict) {
    var result = null;
    var cfg_masks_string = GameProtocolCommonParser.ParseIfExist(dict, GameProtocolDictionary.ProgressiveFeature.Config.configMasks);
    if (!_string.IsNullOrEmpty(cfg_masks_string)) {
        result = new VSProgressiveFeatureConfig;
        var pickedSymbolPos = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.ProgressiveFeature.progressivePick);
        result.pickedSymbolPosition = pickedSymbolPos === null ? -1 : pickedSymbolPos;
        var cfg_masks = cfg_masks_string.split(",");
        var cfg_vals = GameProtocolCommonParser.ParseIntList(dict, GameProtocolDictionary.ProgressiveFeature.Config.configValues);
        result.progressSymbolIDs = [];
        for (var i = 0; i < cfg_masks.length; i++)
            if (cfg_masks[i] == "s")
                result.progressSymbolIDs.push(cfg_vals[i])
    }
    return result
}
;
VSProtocolParser.ParseProgressiveFeatureData = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.progressiveFeature);
    if (!_string.IsNullOrEmpty(data)) {
        var splitData = data.split(",");
        var lvlStr = splitData[0].split(":")[1];
        var progStr = splitData[1].split(":")[1];
        var attemptsStr = splitData[2].split(":")[1];
        if (_string.IsNullOrEmpty(lvlStr) || _string.IsNullOrEmpty(progStr) || _string.IsNullOrEmpty(attemptsStr))
            return null;
        result = new VsProgressiveFeatureData;
        result.level = _number.otoi(lvlStr);
        result.progress = _number.otoi(progStr);
        result.attempts = _number.otoi(attemptsStr)
    } else {
        var prg_m_string = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.ProgressiveFeature.Status.stateMasks);
        if (!_string.IsNullOrEmpty(prg_m_string)) {
            result = new VsProgressiveFeatureData;
            var prg_m = prg_m_string.split(",");
            var prg_v = String(source[GameProtocolDictionary.ProgressiveFeature.Status.stateValues]).split(",");
            for (var i = 0; i < prg_m.length; i++)
                if (prg_m[i] == "ca")
                    result.currentAttempt = _number.otoi(prg_v[i]);
                else if (prg_m[i] == "ta")
                    result.attempts = _number.otoi(prg_v[i]);
                else if (prg_m[i] == "cp")
                    result.progress = _number.otoi(prg_v[i]);
                else if (prg_m[i] == "tp")
                    result.targetProgress = _number.otoi(prg_v[i]);
                else if (prg_m[i] == "lvl")
                    result.level = _number.otoi(prg_v[i]);
                else if (prg_m[i] == "r")
                    result.needsReset = _number.otoi(prg_v[i]) == 1;
                else if (prg_m[i] == "acw")
                    result.accumulatedWin = _number.otod(prg_v[i]);
                else if (prg_m[i] == "pp")
                    result.prizeWin = _number.otod(prg_v[i]);
                else if (prg_m[i] == "pm")
                    result.prizeMultiplier = _number.otoi(prg_v[i]);
                else if (prg_m[i] == "wm")
                    result.winMultiplier = _number.otoi(prg_v[i])
        }
    }
    return result
}
;
VSProtocolParser.ParseMoneySymbolConfig = function(source) {
    var result = null;
    if (source[GameProtocolDictionary.MoneySymbol.symbolID] != undefined) {
        result = new VsMoneySymbolConfig;
        result.symbolID = GameProtocolCommonParser.ParseInt(source, GameProtocolDictionary.MoneySymbol.symbolID);
        result.possibleValues = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.MoneySymbol.possibleValues);
        var jpData = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.MoneySymbol.jackpotValues);
        var i;
        if (!_string.IsNullOrEmpty(jpData)) {
            var jpVals = jpData.split(";");
            result.jackpotValues = [];
            for (i = 0; i < jpVals.length; i++)
                result.jackpotValues.push(_number.otoi(jpVals[i]))
        }
        jpData = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.MoneySymbol.jackpotMasks);
        if (!_string.IsNullOrEmpty(jpData))
            result.jackpotMasks = jpData.split(";")
    }
    return result
}
;
VSProtocolParser.ParseMoneySymbolData = function(source) {
    var result = null;
    if (source[GameProtocolDictionary.MoneySymbol.symbolsValues] != undefined) {
        result = new VsMoneySymbolData;
        result.currentValues = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.MoneySymbol.symbolsValues);
        result.currentSymbolsLook = GameProtocolCommonParser.ParseStringList(source, GameProtocolDictionary.MoneySymbol.symbolsTypes)
    }
    return result
}
;
VSProtocolParser.ParseFSPurchaseConfig = function(source) {
    var cfg = null;
    var masks = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.FreeSpinsPurchase.purchaseOptionsMask);
    var options = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.FreeSpinsPurchase.purchaseOptions);
    if (!_string.IsNullOrEmpty(masks) && !_string.IsNullOrEmpty(options)) {
        cfg = new VsFSPurchaseConfig;
        var masksSplit = masks.split(";");
        var optionsSplit = options.split(";");
        for (var i = 0; i < masksSplit.length; i++) {
            cfg.purchaseOptions.push(new VsFSPurchaseConfig.PurchaseOption);
            var mask = masksSplit[i].split("~");
            var option = optionsSplit[i].split("~");
            for (var j = 0; j < mask.length; j++)
                switch (mask[j]) {
                case "bet":
                    cfg.purchaseOptions[i].bet = _number.otoi(option[j]);
                    break;
                case "fs_count":
                    cfg.purchaseOptions[i].fsCount = _number.otoi(option[j]);
                    break;
                case "bet_level":
                    cfg.purchaseOptions[i].betLevel = _number.otoi(option[j]);
                    break;
                default:
                    break
                }
        }
    }
    return cfg
}
;
VSProtocolParser.ParseBetLevelSettings = function(source) {
    var settings = null;
    var betLevelScale = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.BetLevel.betLevelScale);
    if (betLevelScale != null) {
        settings = new VsBetLevel;
        settings.betLevelIndex = GameProtocolCommonParser.ParseInt(source, GameProtocolDictionary.BetLevel.betLevelIndex);
        settings.betLevelScale = betLevelScale;
        for (var i = 0; i < settings.betLevelScale.length; i++) {
            var blPaytable = VSProtocolParser.ParsePaytable(source, GameProtocolDictionary.BetLevel.betLevelPaytable + i.toString());
            if (blPaytable != null)
                settings.paytables.push(blPaytable)
        }
    }
    return settings
}
;
VSProtocolParser.ParseStickySymbols = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.stickySymbols);
    if (!_string.IsNullOrEmpty(data)) {
        data = _string.Trim(data);
        if (data.length > 0) {
            result = [];
            var stickySymbols = data.split("~");
            for (var ssIndex = 0; ssIndex < stickySymbols.length; ssIndex++) {
                var positions = stickySymbols[ssIndex].split(",");
                var _symbol = new VsStickySymbol;
                _symbol.currentPosition = _number.otoi(positions[0]);
                _symbol.endPosition = _number.otoi(positions[1]);
                result.push(_symbol)
            }
        }
    }
    return result
}
;
VSProtocolParser.ParseMergingSymbols = function(source) {
    var result = null;
    var data = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.mergingSymbols);
    if (!_string.IsNullOrEmpty(data)) {
        data = _string.Trim(data);
        if (data.length > 0) {
            result = [];
            var mergingSymbols = data.split(",");
            for (var ssIndex = 0; ssIndex < mergingSymbols.length; ssIndex++) {
                var mergingInfo = mergingSymbols[ssIndex].split("~");
                var _mergingSymbol = new VsMergingSymbol;
                _mergingSymbol.mergingPosition = _number.otoi(mergingInfo[0]);
                _mergingSymbol.mergedSymbolId = _number.otoi(mergingInfo[1]);
                result.push(_mergingSymbol)
            }
        }
    }
    return result
}
;
VSProtocolParser.GetFreeSpinsOptions = function(source) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.freeSpinsOptions);
    if (!_string.IsNullOrEmpty(ws))
        result = _string.Trim(ws).split("~");
    return result
}
;
VSProtocolParser.GetFreeSpinsOptionsMasks = function(source) {
    var result = null;
    var fsom = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.freeSpinsOptionsMask);
    if (!_string.IsNullOrEmpty(fsom))
        result = _string.Trim(fsom).split(",");
    return result
}
;
VSProtocolParser.ParseFreeSpinsOptions = function(source) {
    var result = null;
    var freeSpinsOptions = VSProtocolParser.GetFreeSpinsOptions(source);
    if (freeSpinsOptions != null) {
        result = [];
        for (var i = 0; i < freeSpinsOptions.length; i++) {
            var _data = freeSpinsOptions[i].split(",");
            var _masks = VSProtocolParser.GetFreeSpinsOptionsMasks(source);
            var _freeSpinsOption = new VsFreeSpinOption;
            if (_masks == null) {
                _freeSpinsOption.FreeSpinsCount = _number.otoi(_data[0]);
                _freeSpinsOption.FreeSpinsMultiplier = _number.otoi(_data[1])
            } else
                for (var j = 0; j < _masks.length; j++)
                    switch (_masks[j]) {
                    case "fs":
                        _freeSpinsOption.FreeSpinsCount = _number.otoi(_data[j]);
                        break;
                    case "m":
                        _freeSpinsOption.FreeSpinsMultiplier = _number.otoi(_data[j]);
                        break;
                    case "ss":
                        _freeSpinsOption.FreeSpinsStackedSymbol = _number.otoi(_data[j]);
                        break;
                    case "ws":
                        _freeSpinsOption.WildSymbolIndex = _number.otoi(_data[j]);
                        break;
                    case "wm":
                        _freeSpinsOption.WildWinMultipliers.push(_number.otoi(_data[j]));
                        break;
                    case "ftr":
                        _freeSpinsOption.SpecialFeatureName = _data[j];
                        break;
                    case "ts":
                        _freeSpinsOption.TriggerSymbolRandomMultiplier = _number.otoi(_data[j]);
                        break;
                    case "rm":
                        var randomMultipliers = _data[j].split(";");
                        for (var rmIndex = 0; rmIndex < randomMultipliers.length; rmIndex++)
                            _freeSpinsOption.TSRandomMultipliers.push(_number.otoi(randomMultipliers[rmIndex]));
                        break;
                    default:
                        break
                    }
            result.push(_freeSpinsOption)
        }
    }
    return result
}
;
VSProtocolParser.GetExpandingSymbolsData = function(source) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.expandingSymbolsData);
    if (!_string.IsNullOrEmpty(ws))
        result = _string.Trim(ws).split(";");
    return result
}
;
VSProtocolParser.GetSymbolsBeforeExpanding = function(source) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.symbolsBeforeExpanding);
    if (!_string.IsNullOrEmpty(ws))
        result = _string.Trim(ws).split(",");
    return result
}
;
VSProtocolParser.GetWinSymbols = function(source) {
    var result = null;
    var ws = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.winSymbols);
    if (!_string.IsNullOrEmpty(ws))
        result = _string.Trim(ws).split(",");
    return result
}
;
VSProtocolParser.GetReelSet = function(source, reelSetIndex) {
    var result = null;
    var rs = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.reelSet(reelSetIndex));
    if (!_string.IsNullOrEmpty(rs))
        result = _string.Trim(rs).split("~");
    return result
}
;
VSProtocolParser.ParseRandomWildsData = function(source, reelHeight) {
    var result = null;
    var rwd = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.randomWildsData);
    if (_string.IsNullOrEmpty(rwd))
        return result;
    result = [];
    var splitByIDs = rwd.split(";");
    for (var i = 0; i < splitByIDs.length; i++) {
        var splitByComponents = splitByIDs[i].split("~");
        var rwdID = _number.otoi(splitByComponents[0]);
        var splitByPosition = splitByComponents[1].split(",");
        for (var j = 0; j < splitByPosition.length; j++) {
            if (j % reelHeight == 0) {
                var vsRWD = new VsRandomWildsData;
                vsRWD.RandomSymbolID = rwdID;
                vsRWD.TargetPositions = [];
                result.push(vsRWD)
            }
            result[result.length - 1].TargetPositions.push(_number.otoi(splitByPosition[j]))
        }
    }
    return result
}
;
VSProtocolParser.ParseUpSymbols = function(source) {
    var result = null;
    var ups = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.upSymbols);
    if (_string.IsNullOrEmpty(ups))
        return result;
    result = [];
    var splitByPosition = ups.split(",");
    for (var i = 0; i < splitByPosition.length; i++)
        result.push(_number.otoi(splitByPosition[i]));
    return result
}
;
VSProtocolParser.ParseExpandingSymbolsData = function(source) {
    var result = null;
    var expandingSymbolsData = VSProtocolParser.GetExpandingSymbolsData(source);
    if (expandingSymbolsData != null) {
        result = [];
        var j;
        for (var i = 0; i < expandingSymbolsData.length; i++) {
            var _data = expandingSymbolsData[i].split("~");
            var _expandingSymbolData = new VsExpandingSymbolData;
            _expandingSymbolData.ExpandingSymbolId = _number.otoi(_data[0]);
            _expandingSymbolData.SourcePositions = [];
            var sourcePositions = _data[1].split(",");
            for (j = 0; j < sourcePositions.length; j++)
                _expandingSymbolData.SourcePositions.push(_number.otoi(sourcePositions[j]));
            _expandingSymbolData.TargetPositions = [];
            var targetPositions = _data[2].split(",");
            for (j = 0; j < targetPositions.length; j++)
                _expandingSymbolData.TargetPositions.push(_number.otoi(targetPositions[j]));
            result.push(_expandingSymbolData)
        }
    }
    return result
}
;
VSProtocolParser.ParseSymbolsBeforeExpanding = function(source, slotHeight) {
    var result = [];
    if (slotHeight > 0) {
        var symbolsBeforeExpanding = VSProtocolParser.GetSymbolsBeforeExpanding(source);
        if (symbolsBeforeExpanding != null)
            if (symbolsBeforeExpanding.length % slotHeight == 0) {
                var lineSize = symbolsBeforeExpanding.length / slotHeight;
                for (var i = 0; i < lineSize; ++i) {
                    var reelSymbols = [];
                    for (var j = 0; j < slotHeight; ++j)
                        reelSymbols.unshift(_number.otoi(symbolsBeforeExpanding[lineSize * j + i]));
                    result.push(reelSymbols)
                }
            } else
                ;
    }
    return result
}
;
VSProtocolParser.ParseWinScreenSymbols = function(source, slotHeight) {
    var result = [];
    if (slotHeight > 0) {
        var winSymbols = VSProtocolParser.GetWinSymbols(source);
        if (winSymbols != null)
            if (winSymbols.length % slotHeight == 0) {
                var lineSize = winSymbols.length / slotHeight;
                for (var i = 0; i < lineSize; ++i) {
                    var reelSymbols = [];
                    for (var j = 0; j < slotHeight; ++j)
                        reelSymbols.unshift(_number.otoi(winSymbols[lineSize * j + i]));
                    result.push(reelSymbols)
                }
            } else
                ;
    }
    return result
}
;
VSProtocolParser.ParseWinLines = function(nameValues) {
    var result = [];
    var combinations = [];
    var comb = GameProtocolCommonParser.ParseIfExist(nameValues, GameProtocolDictionary.ClassicPaytable.combinations);
    if (!_string.IsNullOrEmpty(comb)) {
        var combData = comb.split(",");
        for (var combDataIdx = 0; combDataIdx < combData.length; combDataIdx++)
            combinations.push(_number.otoi(combData[combDataIdx]))
    }
    for (var i = 0; true; i++) {
        if (nameValues[GameProtocolDictionary.winLines(i)] == undefined)
            break;
        var buf = nameValues[GameProtocolDictionary.winLines(i)];
        if (_string.IsNullOrEmpty(buf))
            continue;
        var params = buf.split("~");
        var winLine = new VsWinLine;
        var winPositions = [];
        if (params.length >= 2) {
            winLine.LineNumber = _number.otoi(params.shift());
            winLine.WinAmount = _number.otod(params.shift())
        }
        for (var j = 0; j < params.length; ++j)
            winPositions[j] = _number.otoi(params[j]);
        winLine.WinPositions = winPositions;
        if (combinations.length > 0 && i <= combinations.length - 1)
            winLine.Combination = combinations[i];
        result[i] = winLine
    }
    return result
}
;
VSProtocolParser.ParsePaytable = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined)
        return null;
    var paytable = [];
    var symbolValues = buf.split(";");
    for (var i = 0; i < symbolValues.length; ++i) {
        var symbolPaytable = [];
        var symbolValue = symbolValues[i].split(",");
        for (var j = symbolValue.length - 1; j >= 0; --j)
            symbolPaytable.push(_number.otoi(symbolValue[j]));
        paytable[i] = symbolPaytable
    }
    VSProtocolParser.ParseClassicPaytable(nameValues, paytable);
    return paytable
}
;
VSProtocolParser.ParseClassicPaytable = function(dict, vsPaytable) {
    var key = "c_paytable";
    if (dict[key] == undefined)
        return;
    var paytable = dict[key].split(";");
    for (var i = 0; i < paytable.length; ++i) {
        var split = paytable[i].split("~");
        if (split.length > 3) {
            var id = _number.otoi(split[0]);
            var payout = _array.ConvertAll(split[3].split(","), _number.otoi);
            payout.reverse();
            while (vsPaytable.length <= id)
                vsPaytable.push([]);
            vsPaytable[id] = payout
        }
    }
}
;
VSProtocolParser.ParseScatters = function(nameValues) {
    var buf = nameValues[GameProtocolDictionary.scatters];
    if (buf == undefined)
        return null;
    var scatters = [];
    var scattersValues = buf.split(";");
    for (var i = 0; i < scattersValues.length; ++i) {
        var scatterValues = scattersValues[i].split("~");
        if (scatterValues.length != 4)
            return null;
        var symbolNumber = _number.otoi(scatterValues[0]);
        var j;
        var tmpValues = scatterValues[1].split(",");
        var pays = [];
        for (j = tmpValues.length - 1; j >= 0; --j)
            pays.push(_number.otoi(tmpValues[j]));
        tmpValues = scatterValues[2].split(",");
        var freespins = [];
        for (j = tmpValues.length - 1; j >= 0; --j)
            freespins.push(_number.otoi(tmpValues[j]));
        tmpValues = scatterValues[3].split(",");
        var multipliers = [];
        for (j = tmpValues.length - 1; j >= 0; --j)
            multipliers.push(_number.otoi(tmpValues[j]));
        scatters[i] = new VsScatterData(symbolNumber,pays,freespins,multipliers)
    }
    return scatters
}
;
VSProtocolParser.ParseWilds = function(nameValues, key) {
    var buf = nameValues[key];
    if (buf == undefined)
        return null;
    var wilds = [];
    var wildsValues = buf.split(";");
    for (var i = 0; i < wildsValues.length; i++) {
        var wildValues = wildsValues[i].split("~");
        if (wildValues.length < 2)
            return null;
        var wildSymbol = _number.otoi(wildValues[0]);
        var pays = null;
        var multipliers = null;
        var valuesSplit = wildValues[1].split(",");
        var j;
        if (wildValues.length == 3) {
            pays = [];
            for (j = valuesSplit.length - 1; j >= 0; j--) {
                var pay = _number.otoi(valuesSplit[j]);
                pays.push(pay)
            }
            valuesSplit = wildValues[2].split(",")
        }
        multipliers = [];
        for (j = valuesSplit.length - 1; j >= 0; j--) {
            var multiplier = _number.otoi(valuesSplit[j]);
            multipliers.push(multiplier)
        }
        var wild = new VsWildData(wildSymbol,pays,multipliers);
        wilds.push(wild)
    }
    if (wilds.length == 0)
        return null;
    return wilds
}
;
VSProtocolParser.ParseBonuses = function(nameValues) {
    var bonuses = [];
    var buf = nameValues[GameProtocolDictionary.bonuses];
    if (buf == undefined)
        return null;
    var bonusesValues = buf.split(";");
    for (var i = 0; i < bonusesValues.length; ++i)
        bonuses[i] = _number.otoi(bonusesValues[i]);
    return bonuses
}
;
VSProtocolParser.ParseReelsSymbols = function(nameValues) {
    if (nameValues[GameProtocolDictionary.reel(0)] == undefined)
        return null;
    var reels = [];
    for (var i = 0; true; i++) {
        var buf = nameValues[GameProtocolDictionary.reel(i)];
        if (buf == undefined)
            break;
        var values = buf.split(",");
        var reelSymbols = [];
        for (var j = 0; j < values.length; ++j)
            reelSymbols[j] = _number.otoi(values[j]);
        reels[i] = reelSymbols
    }
    return reels
}
;
VSProtocolParser.ParseNextReelsSymbols = function(nameValues) {
    if (nameValues[GameProtocolDictionary.n_reel(0)] == undefined)
        return null;
    var nextReels = [];
    for (var i = 0; true; i++) {
        var buf = nameValues[GameProtocolDictionary.n_reel(i)];
        if (buf == undefined)
            break;
        buf = buf.split("~")[1];
        var values = buf.split(",");
        var reelSymbols = [];
        for (var j = 0; j < values.length; ++j)
            reelSymbols[j] = _number.otoi(values[j]);
        nextReels[i] = reelSymbols
    }
    return nextReels
}
;
VSProtocolParser.ParseReelSets = function(nameValues) {
    var result = null;
    var numberOfSets = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.numberOfReelSets);
    if (numberOfSets > 0) {
        result = [];
        for (var reelSetsIndex = 0; reelSetsIndex < numberOfSets; reelSetsIndex++)
            for (var reelSetsIndex = 0; reelSetsIndex < numberOfSets; reelSetsIndex++) {
                result.push([]);
                var reels = VSProtocolParser.GetReelSet(nameValues, reelSetsIndex);
                for (var reelIndex = 0; reelIndex < reels.length; reelIndex++) {
                    result[reelSetsIndex].push([]);
                    var symbolIds = reels[reelIndex].split(",");
                    for (var symbolIdIndex = 0; symbolIdIndex < symbolIds.length; symbolIdIndex++)
                        result[reelSetsIndex][reelIndex].push(_number.otoi(symbolIds[symbolIdIndex]))
                }
            }
    }
    return result
}
;
VSProtocolParser.ParseVsJackpotData = function(nameValues) {
    var jpActive = "1" == GameProtocolCommonParser.ParseIfExist(nameValues, GameProtocolDictionary.Jakpot.jackpotActive);
    var jpWinId = GameProtocolCommonParser.ParseUInt(nameValues, GameProtocolDictionary.Jakpot.jackpotWinID);
    var jpWinOrder = GameProtocolCommonParser.ParseUInt(nameValues, GameProtocolDictionary.Jakpot.jackpotWinOrder);
    var jpWinAmount = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.Jakpot.jackpotWinAmount);
    return new VsJackpotData(jpActive,jpWinId,jpWinOrder,jpWinAmount)
}
;
VSProtocolParser.ParseVsFreeRoundEvents = function(nameValues) {
    if (nameValues[GameProtocolDictionary.FreeRound.Events] == undefined)
        return null;
    var evts = [];
    var items = nameValues[GameProtocolDictionary.FreeRound.Events].split(";");
    for (var i = 0; i < items.length; ++i) {
        var item = items[i].split("~");
        if (item.length > 1) {
            var type = item[0];
            var args = item[1].split(",");
            if (type == GameProtocolDictionary.FreeRound.Event.Start || type == GameProtocolDictionary.FreeRound.Event.Finish || type == GameProtocolDictionary.FreeRound.Event.Error) {
                var e = new VsFreeRoundEvent;
                e.Bet = _number.otod(args[0]);
                e.Lines = _number.otoi(args[1]);
                switch (type) {
                case GameProtocolDictionary.FreeRound.Event.Start:
                    e.Type = VsFreeRoundEvent.EventType.Start;
                    e.RoundsLeft = _number.otoi(args[2]);
                    break;
                case GameProtocolDictionary.FreeRound.Event.Finish:
                    e.Type = VsFreeRoundEvent.EventType.Finish;
                    break;
                case GameProtocolDictionary.FreeRound.Event.Error:
                    e.Type = VsFreeRoundEvent.EventType.Error;
                    break
                }
                evts.push(e)
            }
        }
    }
    return evts.length > 0 ? evts : null
}
;
VSProtocolParser.ParseVsFreeRound = function(nameValues) {
    if (nameValues[GameProtocolDictionary.FreeRound.RoundsLeft] != undefined && nameValues[GameProtocolDictionary.FreeRound.TotalWin] != undefined) {
        var res = new VsFreeRound;
        res.RoundsLeft = GameProtocolCommonParser.ParseInt(nameValues, GameProtocolDictionary.FreeRound.RoundsLeft);
        res.TotalWin = GameProtocolCommonParser.ParseDouble(nameValues, GameProtocolDictionary.FreeRound.TotalWin);
        return res
    }
    return null
}
;
VSProtocolParser.ParseVsWildRandomLineMultiplier = function(dict) {
    var key = GameProtocolDictionary.WildRandomLineMultiplier.configuration;
    var cfgs = null;
    if (dict[key] != undefined) {
        cfgs = [];
        var pairs = dict[key].split(";");
        for (var i = 0; i < pairs.length; i++) {
            var wildConfig = new VsWildRandomLineMultiplier.Configuration;
            var values = pairs[i].split("~");
            wildConfig.wildSymbolId = _number.otoi(values[0]);
            wildConfig.multiplierSets = [];
            for (var j = 1; j < values.length; j += 2) {
                var set = new MultiplierSet;
                set.setIndex = _number.otoi(values[j]);
                set.multipliers = [];
                var multipliers = values[j + 1].split(",");
                for (var mIndex = 0; mIndex < multipliers.length; mIndex++)
                    set.multipliers.push(_number.otoi(multipliers[mIndex]));
                wildConfig.multiplierSets.push(set)
            }
            cfgs.push(wildConfig)
        }
    }
    return cfgs
}
;
VSProtocolParser.ParseWRLMResponse = function(dict) {
    var key = GameProtocolDictionary.WildRandomLineMultiplier.response;
    var wrlmResponse = null;
    if (dict[key] != undefined) {
        wrlmResponse = [];
        var entries = dict[key].split(";");
        for (var i = 0; i < entries.length; i++) {
            var values = entries[i].split("~");
            var entry = new VsWildRandomLineMultiplier.SpinResponse;
            entry.wildSymbolId = _number.otoi(values[0]);
            entry.multiplier = _number.otoi(values[1]);
            if (values.length > 2) {
                entry.positions = [];
                var positions = values[2].split(",");
                for (var j = 0; j < positions.length; j++)
                    entry.positions.push(_number.otoi(positions[j]))
            }
            wrlmResponse.push(entry)
        }
    }
    return wrlmResponse
}
;
VSProtocolParser.ParseWRLMCurrentSets = function(dict) {
    var key = GameProtocolDictionary.WildRandomLineMultiplier.currentSet;
    var wrlmCurrentSets = null;
    if (dict[key] != undefined) {
        wrlmCurrentSets = [];
        var sets = dict[key].split(";");
        for (var i = 0; i < sets.length; i++) {
            var currentSet = new VsWildRandomLineMultiplier.CurrentSet;
            var values = sets[i].split("~");
            currentSet.wildSymbolId = _number.otoi(values[0]);
            currentSet.currentSetIndex = _number.otoi(values[1]);
            wrlmCurrentSets.push(currentSet)
        }
    }
    return wrlmCurrentSets
}
;
VSProtocolParser.ParseVsRandomAwardsSymbols = function(dict, key) {
    if (dict[key] == undefined)
        return null;
    var pairs = dict[key].split(";");
    var awards = [];
    for (var i = 0; i < pairs.length; ++i) {
        var pair = pairs[i].split("~");
        var award = new VsRandomAward;
        switch (pair[0]) {
        case GameProtocolDictionary.RandomAward.Type.multiplier:
            award.Type = VsRandomAward.AwardType.Multiplier;
            if (pair.length > 1)
                award.Value = _number.otod(pair[1]);
            break;
        case GameProtocolDictionary.RandomAward.Type.trigger:
            award.Type = VsRandomAward.AwardType.Trigger;
            break;
        case GameProtocolDictionary.RandomAward.Type.featureTrigger:
            award.Type = VsRandomAward.AwardType.FeatureTrigger;
            if (pair.length > 1)
                award.FeatureID = GameProtocolBonusGameParser.ParseWinMask(pair[1]);
            break
        }
        awards.push(award)
    }
    return awards
}
;
VSProtocolParser.ParseVsRandomAwardsConfig = function(dict) {
    var result = null;
    var normal = VSProtocolParser.ParseVsRandomAwardsSymbols(dict, GameProtocolDictionary.RandomAward.Configuration.normal);
    var freeSpins = VSProtocolParser.ParseVsRandomAwardsSymbols(dict, GameProtocolDictionary.RandomAward.Configuration.freeSpins);
    if (normal != null || freeSpins != null) {
        result = new VsRandomAwardConfig;
        result.awardSymbolsNormal = normal;
        result.awardSymbolsFreeSpins = freeSpins
    }
    if (result == null) {
        var reelsCount = GameProtocolCommonParser.ParseInt(dict, GameProtocolDictionary.RandomAward.Configuration.reelConfigCount);
        if (reelsCount > 0) {
            result = new VsRandomAwardConfig;
            result.awardReels = [];
            result.awardReelsCount = reelsCount;
            for (var i = 0; i < reelsCount; i++) {
                var reelConf = VSProtocolParser.ParseVsRandomAwardsSymbols(dict, GameProtocolDictionary.RandomAward.Configuration.reelConfig + i.toString());
                result.awardReels.push(reelConf)
            }
            result.ProcessPossibleAwards()
        }
    }
    return result
}
;
VSProtocolParser.ParseRandomAwardsResponse = function(dict) {
    var rar = null;
    var awIdx = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.RandomAward.index);
    if (awIdx == null)
        awIdx = -1;
    var awPos = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.RandomAward.awardPosition);
    if (awPos == null)
        awPos = -1;
    var reelIdx = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.RandomAward.Configuration.reelConfig);
    if (reelIdx == null)
        reelIdx = -1;
    var nextReelIdx = GameProtocolCommonParser.ParseNulableInt(dict, GameProtocolDictionary.RandomAward.Configuration.nextReelConfig);
    if (nextReelIdx == null)
        nextReelIdx = -1;
    if (awIdx != -1 || awPos != -1) {
        rar = new RandomAwardsResponse;
        rar.awardIndex = awIdx;
        rar.awardPositionInReel = awPos;
        rar.currentReelIndex = reelIdx;
        rar.nextReelIndex = nextReelIdx
    }
    return rar
}
;
VSProtocolParser.ParseFSPurchaseData = function(dict) {
    var fspd = null;
    var fsBought = GameProtocolCommonParser.ParseInt(dict, GameProtocolDictionary.FreeSpinsPurchase.fsBought);
    if (fsBought > 0) {
        fspd = new VsFSPurchaseData;
        fspd.freeSpinsBought = fsBought
    }
    return fspd
}
;
VSProtocolParser.ParseRandomSymbolMultipliers = function(source) {
    var result = null;
    var rsmContent = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.randomSymbolMultiplier);
    if (!_string.IsNullOrEmpty(rsmContent)) {
        result = [];
        var splitRsmContent = rsmContent.split(";");
        for (var rsmIdx = 0; rsmIdx < splitRsmContent.length; rsmIdx++) {
            var rsm = new VsRandomSymbolMultiplier;
            var split = splitRsmContent[rsmIdx].split("~");
            rsm.symbolId = _number.otoi(split[0]);
            rsm.multiplierValue = _number.otoi(split[2]);
            var positions = split[1].split(",");
            for (var i = 0; i < positions.length; i++)
                rsm.symbolPositions.push(_number.otoi(positions[i]));
            result.push(rsm)
        }
    }
    return result
}
;
VSProtocolParser.ParsePossibleRandomSymbolMultipliers = function(source) {
    var result = null;
    var rsmContent = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.possibleRandomSymbolMultipliers);
    if (!_string.IsNullOrEmpty(rsmContent)) {
        result = [];
        var splitSet = rsmContent.split(";");
        for (var setIdx = 0; setIdx < splitSet.length; setIdx++) {
            var prm = new VsPossibleRandomSymbolMultipliers;
            var split = splitSet[setIdx].split("~");
            prm.symbolId = _number.otoi(split[0]);
            var positions = split[1].split(",");
            for (var i = 0; i < positions.length; i++)
                prm.symbolMultipliers.push(_number.otoi(positions[i]));
            result.push(prm)
        }
    }
    return result
}
;
VSProtocolParser.ParseFreeSpinsChainedData = function(source) {
    var fscd = new VsFreeSpinsChainData;
    fscd.FSCSpins = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.spins);
    fscd.FSCMultipliers = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.multipliers);
    fscd.FSCSpinsTotal = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.spinsTotal);
    fscd.FSCMultipliersTotal = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.multipliersTotal);
    fscd.FSCWinsTotal = GameProtocolCommonParser.ParseDoubleList(source, GameProtocolDictionary.FreeSpinsChain.winsTotal);
    fscd.FSCMultipliedWinsTotal = GameProtocolCommonParser.ParseDoubleList(source, GameProtocolDictionary.FreeSpinsChain.multipliedWinTotal);
    fscd.FSCSessionsWonThisSpin = GameProtocolCommonParser.ParseInt(source, GameProtocolDictionary.FreeSpinsChain.sessionsWonThisSpin);
    fscd.FSCSessionsWonSymbolsCount = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.FreeSpinsChain.sessionsWonSymbolsCount);
    if (fscd.HasChainInformation())
        return fscd;
    return null
}
;
VSProtocolParser.ParseOpeningSymbolsData = function(source) {
    var osd = new VsOpeningSymbolsData;
    osd.Positions = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.OpeningSymbols.positions);
    osd.OSFreeSpinsWon = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.OpeningSymbols.freeSpinsWon);
    osd.OSMultiplierWon = GameProtocolCommonParser.ParseNulableInt(source, GameProtocolDictionary.OpeningSymbols.multiplierWon);
    if (osd.Positions != null || osd.OSFreeSpinsWon != null || osd.OSMultiplierWon != null)
        return osd;
    return null
}
;
VSProtocolParser.GetWildRandomMultipliers = function(source) {
    var result = null;
    var wrValues = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.wildRandomMultipliers);
    if (!_string.IsNullOrEmpty(wrValues))
        result = _string.Trim(wrValues).split(";");
    return result
}
;
VSProtocolParser.GetWildRandomMultipliersMasks = function(source) {
    var result = null;
    var wrMask = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.wildRandomMultiplierMask);
    if (!_string.IsNullOrEmpty(wrMask))
        result = _string.Trim(wrMask).split("~");
    return result
}
;
VSProtocolParser.ParseWildRandomMultipliers = function(source) {
    var result = null;
    var wildRandomMultipliers = VSProtocolParser.GetWildRandomMultipliers(source);
    if (wildRandomMultipliers != null) {
        result = [];
        for (var i = 0; i < wildRandomMultipliers.length; i++) {
            var _data = wildRandomMultipliers[i].split("~");
            var _masks = VSProtocolParser.GetWildRandomMultipliersMasks(source);
            var _wildRandomMultiplier = new VsWildRandomMultiplier;
            for (var j = 0; j < _masks.length; j++)
                switch (_masks[j]) {
                case "s":
                    _wildRandomMultiplier.SymbolIndex = _number.otoi(_data[j]);
                    break;
                case "p":
                    _wildRandomMultiplier.Position = _number.otoi(_data[j]);
                    break;
                case "m":
                    _wildRandomMultiplier.Multiplier = _number.otoi(_data[j]);
                    break;
                default:
                    break
                }
            result.push(_wildRandomMultiplier)
        }
    }
    return result
}
;
VSProtocolParser.ParsePatternedMysterySymbols = function(source) {
    var result = null;
    var pms = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.patternedMysterySymbols);
    if (!_string.IsNullOrEmpty(pms)) {
        var buf = pms.split(",");
        if (buf.length > 0) {
            result = new Array;
            for (var i = 0; i < buf.length; i++)
                result.push(_number.otoi(buf[i]))
        }
    }
    return result
}
;
VSProtocolParser.ParseJPVisualization = function(source) {
    var result = null;
    var jpMask = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.JackpotVisualization.JPVMask);
    var jpValues = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.JackpotVisualization.JPVValues);
    if (!_string.IsNullOrEmpty(jpMask)) {
        var bufM = jpMask.split("~");
        var bufV = jpValues.split("~");
        if (bufM.length > 0) {
            result = new VsJackpotVisualization;
            for (var i = 0; i < bufM.length; i++)
                if (bufM[i] == GameProtocolDictionary.JackpotVisualization.JPVType) {
                    if (bufV[i] == GameProtocolDictionary.JackpotVisualization.Type.badges)
                        result.jpvType = VsJackpotVisualization.JpType.badges
                } else if (bufM[i] == GameProtocolDictionary.JackpotVisualization.JPVPositions) {
                    var pos = bufV[i].split(",");
                    if (pos.length > 0) {
                        result.positions = [];
                        for (var j = 0; j < pos.length; j++)
                            result.positions.push(_number.otoi(pos[j]))
                    }
                }
        }
    }
    return result
}
;
VSProtocolParser.ParseGoldSymbol = function(source) {
    var result = null;
    var gs = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.GoldSymbol.goldSymbols);
    var resultGSR = GameProtocolCommonParser.ParseIntList(source, GameProtocolDictionary.GoldSymbol.goldSymbolReels);
    var gsa = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.GoldSymbol.goldSymbolAwards);
    if (resultGSR != null || !_string.IsNullOrEmpty(gs)) {
        result = new VsGoldSymbol;
        result.reels = resultGSR
    }
    if (!_string.IsNullOrEmpty(gs)) {
        var bufGS = gs.split(";");
        if (bufGS.length > 0) {
            result.symbols = [];
            for (var i = 0; i < bufGS.length; i++) {
                var gsSplit = bufGS[i].split("~");
                result.symbols.push([]);
                result.symbols[i].push(_number.otoi(gsSplit[0]));
                result.symbols[i].push(_number.otoi(gsSplit[1]))
            }
        }
    }
    if (!_string.IsNullOrEmpty(gsa)) {
        var bufGSA = gsa.split(";");
        if (bufGSA.length > 0) {
            result.awards = [];
            for (var i = 0; i < bufGSA.length; i++) {
                var gsaSplit = bufGSA[i].split("~");
                result.awards.push([]);
                result.awards[i].push(_number.otoi(gsaSplit[0]));
                result.awards[i].push(_number.otoi(gsaSplit[1]))
            }
        }
    }
    return result
}
;
VSProtocolParser.ParseSymbolReplacementData = function(source) {
    var result = null;
    var srd = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.symbolReplacementData);
    if (!_string.IsNullOrEmpty(srd)) {
        result = [];
        var srdEntries = srd.split(";");
        for (var i = 0; i < srdEntries.length; i++) {
            var symbolData = new VsSymbolReplacement;
            var srdEntry = srdEntries[i].split("~");
            symbolData.FromSymbolId = _number.otoi(srdEntry[0]);
            symbolData.ToSymbolId = _number.otoi(srdEntry[1]);
            symbolData.ReplacementPositions = [];
            var replacementPosData = srdEntry[2].split(",");
            for (var j = 0; j < replacementPosData.length; j++)
                symbolData.ReplacementPositions.push(_number.otoi(replacementPosData[j]));
            result.push(symbolData)
        }
    }
    return result
}
;
VSProtocolParser.ParseNudgedSymbolsData = function(source) {
    var result = null;
    var ns = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.nudgedSymbols);
    if (!_string.IsNullOrEmpty(ns)) {
        ns = _string.Trim(ns);
        var bufNS = ns.split(";");
        if (bufNS.length > 0) {
            result = [];
            var nudgeIndex = 0;
            for (nudgeIndex = 0; nudgeIndex < bufNS.length; nudgeIndex++) {
                var nudgePart = bufNS[nudgeIndex];
                var i = 0;
                var reelID = _number.otoi(nudgePart.split("~")[0]);
                var startingSymbolsIDs = [];
                var bufSSIDs = nudgePart.split("~")[1].split(",");
                for (i = 0; i < bufSSIDs.length; i++)
                    startingSymbolsIDs.push(_number.otoi(bufSSIDs[i]));
                var nudgedSymbolsIDs = [];
                var bufNSIDs = nudgePart.split("~")[2].split(",");
                for (i = 0; i < bufNSIDs.length; i++)
                    nudgedSymbolsIDs.push(_number.otoi(bufNSIDs[i]));
                var nudgedStopPosition = _number.otoi(nudgePart.split("~")[3]);
                var nudgeDirection = _number.otoi(nudgePart.split("~")[4]);
                var nudge = new VsNudgedSymbolsData(reelID,startingSymbolsIDs,nudgedSymbolsIDs,nudgedStopPosition,nudgeDirection);
                result.push(nudge)
            }
        }
    }
    return result
}
;
VSProtocolParser.ParseSpinOneReelData = function(source) {
    var result = null;
    var sor_ra = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.ReelsAllowedToRotateSeparately);
    var sor_coefs = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.ReelsCoeficients);
    var ReelsToBeSpun = [];
    var ReelsCoeficients = [];
    if (!_string.IsNullOrEmpty(sor_ra)) {
        sor_ra = _string.Trim(sor_ra);
        if (sor_ra.length > 0) {
            var temp = sor_ra.split(",");
            for (var i = 0; i < temp.length; i++)
                ReelsToBeSpun.push(_number.otod(temp[i]))
        }
    }
    if (!_string.IsNullOrEmpty(sor_coefs)) {
        sor_coefs = _string.Trim(sor_coefs);
        if (sor_coefs.length > 0) {
            var temp = sor_coefs.split(",");
            for (var i = 0; i < temp.length; i++)
                ReelsCoeficients.push(_number.otod(temp[i]))
        }
    }
    result = new VSSpinOneReelSymbolsData(0,ReelsToBeSpun,ReelsCoeficients);
    return result
}
;
VSProtocolParser.ParseTumblingData = function(source) {
    var result = null;
    var tmbData = GameProtocolCommonParser.ParseIfExist(source, GameProtocolDictionary.Tumbling);
    if (!_string.IsNullOrEmpty(tmbData)) {
        result = new VsTumblingData;
        var tmbSymbols = tmbData.split("~");
        for (var i = 0; i < tmbSymbols.length; i++) {
            var symbolSplit = tmbSymbols[i].split(",");
            var symbol = new VsTumblingData.TumblingSymbol;
            symbol.position = _number.otoi(symbolSplit[0]);
            symbol.id = _number.otoi(symbolSplit[1]);
            result.tumblingSymbols.push(symbol)
        }
    }
    return result
}
;
goog.provide("UHT.ResourceHelpers");
var ResourceEvents = {
    evtRequestResources: "evtRequestResources",
    evtResourcesCompleted: "evtResourcesCompleted"
};
function AssetBundle() {
    this.mainAsset = null
}
function ResourceRequestInfo() {
    this.symbol = "";
    this.brand = "";
    this.locale = "";
    this.files = []
}
function BundlePack() {
    this.assetBundles = []
}
function RequestPack() {
    this.isDone = false;
    this.downloaders = [];
    this.progress = 0;
    this.componentName = ""
}
RequestPack.prototype.Update = function() {
    console.log("RequestPack::Update", this);
    this.isDone = true;
    this.progress = 0;
    for (var i = 0; i < this.downloaders.length; ++i)
        if (!this.downloaders[i].Done) {
            this.isDone = false;
            this.progress += this.downloaders[i].progress
        }
}
;
RequestPack.prototype.GetData = function() {
    var rv = new BundlePack;
    for (var i = 0; i < this.downloaders.length; ++i)
        if (_string.IsNullOrEmpty(this.downloaders[i].error)) {
            var ab = new AssetBundle;
            ab.mainAsset = jsonParse(this.downloaders[i].Data);
            rv.assetBundles.push(ab)
        }
    this.downloaders = [];
    return rv
}
;
goog.provide("UHT.ServerOptions");
var LogLevel = {
    None_Info: 0,
    Warn: 1,
    Debug: 2,
    Error: 3
};
var ServerOptions = {
    serverUrl: "",
    resourcesUrl: "",
    configUri: "/gs2c/configuration.do",
    loginUri: "/gs2c/login.do",
    logoutUri: "/gs2c/logout.do",
    sessionTimeout: "-1",
    menuUri: "/gs2c/menu.do",
    versionUri: "/gs2c/res/versions.info",
    resourceseUri: "/gs2c/res",
    gameServiceUri: "https://ganesh.bet/game/Dragons888PM/server",
    settingsUri: "https://ganesh.bet/game/Dragons888PM/server",
    reloadBalanceUri: "/gs2c/reloadBalance.do",
    reloadJackpotUri: "/gs2c/jackpot/reload.do",
    accountType: "R",
    language: "en",
    currency: "USD",
    resourceVersion: "200",
    styleName: "style",
    casinoName: "casino",
    isExternal: true,
    logLevel: LogLevel.None_Info,
    gameSymbol: URLGameSymbol,
    userAgent: "Mozilla/5.0 (Windows NT 6.1, WOW64, rv:34.0) Gecko/20100101 Firefox/34.0",
    isOnline: false,
    isSecure: true,
    packagesUri: "packages/",
    gameUrl: "",
    configs: null,
    mgckey: "",
    gameHistory: null,
    jurisdiction: null,
    jurisdictionRequirements: null,
    promotionurl: null,
    rcSettings: null,
    amountType: null,
    TournamentURLs: {
        tournaments: "/gs2c/promo/active/",
        details: "/gs2c/promo/tournament/details/",
        leaderboards: "/gs2c/promo/tournament/v2/leaderboard/",
        raceDetails: "/gs2c/promo/race/details/",
        racePrizes: "/gs2c/promo/race/prizes/",
        raceOptIn: "/gs2c/promo/race/player/choice/OPTIN/",
        raceOptOut: "/gs2c/promo/race/player/choice/OPTOUT/",
        tournamentOptIn: "/gs2c/promo/tournament/player/choice/OPTIN/",
        tournamentOptOut: "/gs2c/promo/tournament/player/choice/OPTOUT/"
    },
    SwedishRegulation: {
        notificationUrl: ""
    }
};
goog.provide("UHT.GameConnection");
goog.require("UHT.EventManager");
goog.require("UHT.ServerOptions");
goog.require("UHT.Tracking");
var RequestState = {
    Idle: 0,
    Init: 1,
    Spin: 2,
    Collect: 3,
    InitBonus: 4,
    BonusRespin: 5,
    PickBonus: 6,
    CollectBonus: 7,
    Gamble: 8,
    GambleCollect: 9,
    JackpotCollect: 10,
    PickFSOption: 11,
    InitFSBG: 12,
    PickFSBG: 13,
    GetMysteryScatter: 14,
    Block: 15
};
function GameConnection() {
    this.index = 0;
    this.counter = 0;
    this.repeat = 0;
    this.repeatLimit = 3;
    this.symbol = "vs20cm";
    this.responseReceived = false;
    this.response = "";
    this.srvResponse = null;
    this.retryDelay = 15;
    this.retryTimer = 0;
    this.retryRequest = false;
    this.storedRequest = null;
    this.queuedRequest = null;
    this.queuedState = RequestState.Block;
    this.initData = null;
    this.requestState = RequestState.Idle;
    this.isRegulatoryError = false;
    this.mustStopSpin = false;
    this.mustPostGameRoundEndedOnCollect = false;
    GameConnection.I = this
}
GameConnection.I = null;
GameConnection.prototype.SlotHeight = -1;
GameConnection.noMoneyStopsSpin = false;
GameConnection.prototype.Init = function(gameSymbol) {
    this.index = 1;
    this.counter = 1;
    this.repeat = 0;
    this.symbol = gameSymbol;
    this.responseReceived = false;
    EventManager.AddHandler(GameEvents.evtInitRequest + this.symbol, this.SendInitRequest, this);
    EventManager.AddHandler(GameEvents.evtSpinRequest + this.symbol, this.SendSpinRequest, this);
    EventManager.AddHandler(GameEvents.evtFreespinsFinished + this.symbol, this.SendFSCollectRequest, this);
    EventManager.AddHandler(GameEvents.evtGambleRequest + this.symbol, this.SendGambleV2Request, this);
    EventManager.AddHandler(GameEvents.evtGambleClose + this.symbol, this.SendGambleCollectRequest, this);
    EventManager.AddHandler(GameEvents.evtBonusPickRequest + this.symbol, this.SendBonusRequest, this);
    EventManager.AddHandler(GameEvents.evtBonusRespinRequest + this.symbol, this.SendBonusRespinRequest, this);
    EventManager.AddHandler(GameEvents.evtBonusFinishRequest + this.symbol, this.SendBonusCollectRequest, this);
    EventManager.AddHandler(GameEvents.evtFSOptionPickRequest + this.symbol, this.SendFSOptionRequest, this);
    EventManager.AddHandler(GameEvents.evtFSBGPickRequest + this.symbol, this.SendFSBGRequest, this);
    EventManager.AddHandler(GameEvents.evtMysteryScatterRequest + this.symbol, this.SendMysteryScatterRequest, this);
    EventManager.AddHandler(GameEvents.evtUpdateSettingsRequest + this.symbol, this.SaveSettingsRequest, this);
    EventManager.AddHandler(GameEvents.evtGetSettingsRequest + this.symbol, this.LoadSettingsRequest, this)
}
;
GameConnection.prototype.Update = function() {
    EventManager.TriggerQueued();
    if (this.queuedRequest != null && this.requestState == RequestState.Idle) {
        if (this.CanRequest(this.queuedState)) {
            this.requestState = this.queuedState;
            this.queuedState = RequestState.Block;
            this.SendRequest(this.queuedRequest)
        } else
            console.warn("Request " + this.queuedState + " skipped");
        this.queuedRequest = null
    }
    if (this.responseReceived) {
        this.responseReceived = false;
        this.HandleResponse(this.response)
    }
    if (this.retryRequest)
        if (this.repeat < this.repeatLimit)
            if (this.retryTimer > this.retryDelay) {
                this.retryRequest = false;
                ++this.index;
                ++this.repeat;
                this.storedRequest.Fields[GameProtocolDictionary.counter] = String(this.counter);
                this.storedRequest.Fields[GameProtocolDictionary.repeat] = String(this.repeat);
                EventManager.Trigger(AdapterEvents.evtServerRequest, this.storedRequest);
                RequestManager.AddRequest(this.storedRequest);
                console.warn("Retry #" + this.repeat)
            } else
                this.retryTimer += Time.deltaTime;
        else {
            this.retryRequest = false;
            EventManager.Trigger(AdapterEvents.evtShowMessage, AdapterMessages.connectionLost)
        }
}
;
GameConnection.prototype.StoreResponse = function(param, statusCode) {
    if (statusCode == 200) {
        this.response = _string.Trim(param);
        this.responseReceived = true
    } else {
        this.retryTimer = 0;
        this.retryRequest = true
    }
}
;
GameConnection.prototype.HandleResponse = function(responseStr) {
    this.isRegulatoryError = false;
    this.mustStopSpin = false;
    if (_string.IsNullOrEmpty(responseStr)) {
        console.error("Response is empty!");
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf("error_type=i") != -1)
        this.mustStopSpin = true;
    else if (responseStr.indexOf("ext_code=RegulatoryError") != -1 || responseStr.indexOf("ext_code=TemporaryUnavailableError") != -1) {
        this.isRegulatoryError = true;
        window["globalMustStopAutoplay"] = true
    } else if (responseStr.indexOf(GameProtocolDictionary.frozen) != -1 || responseStr.indexOf("error_type=e") != -1) {
        console.error("Account is frozen! " + responseStr);
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.techbreak) != -1)
        console.error("We may have techbreak " + responseStr);
    else if (responseStr.indexOf(GameProtocolDictionary.reload) != -1) {
        console.error("Couldn't open game " + responseStr);
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.pnow) != -1) {
        console.error("Server is busy " + responseStr);
        this.retryTimer = 0;
        this.retryRequest = true;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.noMoney) != -1)
        console.error("The current bet may be greater than balance " + responseStr);
    else if (responseStr.indexOf(GameProtocolDictionary.undefined) != -1) {
        console.error("Sent wrong request " + responseStr);
        this.requestState = RequestState.Block;
        return
    } else if (responseStr.indexOf(GameProtocolDictionary.unlogged) != -1) {
        console.error("User logged out " + responseStr);
        this.requestState = RequestState.Block;
        return
    }
    var nameValues = responseStr.split("&");
    this.srvResponse = GameProtocolParser.ParseResponse(nameValues);
    ++this.index;
    this.counter = this.srvResponse.Counter + 1;
    this.repeat = this.srvResponse.Repeat;
    if (this.srvResponse.ServerTime > 0)
        EventManager.Trigger(GameEvents.evtServerTimeUpdate, this.srvResponse.ServerTime);
    XT.SetObject(FOXVars.FOX_Response, this.srvResponse.ValuesMap);
    switch (this.requestState) {
    case RequestState.Init:
        XT.TriggerEvent(FOXVars.Evt_FOX_InitReceived);
        this.HandleInitResponse(nameValues, this.srvResponse);
        break;
    case RequestState.Spin:
        XT.TriggerEvent(FOXVars.Evt_FOX_SpinReceived);
        this.HandleSpinResponse(nameValues, this.srvResponse);
        break;
    case RequestState.Collect:
        XT.TriggerEvent(FOXVars.Evt_FOX_CollectReceived);
        this.HandleCollectResponse(nameValues, this.srvResponse);
        break;
    case RequestState.InitBonus:
        XT.TriggerEvent(FOXVars.Evt_FOX_InitBonusReceived);
        this.HandleInitBonusResponse(nameValues, this.srvResponse);
        break;
    case RequestState.PickBonus:
        XT.TriggerEvent(FOXVars.Evt_FOX_PickBonusReceived);
        this.HandlePickBonusResponse(nameValues, this.srvResponse);
        break;
    case RequestState.BonusRespin:
        XT.TriggerEvent(FOXVars.Evt_FOX_BonusRespinReceived);
        this.HandleBonusRespinResponse(nameValues, this.srvResponse);
        break;
    case RequestState.CollectBonus:
        XT.TriggerEvent(FOXVars.Evt_FOX_CollectBonusReceived);
        this.HandleCollectBonusResponse(nameValues, this.srvResponse);
        break;
    case RequestState.Gamble:
        XT.TriggerEvent(FOXVars.Evt_FOX_GambleReceived);
        this.HandleGambleV2Response(nameValues, this.srvResponse);
        break;
    case RequestState.GambleCollect:
        XT.TriggerEvent(FOXVars.Evt_FOX_GambleCollectReceived);
        this.HandleGambleCollectResponse(nameValues, this.srvResponse);
        break;
    case RequestState.JackpotCollect:
        XT.TriggerEvent(FOXVars.Evt_FOX_JackpotCollectReceived);
        this.HandleJackpotCollectResponse(nameValues, this.srvResponse);
        break;
    case RequestState.PickFSOption:
        XT.TriggerEvent(FOXVars.Evt_FOX_PickFSOptionReceived);
        this.HandlePickFSOptionResponse(nameValues, this.srvResponse);
        break;
    case RequestState.InitFSBG:
        XT.TriggerEvent(FOXVars.Evt_FOX_InitFSBGReceived);
        this.HandleInitFSBGResponse(nameValues, this.srvResponse);
        break;
    case RequestState.PickFSBG:
        XT.TriggerEvent(FOXVars.Evt_FOX_PickFSBGReceived);
        this.HandlePickFSBGResponse(nameValues, this.srvResponse);
        break;
    case RequestState.GetMysteryScatter:
        XT.TriggerEvent(FOXVars.Evt_FOX_GetMysteryScatterReceived);
        this.HandleMysteryScatterResponse(nameValues, this.srvResponse);
        break;
    default:
        console.error("Got response for unknown request state " + this.requestState);
        break
    }
    XT.SetObject(FOXVars.FOX_Response, null)
}
;
var ActionSentAferLoadingWheel = false;
GameConnection.prototype.SendRequest = function(data) {
    if (!ActionSentAferLoadingWheel && LoadingWheelSentOnce) {
        globalTracking.SendEvent("uht_behaviour", "Loading_wheel_once_and_user_active", 1, "BehaviourTracker");
        ActionSentAferLoadingWheel = true
    }
    var request = new ServerRequest;
    request.Url = data.Url;
    request.Handler = new EventHandler(this,this.StoreResponse);
    request.Method = data.RequestMethod;
    request.KeepAlive = true;
    request.AllowRedirect = true;
    for (var tmp in data.Fields)
        request.Fields[tmp] = data.Fields[tmp];
    request.Fields[GameProtocolDictionary.index] = String(this.index);
    request.Fields[GameProtocolDictionary.counter] = String(this.counter);
    request.Fields[GameProtocolDictionary.repeat] = String(this.repeat);
    this.storedRequest = request;
    EventManager.Trigger(AdapterEvents.evtServerRequest, request);
    RequestManager.AddRequest(request)
}
;
GameConnection.prototype.SendCollectRequest = function() {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Collect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) < 0)
        return;
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Collect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Collect;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendFSCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - FSCollect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) < 0) {
        console.warn("SendFSCollectRequest skipped");
        return
    }
    if (this.srvResponse.DoCollect) {
        console.warn("Attempt to collect FS again ... ignored");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Collect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Collect;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendInitRequest = function(param) {
    globalTracking.StartTimer("uht_loading", "_X_first_connection_duration", "LoadingTracker");
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Init")
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
  
 
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doInit;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (!_string.IsNullOrEmpty(UHT_REVISION.common))
        data.Fields[GameProtocolDictionary.clientVersion] = UHT_REVISION.common;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Init;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Init;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendSpinRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Spin")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Spin) < 0) {
        console.warn("SendSpinRequest delayed");
        var self = this;
        setTimeout(function() {
            self.SendSpinRequest(param)
        }, 250);
        return
    }
    var request = param;
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doSpin;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.coin] = Number(request.Bet).toString();
    data.Fields[GameProtocolDictionary.line] = Number(request.Line).toString();
    var ReelToBespun = XT.GetInt(Vars.ReelToBeSpun);
    if (ReelToBespun != -1)
        data.Fields[GameProtocolDictionary.ReelToBeSpun] = ReelToBespun;
    if (request.ProgressPick != -1)
        data.Fields[GameProtocolDictionary.ProgressiveFeature.progressivePick] = request.ProgressPick.toString();
    var betLevelSettings = XT.GetObject(Vars.BetLevelSettings);
    if (betLevelSettings != null)
        data.Fields[GameProtocolDictionary.BetLevel.betLevelIndex] = betLevelSettings.betLevelIndex.toString();
    var fsPurchaseConfig = XT.GetObject(Vars.FreeSpinsPurchaseConfig);
    if (fsPurchaseConfig != null && fsPurchaseConfig.optionIndex > -1) {
        data.Fields[GameProtocolDictionary.FreeSpinsPurchase.optionIndex] = fsPurchaseConfig.optionIndex.toString();
        fsPurchaseConfig.optionIndex = -2
    }
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Spin;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Spin;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendGambleRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Gamble")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Gamble) < 0) {
        console.warn("SendGambleRequest skipped");
        return
    }
    var request = param;
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doGamble;
    data.Fields[GameProtocolDictionary.Gambling.option] = Number(request.Choice).toString();
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Gamble;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Gamble;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendFSOptionRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - FSOption")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.FSOption) < 0) {
        console.warn("SendFSOptionRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doFSOption;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (param != null)
        data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.Index).toString();
    if (this.requestState != RequestState.Idle) {
        if (this.requestState == RequestState.PickFSOption) {
            console.error("Tried to pick in fsOptions without waiting for result!");
            return
        }
        if (param != null)
            this.queuedState = RequestState.PickFSOption;
        else
            this.queuedState = RequestState.PickFSOption;
        this.queuedRequest = data
    } else {
        if (param != null)
            this.requestState = RequestState.PickFSOption;
        else
            this.requestState = RequestState.PickFSOption;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendFSBGRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - FSBG")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.FSBonus) < 0) {
        console.warn("SendFSBGRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doFSBonus;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (param != null)
        data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.Index).toString();
    if (this.requestState != RequestState.Idle) {
        if (this.requestState == RequestState.PickFSBG) {
            console.error("Tried to pick in fsbg without waiting for result!");
            return
        }
        if (param != null)
            this.queuedState = RequestState.PickFSBG;
        else
            this.queuedState = RequestState.InitFSBG;
        this.queuedRequest = data
    } else {
        if (param != null)
            this.requestState = RequestState.PickFSBG;
        else
            this.requestState = RequestState.InitFSBG;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendMysteryScatterRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - MysteryScatter")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.MysteryScatter) < 0) {
        console.warn("SendMysteryScatterRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doMysteryScatter;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (this.requestState != RequestState.Idle) {
        if (this.requestState == RequestState.GetMysteryScatter) {
            console.error("Tried to request mystery scatter second time!");
            return
        }
        this.queuedState = RequestState.GetMysteryScatter;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.GetMysteryScatter;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendGambleCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - GambleCollect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.GambleCollect) < 0) {
        console.warn("SendGambleCollectRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doGambleCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.GambleCollect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.GambleCollect;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendJackpotCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - JackpotCollect")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.JackpotCollect) < 0) {
        console.warn("SendJackpotCollectRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doJackpotCollect;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.JackpotCollect;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.JackpotCollect;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendBonusRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Bonus")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Bonus) < 0) {
        console.warn("SendBonusRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doBonus;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (param != null)
        if (param.PickType == 0)
            data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.Index).toString();
        else {
            data.Fields[GameProtocolDictionary.BonusGame.lInd] = Number(param.Index).toString();
            data.Fields[GameProtocolDictionary.BonusGame.bonusGameChoice] = Number(param.PickType).toString()
        }
    if (this.requestState != RequestState.Idle) {
        if (this.requestState == RequestState.PickBonus) {
            console.error("Tried to pick in bonus without waiting for result!");
            return
        }
        if (param != null)
            this.queuedState = RequestState.PickBonus;
        else
            this.queuedState = RequestState.InitBonus;
        this.queuedRequest = data
    } else {
        if (param != null)
            this.requestState = RequestState.PickBonus;
        else
            this.requestState = RequestState.InitBonus;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendBonusRespinRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Bonus")
    }
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Bonus) < 0) {
        console.warn("SendBonusRespinRequest skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doBonus;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.BonusRespin;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.BonusRespin;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.SendBonusCollectRequest = function(param) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - BonusCollect")
    }
    var action = GameProtocolDictionary.Actions.doCollectBonus;
    if (this.srvResponse.NextGameActions != null) {
        if (this.srvResponse.NextGameActions.indexOf(NextGameAction.Bonus) > -1) {
            this.SendBonusRequest(null);
            return
        }
        var collect = this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) > -1;
        var collectBonus = this.srvResponse.NextGameActions.indexOf(NextGameAction.CollectBonus) > -1;
        if (!collect && !collectBonus) {
            console.warn("SendBonusCollectRequest skipped");
            return
        }
        if (collect)
            action = GameProtocolDictionary.Actions.doCollect
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.Actions.action] = action;
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.CollectBonus;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.CollectBonus;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.LoadSettingsRequest = function(param) {
    var request = new ServerRequest;
    var requestUrl = "";
    requestUrl += ServerOptions.serverUrl;
    requestUrl += ServerOptions.settingsUri;
    request.Url = requestUrl;
    request.Handler = new EventHandler(this,this.HandleSettingsLoaded);
    request.Method = "POST";
    request.Fields[DefaultValues.Settings.action] = DefaultValues.Settings.load;
    request.Fields[DefaultValues.Settings.idParam] = this.symbol;
    RequestManager.AddRequest(request)
}
;
GameConnection.prototype.SaveSettingsRequest = function(param) {
    var settings = param;
    var request = new ServerRequest;
    var requestUrl = "";
    requestUrl += ServerOptions.serverUrl;
    requestUrl += ServerOptions.settingsUri;
    request.Url = requestUrl;
    request.Handler = new EventHandler(this,this.HandleSettingSaved);
    request.Method = "POST";
    request.Fields[DefaultValues.Settings.idParam] = this.symbol;
    request.Fields[DefaultValues.Settings.settingsParam] = settings.ToString();
    RequestManager.AddRequest(request)
}
;
GameConnection.prototype.HandleInitResponse = function(nameValues, response) {
    LoaderProgress.InitConnection_Current = 1;
    globalTracking.StopTimerAndSend("uht_loading", "_X_first_connection_duration", "LoadingTracker");
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    GameConnection.prototype.SlotHeight = vsResponse.SlotHeight;
    vsResponse.NextGameActions = response.NextGameActions;
    this.initData = vsResponse.VsInitData.Clone();
    var configs = GameProtocolCommonParser.ParseIntList(data, GameProtocolDictionary.configs);
    if (configs != null)
        ServerOptions.configs = configs;
    this.AddGambleButtonState(vsResponse, true);
    EventManager.Trigger(GameEvents.evtInitResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle;
    if (this.srvResponse.NextGameActions != null) {
        if (this.IsNextAction(NextGameAction.Collect))
            this.SendCollectRequest();
        if (this.IsNextAction(NextGameAction.CollectBonus))
            this.SendBonusCollectRequest(null)
    } else {
        var needToCollect = !response.DoCollect && vsResponse.IsWin() && response.DoSpin;
        if (needToCollect && (vsResponse.IsFreeSpins() && !vsResponse.VsFreeSpin.IsFirstFreeSpin() && !vsResponse.IsFreeSpinBonusGame()))
            needToCollect = false;
        if (needToCollect)
            if (vsResponse.IsBonusRespin())
                this.SendBonusCollectRequest(null);
            else
                this.SendCollectRequest()
    }
    EventManager.Trigger(JackpotEvents.evtJackpotStateChanged, vsResponse.VsJackpotData);
    if (vsResponse.IsJackpotWin())
        this.SendJackpotCollectRequest(null);
    if (vsResponse.IsBonus())
        if (vsResponse.WasDoBonus() || vsResponse.IsBonusRespin() || vsResponse.IsBonusFSPick() || vsResponse.IsOpeningSymbols())
            EventManager.Trigger(GameEvents.evtBonusInitResponse + this.symbol, vsResponse);
        else
            this.SendBonusRequest(null);
    if (vsResponse.IsFreeSpinBonusGame() && !vsResponse.VsFreeSpin.BonusGame.GameOver)
        if (vsResponse.WasDoFSBonus())
            EventManager.Trigger(GameEvents.evtFSBGInitResponse + this.symbol, vsResponse);
        else
            this.SendFSBGRequest(null)
}
;
GameConnection.prototype.HandleSpinResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    if (this.mustStopSpin) {
        EventManager.Queue(GameEvents.evtNoMoneySpinResponse, data);
        this.requestState = RequestState.Idle;
        return
    }
    if (this.NoMoney(data) || this.isRegulatoryError) {
        if (GameConnection.noMoneyStopsSpin) {
            EventManager.Queue(GameEvents.evtNoMoneySpinResponse, data);
            this.requestState = RequestState.Idle
        }
        return
    }
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null)
        EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    var newInitData = vsResponse.VsInitData;
    var configSwitched = newInitData.ReelSymbols != null && newInitData.ReelSymbols.length > 0;
    if (configSwitched)
        this.initData.GamblingSettings = newInitData.GamblingSettings.Clone();
    this.AddGambleButtonState(vsResponse, false);
    if (configSwitched)
        EventManager.Queue(GameEvents.evtConfigSwitchedResponse + this.symbol, vsResponse);
    EventManager.Queue(GameEvents.evtSpinResponse + this.symbol, vsResponse);
    var needToCollect = true;
    if (this.srvResponse.NextGameActions == null)
        needToCollect = response.DoCollect || vsResponse.IsWin();
    if (needToCollect && (vsResponse.IsFreeSpins() && !vsResponse.VsFreeSpin.IsFirstFreeSpin() && !vsResponse.IsFreeSpinBonusGame()))
        needToCollect = false;
    this.requestState = RequestState.Idle;
    if (needToCollect)
        this.SendCollectRequest();
    if (vsResponse.IsJackpotWin())
        this.SendJackpotCollectRequest(null);
    EventManager.Queue(JackpotEvents.evtJackpotStateChanged, vsResponse.VsJackpotData);
    if (vsResponse.IsBonus() && !vsResponse.IsBonusRespin() && !vsResponse.IsBonusFSPick() && !vsResponse.IsBonusOptions() && !vsResponse.IsBonusGameOver())
        if (vsResponse.GetVsBonusGameData().wheelOfFortune != null)
            if (vsResponse.GetVsBonusGameData().wheelOfFortune.stopPosition != -1)
                this.SendBonusRequest(null);
            else
                EventManager.Queue(GameEvents.evtBonusInitResponse + this.symbol, vsResponse);
        else
            this.SendBonusRequest(null);
    else
        EventManager.Queue(GameEvents.evtBonusInitResponse + this.symbol, vsResponse);
    if (vsResponse.IsFreeSpinBonusGame() && !vsResponse.VsFreeSpin.BonusGame.GameOver)
        if (vsResponse.WasDoFSBonus())
            EventManager.Queue(GameEvents.evtFSBGInitResponse + this.symbol, vsResponse);
        else
            this.SendFSBGRequest(null)
}
;
GameConnection.prototype.AddGambleButtonState = function(response, isInit) {
    var spin = false;
    if (this.initData.GamblingSettings.IsOccasionEnable(GamblingOccasions.Spin) && response.IsWin() && !response.IsBonus() && !response.IsFreeSpins())
        spin = isInit ? !this.initData.GamblingSettings.SkipGambleOnInit : true;
    var freespin = false;
    if (this.initData.GamblingSettings.IsOccasionEnable(GamblingOccasions.FreeSpin) && response.IsWin() && response.IsFreeSpins() && response.VsFreeSpin.IsLastFreeSpin())
        freespin = isInit ? !this.initData.GamblingSettings.SkipGambleOnInit : true;
    var bonus = false;
    if (this.initData.GamblingSettings.IsOccasionEnable(GamblingOccasions.Bonus) && response.IsBonus())
        bonus = isInit ? !this.initData.GamblingSettings.SkipGambleOnInit : true;
    response.VsGamblingButtonState = new VsGamblingButtonState(spin,freespin,bonus)
}
;
GameConnection.prototype.HandleCollectResponse = function(nameValues, response) {
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null)
        EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    this.requestState = RequestState.Idle;
    if (this.mustPostGameRoundEndedOnCollect) {
        UHTInterfaceBOSS.PostMessage("gameRoundEnded");
        this.mustPostGameRoundEndedOnCollect = false
    }
}
;
GameConnection.prototype.HandleInitBonusResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    if (vsResponse.IsBonus())
        EventManager.Queue(GameEvents.evtBonusInitResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandlePickBonusResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtBonusPickResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandleBonusRespinResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtBonusRespinResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandleCollectBonusResponse = function(nameValues, response) {
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null)
        EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    XT.TriggerEvent("PS_AnnounceResultShown");
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandlePickFSOptionResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtFSOptionsUpdate + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandleInitFSBGResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtFSBGInitResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandlePickFSBGResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtFSBGPickResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandleMysteryScatterResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var vsResponse = VSProtocolParser.ParseVsResponse(data);
    vsResponse.NextGameActions = response.NextGameActions;
    EventManager.Queue(GameEvents.evtMysteryScatterResponse + this.symbol, vsResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandleGambleResponse = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    if (this.NoMoney(data))
        return;
    var gambleResponse = GameProtocolGamblingParser.ParseVsGamblingResponse(data);
    EventManager.Queue(GameEvents.evtGambleResponse + this.symbol, gambleResponse);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandleGambleCollectResponse = function(nameValues, response) {
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null)
        EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    this.requestState = RequestState.Idle
}
;
GameConnection.prototype.HandleJackpotCollectResponse = function(nameValues, response) {
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null)
        EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData);
    this.HandleFreeRoundsUpdateOnCollect(nameValuesDict);
    this.requestState = RequestState.Idle;
    if (this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) != -1)
        this.SendCollectRequest()
}
;
GameConnection.prototype.HandleSettingsLoaded = function(param, statusCode) {
    console.info("HandleSettingsLoaded", param);
    var settings = new GameSettings;
    settings.FromString(param);
    console.log("HandleSettingsLoaded", GameEvents.evtSettingsUpdated + this.symbol);
    EventManager.Queue(GameEvents.evtSettingsUpdated + this.symbol, settings)
}
;
GameConnection.prototype.HandleSettingSaved = function(param, statusCode) {
    console.info("HandleSettingSaved " + param);
    var settings = new GameSettings;
    settings.FromString(param);
    if (settings.Settings["SoundState"] == undefined) {
        EventManager.Trigger(AdapterEvents.evtShowMessage, AdapterMessages.settingsNotSaved);
        EventManager.Queue(GameEvents.evtSettingsNotSaved, null)
    }
}
;
GameConnection.prototype.NoMoney = function(data) {
    if (data[GameProtocolDictionary.noMoney] != undefined) {
        console.error("You have no money beci!");
        return true
    }
    return false
}
;
GameConnection.prototype.HandleFreeRoundsUpdateOnCollect = function(nameValues) {
    var vsResponse = new VsResponse;
    vsResponse.FreeRound = VSProtocolParser.ParseVsFreeRound(nameValues);
    vsResponse.FreeRoundEvents = VSProtocolParser.ParseVsFreeRoundEvents(nameValues);
    EventManager.Queue(GameEvents.evtFreeRoundsUpdate, vsResponse)
}
;
GameConnection.prototype.HandleGambleV2Response = function(nameValues, response) {
    var data = GameProtocolCommonParser.SplitResponseContent(nameValues);
    EventManager.Queue(GameEvents.evtGambleResponse + this.symbol, GambleV2Protocol.Parser.ParseGambleData(data));
    this.requestState = RequestState.Idle;
    if (this.srvResponse.NextGameActions != null) {
        if (this.srvResponse.NextGameActions.indexOf(NextGameAction.Collect) > -1)
            this.SendCollectRequest();
        if (this.srvResponse.NextGameActions.indexOf(NextGameAction.CollectBonus) > -1)
            this.SendBonusCollectRequest(null)
    }
}
;
GameConnection.prototype.SendGambleV2Request = function(index) {
    if (this.requestState == RequestState.Block) {
        console.error("Connection to the server was interrupted and can't send more requests!");
        console.error("Request attempt was - Gamble")
    }
    if (this.srvResponse.NextGameActions == null) {
        console.warn("SendGambleV2Request skipped");
        return
    }
    var gamble = this.srvResponse.NextGameActions.indexOf(NextGameAction.Gamble) > -1;
    var gambleOption = this.srvResponse.NextGameActions.indexOf(NextGameAction.GambleOption) > -1;
    if (!(gamble || gambleOption)) {
        console.warn("SendGambleV2Request skipped");
        return
    }
    var data = new RequestData;
    data.Fields = {};
    data.Url = 'https://ganesh.bet/game/Dragons888PM/server';
    data.Fields[GameProtocolDictionary.symbol] = this.symbol;
    data.Fields["g_a"] = index < 0 ? "stand" : "gamble";
    if (gamble) {
        data.Fields[GameProtocolDictionary.Actions.action] = GameProtocolDictionary.Actions.doGamble;
        data.Fields["g_ind"] = String(index)
    } else {
        data.Fields[GameProtocolDictionary.Actions.action] = "doGambleOption";
        data.Fields["g_o_ind"] = String(index)
    }
    if (this.requestState != RequestState.Idle) {
        this.queuedState = RequestState.Gamble;
        this.queuedRequest = data
    } else {
        this.requestState = RequestState.Gamble;
        this.SendRequest(data)
    }
}
;
GameConnection.prototype.CanRequest = function(reqState) {
    var can = true;
    if (this.srvResponse != null && this.srvResponse.NextGameActions != null)
        switch (reqState) {
        case RequestState.Collect:
            can = this.IsNextAction(NextGameAction.Collect);
            break;
        case RequestState.Spin:
            can = this.IsNextAction(NextGameAction.Spin);
            break;
        case RequestState.Gamble:
            can = this.IsNextAction(NextGameAction.Gamble) || this.IsNextAction(NextGameAction.GambleOption);
            break;
        case RequestState.PickFSOption:
            can = this.IsNextAction(NextGameAction.FSOption);
            break;
        case RequestState.InitFSBG:
        case RequestState.PickFSBG:
            can = this.IsNextAction(NextGameAction.FSBonus);
            break;
        case RequestState.GetMysteryScatter:
            can = this.IsNextAction(NextGameAction.MysteryScatter);
            break;
        case RequestState.GambleCollect:
            can = this.IsNextAction(NextGameAction.GambleCollect);
            break;
        case RequestState.JackpotCollect:
            can = this.IsNextAction(NextGameAction.JackpotCollect);
            break;
        case RequestState.InitBonus:
        case RequestState.PickBonus:
        case RequestState.BonusRespin:
            can = this.IsNextAction(NextGameAction.Bonus);
            break;
        case RequestState.CollectBonus:
            can = this.IsNextAction(NextGameAction.Collect) || this.IsNextAction(NextGameAction.CollectBonus);
            break
        }
    return can
}
;
GameConnection.prototype.IsNextAction = function(action) {
    return this.srvResponse != null && this.srvResponse.NextGameActions != null && this.srvResponse.NextGameActions.indexOf(action) > -1
}
;
goog.require("UHT.ServerOptions");
goog.require("UHT.Component");
goog.require("UHT.ResourceRequest");
ResourceManager.prototype = Object.create(Component.prototype);
ResourceManager.prototype.constructor = ResourceManager;
function ResourceManager() {
    Component.call(this);
    this.downloadQueue = null;
    this.waitingQueue = null;
    this.packagesInfo = null;
    ResourceManager.instance = this
}
ResourceManager.prototype.Start = function() {
    this.downloadQueue = [];
    this.waitingQueue = [];
    EventManager.AddHandler(ResourceEvents.evtRequestResources, this.OnResourcesRequest, this)
}
;
ResourceManager.prototype.Update = function() {
    var i;
    if (this.waitingQueue.length > 0) {
        for (i = 0; i < this.waitingQueue.length; ++i)
            this.downloadQueue.push(this.waitingQueue[i]);
        this.waitingQueue = []
    }
    if (this.downloadQueue.length > 0)
        for (i = 0; i < this.downloadQueue.length; ++i) {
            this.downloadQueue[i].Update();
            if (this.downloadQueue[i].isDone) {
                EventManager.Queue(ResourceEvents.evtResourcesCompleted + this.downloadQueue[i].componentName, this.downloadQueue[i].GetData());
                this.downloadQueue.splice(i, 1)
            }
        }
}
;
ResourceManager.prototype.OnResourcesRequest = function(componentName) {
    if (UHT_RESOURCES == null) {
        if (this.packagesInfo == null) {
            var self = this;
            setTimeout(function() {
                self.OnResourcesRequest(componentName)
            }, 200)
        }
        return
    }
    globalTracking.StartTimer("uht_loading", "_X_apply_localization_packages", "LoadingTracker");
    this.packagesInfo = UHT_PACKAGES_INFO_OBJ;
    var bundlePack = new BundlePack;
    var currencyPatch = new AssetBundle;
    currencyPatch.mainAsset = jsonParse(UHT_RESOURCES.CURRENCY_PATCH);
    bundlePack.assetBundles.push(currencyPatch);
    for (var i = 0; i < UHT_RESOURCES.LOCALIZATIONS.length; ++i) {
        var bundle = new AssetBundle;
        bundle.mainAsset = jsonParse(UHT_RESOURCES.LOCALIZATIONS[i]);
        bundlePack.assetBundles.push(bundle)
    }
    EventManager.Queue(ResourceEvents.evtResourcesCompleted + componentName, bundlePack);
    globalTracking.StopTimerAndSend("uht_loading", "_X_apply_localization_packages", "LoadingTracker");
    UHT_RESOURCES = null
}
;
ResourceManager.prototype.RequestResources = function(request) {
    console.log("ResourceManager::RequestResources", request);
    var pack = new RequestPack;
    pack.componentName = request.symbol;
    for (var i = 0; i < request.files.length; ++i)
        pack.downloaders.push(new ResourceRequest({
            url: request.files[i]
        }));
    this.waitingQueue.push(pack)
}
;
ResourceManager.prototype.InstLoadLanguage = function(lang) {
    var dict = this.packagesInfo;
    if (dict["languages"] == undefined) {
        console.warn("ResourceManager - language bundles not found!");
        return
    }
    var info = new ResourceRequestInfo;
    info.symbol = lang;
    var languages = dict["languages"];
    var path = ServerOptions.gameUrl + ServerOptions.packagesUri;
    var suffix = (UHT_DEVICE_TYPE.MOBILE ? "_mobile" : "_desktop") + ".json";
    for (var i = 0; i < languages.length; ++i)
        if (languages[i]["language"] == lang) {
            console.info("found bundles for language " + languages[i]["language"]);
            var bundles = languages[i]["bundles"];
            for (var j = 0; j < bundles.length; ++j)
                info.files.push(path + bundles[j]["name"] + suffix)
        }
    this.RequestResources(info)
}
;
ResourceManager.instance = null;
ResourceManager.LoadLanguage = function(lang) {
    var rm = ResourceManager;
    var rmi = ResourceManager.instance;
    if (rmi == null || rmi.packagesInfo == null) {
        setTimeout(function() {
            ResourceManager.LoadLanguage(lang)
        }, 50);
        return
    }
    EventManager.AddHandler(ResourceEvents.evtResourcesCompleted + lang, rm.OnLanguageLoaded, rm);
    rmi.InstLoadLanguage(lang)
}
;
ResourceManager.OnLanguageLoaded = function(pack) {
    for (var i = 0; i < pack.assetBundles.length; ++i) {
        var go = UHTEngine.LoadAssetBundle(pack.assetBundles[i].mainAsset, ServerOptions.gameUrl + "packages/");
        var mm = go.GetComponent(ModificationsManager);
        if (mm != null)
            mm.Init()
    }
    pack.assetBundles = []
}
;
goog.require("UHT.ServerOptions");
goog.provide("UHT.ServerHelpers");
var ServerHelpers = {
    CookiesRequest: function(callback) {
        console.info("Sending request for sessionid from cookies");
        var req = new ServerRequest;
        req.Url = ServerOptions.serverUrl + "/gs2c/richcasino/index.jsp?lang=en";
        req.Handler = callback;
        req.Method = "HEAD";
        RequestManager.AddRequest(req)
    },
    RequestApplicationConfiguration: function(callback) {
        var request = new ServerRequest;
        request.Url = ServerOptions.serverUrl + ServerOptions.configUri;
        request.Handler = callback;
        request.Method = "POST";
        request.KeepAlive = true;
        request.AllowRedirect = true;
        RequestManager.AddRequest(request)
    },
    LoginRequest: function(uName, uPass, callback) {
        var request = new ServerRequest;
        var loginParams = "?method=login&nic=" + uName + "&pwd=" + uPass + "&acctype=R";
        request.Url = ServerOptions.serverUrl + ServerOptions.loginUri + loginParams;
        request.Handler = callback;
        request.Method = "POST";
        request.KeepAlive = true;
        request.AllowRedirect = true;
        RequestManager.AddRequest(request)
    },
    RequestGameConfiguration: function(gameSymbol, callback) {
        var request = new ServerRequest;
        request.Url = ServerOptions.serverUrl + ServerOptions.menuUri;
        request.Handler = callback;
        request.Method = "POST";
        request.KeepAlive = true;
        request.AllowRedirect = true;
        request.Fields["method"] = "gameInfo";
        request.Fields[GameProtocolDictionary.symbol] = gameSymbol;
        RequestManager.AddRequest(request)
    },
    RequestAcceptedVersions: function(callback) {
        var request = new ServerRequest;
        var requestUrl = "";
        requestUrl += ServerOptions.serverUrl;
        requestUrl += ServerOptions.versionUri;
        requestUrl += ServerHelpers.BuildGetParam(DefaultValues.UnityVars.bundleVersion, ServerOptions.resourceVersion);
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "GET";
        RequestManager.AddRequest(request)
    },
    ReloadBalance: function(callback, force) {
        var request = new ServerRequest;
        var requestUrl = "";
        requestUrl += ServerOptions.serverUrl;
        requestUrl += ServerOptions.reloadBalanceUri;
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "GET";
        if (force)
            request.Fields["force"] = "true";
        RequestManager.AddRequest(request)
    },
    ReloadJackpot: function(gameSymbol, callback) {
        var request = new ServerRequest;
        var requestUrl = "";
        requestUrl += ServerOptions.serverUrl;
        requestUrl += ServerOptions.reloadJackpotUri;
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "POST";
        request.Fields[GameProtocolDictionary.symbol] = gameSymbol;
        RequestManager.AddRequest(request)
    },
    RequestRegulationNotification: function(callback) {
        var request = new ServerRequest;
        var requestUrl = "";
        requestUrl += ServerOptions.SwedishRegulation.notificationUrl + "?mgckey=" + ServerOptions.mgckey;
        request.Url = requestUrl;
        request.Handler = callback;
        request.Method = "GET";
        RequestManager.AddRequest(request)
    },
    BuildGetParam: function(name, value) {
        return "?" + name + "=" + value
    },
    BuildGetParams: function(dict) {
        var rv = [];
        for (var tmp in dict)
            rv.push([tmp, dict[tmp]].join("="));
        return "?" + rv.join("&")
    }
};
goog.provide("UHT.BalanceManager");
goog.require("UHT.ServerHelpers");
goog.require("UHT.EventManager");
goog.require("UHT.BalanceData");
var BalanceEvents = {
    evtBalanceUpdated: "evtBalanceUpdated",
    evtBalanceUpdateRequest: "evtBalanceUpdateRequest",
    evtBalanceUpdateFromAdapter: "evtBalanceUpdateFromAdapter",
    evtBalanceUpdateToAdapter: "evtBalanceUpdateToAdapter",
    evtUpdateBalance: "evtUpdateBalance",
    evtUpdateBalanceForced: "evtUpdateBalanceForced"
};
function BalanceManager() {
    this.data = null;
    this.maxBalanceDelay = 10;
    this.balanceRequestTimer = 10;
    this.requestInProgress = false
}
BalanceManager.I = null;
BalanceManager.prototype.Init = function() {
    BalanceManager.I = this;
    this.requestInProgress = false;
    EventManager.AddHandler(BalanceEvents.evtBalanceUpdateRequest, this.OnUpdateRequest, this);
    EventManager.AddHandler(BalanceEvents.evtBalanceUpdateFromAdapter, this.OnBalanceUpdateFromAdapter, this);
    EventManager.AddHandler(BalanceEvents.evtUpdateBalance, this.OnUpdateBalance, this);
    EventManager.AddHandler(BalanceEvents.evtUpdateBalanceForced, this.OnUpdateBalanceForced, this)
}
;
BalanceManager.prototype.OnUpdateRequest = function(param) {
    var newData = param;
    if (this.data == null || newData.Time > this.data.Time) {
        this.balanceRequestTimer = 0;
        this.data = newData;
        EventManager.Queue(BalanceEvents.evtBalanceUpdated, this.data);
        EventManager.Queue(BalanceEvents.evtBalanceUpdateToAdapter, this.data)
    }
}
;
BalanceManager.prototype.OnBalanceUpdateFromAdapter = function(param) {
    var newData = param;
    if (this.data == null || newData.Time > this.data.Time) {
        this.balanceRequestTimer = 0;
        this.data = newData;
        EventManager.Queue(BalanceEvents.evtBalanceUpdated, this.data)
    }
}
;
BalanceManager.prototype.Update = function() {
    this.balanceRequestTimer += Time.deltaTime;
    if (!this.requestInProgress)
        if (this.balanceRequestTimer > this.maxBalanceDelay) {
            this.requestInProgress = true;
            ServerHelpers.ReloadBalance(new EventHandler(this,this.BalanceReloadCallback), false)
        }
}
;
BalanceManager.prototype.BalanceReloadCallback = function(data, statusCode) {
    var nameValues = String(data).split("&");
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null) {
        this.requestInProgress = false;
        this.OnUpdateRequest(balanceData)
    }
}
;
BalanceManager.prototype.OnUpdateBalance = function() {
    ServerHelpers.ReloadBalance(new EventHandler(this,this.BalanceReloadCallback), false)
}
;
BalanceManager.prototype.OnUpdateBalanceForced = function() {
    ServerHelpers.ReloadBalance(new EventHandler(this,this.BalanceReloadCallback), true)
}
;
goog.require("UHT.SimpleWebRequest");
function RequestData() {
    this.RequestMethod = "POST";
    this.Url = "";
    this.Fields = {}
}
function ResponseData(statusCode, response) {
    this.StatusCode = statusCode;
    this.Response = response
}
function ServerRequest() {
    this.Handler = null;
    this.Fields = {};
    this.Url = "";
    this.Method = "GET";
    this.AllowRedirect = false;
    this.KeepAlive = false;
    this.PostData = "";
    this.ContentType = "application/x-www-form-urlencoded";
    this.request = null
}
ServerRequest.prototype.IsDone = function() {
    if (this.request == null)
        return false;
    else
        return this.request.Done
}
;
ServerRequest.prototype.Start = function() {
    if (_string.IsNullOrEmpty(this.PostData)) {
        var args = [];
        for (var name in this.Fields)
            args.push(name + "=" + this.Fields[name]);
        this.PostData = args.join("&")
    }
    this.request = RequestProvider.Instance.NewRequest({
        url: this.Url,
        method: this.Method,
        postData: this.PostData,
        contentType: this.ContentType
    })
}
;
ServerRequest.prototype.Finish = function() {
    console.log("ServerRequest::Finish", this.Handler);
    if (this.Handler != null)
        this.Handler.call(this.request.Data, this.request.statusCode);
    if (String(this.request.Data).indexOf(GameProtocolDictionary.unlogged) != -1) {
        console.error("User logged out" + this.request.Data);
        RequestManager.blockRequests = true
    }
    EventManager.Trigger(ApplicationEvents.evtServerResponse, new ResponseData(this.request.statusCode,this.request.Data))
}
;
goog.provide("UHT.SwedishRegulationManager");
goog.require("UHT.ServerHelpers");
goog.require("UHT.EventManager");
function SwedishRegulationManager() {
    this.regulationRequestInterval = -1;
    this.regulationRequestTimer = 0;
    this.requestInProgress = false;
    this.regulationTimerIsActive = false;
    this.elapsedTime = 0;
    this.elapsedTimeContainerLandscape = null;
    this.elapsedTimeContainerPortrait = null;
    this.initialTime = 0;
    this.initialElapsedTime = 0
}
SwedishRegulationManager.instance = null;
SwedishRegulationManager.prototype.Init = function() {
    SwedishRegulationManager.instance = this;
    this.requestInProgress = false;
    if (UHT_GAME_CONFIG["REGULATION_NOTIFICATION_INTERVAL"] != undefined)
        if (!isNaN(parseInt(UHT_GAME_CONFIG["REGULATION_NOTIFICATION_INTERVAL"], 10)))
            this.regulationRequestInterval = parseInt(UHT_GAME_CONFIG["REGULATION_NOTIFICATION_INTERVAL"], 10);
    if (UHT_GAME_CONFIG["selftestUrl"] && UHT_GAME_CONFIG["pauseplayUrl"] && UHT_GAME_CONFIG["playlimitUrl"]) {
        this.InjectRegulationContainers();
        if (UHT_GAME_CONFIG["elapsedTime"]) {
            this.initialElapsedTime = parseInt(UHT_GAME_CONFIG["elapsedTime"], 10);
            this.regulationTimerIsActive = true
        }
        EventManager.AddHandler("EVT_UHT_RESIZE", this.OnUHTResize, this);
        this.OnUHTResize(null)
    }
    this.elapsedTime = this.initialElapsedTime;
    this.initialTime = (new Date).getTime()
}
;
SwedishRegulationManager.prototype.Update = function() {
    if (this.regulationRequestInterval > 0) {
        this.regulationRequestTimer += Time.deltaTime;
        if (!this.requestInProgress)
            if (this.regulationRequestTimer > this.regulationRequestInterval) {
                this.requestInProgress = true;
                ServerHelpers.RequestRegulationNotification(new EventHandler(this,this.RegulationRequestCallback), false)
            }
    }
    if (this.regulationTimerIsActive)
        this.UpdateTimer()
}
;
SwedishRegulationManager.prototype.RegulationRequestCallback = function(data, statusCode) {
    if (data != null) {
        this.requestInProgress = false;
        this.regulationRequestTimer = 0
    }
}
;
SwedishRegulationManager.prototype.InjectRegulationContainers = function() {
    var htmlString = "";
    if (document.documentElement.id == "Mobile")
        htmlString = '<div class="RGSContainerActive" style="display: block;" data-height="25"><div id="RGSPortrait" style="margin-left: auto; margin-right: auto; width: 100%; display:block; white-space: nowrap;"> <a href="#" class="PausePlay" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelpaus" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTg0LjkgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTg0LjkgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6I0UyMEQxODt9PC9zdHlsZT48Zz48cmVjdCB4PSIwLjUiIHk9IjAuNSIgY2xhc3M9InN0MCIgd2lkdGg9IjE4My45IiBoZWlnaHQ9IjUyLjQiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTgzLjksMXY1MS40SDFWMUgxODMuOSBNMTg0LjksMEgwdjUzLjRoMTg0LjlWMEwxODQuOSwweiIvPjwvZz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTMuMywyNi44QzUzLjMsMzguNSw0My44LDQ4LDMyLDQ4Yy0xMS43LDAtMjEuMy05LjUtMjEuMy0yMS4zQzEwLjgsMTUsMjAuMyw1LjUsMzIsNS41QzQzLjgsNS41LDUzLjMsMTUsNTMuMywyNi44eiIvPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03Ny4xLDMwLjVjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuMywxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTNoMC4yYzAuOSwwLjcsMS45LDEuMywzLjEsMS43czIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNHMtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN2MtMC44LTAuOC0xLjEtMS45LTEuMS0zLjFjMC0xLjUsMC42LTIuNywxLjktMy42YzEuMy0wLjksMi44LTEuNCw0LjgtMS40YzEuMiwwLDIuNCwwLjEsMy40LDAuNGMxLDAuMiwyLDAuNSwyLjgsMC45djIuOGgtMC4yYy0wLjctMC42LTEuNi0xLTIuNy0xLjRjLTEuMS0wLjQtMi4yLTAuNi0zLjQtMC42Yy0xLjMsMC0yLjMsMC4zLTMsMC44Yy0wLjgsMC41LTEuMSwxLjItMS4xLDJjMCwwLjcsMC4yLDEuMywwLjYsMS43YzAuNCwwLjQsMS4xLDAuNywyLDFjMC41LDAuMSwxLjIsMC4yLDIuMiwwLjRjMC45LDAuMiwxLjcsMC4zLDIuNCwwLjVjMS4zLDAuMywyLjMsMC45LDMsMS42Qzc2LjcsMjguMiw3Ny4xLDI5LjIsNzcuMSwzMC41eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik05Mi42LDI4LjhjMCwxLjEtMC4yLDIuMS0wLjUsM2MtMC4zLDAuOS0wLjcsMS42LTEuMywyLjNjLTAuNSwwLjYtMS4xLDEtMS45LDEuNHMtMS41LDAuNS0yLjMsMC41Yy0wLjcsMC0xLjMtMC4xLTEuOS0wLjJjLTAuNi0wLjItMS4xLTAuNC0xLjctMC43djUuNmgtMi4yVjIyLjNoMi4ydjEuNGMwLjYtMC41LDEuMy0wLjksMi0xLjNjMC43LTAuMywxLjUtMC41LDIuNC0wLjVjMS42LDAsMi44LDAuNiwzLjcsMS44QzkyLjIsMjQuOSw5Mi42LDI2LjYsOTIuNiwyOC44eiBNOTAuMywyOC44YzAtMS42LTAuMy0yLjgtMC44LTMuNkM4OC45LDI0LjQsODguMSwyNCw4NywyNGMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M4OS45LDMxLjcsOTAuMywzMC41LDkwLjMsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTA3LjUsMjkuMWgtOS44YzAsMC44LDAuMSwxLjUsMC40LDIuMWMwLjIsMC42LDAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOGMtMC44LDAuMi0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOHMtMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZjMSwxLDEuNSwyLjUsMS41LDQuNVYyOS4xeiBNMTA1LjMsMjcuNGMwLTEuMi0wLjMtMi4xLTAuOS0yLjdjLTAuNi0wLjYtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTA1LjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTExMy4zLDM1LjZoLTIuMlYxN2gyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTI5LjcsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjksMS40cy0xLjUsMC41LTIuMywwLjVjLTAuNywwLTEuMy0wLjEtMS45LTAuMmMtMC42LTAuMi0xLjEtMC40LTEuNy0wLjd2NS42SDExOFYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEMxMjkuMywyNC45LDEyOS43LDI2LjYsMTI5LjcsMjguOHogTTEyNy40LDI4LjhjMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0MxMjcuMSwzMS43LDEyNy40LDMwLjUsMTI3LjQsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQzLjgsMzUuNmgtMi4ydi0xLjRjLTAuMiwwLjEtMC41LDAuMy0wLjgsMC42Yy0wLjMsMC4yLTAuNywwLjQtMSwwLjZjLTAuNCwwLjItMC44LDAuMy0xLjMsMC41Yy0wLjUsMC4xLTEuMSwwLjItMS43LDAuMmMtMS4yLDAtMi4yLTAuNC0zLTEuMnMtMS4yLTEuOC0xLjItM2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM2MtMC4yLTAuMy0wLjQtMC42LTAuOC0wLjhjLTAuMy0wLjItMC43LTAuMy0xLjEtMC40cy0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJzLTEuNSwwLjQtMi4yLDAuN2gtMC4xdi0yLjNjMC40LTAuMSwxLjEtMC4zLDEuOS0wLjRjMC44LTAuMSwxLjYtMC4yLDIuNC0wLjJjMC45LDAsMS44LDAuMSwyLjQsMC4yYzAuNywwLjIsMS4zLDAuNCwxLjgsMC44YzAuNSwwLjQsMC45LDAuOCwxLjEsMS40czAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTQxLjUsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNDAuNCwzMy4xLDE0MSwzMi43LDE0MS41LDMyLjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1OS4zLDM1LjZoLTIuMnYtMS41Yy0wLjgsMC42LTEuNSwxLjEtMi4yLDEuNHMtMS41LDAuNS0yLjMsMC41Yy0xLjQsMC0yLjUtMC40LTMuMy0xLjNzLTEuMi0yLjEtMS4yLTMuOHYtOC42aDIuMnY3LjZjMCwwLjcsMCwxLjMsMC4xLDEuN2MwLjEsMC41LDAuMiwwLjksMC40LDEuMmMwLjIsMC4zLDAuNSwwLjYsMC44LDAuOGMwLjMsMC4yLDAuOCwwLjIsMS41LDAuMmMwLjYsMCwxLjItMC4yLDEuOS0wLjVjMC43LTAuMywxLjMtMC43LDEuOS0xLjJ2LTkuOWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTczLjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM2MwLjksMC4zLDEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zczAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTczLjIsMzAsMTczLjUsMzAuOCwxNzMuNSwzMS43eiIvPjwvZz48L2c+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI4LjcsMzcuNWgtNi4yYy0wLjUsMC0wLjktMC40LTAuOS0wLjlWMTYuOWMwLTAuNSwwLjQtMC45LDAuOS0wLjloNi4yYzAuNSwwLDAuOSwwLjQsMC45LDAuOXYxOS43QzI5LjYsMzcuMSwyOS4yLDM3LjUsMjguNywzNy41eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MS41LDM3LjZoLTYuMmMtMC41LDAtMC45LTAuNC0wLjktMC45VjE2LjljMC0wLjUsMC40LTAuOSwwLjktMC45aDYuMmMwLjUsMCwwLjksMC40LDAuOSwwLjl2MTkuN0M0Mi40LDM3LjIsNDIsMzcuNiw0MS41LDM3LjZ6Ii8+PC9zdmc+"/> </a> <a href="#" class="SelfTest" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Sjlvtest" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTgwLjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTgwLjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6bm9uZTtzdHJva2U6dXJsKCNTVkdJRF8xXyk7c3Ryb2tlLXdpZHRoOjYuNzc0MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LnN0M3tmaWxsOiMxRTFFMUM7fTwvc3R5bGU+PGc+PHJlY3QgeD0iMC41IiB5PSIwLjUiIGNsYXNzPSJzdDAiIHdpZHRoPSIxNzkuNSIgaGVpZ2h0PSI1Mi40Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3OS41LDF2NTEuNEgxVjFIMTc5LjUgTTE4MC42LDBIMHY1My40aDE4MC42VjBMMTgwLjYsMHoiLz48L2c+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTMxLjksNDcuOGMtNS41LTAuMS0xMC43LTIuMy0xNC42LTYuMmMtMy45LTQtNi05LjItNS45LTE0LjhjMC4xLTExLjMsOS40LTIwLjYsMjAuOC0yMC42bDAuMiwwYzUuNSwwLjEsMTAuNywyLjMsMTQuNiw2LjJjMy45LDQsNiw5LjIsNS45LDE0LjhjLTAuMSwxMS4zLTkuNCwyMC42LTIwLjgsMjAuNkwzMS45LDQ3Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTMyLjEsNS43djFsMC4yLDBjNS40LDAuMSwxMC41LDIuMiwxNC4zLDYuMWMzLjgsMy45LDUuOCw5LDUuOCwxNC40Yy0wLjEsMTEuMS05LjIsMjAuMS0yMC4zLDIwLjFsLTAuMiwwYy01LjQtMC4xLTEwLjUtMi4yLTE0LjMtNi4xYy0zLjgtMy45LTUuOC05LTUuOC0xNC40YzAuMS0xMS4xLDkuMi0yMC4xLDIwLjMtMjAuMUwzMi4xLDUuNyBNMzIuMSw1LjdjLTExLjYsMC0yMS4xLDkuNC0yMS4zLDIxYy0wLjEsMTEuNyw5LjMsMjEuNCwyMSwyMS41YzAuMSwwLDAuMSwwLDAuMiwwYzExLjYsMCwyMS4xLTkuNCwyMS4zLTIxYzAuMS0xMS43LTkuMy0yMS40LTIxLTIxLjVDMzIuMyw1LjcsMzIuMiw1LjcsMzIuMSw1LjdMMzIuMSw1Ljd6Ii8+PC9nPjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMuMzkwNCIgeTE9Ii0zMDMuMjA3NyIgeDI9IjUwLjYwNDMiIHkyPSItMzAzLjIwNzciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIC0xIDY0LjAwMDUgLTI4My41MzY1KSI+PHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U0MTkxMyIvPjxzdG9wICBvZmZzZXQ9IjkuNzQ0MDIwZS0wMiIgc3R5bGU9InN0b3AtY29sb3I6I0VBNjUxNiIvPjxzdG9wICBvZmZzZXQ9IjAuMjE0OCIgc3R5bGU9InN0b3AtY29sb3I6I0YzQTUxOCIvPjxzdG9wICBvZmZzZXQ9IjAuMzEyMSIgc3R5bGU9InN0b3AtY29sb3I6I0Y5Q0QxQSIvPjxzdG9wICBvZmZzZXQ9IjAuMzg0IiBzdHlsZT0ic3RvcC1jb2xvcjojRkRFMzFBIi8+PHN0b3AgIG9mZnNldD0iMC40MjI4IiBzdHlsZT0ic3RvcC1jb2xvcjojRkVFQjFBIi8+PHN0b3AgIG9mZnNldD0iMC42MjMxIiBzdHlsZT0ic3RvcC1jb2xvcjojREZERTIwIi8+PHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzAwOTI0NSIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3LjIsMjYuN2MtMi4yLTE4LjYtMjcuOC0xOS0zMC40LDAiLz48Zz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNMjcuNywyNy4zbDguOC0xNS44bC0xLjgsMThjLTAuNiwxLjktMi43LDMtNC42LDIuNFMyNy4xLDI5LjIsMjcuNywyNy4zeiIvPjwvZz48Zz48Zz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzYuNSwzMC41YzAsMC43LTAuMiwxLjQtMC41LDJzLTAuOCwxLjItMS40LDEuN2MtMC42LDAuNS0xLjQsMC45LTIuMiwxLjJjLTAuOCwwLjMtMS45LDAuNC0zLjEsMC40Yy0xLjMsMC0yLjQtMC4xLTMuNC0wLjRjLTEtMC4yLTIuMS0wLjYtMy4xLTEuMXYtM0g2M2MwLjksMC43LDEuOSwxLjMsMy4xLDEuN2MxLjIsMC40LDIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNGMtMC43LTAuMS0xLjQtMC4yLTIuMi0wLjRjLTEuNi0wLjMtMi43LTAuOS0zLjUtMS43Yy0wLjgtMC44LTEuMS0xLjktMS4xLTMuMWMwLTEuNSwwLjYtMi43LDEuOS0zLjZjMS4zLTAuOSwyLjgtMS40LDQuOC0xLjRjMS4yLDAsMi40LDAuMSwzLjQsMC40YzEsMC4yLDIsMC41LDIuOCwwLjl2Mi44aC0wLjJjLTAuNy0wLjYtMS42LTEtMi43LTEuNGMtMS4xLTAuNC0yLjItMC42LTMuNC0wLjZjLTEuMywwLTIuMywwLjMtMywwLjhjLTAuOCwwLjUtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzYuMSwyOC4zLDc2LjUsMjkuMyw3Ni41LDMwLjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTg0LjMsMzUuOWMwLDEuNi0wLjQsMi43LTEuMiwzLjVzLTEuOSwxLjItMy4yLDEuMmMtMC4zLDAtMC43LDAtMS4zLTAuMWMtMC41LTAuMS0xLTAuMS0xLjMtMC4ydi0yLjFoMC4xYzAuMiwwLjEsMC41LDAuMiwwLjksMC4zYzAuNCwwLjEsMC43LDAuMiwxLjEsMC4yYzAuNiwwLDEtMC4xLDEuNC0wLjJjMC4zLTAuMiwwLjYtMC40LDAuOC0wLjdjMC4yLTAuMywwLjMtMC43LDAuMy0xLjFjMC4xLTAuNCwwLjEtMSwwLjEtMS42VjI0LjJoLTIuOHYtMS45aDVWMzUuOXogTTg0LjUsMjAuMWgtMi41di0yLjNoMi41VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTk5LjMsMzUuNkg5N3YtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yQzg4LjQsMzQsODgsMzMsODgsMzEuN2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM3MtMC40LTAuNi0wLjgtMC44Yy0wLjMtMC4yLTAuNy0wLjMtMS4xLTAuNGMtMC40LTAuMS0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJjLTAuNywwLjItMS41LDAuNC0yLjIsMC43aC0wLjF2LTIuM2MwLjQtMC4xLDEuMS0wLjMsMS45LTAuNGMwLjgtMC4xLDEuNi0wLjIsMi40LTAuMmMwLjksMCwxLjgsMC4xLDIuNCwwLjJjMC43LDAuMiwxLjMsMC40LDEuOCwwLjhjMC41LDAuNCwwLjksMC44LDEuMSwxLjRzMC40LDEuMywwLjQsMi4yVjM1LjZ6IE05NywzMi4zdi0zLjdjLTAuNywwLTEuNSwwLjEtMi40LDAuMlM5MywyOSw5Mi40LDI5LjFjLTAuNiwwLjItMS4yLDAuNS0xLjYsMC45Yy0wLjQsMC40LTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdjMC41LDAuNCwxLjIsMC42LDIuMSwwLjZjMC44LDAsMS41LTAuMiwyLjItMC41Qzk1LjksMzMuMSw5Ni41LDMyLjcsOTcsMzIuM3ogTTkyLjgsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6IE05Ny44LDIwLjFoLTIuNHYtMi4zaDIuNFYyMC4xeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMDYuMSwzNS42aC0yLjJWMTcuMWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTIyLjIsMjIuM2wtNS40LDEzLjNoLTIuMmwtNS4zLTEzLjNoMi40bDQuMSwxMC42bDQuMS0xMC42SDEyMi4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMzIuMywzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE0Ni40LDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45YzAuNiwwLjIsMS4yLDAuMywxLjksMC4zYzAuOSwwLDEuOC0wLjIsMi43LTAuNWMwLjktMC40LDEuNi0wLjcsMi0xLjFoMC4xdjIuNGMtMC44LDAuMy0xLjUsMC42LTIuMywwLjhzLTEuNiwwLjMtMi41LDAuM2MtMi4yLDAtMy45LTAuNi01LjItMS44Yy0xLjItMS4yLTEuOS0yLjktMS45LTUuMWMwLTIuMiwwLjYtMy45LDEuOC01LjJjMS4yLTEuMywyLjctMS45LDQuNy0xLjljMS44LDAsMy4yLDAuNSw0LjEsMS42YzEsMSwxLjUsMi41LDEuNSw0LjVWMjkuMnogTTE0NC4yLDI3LjVjMC0xLjItMC4zLTIuMS0wLjktMi43cy0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxNDQuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTU5LjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM3MxLjcsMC41LDIuNSwwLjVjMSwwLDEuOC0wLjIsMi4zLTAuNWMwLjYtMC4zLDAuOC0wLjgsMC44LTEuNWMwLTAuNS0wLjItMC45LTAuNS0xLjJzLTAuOS0wLjUtMS43LTAuN2MtMC4zLTAuMS0wLjctMC4yLTEuMi0wLjNjLTAuNS0wLjEtMS0wLjItMS40LTAuM2MtMS4yLTAuMy0yLTAuOC0yLjUtMS40Yy0wLjUtMC42LTAuNy0xLjMtMC43LTIuMmMwLTAuNSwwLjEtMS4xLDAuMy0xLjVjMC4yLTAuNSwwLjYtMC45LDEtMS4zYzAuNC0wLjQsMS0wLjcsMS43LTAuOWMwLjctMC4yLDEuNS0wLjMsMi4zLTAuM2MwLjgsMCwxLjYsMC4xLDIuNCwwLjNjMC44LDAuMiwxLjUsMC40LDIsMC43djIuNGgtMC4xYy0wLjYtMC40LTEuMy0wLjgtMi4xLTEuMWMtMC44LTAuMy0xLjYtMC40LTIuNC0wLjRjLTAuOCwwLTEuNSwwLjItMi4xLDAuNWMtMC42LDAuMy0wLjgsMC44LTAuOCwxLjRjMCwwLjUsMC4yLDEsMC41LDEuMmMwLjMsMC4zLDAuOSwwLjUsMS42LDAuN2MwLjQsMC4xLDAuOSwwLjIsMS40LDAuM2MwLjUsMC4xLDAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTU5LjIsMzAsMTU5LjUsMzAuOCwxNTkuNSwzMS43eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNjkuOSwzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PC9nPjwvZz48L3N2Zz4="/> </a> <a href="#" class="PlayLimit" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelgrnser" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjE5LjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjE5LjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6IzAwOTczOTt9LnN0M3tmaWxsOiNGRkZGRkY7c3Ryb2tlOiMwMDk3Mzk7c3Ryb2tlLXdpZHRoOjMuODcxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO30uc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzAwOTczOTtzdHJva2Utd2lkdGg6MS45MzU1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO308L3N0eWxlPjxnPjxyZWN0IHg9IjAuNSIgeT0iMC41IiBjbGFzcz0ic3QwIiB3aWR0aD0iMjE4LjUiIGhlaWdodD0iNTIuNCIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yMTguNSwxdjUxLjRIMVYxSDIxOC41IE0yMTkuNiwwSDB2NTMuNGgyMTkuNlYwTDIxOS42LDB6Ii8+PC9nPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03OC4yLDMwLjZjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuNCwxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTIuOWgwLjJjMC45LDAuNywxLjksMS4zLDMuMSwxLjdjMS4yLDAuNCwyLjMsMC42LDMuMywwLjZjMS41LDAsMi42LTAuMywzLjQtMC44YzAuOC0wLjUsMS4yLTEuMywxLjItMi4yYzAtMC44LTAuMi0xLjQtMC42LTEuN3MtMS0wLjctMS44LTAuOWMtMC42LTAuMi0xLjItMC4zLTEuOS0wLjRjLTAuNy0wLjEtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN3MtMS4xLTEuOS0xLjEtMy4xYzAtMS41LDAuNi0yLjcsMS45LTMuNmMxLjMtMC45LDIuOC0xLjQsNC44LTEuNGMxLjIsMCwyLjQsMC4xLDMuNCwwLjRjMSwwLjIsMiwwLjUsMi44LDAuOXYyLjhoLTAuMmMtMC43LTAuNi0xLjYtMS0yLjctMS40Yy0xLjEtMC40LTIuMi0wLjYtMy40LTAuNmMtMS4zLDAtMi4zLDAuMy0zLDAuOHMtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzcuOSwyOC4zLDc4LjIsMjkuMyw3OC4yLDMwLjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTkzLjYsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjgsMS40Yy0wLjcsMC4zLTEuNSwwLjUtMi4zLDAuNWMtMC43LDAtMS4zLTAuMS0xLjktMC4yYy0wLjYtMC4yLTEuMS0wLjQtMS43LTAuN3Y1LjZoLTIuMlYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEM5My4yLDI1LDkzLjYsMjYuNyw5My42LDI4Ljh6IE05MS4zLDI4LjljMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M5MSwzMS44LDkxLjMsMzAuNSw5MS4zLDI4Ljl6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEwOC4zLDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45czEuMiwwLjMsMS45LDAuM2MwLjksMCwxLjgtMC4yLDIuNy0wLjVjMC45LTAuNCwxLjYtMC43LDItMS4xaDAuMXYyLjRjLTAuOCwwLjMtMS41LDAuNi0yLjMsMC44cy0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOGMtMS4yLTEuMi0xLjktMi45LTEuOS01LjFjMC0yLjIsMC42LTMuOSwxLjgtNS4yYzEuMi0xLjMsMi43LTEuOSw0LjctMS45YzEuOCwwLDMuMiwwLjUsNC4xLDEuNmMxLDEsMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xMDYuMiwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN2MtMC42LTAuNi0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxMDYuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTE0LjEsMzUuNmgtMi4yVjE3LjFoMi4yVjM1LjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEyOS40LDM0LjFjMCwyLjMtMC41LDMuOS0xLjUsNWMtMSwxLjEtMi42LDEuNi00LjcsMS42Yy0wLjcsMC0xLjQsMC0yLjEtMC4xYy0wLjctMC4xLTEuMy0wLjItMi0wLjR2LTIuM2gwLjFjMC40LDAuMSwwLjksMC4zLDEuNywwLjVzMS42LDAuMywyLjQsMC4zYzAuOCwwLDEuNC0wLjEsMS45LTAuM2MwLjUtMC4yLDAuOS0wLjQsMS4yLTAuOGMwLjMtMC4zLDAuNS0wLjcsMC42LTEuMWMwLjEtMC40LDAuMi0wLjksMC4yLTEuNXYtMS4yYy0wLjcsMC41LTEuMywwLjktMS45LDEuMnMtMS40LDAuNC0yLjMsMC40Yy0xLjYsMC0yLjgtMC42LTMuOC0xLjdjLTAuOS0xLjEtMS40LTIuOC0xLjQtNC44YzAtMS4xLDAuMi0yLjEsMC41LTNjMC4zLTAuOCwwLjgtMS41LDEuMy0yLjFjMC41LTAuNiwxLjEtMSwxLjktMS4zYzAuNy0wLjMsMS41LTAuNSwyLjItMC41YzAuOCwwLDEuNCwwLjEsMS45LDAuMnMxLjEsMC40LDEuNiwwLjdsMC4xLTAuNmgyLjFWMzQuMXogTTEyNy4yLDMydi03LjJjLTAuNi0wLjMtMS4xLTAuNS0xLjctMC42Yy0wLjUtMC4xLTEtMC4yLTEuNS0wLjJjLTEuMiwwLTIuMiwwLjQtMi45LDEuMnMtMS4xLDItMS4xLDMuNmMwLDEuNSwwLjMsMi42LDAuOCwzLjRjMC41LDAuOCwxLjQsMS4yLDIuNiwxLjJjMC43LDAsMS4zLTAuMSwyLTAuNFMxMjYuNiwzMi40LDEyNy4yLDMyeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDIuMiwyNC44aC0wLjFjLTAuMy0wLjEtMC43LTAuMS0xLTAuMmMtMC4zLDAtMC43LTAuMS0xLjEtMC4xYy0wLjcsMC0xLjQsMC4yLTIsMC41Yy0wLjYsMC4zLTEuMywwLjctMS45LDEuMnY5LjRIMTM0VjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1NC44LDM1LjZoLTIuMnYtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yYy0wLjgtMC44LTEuMi0xLjgtMS4yLTNjMC0xLDAuMi0xLjgsMC42LTIuNGMwLjQtMC42LDEtMS4xLDEuOC0xLjVjMC44LTAuNCwxLjgtMC42LDIuOS0wLjdzMi40LTAuMiwzLjctMC4zdi0wLjNjMC0wLjUtMC4xLTAuOS0wLjMtMS4zYy0wLjItMC4zLTAuNC0wLjYtMC44LTAuOGMtMC4zLTAuMi0wLjctMC4zLTEuMS0wLjRDMTUwLDI0LDE0OS41LDI0LDE0OSwyNGMtMC42LDAtMS4yLDAuMS0yLDAuMmMtMC43LDAuMi0xLjUsMC40LTIuMiwwLjdoLTAuMXYtMi4zYzAuNC0wLjEsMS4xLTAuMiwxLjktMC40YzAuOC0wLjEsMS42LTAuMiwyLjQtMC4yYzAuOSwwLDEuOCwwLjEsMi40LDAuMmMwLjcsMC4yLDEuMywwLjQsMS44LDAuOGMwLjUsMC40LDAuOSwwLjgsMS4xLDEuNGMwLjMsMC42LDAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTUyLjYsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNTEuNCwzMy4xLDE1MiwzMi44LDE1Mi42LDMyLjN6IE0xNDguNCwyMC4xSDE0NnYtMi4zaDIuNFYyMC4xeiBNMTUzLjMsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3MC4zLDM1LjZoLTIuMnYtNy42YzAtMC42LDAtMS4yLTAuMS0xLjdzLTAuMi0xLTAuNC0xLjNjLTAuMi0wLjMtMC41LTAuNi0wLjktMC43Yy0wLjQtMC4yLTAuOS0wLjItMS41LTAuMmMtMC42LDAtMS4yLDAuMi0xLjksMC41Yy0wLjcsMC4zLTEuMywwLjctMS45LDEuMnY5LjloLTIuMlYyMi4zaDIuMnYxLjVjMC43LTAuNiwxLjQtMSwyLjItMS40YzAuNy0wLjMsMS41LTAuNSwyLjMtMC41YzEuNCwwLDIuNSwwLjQsMy4zLDEuM2MwLjgsMC45LDEuMSwyLjEsMS4xLDMuN1YzNS42eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xODQuMywzMS44YzAsMS4yLTAuNSwyLjItMS41LDNjLTEsMC44LTIuNCwxLjItNC4xLDEuMmMtMSwwLTEuOS0wLjEtMi43LTAuNGMtMC44LTAuMi0xLjUtMC41LTIuMS0wLjh2LTIuNWgwLjFjMC43LDAuNSwxLjUsMSwyLjQsMS4zczEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zYzAuNSwwLjEsMC45LDAuMiwxLjMsMC4zYzEsMC4yLDEuOCwwLjYsMi40LDEuMkMxODQsMzAsMTg0LjMsMzAuOCwxODQuMywzMS44eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xOTguNywyOS4yaC05LjhjMCwwLjgsMC4xLDEuNSwwLjQsMi4xczAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOHMtMS42LDAuMy0yLjUsMC4zYy0yLjIsMC0zLjktMC42LTUuMi0xLjhjLTEuMi0xLjItMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZzMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xOTYuNSwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN3MtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTk2LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTIxMC41LDI0LjhoLTAuMWMtMC4zLTAuMS0wLjctMC4xLTEtMC4yYy0wLjMsMC0wLjctMC4xLTEuMS0wLjFjLTAuNywwLTEuNCwwLjItMiwwLjVjLTAuNiwwLjMtMS4zLDAuNy0xLjksMS4ydjkuNGgtMi4yVjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PC9nPjwvZz48Zz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzIuNSw0Ny4zYy0xMS4yLDAtMjAuMy05LjEtMjAuMy0yMC4zUzIxLjMsNi43LDMyLjUsNi43YzExLjIsMCwyMC4zLDkuMSwyMC4zLDIwLjNTNDMuNyw0Ny4zLDMyLjUsNDcuM3oiLz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNMzIuNSw3LjdjMTAuNywwLDE5LjMsOC43LDE5LjMsMTkuM2MwLDEwLjctOC43LDE5LjMtMTkuMywxOS4zYy0xMC43LDAtMTkuMy04LjctMTkuMy0xOS4zQzEzLjIsMTYuMywyMS44LDcuNywzMi41LDcuNyBNMzIuNSw1LjdjLTExLjcsMC0yMS4zLDkuNS0yMS4zLDIxLjNjMCwxMS43LDkuNSwyMS4zLDIxLjMsMjEuM2MxMS43LDAsMjEuMy05LjUsMjEuMy0yMS4zQzUzLjcsMTUuMiw0NC4yLDUuNywzMi41LDUuN0wzMi41LDUuN3oiLz48L2c+PGxpbmUgY2xhc3M9InN0MyIgeDE9IjI2LjciIHkxPSIxNC4zIiB4Mj0iMzQuNCIgeTI9IjI2LjUiLz48bGluZSBjbGFzcz0ic3QzIiB4MT0iMjUuMyIgeTE9IjMzLjMiIHgyPSIzNC41IiB5Mj0iMjYuOSIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjQ4LjYiIGN5PSIzNi4yIiByPSIxMi45Ii8+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTQxLjMsMjkuOEg0NHY1LjRoMGw0LjItNS40aDMuNGwtNC44LDYuMWw1LDYuN2gtMy4zbC00LjUtNmgwdjZoLTIuN1YyOS44eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01NS4xLDM0LjJ2MS4yaDBjMC4yLTAuNCwwLjUtMC43LDAuOS0xYzAuMy0wLjIsMC42LTAuNCwwLjktMC40YzAuMiwwLDAuMywwLDAuNSwwdjIuN2MtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0wLjUsMC0wLjksMC4yLTEuMiwwLjVjLTAuMywwLjQtMC40LDAuOS0wLjQsMS41djMuN2gtMi41di04LjNINTUuMXoiLz48L2c+PGxpbmUgY2xhc3M9InN0NCIgeDE9IjE2IiB5MT0iMjciIHgyPSIxOC40IiB5Mj0iMjciLz48bGluZSBjbGFzcz0ic3Q0IiB4MT0iMzIuNyIgeTE9IjEyLjciIHgyPSIzMi43IiB5Mj0iMTAuMyIvPjxsaW5lIGNsYXNzPSJzdDQiIHgxPSIzMi41IiB5MT0iNDQuMiIgeDI9IjMyLjUiIHkyPSI0MS44Ii8+PC9zdmc+"/> </a><div id="InloggadPortrait" style="color:#fff; display:inline-block; float: right; font-size: 12px; padding-top: 4px;"></div></div><div id="RGSLandscape" style="margin-left: auto; margin-right: auto; width: 100%; display:none; white-space: nowrap;"> <a href="#" class="PausePlay" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelpaus" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTg0LjkgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTg0LjkgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6I0UyMEQxODt9PC9zdHlsZT48Zz48cmVjdCB4PSIwLjUiIHk9IjAuNSIgY2xhc3M9InN0MCIgd2lkdGg9IjE4My45IiBoZWlnaHQ9IjUyLjQiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTgzLjksMXY1MS40SDFWMUgxODMuOSBNMTg0LjksMEgwdjUzLjRoMTg0LjlWMEwxODQuOSwweiIvPjwvZz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTMuMywyNi44QzUzLjMsMzguNSw0My44LDQ4LDMyLDQ4Yy0xMS43LDAtMjEuMy05LjUtMjEuMy0yMS4zQzEwLjgsMTUsMjAuMyw1LjUsMzIsNS41QzQzLjgsNS41LDUzLjMsMTUsNTMuMywyNi44eiIvPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03Ny4xLDMwLjVjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuMywxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTNoMC4yYzAuOSwwLjcsMS45LDEuMywzLjEsMS43czIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNHMtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN2MtMC44LTAuOC0xLjEtMS45LTEuMS0zLjFjMC0xLjUsMC42LTIuNywxLjktMy42YzEuMy0wLjksMi44LTEuNCw0LjgtMS40YzEuMiwwLDIuNCwwLjEsMy40LDAuNGMxLDAuMiwyLDAuNSwyLjgsMC45djIuOGgtMC4yYy0wLjctMC42LTEuNi0xLTIuNy0xLjRjLTEuMS0wLjQtMi4yLTAuNi0zLjQtMC42Yy0xLjMsMC0yLjMsMC4zLTMsMC44Yy0wLjgsMC41LTEuMSwxLjItMS4xLDJjMCwwLjcsMC4yLDEuMywwLjYsMS43YzAuNCwwLjQsMS4xLDAuNywyLDFjMC41LDAuMSwxLjIsMC4yLDIuMiwwLjRjMC45LDAuMiwxLjcsMC4zLDIuNCwwLjVjMS4zLDAuMywyLjMsMC45LDMsMS42Qzc2LjcsMjguMiw3Ny4xLDI5LjIsNzcuMSwzMC41eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik05Mi42LDI4LjhjMCwxLjEtMC4yLDIuMS0wLjUsM2MtMC4zLDAuOS0wLjcsMS42LTEuMywyLjNjLTAuNSwwLjYtMS4xLDEtMS45LDEuNHMtMS41LDAuNS0yLjMsMC41Yy0wLjcsMC0xLjMtMC4xLTEuOS0wLjJjLTAuNi0wLjItMS4xLTAuNC0xLjctMC43djUuNmgtMi4yVjIyLjNoMi4ydjEuNGMwLjYtMC41LDEuMy0wLjksMi0xLjNjMC43LTAuMywxLjUtMC41LDIuNC0wLjVjMS42LDAsMi44LDAuNiwzLjcsMS44QzkyLjIsMjQuOSw5Mi42LDI2LjYsOTIuNiwyOC44eiBNOTAuMywyOC44YzAtMS42LTAuMy0yLjgtMC44LTMuNkM4OC45LDI0LjQsODguMSwyNCw4NywyNGMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M4OS45LDMxLjcsOTAuMywzMC41LDkwLjMsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTA3LjUsMjkuMWgtOS44YzAsMC44LDAuMSwxLjUsMC40LDIuMWMwLjIsMC42LDAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOGMtMC44LDAuMi0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOHMtMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZjMSwxLDEuNSwyLjUsMS41LDQuNVYyOS4xeiBNMTA1LjMsMjcuNGMwLTEuMi0wLjMtMi4xLTAuOS0yLjdjLTAuNi0wLjYtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTA1LjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTExMy4zLDM1LjZoLTIuMlYxN2gyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTI5LjcsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjksMS40cy0xLjUsMC41LTIuMywwLjVjLTAuNywwLTEuMy0wLjEtMS45LTAuMmMtMC42LTAuMi0xLjEtMC40LTEuNy0wLjd2NS42SDExOFYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEMxMjkuMywyNC45LDEyOS43LDI2LjYsMTI5LjcsMjguOHogTTEyNy40LDI4LjhjMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0MxMjcuMSwzMS43LDEyNy40LDMwLjUsMTI3LjQsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQzLjgsMzUuNmgtMi4ydi0xLjRjLTAuMiwwLjEtMC41LDAuMy0wLjgsMC42Yy0wLjMsMC4yLTAuNywwLjQtMSwwLjZjLTAuNCwwLjItMC44LDAuMy0xLjMsMC41Yy0wLjUsMC4xLTEuMSwwLjItMS43LDAuMmMtMS4yLDAtMi4yLTAuNC0zLTEuMnMtMS4yLTEuOC0xLjItM2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM2MtMC4yLTAuMy0wLjQtMC42LTAuOC0wLjhjLTAuMy0wLjItMC43LTAuMy0xLjEtMC40cy0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJzLTEuNSwwLjQtMi4yLDAuN2gtMC4xdi0yLjNjMC40LTAuMSwxLjEtMC4zLDEuOS0wLjRjMC44LTAuMSwxLjYtMC4yLDIuNC0wLjJjMC45LDAsMS44LDAuMSwyLjQsMC4yYzAuNywwLjIsMS4zLDAuNCwxLjgsMC44YzAuNSwwLjQsMC45LDAuOCwxLjEsMS40czAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTQxLjUsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNDAuNCwzMy4xLDE0MSwzMi43LDE0MS41LDMyLjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1OS4zLDM1LjZoLTIuMnYtMS41Yy0wLjgsMC42LTEuNSwxLjEtMi4yLDEuNHMtMS41LDAuNS0yLjMsMC41Yy0xLjQsMC0yLjUtMC40LTMuMy0xLjNzLTEuMi0yLjEtMS4yLTMuOHYtOC42aDIuMnY3LjZjMCwwLjcsMCwxLjMsMC4xLDEuN2MwLjEsMC41LDAuMiwwLjksMC40LDEuMmMwLjIsMC4zLDAuNSwwLjYsMC44LDAuOGMwLjMsMC4yLDAuOCwwLjIsMS41LDAuMmMwLjYsMCwxLjItMC4yLDEuOS0wLjVjMC43LTAuMywxLjMtMC43LDEuOS0xLjJ2LTkuOWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTczLjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM2MwLjksMC4zLDEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zczAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTczLjIsMzAsMTczLjUsMzAuOCwxNzMuNSwzMS43eiIvPjwvZz48L2c+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI4LjcsMzcuNWgtNi4yYy0wLjUsMC0wLjktMC40LTAuOS0wLjlWMTYuOWMwLTAuNSwwLjQtMC45LDAuOS0wLjloNi4yYzAuNSwwLDAuOSwwLjQsMC45LDAuOXYxOS43QzI5LjYsMzcuMSwyOS4yLDM3LjUsMjguNywzNy41eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MS41LDM3LjZoLTYuMmMtMC41LDAtMC45LTAuNC0wLjktMC45VjE2LjljMC0wLjUsMC40LTAuOSwwLjktMC45aDYuMmMwLjUsMCwwLjksMC40LDAuOSwwLjl2MTkuN0M0Mi40LDM3LjIsNDIsMzcuNiw0MS41LDM3LjZ6Ii8+PC9zdmc+"/> </a> <a href="#" class="SelfTest" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Sjlvtest" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTgwLjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTgwLjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6bm9uZTtzdHJva2U6dXJsKCNTVkdJRF8xXyk7c3Ryb2tlLXdpZHRoOjYuNzc0MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LnN0M3tmaWxsOiMxRTFFMUM7fTwvc3R5bGU+PGc+PHJlY3QgeD0iMC41IiB5PSIwLjUiIGNsYXNzPSJzdDAiIHdpZHRoPSIxNzkuNSIgaGVpZ2h0PSI1Mi40Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3OS41LDF2NTEuNEgxVjFIMTc5LjUgTTE4MC42LDBIMHY1My40aDE4MC42VjBMMTgwLjYsMHoiLz48L2c+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTMxLjksNDcuOGMtNS41LTAuMS0xMC43LTIuMy0xNC42LTYuMmMtMy45LTQtNi05LjItNS45LTE0LjhjMC4xLTExLjMsOS40LTIwLjYsMjAuOC0yMC42bDAuMiwwYzUuNSwwLjEsMTAuNywyLjMsMTQuNiw2LjJjMy45LDQsNiw5LjIsNS45LDE0LjhjLTAuMSwxMS4zLTkuNCwyMC42LTIwLjgsMjAuNkwzMS45LDQ3Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTMyLjEsNS43djFsMC4yLDBjNS40LDAuMSwxMC41LDIuMiwxNC4zLDYuMWMzLjgsMy45LDUuOCw5LDUuOCwxNC40Yy0wLjEsMTEuMS05LjIsMjAuMS0yMC4zLDIwLjFsLTAuMiwwYy01LjQtMC4xLTEwLjUtMi4yLTE0LjMtNi4xYy0zLjgtMy45LTUuOC05LTUuOC0xNC40YzAuMS0xMS4xLDkuMi0yMC4xLDIwLjMtMjAuMUwzMi4xLDUuNyBNMzIuMSw1LjdjLTExLjYsMC0yMS4xLDkuNC0yMS4zLDIxYy0wLjEsMTEuNyw5LjMsMjEuNCwyMSwyMS41YzAuMSwwLDAuMSwwLDAuMiwwYzExLjYsMCwyMS4xLTkuNCwyMS4zLTIxYzAuMS0xMS43LTkuMy0yMS40LTIxLTIxLjVDMzIuMyw1LjcsMzIuMiw1LjcsMzIuMSw1LjdMMzIuMSw1Ljd6Ii8+PC9nPjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMuMzkwNCIgeTE9Ii0zMDMuMjA3NyIgeDI9IjUwLjYwNDMiIHkyPSItMzAzLjIwNzciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIC0xIDY0LjAwMDUgLTI4My41MzY1KSI+PHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U0MTkxMyIvPjxzdG9wICBvZmZzZXQ9IjkuNzQ0MDIwZS0wMiIgc3R5bGU9InN0b3AtY29sb3I6I0VBNjUxNiIvPjxzdG9wICBvZmZzZXQ9IjAuMjE0OCIgc3R5bGU9InN0b3AtY29sb3I6I0YzQTUxOCIvPjxzdG9wICBvZmZzZXQ9IjAuMzEyMSIgc3R5bGU9InN0b3AtY29sb3I6I0Y5Q0QxQSIvPjxzdG9wICBvZmZzZXQ9IjAuMzg0IiBzdHlsZT0ic3RvcC1jb2xvcjojRkRFMzFBIi8+PHN0b3AgIG9mZnNldD0iMC40MjI4IiBzdHlsZT0ic3RvcC1jb2xvcjojRkVFQjFBIi8+PHN0b3AgIG9mZnNldD0iMC42MjMxIiBzdHlsZT0ic3RvcC1jb2xvcjojREZERTIwIi8+PHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzAwOTI0NSIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3LjIsMjYuN2MtMi4yLTE4LjYtMjcuOC0xOS0zMC40LDAiLz48Zz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNMjcuNywyNy4zbDguOC0xNS44bC0xLjgsMThjLTAuNiwxLjktMi43LDMtNC42LDIuNFMyNy4xLDI5LjIsMjcuNywyNy4zeiIvPjwvZz48Zz48Zz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzYuNSwzMC41YzAsMC43LTAuMiwxLjQtMC41LDJzLTAuOCwxLjItMS40LDEuN2MtMC42LDAuNS0xLjQsMC45LTIuMiwxLjJjLTAuOCwwLjMtMS45LDAuNC0zLjEsMC40Yy0xLjMsMC0yLjQtMC4xLTMuNC0wLjRjLTEtMC4yLTIuMS0wLjYtMy4xLTEuMXYtM0g2M2MwLjksMC43LDEuOSwxLjMsMy4xLDEuN2MxLjIsMC40LDIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNGMtMC43LTAuMS0xLjQtMC4yLTIuMi0wLjRjLTEuNi0wLjMtMi43LTAuOS0zLjUtMS43Yy0wLjgtMC44LTEuMS0xLjktMS4xLTMuMWMwLTEuNSwwLjYtMi43LDEuOS0zLjZjMS4zLTAuOSwyLjgtMS40LDQuOC0xLjRjMS4yLDAsMi40LDAuMSwzLjQsMC40YzEsMC4yLDIsMC41LDIuOCwwLjl2Mi44aC0wLjJjLTAuNy0wLjYtMS42LTEtMi43LTEuNGMtMS4xLTAuNC0yLjItMC42LTMuNC0wLjZjLTEuMywwLTIuMywwLjMtMywwLjhjLTAuOCwwLjUtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzYuMSwyOC4zLDc2LjUsMjkuMyw3Ni41LDMwLjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTg0LjMsMzUuOWMwLDEuNi0wLjQsMi43LTEuMiwzLjVzLTEuOSwxLjItMy4yLDEuMmMtMC4zLDAtMC43LDAtMS4zLTAuMWMtMC41LTAuMS0xLTAuMS0xLjMtMC4ydi0yLjFoMC4xYzAuMiwwLjEsMC41LDAuMiwwLjksMC4zYzAuNCwwLjEsMC43LDAuMiwxLjEsMC4yYzAuNiwwLDEtMC4xLDEuNC0wLjJjMC4zLTAuMiwwLjYtMC40LDAuOC0wLjdjMC4yLTAuMywwLjMtMC43LDAuMy0xLjFjMC4xLTAuNCwwLjEtMSwwLjEtMS42VjI0LjJoLTIuOHYtMS45aDVWMzUuOXogTTg0LjUsMjAuMWgtMi41di0yLjNoMi41VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTk5LjMsMzUuNkg5N3YtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yQzg4LjQsMzQsODgsMzMsODgsMzEuN2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM3MtMC40LTAuNi0wLjgtMC44Yy0wLjMtMC4yLTAuNy0wLjMtMS4xLTAuNGMtMC40LTAuMS0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJjLTAuNywwLjItMS41LDAuNC0yLjIsMC43aC0wLjF2LTIuM2MwLjQtMC4xLDEuMS0wLjMsMS45LTAuNGMwLjgtMC4xLDEuNi0wLjIsMi40LTAuMmMwLjksMCwxLjgsMC4xLDIuNCwwLjJjMC43LDAuMiwxLjMsMC40LDEuOCwwLjhjMC41LDAuNCwwLjksMC44LDEuMSwxLjRzMC40LDEuMywwLjQsMi4yVjM1LjZ6IE05NywzMi4zdi0zLjdjLTAuNywwLTEuNSwwLjEtMi40LDAuMlM5MywyOSw5Mi40LDI5LjFjLTAuNiwwLjItMS4yLDAuNS0xLjYsMC45Yy0wLjQsMC40LTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdjMC41LDAuNCwxLjIsMC42LDIuMSwwLjZjMC44LDAsMS41LTAuMiwyLjItMC41Qzk1LjksMzMuMSw5Ni41LDMyLjcsOTcsMzIuM3ogTTkyLjgsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6IE05Ny44LDIwLjFoLTIuNHYtMi4zaDIuNFYyMC4xeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMDYuMSwzNS42aC0yLjJWMTcuMWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTIyLjIsMjIuM2wtNS40LDEzLjNoLTIuMmwtNS4zLTEzLjNoMi40bDQuMSwxMC42bDQuMS0xMC42SDEyMi4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMzIuMywzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE0Ni40LDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45YzAuNiwwLjIsMS4yLDAuMywxLjksMC4zYzAuOSwwLDEuOC0wLjIsMi43LTAuNWMwLjktMC40LDEuNi0wLjcsMi0xLjFoMC4xdjIuNGMtMC44LDAuMy0xLjUsMC42LTIuMywwLjhzLTEuNiwwLjMtMi41LDAuM2MtMi4yLDAtMy45LTAuNi01LjItMS44Yy0xLjItMS4yLTEuOS0yLjktMS45LTUuMWMwLTIuMiwwLjYtMy45LDEuOC01LjJjMS4yLTEuMywyLjctMS45LDQuNy0xLjljMS44LDAsMy4yLDAuNSw0LjEsMS42YzEsMSwxLjUsMi41LDEuNSw0LjVWMjkuMnogTTE0NC4yLDI3LjVjMC0xLjItMC4zLTIuMS0wLjktMi43cy0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxNDQuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTU5LjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM3MxLjcsMC41LDIuNSwwLjVjMSwwLDEuOC0wLjIsMi4zLTAuNWMwLjYtMC4zLDAuOC0wLjgsMC44LTEuNWMwLTAuNS0wLjItMC45LTAuNS0xLjJzLTAuOS0wLjUtMS43LTAuN2MtMC4zLTAuMS0wLjctMC4yLTEuMi0wLjNjLTAuNS0wLjEtMS0wLjItMS40LTAuM2MtMS4yLTAuMy0yLTAuOC0yLjUtMS40Yy0wLjUtMC42LTAuNy0xLjMtMC43LTIuMmMwLTAuNSwwLjEtMS4xLDAuMy0xLjVjMC4yLTAuNSwwLjYtMC45LDEtMS4zYzAuNC0wLjQsMS0wLjcsMS43LTAuOWMwLjctMC4yLDEuNS0wLjMsMi4zLTAuM2MwLjgsMCwxLjYsMC4xLDIuNCwwLjNjMC44LDAuMiwxLjUsMC40LDIsMC43djIuNGgtMC4xYy0wLjYtMC40LTEuMy0wLjgtMi4xLTEuMWMtMC44LTAuMy0xLjYtMC40LTIuNC0wLjRjLTAuOCwwLTEuNSwwLjItMi4xLDAuNWMtMC42LDAuMy0wLjgsMC44LTAuOCwxLjRjMCwwLjUsMC4yLDEsMC41LDEuMmMwLjMsMC4zLDAuOSwwLjUsMS42LDAuN2MwLjQsMC4xLDAuOSwwLjIsMS40LDAuM2MwLjUsMC4xLDAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTU5LjIsMzAsMTU5LjUsMzAuOCwxNTkuNSwzMS43eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNjkuOSwzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PC9nPjwvZz48L3N2Zz4="/> </a> <a href="#" class="PlayLimit" target="_blank" style="text-decoration: none;"> <img style="height:20px;" alt="Spelgrnser" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjE5LjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjE5LjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6IzAwOTczOTt9LnN0M3tmaWxsOiNGRkZGRkY7c3Ryb2tlOiMwMDk3Mzk7c3Ryb2tlLXdpZHRoOjMuODcxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO30uc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzAwOTczOTtzdHJva2Utd2lkdGg6MS45MzU1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO308L3N0eWxlPjxnPjxyZWN0IHg9IjAuNSIgeT0iMC41IiBjbGFzcz0ic3QwIiB3aWR0aD0iMjE4LjUiIGhlaWdodD0iNTIuNCIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yMTguNSwxdjUxLjRIMVYxSDIxOC41IE0yMTkuNiwwSDB2NTMuNGgyMTkuNlYwTDIxOS42LDB6Ii8+PC9nPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03OC4yLDMwLjZjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuNCwxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTIuOWgwLjJjMC45LDAuNywxLjksMS4zLDMuMSwxLjdjMS4yLDAuNCwyLjMsMC42LDMuMywwLjZjMS41LDAsMi42LTAuMywzLjQtMC44YzAuOC0wLjUsMS4yLTEuMywxLjItMi4yYzAtMC44LTAuMi0xLjQtMC42LTEuN3MtMS0wLjctMS44LTAuOWMtMC42LTAuMi0xLjItMC4zLTEuOS0wLjRjLTAuNy0wLjEtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN3MtMS4xLTEuOS0xLjEtMy4xYzAtMS41LDAuNi0yLjcsMS45LTMuNmMxLjMtMC45LDIuOC0xLjQsNC44LTEuNGMxLjIsMCwyLjQsMC4xLDMuNCwwLjRjMSwwLjIsMiwwLjUsMi44LDAuOXYyLjhoLTAuMmMtMC43LTAuNi0xLjYtMS0yLjctMS40Yy0xLjEtMC40LTIuMi0wLjYtMy40LTAuNmMtMS4zLDAtMi4zLDAuMy0zLDAuOHMtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzcuOSwyOC4zLDc4LjIsMjkuMyw3OC4yLDMwLjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTkzLjYsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjgsMS40Yy0wLjcsMC4zLTEuNSwwLjUtMi4zLDAuNWMtMC43LDAtMS4zLTAuMS0xLjktMC4yYy0wLjYtMC4yLTEuMS0wLjQtMS43LTAuN3Y1LjZoLTIuMlYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEM5My4yLDI1LDkzLjYsMjYuNyw5My42LDI4Ljh6IE05MS4zLDI4LjljMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M5MSwzMS44LDkxLjMsMzAuNSw5MS4zLDI4Ljl6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEwOC4zLDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45czEuMiwwLjMsMS45LDAuM2MwLjksMCwxLjgtMC4yLDIuNy0wLjVjMC45LTAuNCwxLjYtMC43LDItMS4xaDAuMXYyLjRjLTAuOCwwLjMtMS41LDAuNi0yLjMsMC44cy0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOGMtMS4yLTEuMi0xLjktMi45LTEuOS01LjFjMC0yLjIsMC42LTMuOSwxLjgtNS4yYzEuMi0xLjMsMi43LTEuOSw0LjctMS45YzEuOCwwLDMuMiwwLjUsNC4xLDEuNmMxLDEsMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xMDYuMiwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN2MtMC42LTAuNi0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxMDYuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTE0LjEsMzUuNmgtMi4yVjE3LjFoMi4yVjM1LjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEyOS40LDM0LjFjMCwyLjMtMC41LDMuOS0xLjUsNWMtMSwxLjEtMi42LDEuNi00LjcsMS42Yy0wLjcsMC0xLjQsMC0yLjEtMC4xYy0wLjctMC4xLTEuMy0wLjItMi0wLjR2LTIuM2gwLjFjMC40LDAuMSwwLjksMC4zLDEuNywwLjVzMS42LDAuMywyLjQsMC4zYzAuOCwwLDEuNC0wLjEsMS45LTAuM2MwLjUtMC4yLDAuOS0wLjQsMS4yLTAuOGMwLjMtMC4zLDAuNS0wLjcsMC42LTEuMWMwLjEtMC40LDAuMi0wLjksMC4yLTEuNXYtMS4yYy0wLjcsMC41LTEuMywwLjktMS45LDEuMnMtMS40LDAuNC0yLjMsMC40Yy0xLjYsMC0yLjgtMC42LTMuOC0xLjdjLTAuOS0xLjEtMS40LTIuOC0xLjQtNC44YzAtMS4xLDAuMi0yLjEsMC41LTNjMC4zLTAuOCwwLjgtMS41LDEuMy0yLjFjMC41LTAuNiwxLjEtMSwxLjktMS4zYzAuNy0wLjMsMS41LTAuNSwyLjItMC41YzAuOCwwLDEuNCwwLjEsMS45LDAuMnMxLjEsMC40LDEuNiwwLjdsMC4xLTAuNmgyLjFWMzQuMXogTTEyNy4yLDMydi03LjJjLTAuNi0wLjMtMS4xLTAuNS0xLjctMC42Yy0wLjUtMC4xLTEtMC4yLTEuNS0wLjJjLTEuMiwwLTIuMiwwLjQtMi45LDEuMnMtMS4xLDItMS4xLDMuNmMwLDEuNSwwLjMsMi42LDAuOCwzLjRjMC41LDAuOCwxLjQsMS4yLDIuNiwxLjJjMC43LDAsMS4zLTAuMSwyLTAuNFMxMjYuNiwzMi40LDEyNy4yLDMyeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDIuMiwyNC44aC0wLjFjLTAuMy0wLjEtMC43LTAuMS0xLTAuMmMtMC4zLDAtMC43LTAuMS0xLjEtMC4xYy0wLjcsMC0xLjQsMC4yLTIsMC41Yy0wLjYsMC4zLTEuMywwLjctMS45LDEuMnY5LjRIMTM0VjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1NC44LDM1LjZoLTIuMnYtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yYy0wLjgtMC44LTEuMi0xLjgtMS4yLTNjMC0xLDAuMi0xLjgsMC42LTIuNGMwLjQtMC42LDEtMS4xLDEuOC0xLjVjMC44LTAuNCwxLjgtMC42LDIuOS0wLjdzMi40LTAuMiwzLjctMC4zdi0wLjNjMC0wLjUtMC4xLTAuOS0wLjMtMS4zYy0wLjItMC4zLTAuNC0wLjYtMC44LTAuOGMtMC4zLTAuMi0wLjctMC4zLTEuMS0wLjRDMTUwLDI0LDE0OS41LDI0LDE0OSwyNGMtMC42LDAtMS4yLDAuMS0yLDAuMmMtMC43LDAuMi0xLjUsMC40LTIuMiwwLjdoLTAuMXYtMi4zYzAuNC0wLjEsMS4xLTAuMiwxLjktMC40YzAuOC0wLjEsMS42LTAuMiwyLjQtMC4yYzAuOSwwLDEuOCwwLjEsMi40LDAuMmMwLjcsMC4yLDEuMywwLjQsMS44LDAuOGMwLjUsMC40LDAuOSwwLjgsMS4xLDEuNGMwLjMsMC42LDAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTUyLjYsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNTEuNCwzMy4xLDE1MiwzMi44LDE1Mi42LDMyLjN6IE0xNDguNCwyMC4xSDE0NnYtMi4zaDIuNFYyMC4xeiBNMTUzLjMsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3MC4zLDM1LjZoLTIuMnYtNy42YzAtMC42LDAtMS4yLTAuMS0xLjdzLTAuMi0xLTAuNC0xLjNjLTAuMi0wLjMtMC41LTAuNi0wLjktMC43Yy0wLjQtMC4yLTAuOS0wLjItMS41LTAuMmMtMC42LDAtMS4yLDAuMi0xLjksMC41Yy0wLjcsMC4zLTEuMywwLjctMS45LDEuMnY5LjloLTIuMlYyMi4zaDIuMnYxLjVjMC43LTAuNiwxLjQtMSwyLjItMS40YzAuNy0wLjMsMS41LTAuNSwyLjMtMC41YzEuNCwwLDIuNSwwLjQsMy4zLDEuM2MwLjgsMC45LDEuMSwyLjEsMS4xLDMuN1YzNS42eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xODQuMywzMS44YzAsMS4yLTAuNSwyLjItMS41LDNjLTEsMC44LTIuNCwxLjItNC4xLDEuMmMtMSwwLTEuOS0wLjEtMi43LTAuNGMtMC44LTAuMi0xLjUtMC41LTIuMS0wLjh2LTIuNWgwLjFjMC43LDAuNSwxLjUsMSwyLjQsMS4zczEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zYzAuNSwwLjEsMC45LDAuMiwxLjMsMC4zYzEsMC4yLDEuOCwwLjYsMi40LDEuMkMxODQsMzAsMTg0LjMsMzAuOCwxODQuMywzMS44eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xOTguNywyOS4yaC05LjhjMCwwLjgsMC4xLDEuNSwwLjQsMi4xczAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOHMtMS42LDAuMy0yLjUsMC4zYy0yLjIsMC0zLjktMC42LTUuMi0xLjhjLTEuMi0xLjItMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZzMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xOTYuNSwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN3MtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTk2LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTIxMC41LDI0LjhoLTAuMWMtMC4zLTAuMS0wLjctMC4xLTEtMC4yYy0wLjMsMC0wLjctMC4xLTEuMS0wLjFjLTAuNywwLTEuNCwwLjItMiwwLjVjLTAuNiwwLjMtMS4zLDAuNy0xLjksMS4ydjkuNGgtMi4yVjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PC9nPjwvZz48Zz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzIuNSw0Ny4zYy0xMS4yLDAtMjAuMy05LjEtMjAuMy0yMC4zUzIxLjMsNi43LDMyLjUsNi43YzExLjIsMCwyMC4zLDkuMSwyMC4zLDIwLjNTNDMuNyw0Ny4zLDMyLjUsNDcuM3oiLz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNMzIuNSw3LjdjMTAuNywwLDE5LjMsOC43LDE5LjMsMTkuM2MwLDEwLjctOC43LDE5LjMtMTkuMywxOS4zYy0xMC43LDAtMTkuMy04LjctMTkuMy0xOS4zQzEzLjIsMTYuMywyMS44LDcuNywzMi41LDcuNyBNMzIuNSw1LjdjLTExLjcsMC0yMS4zLDkuNS0yMS4zLDIxLjNjMCwxMS43LDkuNSwyMS4zLDIxLjMsMjEuM2MxMS43LDAsMjEuMy05LjUsMjEuMy0yMS4zQzUzLjcsMTUuMiw0NC4yLDUuNywzMi41LDUuN0wzMi41LDUuN3oiLz48L2c+PGxpbmUgY2xhc3M9InN0MyIgeDE9IjI2LjciIHkxPSIxNC4zIiB4Mj0iMzQuNCIgeTI9IjI2LjUiLz48bGluZSBjbGFzcz0ic3QzIiB4MT0iMjUuMyIgeTE9IjMzLjMiIHgyPSIzNC41IiB5Mj0iMjYuOSIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjQ4LjYiIGN5PSIzNi4yIiByPSIxMi45Ii8+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTQxLjMsMjkuOEg0NHY1LjRoMGw0LjItNS40aDMuNGwtNC44LDYuMWw1LDYuN2gtMy4zbC00LjUtNmgwdjZoLTIuN1YyOS44eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01NS4xLDM0LjJ2MS4yaDBjMC4yLTAuNCwwLjUtMC43LDAuOS0xYzAuMy0wLjIsMC42LTAuNCwwLjktMC40YzAuMiwwLDAuMywwLDAuNSwwdjIuN2MtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0wLjUsMC0wLjksMC4yLTEuMiwwLjVjLTAuMywwLjQtMC40LDAuOS0wLjQsMS41djMuN2gtMi41di04LjNINTUuMXoiLz48L2c+PGxpbmUgY2xhc3M9InN0NCIgeDE9IjE2IiB5MT0iMjciIHgyPSIxOC40IiB5Mj0iMjciLz48bGluZSBjbGFzcz0ic3Q0IiB4MT0iMzIuNyIgeTE9IjEyLjciIHgyPSIzMi43IiB5Mj0iMTAuMyIvPjxsaW5lIGNsYXNzPSJzdDQiIHgxPSIzMi41IiB5MT0iNDQuMiIgeDI9IjMyLjUiIHkyPSI0MS44Ii8+PC9zdmc+"/> </a><div id="InloggadLandscape" style="color:#fff; display:inline-block; float: right; font-size: 13px; padding-top: 4px;"></div></div></div>';
    else
        htmlString = '<div class="RGSContainerActive" style="display: block;" data-height="29"><div id="RGSDesktop" style="margin-left: auto; margin-right: auto; width: 100%; display:block; white-space: nowrap;"> <a href="#" class="PausePlay" target="_blank" style="text-decoration: none;"> <img style="height:25px;" alt="Spelpaus" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTg0LjkgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTg0LjkgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6I0UyMEQxODt9PC9zdHlsZT48Zz48cmVjdCB4PSIwLjUiIHk9IjAuNSIgY2xhc3M9InN0MCIgd2lkdGg9IjE4My45IiBoZWlnaHQ9IjUyLjQiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTgzLjksMXY1MS40SDFWMUgxODMuOSBNMTg0LjksMEgwdjUzLjRoMTg0LjlWMEwxODQuOSwweiIvPjwvZz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNNTMuMywyNi44QzUzLjMsMzguNSw0My44LDQ4LDMyLDQ4Yy0xMS43LDAtMjEuMy05LjUtMjEuMy0yMS4zQzEwLjgsMTUsMjAuMyw1LjUsMzIsNS41QzQzLjgsNS41LDUzLjMsMTUsNTMuMywyNi44eiIvPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03Ny4xLDMwLjVjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuMywxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTNoMC4yYzAuOSwwLjcsMS45LDEuMywzLjEsMS43czIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNHMtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN2MtMC44LTAuOC0xLjEtMS45LTEuMS0zLjFjMC0xLjUsMC42LTIuNywxLjktMy42YzEuMy0wLjksMi44LTEuNCw0LjgtMS40YzEuMiwwLDIuNCwwLjEsMy40LDAuNGMxLDAuMiwyLDAuNSwyLjgsMC45djIuOGgtMC4yYy0wLjctMC42LTEuNi0xLTIuNy0xLjRjLTEuMS0wLjQtMi4yLTAuNi0zLjQtMC42Yy0xLjMsMC0yLjMsMC4zLTMsMC44Yy0wLjgsMC41LTEuMSwxLjItMS4xLDJjMCwwLjcsMC4yLDEuMywwLjYsMS43YzAuNCwwLjQsMS4xLDAuNywyLDFjMC41LDAuMSwxLjIsMC4yLDIuMiwwLjRjMC45LDAuMiwxLjcsMC4zLDIuNCwwLjVjMS4zLDAuMywyLjMsMC45LDMsMS42Qzc2LjcsMjguMiw3Ny4xLDI5LjIsNzcuMSwzMC41eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik05Mi42LDI4LjhjMCwxLjEtMC4yLDIuMS0wLjUsM2MtMC4zLDAuOS0wLjcsMS42LTEuMywyLjNjLTAuNSwwLjYtMS4xLDEtMS45LDEuNHMtMS41LDAuNS0yLjMsMC41Yy0wLjcsMC0xLjMtMC4xLTEuOS0wLjJjLTAuNi0wLjItMS4xLTAuNC0xLjctMC43djUuNmgtMi4yVjIyLjNoMi4ydjEuNGMwLjYtMC41LDEuMy0wLjksMi0xLjNjMC43LTAuMywxLjUtMC41LDIuNC0wLjVjMS42LDAsMi44LDAuNiwzLjcsMS44QzkyLjIsMjQuOSw5Mi42LDI2LjYsOTIuNiwyOC44eiBNOTAuMywyOC44YzAtMS42LTAuMy0yLjgtMC44LTMuNkM4OC45LDI0LjQsODguMSwyNCw4NywyNGMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M4OS45LDMxLjcsOTAuMywzMC41LDkwLjMsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTA3LjUsMjkuMWgtOS44YzAsMC44LDAuMSwxLjUsMC40LDIuMWMwLjIsMC42LDAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOGMtMC44LDAuMi0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOHMtMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZjMSwxLDEuNSwyLjUsMS41LDQuNVYyOS4xeiBNMTA1LjMsMjcuNGMwLTEuMi0wLjMtMi4xLTAuOS0yLjdjLTAuNi0wLjYtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTA1LjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTExMy4zLDM1LjZoLTIuMlYxN2gyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTI5LjcsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjksMS40cy0xLjUsMC41LTIuMywwLjVjLTAuNywwLTEuMy0wLjEtMS45LTAuMmMtMC42LTAuMi0xLjEtMC40LTEuNy0wLjd2NS42SDExOFYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEMxMjkuMywyNC45LDEyOS43LDI2LjYsMTI5LjcsMjguOHogTTEyNy40LDI4LjhjMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0MxMjcuMSwzMS43LDEyNy40LDMwLjUsMTI3LjQsMjguOHoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTQzLjgsMzUuNmgtMi4ydi0xLjRjLTAuMiwwLjEtMC41LDAuMy0wLjgsMC42Yy0wLjMsMC4yLTAuNywwLjQtMSwwLjZjLTAuNCwwLjItMC44LDAuMy0xLjMsMC41Yy0wLjUsMC4xLTEuMSwwLjItMS43LDAuMmMtMS4yLDAtMi4yLTAuNC0zLTEuMnMtMS4yLTEuOC0xLjItM2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM2MtMC4yLTAuMy0wLjQtMC42LTAuOC0wLjhjLTAuMy0wLjItMC43LTAuMy0xLjEtMC40cy0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJzLTEuNSwwLjQtMi4yLDAuN2gtMC4xdi0yLjNjMC40LTAuMSwxLjEtMC4zLDEuOS0wLjRjMC44LTAuMSwxLjYtMC4yLDIuNC0wLjJjMC45LDAsMS44LDAuMSwyLjQsMC4yYzAuNywwLjIsMS4zLDAuNCwxLjgsMC44YzAuNSwwLjQsMC45LDAuOCwxLjEsMS40czAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTQxLjUsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNDAuNCwzMy4xLDE0MSwzMi43LDE0MS41LDMyLjN6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1OS4zLDM1LjZoLTIuMnYtMS41Yy0wLjgsMC42LTEuNSwxLjEtMi4yLDEuNHMtMS41LDAuNS0yLjMsMC41Yy0xLjQsMC0yLjUtMC40LTMuMy0xLjNzLTEuMi0yLjEtMS4yLTMuOHYtOC42aDIuMnY3LjZjMCwwLjcsMCwxLjMsMC4xLDEuN2MwLjEsMC41LDAuMiwwLjksMC40LDEuMmMwLjIsMC4zLDAuNSwwLjYsMC44LDAuOGMwLjMsMC4yLDAuOCwwLjIsMS41LDAuMmMwLjYsMCwxLjItMC4yLDEuOS0wLjVjMC43LTAuMywxLjMtMC43LDEuOS0xLjJ2LTkuOWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTczLjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM2MwLjksMC4zLDEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zczAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTczLjIsMzAsMTczLjUsMzAuOCwxNzMuNSwzMS43eiIvPjwvZz48L2c+PHBhdGggY2xhc3M9InN0MCIgZD0iTTI4LjcsMzcuNWgtNi4yYy0wLjUsMC0wLjktMC40LTAuOS0wLjlWMTYuOWMwLTAuNSwwLjQtMC45LDAuOS0wLjloNi4yYzAuNSwwLDAuOSwwLjQsMC45LDAuOXYxOS43QzI5LjYsMzcuMSwyOS4yLDM3LjUsMjguNywzNy41eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MS41LDM3LjZoLTYuMmMtMC41LDAtMC45LTAuNC0wLjktMC45VjE2LjljMC0wLjUsMC40LTAuOSwwLjktMC45aDYuMmMwLjUsMCwwLjksMC40LDAuOSwwLjl2MTkuN0M0Mi40LDM3LjIsNDIsMzcuNiw0MS41LDM3LjZ6Ii8+PC9zdmc+"/> </a> <a href="#" class="SelfTest" target="_blank" style="text-decoration: none;"> <img style="height:25px;" alt="Sjlvtest" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMTgwLjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTgwLjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6bm9uZTtzdHJva2U6dXJsKCNTVkdJRF8xXyk7c3Ryb2tlLXdpZHRoOjYuNzc0MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9LnN0M3tmaWxsOiMxRTFFMUM7fTwvc3R5bGU+PGc+PHJlY3QgeD0iMC41IiB5PSIwLjUiIGNsYXNzPSJzdDAiIHdpZHRoPSIxNzkuNSIgaGVpZ2h0PSI1Mi40Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3OS41LDF2NTEuNEgxVjFIMTc5LjUgTTE4MC42LDBIMHY1My40aDE4MC42VjBMMTgwLjYsMHoiLz48L2c+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTMxLjksNDcuOGMtNS41LTAuMS0xMC43LTIuMy0xNC42LTYuMmMtMy45LTQtNi05LjItNS45LTE0LjhjMC4xLTExLjMsOS40LTIwLjYsMjAuOC0yMC42bDAuMiwwYzUuNSwwLjEsMTAuNywyLjMsMTQuNiw2LjJjMy45LDQsNiw5LjIsNS45LDE0LjhjLTAuMSwxMS4zLTkuNCwyMC42LTIwLjgsMjAuNkwzMS45LDQ3Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTMyLjEsNS43djFsMC4yLDBjNS40LDAuMSwxMC41LDIuMiwxNC4zLDYuMWMzLjgsMy45LDUuOCw5LDUuOCwxNC40Yy0wLjEsMTEuMS05LjIsMjAuMS0yMC4zLDIwLjFsLTAuMiwwYy01LjQtMC4xLTEwLjUtMi4yLTE0LjMtNi4xYy0zLjgtMy45LTUuOC05LTUuOC0xNC40YzAuMS0xMS4xLDkuMi0yMC4xLDIwLjMtMjAuMUwzMi4xLDUuNyBNMzIuMSw1LjdjLTExLjYsMC0yMS4xLDkuNC0yMS4zLDIxYy0wLjEsMTEuNyw5LjMsMjEuNCwyMSwyMS41YzAuMSwwLDAuMSwwLDAuMiwwYzExLjYsMCwyMS4xLTkuNCwyMS4zLTIxYzAuMS0xMS43LTkuMy0yMS40LTIxLTIxLjVDMzIuMyw1LjcsMzIuMiw1LjcsMzIuMSw1LjdMMzIuMSw1Ljd6Ii8+PC9nPjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTMuMzkwNCIgeTE9Ii0zMDMuMjA3NyIgeDI9IjUwLjYwNDMiIHkyPSItMzAzLjIwNzciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEgMCAwIC0xIDY0LjAwMDUgLTI4My41MzY1KSI+PHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U0MTkxMyIvPjxzdG9wICBvZmZzZXQ9IjkuNzQ0MDIwZS0wMiIgc3R5bGU9InN0b3AtY29sb3I6I0VBNjUxNiIvPjxzdG9wICBvZmZzZXQ9IjAuMjE0OCIgc3R5bGU9InN0b3AtY29sb3I6I0YzQTUxOCIvPjxzdG9wICBvZmZzZXQ9IjAuMzEyMSIgc3R5bGU9InN0b3AtY29sb3I6I0Y5Q0QxQSIvPjxzdG9wICBvZmZzZXQ9IjAuMzg0IiBzdHlsZT0ic3RvcC1jb2xvcjojRkRFMzFBIi8+PHN0b3AgIG9mZnNldD0iMC40MjI4IiBzdHlsZT0ic3RvcC1jb2xvcjojRkVFQjFBIi8+PHN0b3AgIG9mZnNldD0iMC42MjMxIiBzdHlsZT0ic3RvcC1jb2xvcjojREZERTIwIi8+PHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzAwOTI0NSIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQ3LjIsMjYuN2MtMi4yLTE4LjYtMjcuOC0xOS0zMC40LDAiLz48Zz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNMjcuNywyNy4zbDguOC0xNS44bC0xLjgsMThjLTAuNiwxLjktMi43LDMtNC42LDIuNFMyNy4xLDI5LjIsMjcuNywyNy4zeiIvPjwvZz48Zz48Zz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzYuNSwzMC41YzAsMC43LTAuMiwxLjQtMC41LDJzLTAuOCwxLjItMS40LDEuN2MtMC42LDAuNS0xLjQsMC45LTIuMiwxLjJjLTAuOCwwLjMtMS45LDAuNC0zLjEsMC40Yy0xLjMsMC0yLjQtMC4xLTMuNC0wLjRjLTEtMC4yLTIuMS0wLjYtMy4xLTEuMXYtM0g2M2MwLjksMC43LDEuOSwxLjMsMy4xLDEuN2MxLjIsMC40LDIuMywwLjYsMy4zLDAuNmMxLjUsMCwyLjYtMC4zLDMuNC0wLjhjMC44LTAuNSwxLjItMS4zLDEuMi0yLjJjMC0wLjgtMC4yLTEuNC0wLjYtMS43cy0xLTAuNy0xLjgtMC45Yy0wLjYtMC4yLTEuMi0wLjMtMS45LTAuNGMtMC43LTAuMS0xLjQtMC4yLTIuMi0wLjRjLTEuNi0wLjMtMi43LTAuOS0zLjUtMS43Yy0wLjgtMC44LTEuMS0xLjktMS4xLTMuMWMwLTEuNSwwLjYtMi43LDEuOS0zLjZjMS4zLTAuOSwyLjgtMS40LDQuOC0xLjRjMS4yLDAsMi40LDAuMSwzLjQsMC40YzEsMC4yLDIsMC41LDIuOCwwLjl2Mi44aC0wLjJjLTAuNy0wLjYtMS42LTEtMi43LTEuNGMtMS4xLTAuNC0yLjItMC42LTMuNC0wLjZjLTEuMywwLTIuMywwLjMtMywwLjhjLTAuOCwwLjUtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzYuMSwyOC4zLDc2LjUsMjkuMyw3Ni41LDMwLjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTg0LjMsMzUuOWMwLDEuNi0wLjQsMi43LTEuMiwzLjVzLTEuOSwxLjItMy4yLDEuMmMtMC4zLDAtMC43LDAtMS4zLTAuMWMtMC41LTAuMS0xLTAuMS0xLjMtMC4ydi0yLjFoMC4xYzAuMiwwLjEsMC41LDAuMiwwLjksMC4zYzAuNCwwLjEsMC43LDAuMiwxLjEsMC4yYzAuNiwwLDEtMC4xLDEuNC0wLjJjMC4zLTAuMiwwLjYtMC40LDAuOC0wLjdjMC4yLTAuMywwLjMtMC43LDAuMy0xLjFjMC4xLTAuNCwwLjEtMSwwLjEtMS42VjI0LjJoLTIuOHYtMS45aDVWMzUuOXogTTg0LjUsMjAuMWgtMi41di0yLjNoMi41VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTk5LjMsMzUuNkg5N3YtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yQzg4LjQsMzQsODgsMzMsODgsMzEuN2MwLTEsMC4yLTEuOCwwLjYtMi40YzAuNC0wLjYsMS0xLjEsMS44LTEuNWMwLjgtMC40LDEuOC0wLjYsMi45LTAuN2MxLjEtMC4xLDIuNC0wLjIsMy43LTAuM3YtMC4zYzAtMC41LTAuMS0wLjktMC4zLTEuM3MtMC40LTAuNi0wLjgtMC44Yy0wLjMtMC4yLTAuNy0wLjMtMS4xLTAuNGMtMC40LTAuMS0wLjktMC4xLTEuNC0wLjFjLTAuNiwwLTEuMiwwLjEtMiwwLjJjLTAuNywwLjItMS41LDAuNC0yLjIsMC43aC0wLjF2LTIuM2MwLjQtMC4xLDEuMS0wLjMsMS45LTAuNGMwLjgtMC4xLDEuNi0wLjIsMi40LTAuMmMwLjksMCwxLjgsMC4xLDIuNCwwLjJjMC43LDAuMiwxLjMsMC40LDEuOCwwLjhjMC41LDAuNCwwLjksMC44LDEuMSwxLjRzMC40LDEuMywwLjQsMi4yVjM1LjZ6IE05NywzMi4zdi0zLjdjLTAuNywwLTEuNSwwLjEtMi40LDAuMlM5MywyOSw5Mi40LDI5LjFjLTAuNiwwLjItMS4yLDAuNS0xLjYsMC45Yy0wLjQsMC40LTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdjMC41LDAuNCwxLjIsMC42LDIuMSwwLjZjMC44LDAsMS41LTAuMiwyLjItMC41Qzk1LjksMzMuMSw5Ni41LDMyLjcsOTcsMzIuM3ogTTkyLjgsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6IE05Ny44LDIwLjFoLTIuNHYtMi4zaDIuNFYyMC4xeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMDYuMSwzNS42aC0yLjJWMTcuMWgyLjJWMzUuNnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTIyLjIsMjIuM2wtNS40LDEzLjNoLTIuMmwtNS4zLTEzLjNoMi40bDQuMSwxMC42bDQuMS0xMC42SDEyMi4yeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xMzIuMywzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE0Ni40LDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45YzAuNiwwLjIsMS4yLDAuMywxLjksMC4zYzAuOSwwLDEuOC0wLjIsMi43LTAuNWMwLjktMC40LDEuNi0wLjcsMi0xLjFoMC4xdjIuNGMtMC44LDAuMy0xLjUsMC42LTIuMywwLjhzLTEuNiwwLjMtMi41LDAuM2MtMi4yLDAtMy45LTAuNi01LjItMS44Yy0xLjItMS4yLTEuOS0yLjktMS45LTUuMWMwLTIuMiwwLjYtMy45LDEuOC01LjJjMS4yLTEuMywyLjctMS45LDQuNy0xLjljMS44LDAsMy4yLDAuNSw0LjEsMS42YzEsMSwxLjUsMi41LDEuNSw0LjVWMjkuMnogTTE0NC4yLDI3LjVjMC0xLjItMC4zLTIuMS0wLjktMi43cy0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxNDQuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTU5LjUsMzEuN2MwLDEuMi0wLjUsMi4yLTEuNSwzcy0yLjQsMS4yLTQuMSwxLjJjLTEsMC0xLjktMC4xLTIuNy0wLjRjLTAuOC0wLjItMS41LTAuNS0yLjEtMC44di0yLjVoMC4xYzAuNywwLjUsMS41LDEsMi40LDEuM3MxLjcsMC41LDIuNSwwLjVjMSwwLDEuOC0wLjIsMi4zLTAuNWMwLjYtMC4zLDAuOC0wLjgsMC44LTEuNWMwLTAuNS0wLjItMC45LTAuNS0xLjJzLTAuOS0wLjUtMS43LTAuN2MtMC4zLTAuMS0wLjctMC4yLTEuMi0wLjNjLTAuNS0wLjEtMS0wLjItMS40LTAuM2MtMS4yLTAuMy0yLTAuOC0yLjUtMS40Yy0wLjUtMC42LTAuNy0xLjMtMC43LTIuMmMwLTAuNSwwLjEtMS4xLDAuMy0xLjVjMC4yLTAuNSwwLjYtMC45LDEtMS4zYzAuNC0wLjQsMS0wLjcsMS43LTAuOWMwLjctMC4yLDEuNS0wLjMsMi4zLTAuM2MwLjgsMCwxLjYsMC4xLDIuNCwwLjNjMC44LDAuMiwxLjUsMC40LDIsMC43djIuNGgtMC4xYy0wLjYtMC40LTEuMy0wLjgtMi4xLTEuMWMtMC44LTAuMy0xLjYtMC40LTIuNC0wLjRjLTAuOCwwLTEuNSwwLjItMi4xLDAuNWMtMC42LDAuMy0wLjgsMC44LTAuOCwxLjRjMCwwLjUsMC4yLDEsMC41LDEuMmMwLjMsMC4zLDAuOSwwLjUsMS42LDAuN2MwLjQsMC4xLDAuOSwwLjIsMS40LDAuM2MwLjUsMC4xLDAuOSwwLjIsMS4zLDAuM2MxLDAuMiwxLjgsMC42LDIuNCwxLjJDMTU5LjIsMzAsMTU5LjUsMzAuOCwxNTkuNSwzMS43eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNjkuOSwzNS41Yy0wLjQsMC4xLTAuOSwwLjItMS40LDAuM2MtMC41LDAuMS0wLjksMC4xLTEuMywwLjFjLTEuNCwwLTIuNC0wLjQtMy4xLTEuMWMtMC43LTAuNy0xLjEtMS45LTEuMS0zLjV2LTcuMWgtMS41di0xLjloMS41di0zLjhoMi4ydjMuOGg0LjZ2MS45aC00LjZ2Ni4xYzAsMC43LDAsMS4yLDAsMS42YzAsMC40LDAuMSwwLjgsMC4zLDEuMWMwLjIsMC4zLDAuNCwwLjUsMC43LDAuN2MwLjMsMC4xLDAuOCwwLjIsMS40LDAuMmMwLjQsMCwwLjctMC4xLDEuMS0wLjJjMC40LTAuMSwwLjctMC4yLDAuOS0wLjNoMC4xVjM1LjV6Ii8+PC9nPjwvZz48L3N2Zz4="/> </a> <a href="#" class="PlayLimit" target="_blank" style="text-decoration: none;"> <img style="height:25px;" alt="Spelgrnser" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxhZ2VyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjE5LjYgNTMuNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjE5LjYgNTMuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+LnN0MHtmaWxsOiNGRkZGRkY7fS5zdDF7ZmlsbDojMDIwMjAzO30uc3Qye2ZpbGw6IzAwOTczOTt9LnN0M3tmaWxsOiNGRkZGRkY7c3Ryb2tlOiMwMDk3Mzk7c3Ryb2tlLXdpZHRoOjMuODcxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO30uc3Q0e2ZpbGw6bm9uZTtzdHJva2U6IzAwOTczOTtzdHJva2Utd2lkdGg6MS45MzU1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjEwO308L3N0eWxlPjxnPjxyZWN0IHg9IjAuNSIgeT0iMC41IiBjbGFzcz0ic3QwIiB3aWR0aD0iMjE4LjUiIGhlaWdodD0iNTIuNCIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0yMTguNSwxdjUxLjRIMVYxSDIxOC41IE0yMTkuNiwwSDB2NTMuNGgyMTkuNlYwTDIxOS42LDB6Ii8+PC9nPjxnPjxnPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik03OC4yLDMwLjZjMCwwLjctMC4yLDEuNC0wLjUsMmMtMC4zLDAuNy0wLjgsMS4yLTEuNCwxLjdjLTAuNiwwLjUtMS40LDAuOS0yLjIsMS4yYy0wLjgsMC4zLTEuOSwwLjQtMy4xLDAuNGMtMS4zLDAtMi40LTAuMS0zLjQtMC40Yy0xLTAuMi0yLjEtMC42LTMuMS0xLjF2LTIuOWgwLjJjMC45LDAuNywxLjksMS4zLDMuMSwxLjdjMS4yLDAuNCwyLjMsMC42LDMuMywwLjZjMS41LDAsMi42LTAuMywzLjQtMC44YzAuOC0wLjUsMS4yLTEuMywxLjItMi4yYzAtMC44LTAuMi0xLjQtMC42LTEuN3MtMS0wLjctMS44LTAuOWMtMC42LTAuMi0xLjItMC4zLTEuOS0wLjRjLTAuNy0wLjEtMS40LTAuMi0yLjItMC40Yy0xLjYtMC4zLTIuNy0wLjktMy41LTEuN3MtMS4xLTEuOS0xLjEtMy4xYzAtMS41LDAuNi0yLjcsMS45LTMuNmMxLjMtMC45LDIuOC0xLjQsNC44LTEuNGMxLjIsMCwyLjQsMC4xLDMuNCwwLjRjMSwwLjIsMiwwLjUsMi44LDAuOXYyLjhoLTAuMmMtMC43LTAuNi0xLjYtMS0yLjctMS40Yy0xLjEtMC40LTIuMi0wLjYtMy40LTAuNmMtMS4zLDAtMi4zLDAuMy0zLDAuOHMtMS4xLDEuMi0xLjEsMmMwLDAuNywwLjIsMS4zLDAuNiwxLjdjMC40LDAuNCwxLjEsMC43LDIsMWMwLjUsMC4xLDEuMiwwLjIsMi4yLDAuNGMwLjksMC4yLDEuNywwLjMsMi40LDAuNWMxLjMsMC4zLDIuMywwLjksMywxLjZDNzcuOSwyOC4zLDc4LjIsMjkuMyw3OC4yLDMwLjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTkzLjYsMjguOGMwLDEuMS0wLjIsMi4xLTAuNSwzYy0wLjMsMC45LTAuNywxLjYtMS4zLDIuM2MtMC41LDAuNi0xLjEsMS0xLjgsMS40Yy0wLjcsMC4zLTEuNSwwLjUtMi4zLDAuNWMtMC43LDAtMS4zLTAuMS0xLjktMC4yYy0wLjYtMC4yLTEuMS0wLjQtMS43LTAuN3Y1LjZoLTIuMlYyMi4zaDIuMnYxLjRjMC42LTAuNSwxLjMtMC45LDItMS4zYzAuNy0wLjMsMS41LTAuNSwyLjQtMC41YzEuNiwwLDIuOCwwLjYsMy43LDEuOEM5My4yLDI1LDkzLjYsMjYuNyw5My42LDI4Ljh6IE05MS4zLDI4LjljMC0xLjYtMC4zLTIuOC0wLjgtMy42Yy0wLjUtMC44LTEuNC0xLjItMi41LTEuMmMtMC42LDAtMS4zLDAuMS0xLjksMC40Yy0wLjcsMC4zLTEuMywwLjYtMS45LDEuMXY3LjVjMC42LDAuMywxLjIsMC41LDEuNiwwLjZjMC41LDAuMSwxLDAuMiwxLjYsMC4yYzEuMiwwLDIuMi0wLjQsMi45LTEuM0M5MSwzMS44LDkxLjMsMzAuNSw5MS4zLDI4Ljl6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEwOC4zLDI5LjJoLTkuOGMwLDAuOCwwLjEsMS41LDAuNCwyLjFjMC4yLDAuNiwwLjYsMS4xLDEsMS41YzAuNCwwLjQsMC45LDAuNywxLjUsMC45czEuMiwwLjMsMS45LDAuM2MwLjksMCwxLjgtMC4yLDIuNy0wLjVjMC45LTAuNCwxLjYtMC43LDItMS4xaDAuMXYyLjRjLTAuOCwwLjMtMS41LDAuNi0yLjMsMC44cy0xLjYsMC4zLTIuNSwwLjNjLTIuMiwwLTMuOS0wLjYtNS4yLTEuOGMtMS4yLTEuMi0xLjktMi45LTEuOS01LjFjMC0yLjIsMC42LTMuOSwxLjgtNS4yYzEuMi0xLjMsMi43LTEuOSw0LjctMS45YzEuOCwwLDMuMiwwLjUsNC4xLDEuNmMxLDEsMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xMDYuMiwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN2MtMC42LTAuNi0xLjUtMS0yLjctMWMtMS4yLDAtMi4yLDAuNC0yLjksMS4xYy0wLjcsMC43LTEuMSwxLjYtMS4yLDIuNkgxMDYuMnoiLz48cGF0aCBjbGFzcz0ic3QxIiBkPSJNMTE0LjEsMzUuNmgtMi4yVjE3LjFoMi4yVjM1LjZ6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTEyOS40LDM0LjFjMCwyLjMtMC41LDMuOS0xLjUsNWMtMSwxLjEtMi42LDEuNi00LjcsMS42Yy0wLjcsMC0xLjQsMC0yLjEtMC4xYy0wLjctMC4xLTEuMy0wLjItMi0wLjR2LTIuM2gwLjFjMC40LDAuMSwwLjksMC4zLDEuNywwLjVzMS42LDAuMywyLjQsMC4zYzAuOCwwLDEuNC0wLjEsMS45LTAuM2MwLjUtMC4yLDAuOS0wLjQsMS4yLTAuOGMwLjMtMC4zLDAuNS0wLjcsMC42LTEuMWMwLjEtMC40LDAuMi0wLjksMC4yLTEuNXYtMS4yYy0wLjcsMC41LTEuMywwLjktMS45LDEuMnMtMS40LDAuNC0yLjMsMC40Yy0xLjYsMC0yLjgtMC42LTMuOC0xLjdjLTAuOS0xLjEtMS40LTIuOC0xLjQtNC44YzAtMS4xLDAuMi0yLjEsMC41LTNjMC4zLTAuOCwwLjgtMS41LDEuMy0yLjFjMC41LTAuNiwxLjEtMSwxLjktMS4zYzAuNy0wLjMsMS41LTAuNSwyLjItMC41YzAuOCwwLDEuNCwwLjEsMS45LDAuMnMxLjEsMC40LDEuNiwwLjdsMC4xLTAuNmgyLjFWMzQuMXogTTEyNy4yLDMydi03LjJjLTAuNi0wLjMtMS4xLTAuNS0xLjctMC42Yy0wLjUtMC4xLTEtMC4yLTEuNS0wLjJjLTEuMiwwLTIuMiwwLjQtMi45LDEuMnMtMS4xLDItMS4xLDMuNmMwLDEuNSwwLjMsMi42LDAuOCwzLjRjMC41LDAuOCwxLjQsMS4yLDIuNiwxLjJjMC43LDAsMS4zLTAuMSwyLTAuNFMxMjYuNiwzMi40LDEyNy4yLDMyeiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xNDIuMiwyNC44aC0wLjFjLTAuMy0wLjEtMC43LTAuMS0xLTAuMmMtMC4zLDAtMC43LTAuMS0xLjEtMC4xYy0wLjcsMC0xLjQsMC4yLTIsMC41Yy0wLjYsMC4zLTEuMywwLjctMS45LDEuMnY5LjRIMTM0VjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE1NC44LDM1LjZoLTIuMnYtMS40Yy0wLjIsMC4xLTAuNSwwLjMtMC44LDAuNnMtMC43LDAuNC0xLDAuNmMtMC40LDAuMi0wLjgsMC4zLTEuMywwLjVjLTAuNSwwLjEtMS4xLDAuMi0xLjcsMC4yYy0xLjIsMC0yLjItMC40LTMtMS4yYy0wLjgtMC44LTEuMi0xLjgtMS4yLTNjMC0xLDAuMi0xLjgsMC42LTIuNGMwLjQtMC42LDEtMS4xLDEuOC0xLjVjMC44LTAuNCwxLjgtMC42LDIuOS0wLjdzMi40LTAuMiwzLjctMC4zdi0wLjNjMC0wLjUtMC4xLTAuOS0wLjMtMS4zYy0wLjItMC4zLTAuNC0wLjYtMC44LTAuOGMtMC4zLTAuMi0wLjctMC4zLTEuMS0wLjRDMTUwLDI0LDE0OS41LDI0LDE0OSwyNGMtMC42LDAtMS4yLDAuMS0yLDAuMmMtMC43LDAuMi0xLjUsMC40LTIuMiwwLjdoLTAuMXYtMi4zYzAuNC0wLjEsMS4xLTAuMiwxLjktMC40YzAuOC0wLjEsMS42LTAuMiwyLjQtMC4yYzAuOSwwLDEuOCwwLjEsMi40LDAuMmMwLjcsMC4yLDEuMywwLjQsMS44LDAuOGMwLjUsMC40LDAuOSwwLjgsMS4xLDEuNGMwLjMsMC42LDAuNCwxLjMsMC40LDIuMlYzNS42eiBNMTUyLjYsMzIuM3YtMy43Yy0wLjcsMC0xLjUsMC4xLTIuNCwwLjJzLTEuNywwLjItMi4yLDAuM2MtMC42LDAuMi0xLjIsMC41LTEuNiwwLjlzLTAuNiwwLjktMC42LDEuNmMwLDAuOCwwLjIsMS4zLDAuNywxLjdzMS4yLDAuNiwyLjEsMC42YzAuOCwwLDEuNS0wLjIsMi4yLTAuNUMxNTEuNCwzMy4xLDE1MiwzMi44LDE1Mi42LDMyLjN6IE0xNDguNCwyMC4xSDE0NnYtMi4zaDIuNFYyMC4xeiBNMTUzLjMsMjAuMWgtMi40di0yLjNoMi40VjIwLjF6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTE3MC4zLDM1LjZoLTIuMnYtNy42YzAtMC42LDAtMS4yLTAuMS0xLjdzLTAuMi0xLTAuNC0xLjNjLTAuMi0wLjMtMC41LTAuNi0wLjktMC43Yy0wLjQtMC4yLTAuOS0wLjItMS41LTAuMmMtMC42LDAtMS4yLDAuMi0xLjksMC41Yy0wLjcsMC4zLTEuMywwLjctMS45LDEuMnY5LjloLTIuMlYyMi4zaDIuMnYxLjVjMC43LTAuNiwxLjQtMSwyLjItMS40YzAuNy0wLjMsMS41LTAuNSwyLjMtMC41YzEuNCwwLDIuNSwwLjQsMy4zLDEuM2MwLjgsMC45LDEuMSwyLjEsMS4xLDMuN1YzNS42eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xODQuMywzMS44YzAsMS4yLTAuNSwyLjItMS41LDNjLTEsMC44LTIuNCwxLjItNC4xLDEuMmMtMSwwLTEuOS0wLjEtMi43LTAuNGMtMC44LTAuMi0xLjUtMC41LTIuMS0wLjh2LTIuNWgwLjFjMC43LDAuNSwxLjUsMSwyLjQsMS4zczEuNywwLjUsMi41LDAuNWMxLDAsMS44LTAuMiwyLjMtMC41YzAuNi0wLjMsMC44LTAuOCwwLjgtMS41YzAtMC41LTAuMi0wLjktMC41LTEuMnMtMC45LTAuNS0xLjctMC43Yy0wLjMtMC4xLTAuNy0wLjItMS4yLTAuM2MtMC41LTAuMS0xLTAuMi0xLjQtMC4zYy0xLjItMC4zLTItMC44LTIuNS0xLjRjLTAuNS0wLjYtMC43LTEuMy0wLjctMi4yYzAtMC41LDAuMS0xLjEsMC4zLTEuNWMwLjItMC41LDAuNi0wLjksMS0xLjNjMC40LTAuNCwxLTAuNywxLjctMC45YzAuNy0wLjIsMS41LTAuMywyLjMtMC4zYzAuOCwwLDEuNiwwLjEsMi40LDAuM2MwLjgsMC4yLDEuNSwwLjQsMiwwLjd2Mi40aC0wLjFjLTAuNi0wLjQtMS4zLTAuOC0yLjEtMS4xYy0wLjgtMC4zLTEuNi0wLjQtMi40LTAuNGMtMC44LDAtMS41LDAuMi0yLjEsMC41Yy0wLjYsMC4zLTAuOCwwLjgtMC44LDEuNGMwLDAuNSwwLjIsMSwwLjUsMS4yYzAuMywwLjMsMC45LDAuNSwxLjYsMC43YzAuNCwwLjEsMC45LDAuMiwxLjQsMC4zYzAuNSwwLjEsMC45LDAuMiwxLjMsMC4zYzEsMC4yLDEuOCwwLjYsMi40LDEuMkMxODQsMzAsMTg0LjMsMzAuOCwxODQuMywzMS44eiIvPjxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik0xOTguNywyOS4yaC05LjhjMCwwLjgsMC4xLDEuNSwwLjQsMi4xczAuNiwxLjEsMSwxLjVjMC40LDAuNCwwLjksMC43LDEuNSwwLjljMC42LDAuMiwxLjIsMC4zLDEuOSwwLjNjMC45LDAsMS44LTAuMiwyLjctMC41YzAuOS0wLjQsMS42LTAuNywyLTEuMWgwLjF2Mi40Yy0wLjgsMC4zLTEuNSwwLjYtMi4zLDAuOHMtMS42LDAuMy0yLjUsMC4zYy0yLjIsMC0zLjktMC42LTUuMi0xLjhjLTEuMi0xLjItMS45LTIuOS0xLjktNS4xYzAtMi4yLDAuNi0zLjksMS44LTUuMmMxLjItMS4zLDIuNy0xLjksNC43LTEuOWMxLjgsMCwzLjIsMC41LDQuMSwxLjZzMS41LDIuNSwxLjUsNC41VjI5LjJ6IE0xOTYuNSwyNy41YzAtMS4yLTAuMy0yLjEtMC45LTIuN3MtMS41LTEtMi43LTFjLTEuMiwwLTIuMiwwLjQtMi45LDEuMWMtMC43LDAuNy0xLjEsMS42LTEuMiwyLjZIMTk2LjV6Ii8+PHBhdGggY2xhc3M9InN0MSIgZD0iTTIxMC41LDI0LjhoLTAuMWMtMC4zLTAuMS0wLjctMC4xLTEtMC4yYy0wLjMsMC0wLjctMC4xLTEuMS0wLjFjLTAuNywwLTEuNCwwLjItMiwwLjVjLTAuNiwwLjMtMS4zLDAuNy0xLjksMS4ydjkuNGgtMi4yVjIyLjNoMi4ydjJjMC45LTAuNywxLjctMS4yLDIuMy0xLjVjMC43LTAuMywxLjQtMC40LDIuMS0wLjRjMC40LDAsMC43LDAsMC44LDBjMC4yLDAsMC40LDAuMSwwLjgsMC4xVjI0Ljh6Ii8+PC9nPjwvZz48Zz48cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzIuNSw0Ny4zYy0xMS4yLDAtMjAuMy05LjEtMjAuMy0yMC4zUzIxLjMsNi43LDMyLjUsNi43YzExLjIsMCwyMC4zLDkuMSwyMC4zLDIwLjNTNDMuNyw0Ny4zLDMyLjUsNDcuM3oiLz48cGF0aCBjbGFzcz0ic3QyIiBkPSJNMzIuNSw3LjdjMTAuNywwLDE5LjMsOC43LDE5LjMsMTkuM2MwLDEwLjctOC43LDE5LjMtMTkuMywxOS4zYy0xMC43LDAtMTkuMy04LjctMTkuMy0xOS4zQzEzLjIsMTYuMywyMS44LDcuNywzMi41LDcuNyBNMzIuNSw1LjdjLTExLjcsMC0yMS4zLDkuNS0yMS4zLDIxLjNjMCwxMS43LDkuNSwyMS4zLDIxLjMsMjEuM2MxMS43LDAsMjEuMy05LjUsMjEuMy0yMS4zQzUzLjcsMTUuMiw0NC4yLDUuNywzMi41LDUuN0wzMi41LDUuN3oiLz48L2c+PGxpbmUgY2xhc3M9InN0MyIgeDE9IjI2LjciIHkxPSIxNC4zIiB4Mj0iMzQuNCIgeTI9IjI2LjUiLz48bGluZSBjbGFzcz0ic3QzIiB4MT0iMjUuMyIgeTE9IjMzLjMiIHgyPSIzNC41IiB5Mj0iMjYuOSIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjQ4LjYiIGN5PSIzNi4yIiByPSIxMi45Ii8+PGc+PHBhdGggY2xhc3M9InN0MCIgZD0iTTQxLjMsMjkuOEg0NHY1LjRoMGw0LjItNS40aDMuNGwtNC44LDYuMWw1LDYuN2gtMy4zbC00LjUtNmgwdjZoLTIuN1YyOS44eiIvPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik01NS4xLDM0LjJ2MS4yaDBjMC4yLTAuNCwwLjUtMC43LDAuOS0xYzAuMy0wLjIsMC42LTAuNCwwLjktMC40YzAuMiwwLDAuMywwLDAuNSwwdjIuN2MtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0wLjUsMC0wLjksMC4yLTEuMiwwLjVjLTAuMywwLjQtMC40LDAuOS0wLjQsMS41djMuN2gtMi41di04LjNINTUuMXoiLz48L2c+PGxpbmUgY2xhc3M9InN0NCIgeDE9IjE2IiB5MT0iMjciIHgyPSIxOC40IiB5Mj0iMjciLz48bGluZSBjbGFzcz0ic3Q0IiB4MT0iMzIuNyIgeTE9IjEyLjciIHgyPSIzMi43IiB5Mj0iMTAuMyIvPjxsaW5lIGNsYXNzPSJzdDQiIHgxPSIzMi41IiB5MT0iNDQuMiIgeDI9IjMyLjUiIHkyPSI0MS44Ii8+PC9zdmc+"/> </a><div id="InloggadLandscape" style="color:#fff; display:inline-block; float: right; font-size: 18px; padding-top: 3px;"></div></div></div>';
    var htmlContent = (new DOMParser).parseFromString(htmlString, "text/html");
    document.body.insertBefore(htmlContent.firstChild, document.getElementsByTagName("canvas")[0]);
    var pausePlayContainers = document.getElementsByClassName("PausePlay");
    var selfTestContainers = document.getElementsByClassName("SelfTest");
    var playLimitContainers = document.getElementsByClassName("PlayLimit");
    this.elapsedTimeContainerLandscape = document.getElementById("InloggadLandscape");
    this.elapsedTimeContainerPortrait = document.getElementById("InloggadPortrait");
    for (var i = 0; i < pausePlayContainers.length; i++) {
        pausePlayContainers[i].href = UHT_GAME_CONFIG["pauseplayUrl"];
        selfTestContainers[i].href = UHT_GAME_CONFIG["selftestUrl"];
        playLimitContainers[i].href = UHT_GAME_CONFIG["playlimitUrl"]
    }
    document.getElementsByTagName("canvas")[0].classList.add("SwedishCanvas")
}
;
SwedishRegulationManager.prototype.UpdateTimer = function() {
    var currentTime = (new Date).getTime();
    this.elapsedTime = Math.floor((currentTime - this.initialTime) / 1E3) + this.initialElapsedTime;
    var seconds = (parseInt(this.elapsedTime, 10) % 60).toString();
    var minutes = parseInt(parseInt(this.elapsedTime, 10) / 60 % 60, 10).toString();
    var hours = parseInt(parseInt(this.elapsedTime, 10) / 3600, 10).toString();
    if (seconds.length < 2)
        seconds = "0" + seconds;
    if (minutes.length < 2)
        minutes = "0" + minutes;
    if (hours.length < 2)
        hours = "0" + hours;
    this.elapsedTimeContainerLandscape.innerHTML = "Inloggad: " + hours + ":" + minutes + ":" + seconds;
    if (this.elapsedTimeContainerPortrait != null)
        this.elapsedTimeContainerPortrait.innerHTML = "Inloggad: " + hours + ":" + minutes + ":" + seconds
}
;
SwedishRegulationManager.prototype.OnUHTResize = function(unused) {
    var canv = document.getElementsByTagName("canvas")[0];
    var rgsParent = document.getElementsByClassName("RGSContainerActive")[0].dataset;
    var pixelRatio = UHTScreen.height / window.innerHeight;
    var scale = 1 - rgsParent.height * pixelRatio / UHTScreen.height;
    var sign = document.documentElement.className.indexOf("iPhone") >= 0 && document.documentElement.id == "Mobile" && window.orientation == 90 ? 1 : -1;
    var transY = sign * (rgsParent.height * pixelRatio / (UHTScreen.height - rgsParent.height * pixelRatio) / 2) * 100;
    canv.style.transform = "scale(" + scale + ") translateY(" + transY + "%)"
}
;
goog.provide("UHT.TournamentConnection");
function TournamentConnection() {
    this.xtLayer = null;
    this.reloadLeaderboardsInterval = 30;
    this.leaderboardsTimer = 30;
    this.isReloadindLeaderboards = false;
    this.reloadTournamentsInterval = 60;
    this.tournamentsTimer = 60;
    this.isReloadindTournaments = false;
    this.reloadRacePrizesInterval = 30;
    this.racePrizesTimer = 30;
    this.isReloadindRacePrizes = false;
    this.tournamentIds = [];
    this.raceIds = [];
    this.tournamentsURL;
    this.detailsURL;
    this.leaderboardsURL;
    this.raceDetailsURL;
    this.racePrizesURL;
    this.raceOptInURL;
    this.raceOptOutURL;
    this.tournamentOptInURL;
    this.tournamentOptOutURL;
    this.optRequests = {};
    this.promoHolders = [];
    this.activeTournaments = false;
    this.activeRaces = false;
    this.isReloaded = false;
    this.isRaceDetailsReloaded = true;
    this.isTournamentDetailsReloaded = true;
    this.hasUpdates = false;
    this.canUpdate = false;
    var args = new Array(2);
    args[0] = GameProtocolDictionary.symbol + "=" + ServerOptions.gameSymbol;
    args[1] = GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    var query = args.join("&");
    this.tournamentsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.tournaments;
    this.tournamentsURL += this.QueryPrefix(this.tournamentsURL) + query;
    this.detailsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.details;
    this.detailsURL += this.QueryPrefix(this.detailsURL) + query;
    this.leaderboardsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.leaderboards;
    this.leaderboardsURL += this.QueryPrefix(this.leaderboardsURL) + query;
    this.raceDetailsURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.raceDetails;
    this.raceDetailsURL += this.QueryPrefix(this.raceDetailsURL) + query;
    this.racePrizesURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.racePrizes;
    this.racePrizesURL += this.QueryPrefix(this.racePrizesURL) + query;
    this.raceOptInURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.raceOptIn;
    this.raceOptInURL += this.QueryPrefix(this.raceOptInURL) + query;
    this.raceOptOutURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.raceOptOut;
    this.raceOptOutURL += this.QueryPrefix(this.raceOptOutURL) + query;
    this.tournamentOptInURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.tournamentOptIn;
    this.tournamentOptInURL += this.QueryPrefix(this.tournamentOptInURL) + query;
    this.tournamentOptOutURL = ServerOptions.serverUrl + ServerOptions.TournamentURLs.tournamentOptOut;
    this.tournamentOptOutURL += this.QueryPrefix(this.tournamentOptOutURL) + query;
    TournamentConnection.instance = this
}
TournamentConnection.instance = null;
TournamentConnection.PromoHolder = function(_id, _type) {
    this.id = _id;
    this.type = _type;
    this.uid = TournamentConnection.PromoHolder.GetUID(_id, _type);
    this.promotion = null;
    this.details = null;
    this.leaderboard = null;
    this.isNew = true
}
;
TournamentConnection.PromoHolder.GetUID = function(id, type) {
    return type + "#" + id
}
;
TournamentConnection.PromoHolder.Compare = function(x, y) {
    var ret = 0;
    var xVal = 0;
    var yVal = 0;
    xVal = x.promotion != null ? -1 : 1;
    yVal = y.promotion != null ? -1 : 1;
    ret = xVal - yVal;
    if (ret == 0)
        if (x.promotion == null)
            return ret;
    if (ret == 0)
        ret = x.promotion.status - y.promotion.status;
    if (ret == 0)
        ret = x.type - y.type;
    if (ret == 0) {
        if (x.type == TournamentProtocol.PromoType.Race) {
            xVal = x.details != null ? -1 : 1;
            yVal = y.details != null ? -1 : 1;
            ret = xVal - yVal;
            if (ret == 0)
                if (x.details != null) {
                    xVal = x.details.prizePool != null ? -1 : 1;
                    yVal = y.details.prizePool != null ? -1 : 1;
                    ret = xVal - yVal;
                    if (ret == 0)
                        if (x.details.prizePool != null)
                            ret = y.details.prizePool.totalCount - x.details.prizePool.totalCount
                }
        }
        if (x.type == TournamentProtocol.PromoType.Tournament) {
            xVal = x.leaderboard != null ? -1 : 1;
            yVal = y.leaderboard != null ? -1 : 1;
            ret = xVal - yVal;
            if (ret == 0)
                if (x.leaderboard != null)
                    ret = x.leaderboard.playerPosition - y.leaderboard.playerPosition
        }
    }
    if (ret == 0) {
        if (x.promotion.status == TournamentProtocol.StatusCode.Open)
            ret = x.promotion.endDate - y.promotion.endDate;
        if (x.promotion.status == TournamentProtocol.StatusCode.StartsSoon)
            ret = x.promotion.startDate - y.promotion.startDate;
        if (x.promotion.status == TournamentProtocol.StatusCode.Closed)
            ret = y.promotion.endDate - x.promotion.endDate
    }
    return ret
}
;
TournamentConnection.prototype.Update = function() {
    if (!this.isReloadindTournaments && this.tournamentsTimer >= this.reloadTournamentsInterval) {
        this.isReloadindTournaments = true;
        this.Reload(this.tournamentsURL, new EventHandler(this,this.OnTournamentsReloaded))
    }
    if (!this.isReloadindLeaderboards && this.leaderboardsTimer >= this.reloadLeaderboardsInterval && this.activeTournaments) {
        this.isReloadindLeaderboards = true;
        this.Reload(this.leaderboardsURL, new EventHandler(this,this.OnLeaderboardReloaded))
    }
    if (!this.isReloadindRacePrizes && this.racePrizesTimer >= this.reloadRacePrizesInterval && this.activeRaces) {
        this.isReloadindRacePrizes = true;
        this.Reload(this.racePrizesURL, new EventHandler(this,this.OnRacePrizesReloaded))
    }
    this.tournamentsTimer += Time.deltaTime;
    this.leaderboardsTimer += Time.deltaTime;
    this.racePrizesTimer += Time.deltaTime;
    if (this.isReloaded && (!this.hasUpdates || this.canUpdate && this.isRaceDetailsReloaded && this.isTournamentDetailsReloaded)) {
        this.xtLayer.SetDetails(this.GetDetails());
        this.xtLayer.SetLeaderboards(this.GetLeaderboards());
        this.xtLayer.SetTournaments(this.GetPromotions(true));
        if (this.hasUpdates)
            this.xtLayer.AnnouncePromotions();
        this.canUpdate = false;
        this.hasUpdates = false;
        this.isReloaded = false
    }
    this.CheckOptResponses()
}
;
TournamentConnection.prototype.Reload = function(url, callback) {
    var req = new ServerRequest;
    req.Url = url;
    req.Handler = callback;
    req.Method = "GET";
    RequestManager.AddRequest(req)
}
;
TournamentConnection.prototype.OnTournamentsReloaded = function(param, statusCode) {
    this.tournamentsTimer = 0;
    this.isReloadindTournaments = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/active)";
    var response = TournamentProtocol.TournamentParser.ParseTournamentsResponse(param);
    if (response == null) {
        this.xtLayer.SetTournaments(null);
        return
    }
    var items = [];
    this.ReloadIfNeeded(response.tournaments, this.tournamentIds, this.detailsURL, this.OnDetailsReloaded, items);
    this.ReloadIfNeeded(response.races, this.raceIds, this.raceDetailsURL, this.OnRaceDetailsReloaded, items);
    this.promoHolders = items;
    this.activeTournaments = false;
    this.activeRaces = false;
    for (var i = 0; i < this.promoHolders.length; i++) {
        if (this.promoHolders[i].type == TournamentProtocol.PromoType.Tournament)
            this.activeTournaments = true;
        if (this.promoHolders[i].type == TournamentProtocol.PromoType.Race)
            this.activeRaces = true
    }
    this.xtLayer.SetServerTime(response.serverTime);
    this.isReloaded = true
}
;
TournamentConnection.prototype.OnDetailsReloaded = function(param, statusCode) {
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/tournament/details)";
    var response = TournamentProtocol.TournamentParser.ParseDetailsResponse(param);
    if (response == null || response.details == null)
        return;
    for (var i = 0; i < response.details.length; ++i)
        this.FindPromoHolderInternal(response.details[i].id, TournamentProtocol.PromoType.Tournament).details = response.details[i];
    this.isReloaded = true;
    this.isTournamentDetailsReloaded = true
}
;
TournamentConnection.prototype.OnLeaderboardReloaded = function(param, statusCode) {
    this.leaderboardsTimer = 0;
    this.isReloadindLeaderboards = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/tournament/leaderboard)";
    var response = TournamentProtocol.TournamentParser.ParseLeaderboardResponse(param);
    if (response == null)
        return;
    if (response.leaderboards != null)
        for (var i = 0; i < response.leaderboards.length; ++i)
            this.FindPromoHolderInternal(response.leaderboards[i].tournamentID, TournamentProtocol.PromoType.Tournament).leaderboard = response.leaderboards[i];
    this.isReloaded = true
}
;
TournamentConnection.prototype.OnRaceDetailsReloaded = function(param, statusCode) {
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/race/details)";
    var response = TournamentProtocol.TournamentParser.ParseDetailsResponse(param);
    if (response == null || response.details == null)
        return;
    for (var i = 0; i < response.details.length; ++i) {
        var item = this.FindPromoHolderInternal(response.details[i].id, TournamentProtocol.PromoType.Race);
        if (item.details == null)
            item.details = response.details[i];
        item.details.htmlRules = response.details[i].htmlRules;
        item.details.shortHtmlRules = response.details[i].shortHtmlRules
    }
    this.isReloaded = true;
    this.isRaceDetailsReloaded = true
}
;
TournamentConnection.prototype.OnRacePrizesReloaded = function(param, statusCode) {
    this.racePrizesTimer = 0;
    this.isReloadindRacePrizes = false;
    TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (promo/race/prizes)";
    var response = TournamentProtocol.TournamentParser.ParseDetailsResponse(param);
    if (response == null || response.details == null)
        return;
    for (var i = 0; i < response.details.length; ++i) {
        var item = this.FindPromoHolderInternal(response.details[i].id, TournamentProtocol.PromoType.Race);
        if (item.details == null)
            item.details = response.details[i];
        item.details.prizePool = response.details[i].prizePool
    }
    this.isReloaded = true
}
;
TournamentConnection.prototype.QueryPrefix = function(url) {
    return /\?/.test(url) ? "&" : "?"
}
;
TournamentConnection.prototype.ReloadIfNeeded = function(events, eventIds, url, callback, items) {
    if (events == null)
        return;
    var reload = false;
    var ids = [];
    for (var i = 0; i < events.length; ++i) {
        ids.push(events[i].id);
        var item = this.FindPromoHolderInternal(events[i].id, events[i].type);
        if (!item.isNew && item.promotion != null && item.promotion.isOpted && !events[i].isOpted) {
            item.isNew = true;
            this.hasUpdates = true
        }
        item.promotion = events[i];
        items.push(item);
        if (eventIds.indexOf(events[i].id) < 0) {
            reload = true;
            if (item.type == TournamentProtocol.PromoType.Race)
                this.isRaceDetailsReloaded = false;
            else if (item.type == TournamentProtocol.PromoType.Tournament)
                this.isTournamentDetailsReloaded = false
        }
    }
    eventIds.splice(0);
    for (var i = 0; i < ids.length; ++i)
        eventIds.push(ids[i]);
    if (reload) {
        this.hasUpdates = true;
        this.Reload(url, new EventHandler(this,callback))
    }
}
;
TournamentConnection.prototype.FindPromoHolderInternal = function(id, type) {
    var item = this.FindPromoHolder(TournamentConnection.PromoHolder.GetUID(id, type));
    if (item == null) {
        item = new TournamentConnection.PromoHolder(id,type);
        this.promoHolders.push(item);
        if (item.type == TournamentProtocol.PromoType.Tournament)
            this.activeTournaments = true;
        if (item.type == TournamentProtocol.PromoType.Race)
            this.activeRaces = true
    }
    return item
}
;
TournamentConnection.prototype.FindPromoHolder = function(uid) {
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].uid == uid)
            return this.promoHolders[i];
    return null
}
;
TournamentConnection.prototype.FindNewPromoHolders = function() {
    var list = [];
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].isNew && this.promoHolders[i].details != null && this.promoHolders[i].promotion != null) {
            this.promoHolders[i].isNew = false;
            if (!this.promoHolders[i].promotion.isOpted)
                list.push(this.promoHolders[i])
        }
    return list
}
;
TournamentConnection.prototype.GetPromotions = function(sort) {
    var ret = [];
    if (sort)
        this.promoHolders.sort(TournamentConnection.PromoHolder.Compare);
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].promotion != null && this.promoHolders[i].promotion.clientMode == TournamentProtocol.ClientMode.Visible) {
            if (_string.IsNullOrEmpty(this.promoHolders[i].promotion.uid))
                this.promoHolders[i].promotion.uid = this.promoHolders[i].uid;
            ret.push(this.promoHolders[i].promotion)
        }
    return ret.length > 0 ? ret : null
}
;
TournamentConnection.prototype.GetDetails = function() {
    var ret = [];
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].details != null) {
            if (_string.IsNullOrEmpty(this.promoHolders[i].details.uid))
                this.promoHolders[i].details.uid = this.promoHolders[i].uid;
            if (this.promoHolders[i].type == TournamentProtocol.PromoType.Race && this.promoHolders[i].promotion != null && this.promoHolders[i].promotion.status == TournamentProtocol.StatusCode.Closed && this.promoHolders[i].details.prizePool != null && this.promoHolders[i].details.prizePool.prizesList != null)
                this.promoHolders[i].details.prizePool.prizesList = null;
            ret.push(this.promoHolders[i].details)
        }
    return ret.length > 0 ? ret : null
}
;
TournamentConnection.prototype.GetLeaderboards = function() {
    var ret = [];
    for (var i = 0; i < this.promoHolders.length; ++i)
        if (this.promoHolders[i].leaderboard != null) {
            if (_string.IsNullOrEmpty(this.promoHolders[i].leaderboard.uid))
                this.promoHolders[i].leaderboard.uid = this.promoHolders[i].uid;
            ret.push(this.promoHolders[i].leaderboard)
        }
    return ret.length > 0 ? ret : null
}
;
TournamentConnection.prototype.SendOptRequest = function(uid, isIn) {
    var holder = this.FindPromoHolder(uid);
    if (holder == null)
        return;
    if (holder.promotion.type == TournamentProtocol.PromoType.Tournament)
        this.InternalSendOptRequest(isIn ? this.tournamentOptInURL : this.tournamentOptOutURL, uid, holder.id);
    else if (holder.promotion.type == TournamentProtocol.PromoType.Race)
        this.InternalSendOptRequest(isIn ? this.raceOptInURL : this.raceOptOutURL, uid, holder.id)
}
;
TournamentConnection.prototype.InternalSendOptRequest = function(url, uid, id) {
    var req = new ServerRequest;
    req.Url = url;
    req.PostData = '{"promoID":' + String(id) + "}";
    req.ContentType = "application/json";
    RequestManager.AddRequest(req);
    this.optRequests[uid] = req
}
;
TournamentConnection.prototype.CheckOptResponses = function() {
    if (Object.keys(Object(this.optRequests)).length == 0)
        return;
    var outUids = [];
    var reqs = this.optRequests;
    this.optRequests = {};
    for (var uid in reqs) {
        var req = reqs[uid];
        if (!req.IsDone())
            this.optRequests[uid] = req;
        else {
            TournamentProtocol.TournamentParser.errorMessage = "PromoAPI Parsing Error (player/choice)";
            var response = TournamentProtocol.TournamentParser.ParseBaseResponse(req.request.Data);
            var holder = this.FindPromoHolder(uid);
            if (response == null || response.error != TournamentProtocol.ErrorCode.None)
                this.InternalSendOptRequest(req.Url, uid, holder.id);
            else {
                holder.promotion.isOpted = true;
                if (req.Url.indexOf("OPTOUT") > -1)
                    outUids.push(uid)
            }
        }
    }
    if (outUids.length == 0)
        return;
    var holders = this.promoHolders;
    this.promoHolders = [];
    this.activeTournaments = false;
    this.activeRaces = false;
    for (var i = 0; i < holders.length; ++i)
        if (outUids.indexOf(holders[i].uid) < 0) {
            this.promoHolders.push(holders[i]);
            if (holders[i].type == TournamentProtocol.PromoType.Tournament)
                this.activeTournaments = true;
            if (holders[i].type == TournamentProtocol.PromoType.Race)
                this.activeRaces = true
        }
    if (outUids.indexOf(XT.GetString(TournamentVars.SelectedTournamentID)) > -1)
        XT.SetString(TournamentVars.SelectedTournamentID, "");
    this.xtLayer.SetTournaments(this.GetPromotions(false))
}
;
var PromotionsHelper = {};
PromotionsHelper.RankInfo = function() {
    this.uid = "";
    this.value = -1;
    this.type = TournamentProtocol.PromoType.Invalid;
    this.style = TournamentProtocol.ClientStyle.Invalid
}
;
PromotionsHelper.AnnouncementInfo = function() {
    this.uid = "";
    this.type = TournamentProtocol.PromoType.Invalid;
    this.currency = "";
    this.prizesCount = 0;
    this.prizesAmount = 0;
    this.description = ""
}
;
PromotionsHelper.FindPromotion = function(uid) {
    if (_string.IsNullOrEmpty(uid))
        return null;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? null : item.promotion
}
;
PromotionsHelper.FindDetails = function(uid) {
    if (_string.IsNullOrEmpty(uid))
        return null;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? null : item.details
}
;
PromotionsHelper.FindLeaderboard = function(uid) {
    if (_string.IsNullOrEmpty(uid))
        return null;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? null : item.leaderboard
}
;
PromotionsHelper.GetRankInfo = function() {
    var ri = new PromotionsHelper.RankInfo;
    if (TournamentConnection.instance == null)
        return ri;
    var list = TournamentConnection.instance.GetPromotions(false);
    if (list != null)
        for (var i = 0; i < list.length; ++i) {
            var item = null;
            if (i == 0) {
                item = TournamentConnection.instance.FindPromoHolder(list[i].uid);
                ri.type = item.type;
                ri.style = list[i].clientStyle
            }
            if (list[i].status == TournamentProtocol.StatusCode.Open) {
                if (item == null)
                    item = TournamentConnection.instance.FindPromoHolder(list[i].uid);
                ri.uid = item.uid;
                ri.type = item.type;
                if (item.type == TournamentProtocol.PromoType.Tournament) {
                    if (item.leaderboard != null)
                        ri.value = item.leaderboard.playerIndex > -1 ? item.leaderboard.playerPosition : -1
                } else if (item.type == TournamentProtocol.PromoType.Race)
                    if (item.details != null && item.details.prizePool != null)
                        ri.value = item.details.prizePool.totalCount > 0 ? item.details.prizePool.totalCount : -1;
                return ri
            }
        }
    return ri
}
;
PromotionsHelper.GetPromotionType = function(uid) {
    if (_string.IsNullOrEmpty(uid))
        return TournamentProtocol.PromoType.Invalid;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    return item == null ? TournamentProtocol.PromoType.Invalid : item.type
}
;
PromotionsHelper.GetAnnouncements = function() {
    var ret = [];
    var list = TournamentConnection.instance.FindNewPromoHolders();
    for (var i = 0; i < list.length; ++i) {
        var item = new PromotionsHelper.AnnouncementInfo;
        item.uid = list[i].uid;
        item.type = list[i].type;
        item.prizesCount = list[i].details.prizePool.totalCount;
        item.prizesAmount = list[i].details.prizePool.totalAmount;
        item.description = list[i].details.shortHtmlRules;
        ret.push(item)
    }
    return ret
}
;
PromotionsHelper.GetUID = function(id, type) {
    return TournamentConnection.PromoHolder.GetUID(id, type)
}
;
PromotionsHelper.GetCurrency = function(uid) {
    if (_string.IsNullOrEmpty(uid))
        return ServerOptions.currency;
    var item = TournamentConnection.instance.FindPromoHolder(uid);
    if (item == null || item.details == null || item.details.prizePool == null)
        return ServerOptions.currency;
    return item.details.prizePool.currency
}
;
PromotionsHelper.OptIn = function(uid) {
    TournamentConnection.instance.SendOptRequest(uid, true)
}
;
PromotionsHelper.OptOut = function(uid) {
    TournamentConnection.instance.SendOptRequest(uid, false)
}
;
PromotionsHelper.PromotionAvailable = function(uid) {
    return TournamentConnection.instance.FindPromoHolder(uid) != null
}
;
goog.provide("UHT.TournamentProtocol");
var TournamentProtocol = {};
TournamentProtocol.Dictionary = {
    StatusCode: {
        StartsSoon: "S",
        Open: "O",
        Closed: "C"
    },
    ClientMode: {
        Visible: "V",
        Hidden: "H"
    },
    ClientStyle: {
        Europe: "EU",
        Asia: "AS"
    },
    Tournament: {
        id: "id",
        status: "status",
        name: "name",
        startDate: "startDate",
        endDate: "endDate",
        clientMode: "clientMode",
        clientStyle: "clientStyle",
        optIn: "optin"
    },
    Details: {
        id: "id",
        htmlRules: "htmlRules",
        prizePool: "prizePool",
        prizes: "prizes",
        shortHtmlRules: "shortHtmlRules"
    },
    PrizePool: {
        currency: "currency",
        prizesList: "prizesList",
        prizeRemains: "prizeRemains"
    },
    Prize: {
        placeFrom: "placeFrom",
        placeTo: "placeTo",
        amount: "amount",
        gift: "gift",
        count: "count"
    },
    Leaderboard: {
        tournamentID: "tournamentID",
        playerIndex: "index",
        items: "items"
    },
    LeaderboardItem: {
        position: "position",
        playerID: "playerID",
        score: "score"
    },
    Response: {
        error: "error",
        description: "description"
    },
    TournamentsResponse: {
        tournaments: "tournaments",
        serverTime: "serverTime",
        races: "races"
    },
    DetailsResponse: {
        details: "details"
    },
    LeaderboardResponse: {
        leaderboards: "leaderboards"
    }
};
goog.require("UHT.TournamentProtocol");
TournamentProtocol.TournamentParser = {};
TournamentProtocol.TournamentParser.errorMessage = "";
TournamentProtocol.TournamentParser.ParseTournamentsResponse = function(json) {
    if (_string.IsNullOrEmpty(json))
        return null;
    var dict = JSON.parse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null || dict[TournamentProtocol.Dictionary.TournamentsResponse.serverTime] == undefined) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = new TournamentProtocol.TournamentsResponse(response);
    res.serverTime = _number.otoi(dict[TournamentProtocol.Dictionary.TournamentsResponse.serverTime]);
    if (dict[TournamentProtocol.Dictionary.TournamentsResponse.tournaments] != undefined)
        res.tournaments = TournamentProtocol.TournamentParser.ParseTournaments(dict[TournamentProtocol.Dictionary.TournamentsResponse.tournaments], TournamentProtocol.PromoType.Tournament);
    if (dict[TournamentProtocol.Dictionary.TournamentsResponse.races] != undefined)
        res.races = TournamentProtocol.TournamentParser.ParseTournaments(dict[TournamentProtocol.Dictionary.TournamentsResponse.races], TournamentProtocol.PromoType.Race);
    return res
}
;
TournamentProtocol.TournamentParser.ParseDetailsResponse = function(json) {
    if (_string.IsNullOrEmpty(json))
        return null;
    var dict = JSON.parse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = new TournamentProtocol.DetailsResponse(response);
    if (dict[TournamentProtocol.Dictionary.DetailsResponse.details] != undefined)
        res.details = TournamentProtocol.TournamentParser.ParseTournamentDetails(dict[TournamentProtocol.Dictionary.DetailsResponse.details]);
    if (dict[TournamentProtocol.Dictionary.Details.prizes] != undefined)
        res.details = TournamentProtocol.TournamentParser.ParseTournamentDetails(dict[TournamentProtocol.Dictionary.Details.prizes]);
    return res
}
;
TournamentProtocol.TournamentParser.ParseLeaderboardResponse = function(json) {
    if (_string.IsNullOrEmpty(json))
        return null;
    var dict = JSON.parse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = new TournamentProtocol.LeaderboardResponse(response);
    if (dict[TournamentProtocol.Dictionary.LeaderboardResponse.leaderboards] != undefined)
        res.leaderboards = TournamentProtocol.TournamentParser.ParseLeaderboards(dict[TournamentProtocol.Dictionary.LeaderboardResponse.leaderboards]);
    return res
}
;
TournamentProtocol.TournamentParser.ParseResponse = function(dict) {
    if (dict == null || dict[TournamentProtocol.Dictionary.Response.error] == undefined || dict[TournamentProtocol.Dictionary.Response.description] == undefined)
        return null;
    var res = new TournamentProtocol.Response;
    res.description = String(dict[TournamentProtocol.Dictionary.Response.description]);
    var error = _number.otoi(dict[TournamentProtocol.Dictionary.Response.error]);
    switch (error) {
    case TournamentProtocol.ErrorCode.None:
        res.error = TournamentProtocol.ErrorCode.None;
        break;
    case TournamentProtocol.ErrorCode.InvalidParameter:
        res.error = TournamentProtocol.ErrorCode.InvalidParameter;
        break;
    case TournamentProtocol.ErrorCode.TournamentNotFound:
        res.error = TournamentProtocol.ErrorCode.TournamentNotFound;
        break;
    case TournamentProtocol.ErrorCode.ServiceError:
        res.error = TournamentProtocol.ErrorCode.ServiceError;
        break
    }
    return res
}
;
TournamentProtocol.TournamentParser.ParseTournaments = function(param, promoType) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TournamentProtocol.Dictionary.Tournament.id] == undefined || dict[TournamentProtocol.Dictionary.Tournament.status] == undefined || dict[TournamentProtocol.Dictionary.Tournament.name] == undefined || dict[TournamentProtocol.Dictionary.Tournament.startDate] == undefined || dict[TournamentProtocol.Dictionary.Tournament.endDate] == undefined) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var tournament = new TournamentProtocol.Tournament;
        tournament.id = _number.otoi(dict[TournamentProtocol.Dictionary.Tournament.id]);
        tournament.name = String(dict[TournamentProtocol.Dictionary.Tournament.name]);
        tournament.startDate = _number.otoi(dict[TournamentProtocol.Dictionary.Tournament.startDate]);
        tournament.endDate = _number.otoi(dict[TournamentProtocol.Dictionary.Tournament.endDate]);
        tournament.type = promoType;
        var status = String(dict[TournamentProtocol.Dictionary.Tournament.status]);
        switch (status) {
        case TournamentProtocol.Dictionary.StatusCode.StartsSoon:
            tournament.status = TournamentProtocol.StatusCode.StartsSoon;
            break;
        case TournamentProtocol.Dictionary.StatusCode.Open:
            tournament.status = TournamentProtocol.StatusCode.Open;
            break;
        case TournamentProtocol.Dictionary.StatusCode.Closed:
            tournament.status = TournamentProtocol.StatusCode.Closed;
            break
        }
        if (dict[TournamentProtocol.Dictionary.Tournament.clientMode] != undefined) {
            var clientMode = String(dict[TournamentProtocol.Dictionary.Tournament.clientMode]);
            switch (clientMode) {
            case TournamentProtocol.Dictionary.ClientMode.Visible:
                tournament.clientMode = TournamentProtocol.ClientMode.Visible;
                break;
            case TournamentProtocol.Dictionary.ClientMode.Hidden:
                tournament.clientMode = TournamentProtocol.ClientMode.Hidden;
                break
            }
        } else if (promoType == TournamentProtocol.PromoType.Race)
            tournament.clientMode = TournamentProtocol.ClientMode.Visible;
        if (dict[TournamentProtocol.Dictionary.Tournament.optIn] != undefined)
            tournament.isOpted = _bool.Parse(dict[TournamentProtocol.Dictionary.Tournament.optIn]);
        if (dict[TournamentProtocol.Dictionary.Tournament.clientStyle] != undefined) {
            var clientStyle = String(dict[TournamentProtocol.Dictionary.Tournament.clientStyle]);
            switch (clientStyle) {
            case TournamentProtocol.Dictionary.ClientStyle.Asia:
                tournament.clientStyle = TournamentProtocol.ClientStyle.Asia;
                break;
            case TournamentProtocol.Dictionary.ClientStyle.Europe:
                tournament.clientStyle = TournamentProtocol.ClientStyle.Europe;
                break
            }
        }
        res.push(tournament)
    }
    return res
}
;
TournamentProtocol.TournamentParser.ParseTournamentDetails = function(param) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TournamentProtocol.Dictionary.Details.id] == undefined) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var details = new TournamentProtocol.TournamentDetails;
        details.id = _number.otoi(dict[TournamentProtocol.Dictionary.Details.id]);
        if (dict[TournamentProtocol.Dictionary.Details.prizePool] != undefined)
            details.prizePool = TournamentProtocol.TournamentParser.ParsePrizePool(dict[TournamentProtocol.Dictionary.Details.prizePool]);
        if (dict[TournamentProtocol.Dictionary.PrizePool.prizeRemains] != undefined)
            details.prizePool = TournamentProtocol.TournamentParser.ParsePrizePool(dict);
        if (dict[TournamentProtocol.Dictionary.Details.htmlRules] != undefined)
            details.htmlRules = _string.Trim(String(dict[TournamentProtocol.Dictionary.Details.htmlRules]).replace("\r", ""), "\n");
        if (dict[TournamentProtocol.Dictionary.Details.shortHtmlRules] != undefined)
            details.shortHtmlRules = _string.Trim(String(dict[TournamentProtocol.Dictionary.Details.shortHtmlRules]).replace("\r", ""), "\n");
        res.push(details)
    }
    return res
}
;
TournamentProtocol.TournamentParser.ParsePrizePool = function(param) {
    var dict = param;
    if (dict == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = new TournamentProtocol.PrizePool;
    if (dict[TournamentProtocol.Dictionary.PrizePool.currency] != undefined)
        res.currency = String(dict[TournamentProtocol.Dictionary.PrizePool.currency]);
    else
        res.currency = ServerOptions.currency;
    if (dict[TournamentProtocol.Dictionary.PrizePool.prizesList] != undefined)
        res.prizesList = TournamentProtocol.TournamentParser.ParsePrizes(dict[TournamentProtocol.Dictionary.PrizePool.prizesList], res);
    if (dict[TournamentProtocol.Dictionary.PrizePool.prizeRemains] != undefined)
        res.prizesList = TournamentProtocol.TournamentParser.ParsePrizes(dict[TournamentProtocol.Dictionary.PrizePool.prizeRemains], res);
    return res
}
;
TournamentProtocol.TournamentParser.ParsePrizes = function(param, pool) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var totalCount = 0;
    var totalAmount = 0;
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var prize = new TournamentProtocol.Prize;
        if (dict[TournamentProtocol.Dictionary.Prize.placeFrom] != undefined)
            prize.placeFrom = _number.otoi(dict[TournamentProtocol.Dictionary.Prize.placeFrom]);
        if (dict[TournamentProtocol.Dictionary.Prize.placeTo] != undefined)
            prize.placeTo = _number.otoi(dict[TournamentProtocol.Dictionary.Prize.placeTo]);
        if (dict[TournamentProtocol.Dictionary.Prize.amount] != undefined)
            prize.amount = _number.otod(dict[TournamentProtocol.Dictionary.Prize.amount]);
        if (dict[TournamentProtocol.Dictionary.Prize.gift] != undefined)
            prize.gift = String(dict[TournamentProtocol.Dictionary.Prize.gift]);
        if (dict[TournamentProtocol.Dictionary.Prize.count] != undefined) {
            prize.count = _number.otod(dict[TournamentProtocol.Dictionary.Prize.count]);
            totalCount += prize.count;
            totalAmount += prize.amount * prize.count
        }
        res.push(prize)
    }
    pool.totalCount = totalCount;
    pool.totalAmount = totalAmount;
    return res
}
;
TournamentProtocol.TournamentParser.ParseLeaderboards = function(param) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TournamentProtocol.Dictionary.Leaderboard.tournamentID] == undefined || dict[TournamentProtocol.Dictionary.Leaderboard.items] == undefined) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var leaderboard = new TournamentProtocol.Leaderboard;
        leaderboard.tournamentID = _number.otoi(dict[TournamentProtocol.Dictionary.Leaderboard.tournamentID]);
        leaderboard.items = TournamentProtocol.TournamentParser.ParseLeaderboardItems(dict[TournamentProtocol.Dictionary.Leaderboard.items]);
        if (dict[TournamentProtocol.Dictionary.Leaderboard.playerIndex] != undefined)
            leaderboard.playerIndex = _number.otoi(dict[TournamentProtocol.Dictionary.Leaderboard.playerIndex]);
        else
            leaderboard.playerIndex = -1;
        if (leaderboard.items != null && leaderboard.playerIndex > -1) {
            leaderboard.items[leaderboard.playerIndex].isPlayer = true;
            leaderboard.playerPosition = leaderboard.items[leaderboard.playerIndex].position
        }
        res.push(leaderboard)
    }
    return res
}
;
TournamentProtocol.TournamentParser.ParseLeaderboardItems = function(param) {
    var list = param;
    if (list == null) {
        console.error(TournamentProtocol.TournamentParser.errorMessage);
        return null
    }
    var res = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[TournamentProtocol.Dictionary.LeaderboardItem.position] == undefined || dict[TournamentProtocol.Dictionary.LeaderboardItem.playerID] == undefined || dict[TournamentProtocol.Dictionary.LeaderboardItem.score] == undefined) {
            console.error(TournamentProtocol.TournamentParser.errorMessage);
            continue
        }
        var item = new TournamentProtocol.LeaderboardItem;
        item.position = _number.otoi(dict[TournamentProtocol.Dictionary.LeaderboardItem.position]);
        item.playerID = String(dict[TournamentProtocol.Dictionary.LeaderboardItem.playerID]);
        item.score = _number.otod(dict[TournamentProtocol.Dictionary.LeaderboardItem.score]);
        res.push(item)
    }
    return res
}
;
TournamentProtocol.TournamentParser.ParseBaseResponse = function(json) {
    if (_string.IsNullOrEmpty(json))
        return null;
    var dict = JSON.parse(json);
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null)
        console.error(TournamentProtocol.TournamentParser.errorMessage);
    return response
}
;
goog.require("UHT.TournamentProtocol");
TournamentProtocol.ErrorCode = {
    Invalid: 500,
    None: 0,
    InvalidParameter: 1,
    TournamentNotFound: 2,
    ServiceError: 100
};
TournamentProtocol.StatusCode = {
    Open: 0,
    StartsSoon: 1,
    Closed: 2,
    Invalid: 3
};
TournamentProtocol.ClientMode = {
    Visible: 0,
    Hidden: 1,
    Invalid: 2
};
TournamentProtocol.ClientStyle = {
    Europe: 0,
    Asia: 1,
    Invalid: 2
};
TournamentProtocol.PromoType = {
    Race: 0,
    Tournament: 1,
    Invalid: 2
};
TournamentProtocol.Tournament = function() {
    this.id = 0;
    this.status = TournamentProtocol.StatusCode.Invalid;
    this.name = "";
    this.startDate = 0;
    this.endDate = 0;
    this.clientMode = TournamentProtocol.ClientMode.Invalid;
    this.clientStyle = TournamentProtocol.ClientStyle.Invalid;
    this.type = TournamentProtocol.PromoType.Invalid;
    this.uid = "";
    this.isOpted = true
}
;
TournamentProtocol.TournamentDetails = function() {
    this.id = 0;
    this.htmlRules = "";
    this.prizePool = null;
    this.uid = "";
    this.shortHtmlRules = ""
}
;
TournamentProtocol.PrizePool = function() {
    this.currency = "";
    this.prizesList = null;
    this.totalCount = 0;
    this.totalAmount = 0
}
;
TournamentProtocol.Prize = function() {
    this.placeFrom = 0;
    this.placeTo = 0;
    this.amount = 0;
    this.gift = "";
    this.count = 0
}
;
TournamentProtocol.Leaderboard = function() {
    this.tournamentID = 0;
    this.playerIndex = 0;
    this.playerPosition = 0;
    this.items = null;
    this.uid = ""
}
;
TournamentProtocol.LeaderboardItem = function() {
    this.position = 0;
    this.playerID = "";
    this.score = 0;
    this.isPlayer = false
}
;
TournamentProtocol.Request = function() {
    this.symbol = "";
    this.mgckey = ""
}
;
TournamentProtocol.Response = function(response) {
    this.error = TournamentProtocol.ErrorCode.Invalid;
    this.description;
    if (response != undefined) {
        this.error = response.error;
        this.description = response.description
    }
}
;
TournamentProtocol.TournamentsResponse = function(response) {
    TournamentProtocol.Response.call(this, response);
    this.tournaments = null;
    this.races = null;
    this.serverTime = 0
}
;
TournamentProtocol.TournamentsResponse.prototype = Object.create(TournamentProtocol.Response.prototype);
TournamentProtocol.TournamentsResponse.prototype.constructor = TournamentProtocol.TournamentsResponse;
TournamentProtocol.DetailsResponse = function(response) {
    TournamentProtocol.Response.call(this, response);
    this.details = null
}
;
TournamentProtocol.DetailsResponse.prototype = Object.create(TournamentProtocol.Response.prototype);
TournamentProtocol.DetailsResponse.prototype.constructor = TournamentProtocol.DetailsResponse;
TournamentProtocol.LeaderboardResponse = function(response) {
    TournamentProtocol.Response.call(this, response);
    this.leaderboards = null
}
;
TournamentProtocol.LeaderboardResponse.prototype = Object.create(TournamentProtocol.Response.prototype);
TournamentProtocol.LeaderboardResponse.prototype.constructor = TournamentProtocol.LeaderboardResponse;
var TournamentVars = {
    Tournaments: "Tournaments",
    Evt_Internal_TournamentsUpdated: "Evt_Internal_TournamentsUpdated",
    TournamentDetails: "TournamentDetails",
    TournamentLeaderboards: "TournamentLeaderboards",
    ServerTime: "ServerTime",
    SelectedTournamentID: "SelectedTournamentID",
    Evt_Internal_PromotionsAnnouncer_Prepare: "Evt_Internal_PromotionsAnnouncer_Prepare",
    Evt_Internal_PromotionsAnnouncer_Announce: "Evt_Internal_PromotionsAnnouncer_Announce",
    Evt_Internal_PromotionsAnnouncer_PrepareForWin: "Evt_Internal_PromotionsAnnouncer_PrepareForWin",
    Evt_Internal_PromotionsAnnouncer_ShowWin: "Evt_Internal_PromotionsAnnouncer_ShowWin",
    Evt_Internal_PromotionsAnnouncer_WinShown: "Evt_Internal_PromotionsAnnouncer_WinShown",
    Promotion_WinID: "Promotion_WinID",
    Promotion_WinReceived: "Promotion_WinReceived",
    Promotion_WinDisplayed: "Promotion_WinDisplayed",
    Promotion_GiftReceived: "Promotion_GiftReceived",
    PromotionRuleUnitsPooler: "PromotionRuleUnitsPooler",
    PromotionRuleLinkID: "PromotionRuleLinkID",
    Evt_Internal_PromotionRuleLink_Visited: "Evt_Internal_PromotionRuleLink_Visited",
    Evt_Internal_PromotionRuleLink_HoveredOn: "Evt_Internal_PromotionRuleLink_HoveredOn",
    Evt_Internal_PromotionRuleLink_HoveredOff: "Evt_Internal_PromotionRuleLink_HoveredOff",
    Evt_Internal_PromotionRuleLink_Pressed: "Evt_Internal_PromotionRuleLink_Pressed",
    Evt_Internal_PromotionRuleLink_Released: "Evt_Internal_PromotionRuleLink_Released"
};
goog.provide("UHT.TournamentRule");
function TournamentRule() {
    this.rules = "";
    this.sampleLabel = null;
    this.maxLabelWidth = 0;
    this.maxNumberOfLines = 0;
    this.isSplit = false;
    this.splitRules = [];
    this.paragraphs = [];
    this.isStopped = false
}
TournamentRule.prototype.UpdateRules = function(value) {
    if (this.rules == value)
        return;
    this.rules = value;
    this.splitRules.splice(0);
    this.isSplit = _string.IsNullOrEmpty(this.rules);
    if (!this.isSplit)
        this.SplitParagraphs()
}
;
TournamentRule.prototype.Split = function() {
    if (this.isSplit)
        return;
    this.splitRules = this.splitRules.concat(this.SplitToLines())
}
;
TournamentRule.prototype.GetSplitRules = function() {
    if (!this.isSplit)
        this.Split();
    return this.splitRules
}
;
TournamentRule.prototype.SplitParagraphs = function() {
    this.paragraphs.splice(0);
    this.paragraphs = this.paragraphs.concat(this.rules.split("\n"))
}
;
TournamentRule.prototype.SplitToLines = function() {
    this.isStopped = false;
    var res = [];
    for (var i = 0; i < this.paragraphs.length; ++i) {
        var words = this.paragraphs[i].split(" ");
        this.sampleLabel.text = "";
        if (words.length > 1) {
            this.SplitWords(res, words, i + 1);
            if (this.isStopped)
                return res
        } else {
            this.SplitChars(res, "", this.paragraphs[i], i + 1, null, 0);
            if (this.isStopped)
                return res
        }
    }
    this.isSplit = true;
    return res
}
;
TournamentRule.prototype.SplitWords = function(res, words, paragraphIdx) {
    var text = "";
    var labelTxt = "";
    for (var i = 0; i < words.length; ++i) {
        labelTxt = this.sampleLabel.text;
        this.sampleLabel.text = words[i];
        if (this.sampleLabel.GetWidth() <= this.maxLabelWidth) {
            this.sampleLabel.text = labelTxt + words[i];
            if (this.sampleLabel.GetWidth() <= this.maxLabelWidth) {
                text = this.sampleLabel.text;
                this.sampleLabel.text += " "
            } else {
                res.push(text);
                if (res.length >= this.maxNumberOfLines) {
                    this.StopAt(null, 0, words, i, paragraphIdx);
                    return
                }
                this.sampleLabel.text = "";
                text = "";
                i--
            }
        } else {
            this.sampleLabel.text = labelTxt;
            text = "";
            this.SplitChars(res, text, words[i], paragraphIdx, words, i);
            if (this.isStopped)
                return
        }
    }
    if (text != "") {
        res.push(text);
        if (res.length >= this.maxNumberOfLines)
            this.StopAt(null, 0, null, 0, paragraphIdx)
    }
}
;
TournamentRule.prototype.SplitChars = function(res, text, chars, paragraphIdx, words, wordIdx) {
    if (chars.length == 0) {
        res.push("");
        if (res.length >= this.maxNumberOfLines)
            this.StopAt(null, 0, null, 0, paragraphIdx);
        return
    }
    for (var i = 0; i < chars.length; ++i) {
        this.sampleLabel.text += chars[i];
        if (this.sampleLabel.GetWidth() <= this.maxLabelWidth)
            text = this.sampleLabel.text;
        else {
            res.push(text);
            if (res.length >= this.maxNumberOfLines) {
                this.StopAt(chars, i, words, wordIdx + 1, paragraphIdx);
                return
            }
            this.sampleLabel.text = "";
            text = "";
            i--
        }
    }
    if (text != "") {
        res.push(text);
        if (res.length >= this.maxNumberOfLines)
            this.StopAt(null, 0, null, 0, paragraphIdx)
    }
}
;
TournamentRule.prototype.StopAt = function(chars, charIdx, words, wordIdx, paragraphIdx) {
    var curParagraph = [];
    if (chars != null) {
        var c = "";
        for (var i = charIdx; i < chars.length; ++i)
            c += chars[i];
        if (!_string.IsNullOrEmpty(c))
            curParagraph.push(c)
    }
    if (words != null)
        for (var i = wordIdx; i < words.length; ++i)
            curParagraph.push(words[i]);
    var notProcessedParagraphs = [];
    if (curParagraph.length > 0)
        notProcessedParagraphs.push(curParagraph.join(" "));
    for (var i = paragraphIdx; i < this.paragraphs.length; ++i)
        notProcessedParagraphs.push(this.paragraphs[i]);
    this.paragraphs = notProcessedParagraphs;
    this.isStopped = true;
    this.isSplit = this.paragraphs.length == 0
}
;
goog.provide("UHT.PromotionRule");
goog.require("UHT.TournamentRule");
PromotionRule.prototype = Object.create(TournamentRule.prototype);
PromotionRule.prototype.constructor = PromotionRule;
function PromotionRule() {
    TournamentRule.call(this);
    this.uid = "";
    this.rulesText = "";
    this.links = [];
    this.lines = []
}
PromotionRule.Unit = function(arg0, arg1, arg2, arg3, arg4) {
    this.uid = "";
    this.text = "";
    this.url = "";
    this.startIdx = 0;
    this.endIdxExcl = 0;
    this.isLink = false;
    this.isVisited = false;
    if (arguments.length == 2 || arguments.length == 5) {
        this.text = arguments[0];
        this.SetURL(arguments[1])
    }
    if (arguments.length == 3) {
        this.text = arguments[0];
        this.startIdx = arguments[1];
        this.endIdxExcl = arguments[2]
    }
    if (arguments.length == 5) {
        this.uid = arguments[2];
        this.startIdx = arguments[3];
        this.endIdxExcl = arguments[4]
    }
}
;
PromotionRule.Unit.visitedURLs = [];
PromotionRule.Unit.prototype.SetURL = function(url) {
    this.url = url;
    this.isLink = !_string.IsNullOrEmpty(url);
    this.isVisited = PromotionRule.Unit.visitedURLs.indexOf(url) > -1
}
;
PromotionRule.Unit.prototype.SetVisited = function() {
    this.isVisited = true;
    PromotionRule.Unit.visitedURLs.push(this.url)
}
;
PromotionRule.Unit.prototype.CheckVisited = function() {
    if (!this.isVisited)
        this.isVisited = PromotionRule.Unit.visitedURLs.indexOf(this.url) > -1
}
;
PromotionRule.Line = function() {
    this.endIdxExcl = 0;
    this.units = []
}
;
PromotionRule.prototype.Split = function() {
    if (this.isSplit)
        return;
    var prevCount = this.splitRules.length;
    this.splitRules = this.splitRules.concat(this.SplitToLines());
    if (prevCount == 0)
        this.lines.push(this.ProcessLine(0, this.splitRules[0]));
    for (var i = this.lines.length; i < this.splitRules.length; ++i)
        this.lines.push(this.ProcessLine(this.lines[i - 1].endIdxExcl, this.splitRules[i]));
    if (this.isSplit) {
        this.splitRules.splice(0);
        this.rulesText = ""
    }
}
;
PromotionRule.prototype.GetSplitLines = function() {
    if (!this.isSplit)
        this.Split();
    return this.lines
}
;
PromotionRule.prototype.SplitParagraphs = function() {
    this.ProcessLinks();
    this.paragraphs.splice(0);
    this.paragraphs = this.paragraphs.concat(this.rulesText.split("\n"))
}
;
PromotionRule.prototype.ProcessLinks = function() {
    this.links.splice(0);
    this.lines.splice(0);
    var htmls = [];
    var htmlMatch = this.rules.match(/<a\s.*?>.*?<\/a\s*?>/gi);
    if (htmlMatch != null)
        for (var i = 0; i < htmlMatch.length; ++i) {
            var html = htmlMatch[i];
            var text = "";
            var url = "";
            var textMatch = html.match(/>.*?</i);
            if (textMatch != null)
                text = textMatch[0].replace(">", "").replace("<", "");
            var urlMatch = html.match(/\bhref=".*?"/i);
            if (urlMatch == null)
                urlMatch = html.match(/\bhref='.*?'/i);
            if (urlMatch != null)
                url = urlMatch[0].replace("href=", "").replace(/['"]/g, "");
            htmls.push(html);
            this.links.push(new PromotionRule.Unit(text,url))
        }
    this.rulesText = this.rules;
    for (var i = 0; i < this.links.length; ++i) {
        this.links[i].uid = this.uid + "Link#" + i;
        this.links[i].startIdx = this.rulesText.indexOf(htmls[i]);
        this.links[i].endIdxExcl = this.links[i].startIdx + this.links[i].text.length;
        this.rulesText = this.rulesText.substr(0, this.links[i].startIdx) + this.links[i].text + this.rulesText.substr(this.links[i].startIdx + htmls[i].length)
    }
}
;
PromotionRule.prototype.ProcessLine = function(startIdx, text) {
    var ret = new PromotionRule.Line;
    var units = [];
    startIdx += this.rulesText.substr(startIdx).indexOf(text);
    ret.endIdxExcl = startIdx + text.length;
    ret.units = units;
    var prevUnit = new PromotionRule.Unit(text,startIdx,ret.endIdxExcl);
    units.push(prevUnit);
    for (var i = 0; i < this.links.length; ++i) {
        if (this.links[i].endIdxExcl <= startIdx)
            continue;
        else if (this.links[i].startIdx >= ret.endIdxExcl)
            break;
        if (this.links[i].startIdx <= startIdx) {
            var endIdxEx = this.links[i].endIdxExcl > ret.endIdxExcl ? ret.endIdxExcl : this.links[i].endIdxExcl;
            prevUnit.uid = this.links[i].uid;
            prevUnit.text = this.rulesText.substr(startIdx, endIdxEx - startIdx);
            prevUnit.SetURL(this.links[i].url);
            prevUnit.endIdxExcl = endIdxEx
        } else if (this.links[i].startIdx > startIdx) {
            if (prevUnit.endIdxExcl < this.links[i].startIdx) {
                prevUnit = new PromotionRule.Unit(this.rulesText.substr(prevUnit.endIdxExcl, this.links[i].startIdx - prevUnit.endIdxExcl),prevUnit.endIdxExcl,this.links[i].startIdx);
                units.push(prevUnit)
            } else if (_string.IsNullOrEmpty(prevUnit.url)) {
                prevUnit.text = this.rulesText.substr(prevUnit.startIdx, this.links[i].startIdx - prevUnit.startIdx);
                prevUnit.endIdxExcl = this.links[i].startIdx
            }
            var unit = null;
            if (this.links[i].endIdxExcl > ret.endIdxExcl)
                unit = new PromotionRule.Unit(this.rulesText.substr(this.links[i].startIdx, ret.endIdxExcl - this.links[i].startIdx),this.links[i].url,this.links[i].uid,this.links[i].startIdx,ret.endIdxExcl);
            else
                unit = this.links[i];
            units.push(unit);
            prevUnit = unit
        }
    }
    if (prevUnit.endIdxExcl < ret.endIdxExcl)
        units.push(new PromotionRule.Unit(this.rulesText.substr(prevUnit.endIdxExcl, ret.endIdxExcl - prevUnit.endIdxExcl),prevUnit.endIdxExcl,ret.endIdxExcl));
    return ret
}
;
goog.require("UHT.Component");
ButtonAutoClicker.prototype = Object.create(Component.prototype);
ButtonAutoClicker.prototype.constructor = ButtonAutoClicker;
function ButtonAutoClicker() {
    Component.call(this);
    this.delay = 0;
    this.delayInAutoplay = 0;
    this.timeLeft = 0;
    this.started = false;
    this.isUsingShortDelay = false
}
ButtonAutoClicker.prototype.OnEnable = function() {
    this.isUsingShortDelay = XT.GetBool(Vars.Autoplay_SkipScreens) && XT.GetInt(Vars.AutoplaySpinsLeft) >= 0 || XT.GetBool(Vars.ContinuousSpin);
    this.timeLeft = this.isUsingShortDelay ? this.delayInAutoplay : this.delay;
    if (!this.isUsingShortDelay && this.delay > 29)
        this.started = false;
    else
        this.started = true
}
;
ButtonAutoClicker.prototype.Update = function() {
    if (this.started) {
        this.timeLeft -= Time.deltaTime;
        if (this.timeLeft < 0) {
            this.gameObject.SendMessage("OnClick");
            this.started = false
        }
    }
}
;
goog.require("UHT.Component");
goog.provide("UHT.MessageSender");
MessageSender.prototype = Object.create(Component.prototype);
MessageSender.prototype.constructor = MessageSender;
function MessageSender() {
    Component.call(this);
    this.animationEvents = [];
    this.onClickEvents = [];
    this.onEnabledEvents = []
}
MessageSender.prototype.SendMessageFromAnimation = function(id) {
    if (id >= this.animationEvents.length || id < 0)
        return;
    this.InternalSendMessage(this.animationEvents, id)
}
;
MessageSender.SendMessage = function(msg) {
    if (msg.eventReceiver != null && !_string.IsNullOrEmpty(msg.methodToCall))
        if (msg.useParam)
            msg.eventReceiver.SendMessage(msg.methodToCall, msg.paramString);
        else
            msg.eventReceiver.SendMessage(msg.methodToCall)
}
;
MessageSender.prototype.OnClick = function() {
    if (this.gameObject.collider == null || !this.gameObject.collider.enabled)
        return;
    if (this.onClickEvents.length <= 0)
        return;
    this.InternalSendMessageToAll(this.onClickEvents)
}
;
MessageSender.prototype.OnEnable = function() {
    if (this.onEnabledEvents == null || this.onEnabledEvents.length <= 0)
        return;
    this.InternalSendMessageToAll(this.onEnabledEvents)
}
;
MessageSender.prototype.InternalSendMessageToAll = function(data) {
    for (var i in data)
        this.InternalSendMessage(data, i)
}
;
MessageSender.prototype.InternalSendMessage = function(data, idx) {
    if (idx >= data.length || idx < 0)
        return;
    MessageSender.SendMessage(data[idx])
}
;
function MessageData(_receiver, _methodToCall, _useParam, _paramString) {
    this.eventReceiver = _receiver;
    this.useParam = _useParam;
    this.paramString = _paramString;
    this.methodToCall = _methodToCall
}
goog.require("UHT.CAT_Action");
goog.require("UHT.MessageSender");
CAT_Action_SendMessage.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SendMessage.prototype.constructor = CAT_Action_SendMessage;
function CAT_Action_SendMessage() {
    CAT_Action.call(this);
    this.data = null
}
CAT_Action_SendMessage.prototype.OnStateChanged_Running = function() {
    MessageSender.SendMessage(this.data);
    this.ChangeState(CATState.Finished)
}
;
goog.require("UHT.CAT_Action");
goog.require("UHT.MessageSender");
CAT_Action_SendMessageMultipleReceivers.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SendMessageMultipleReceivers.prototype.constructor = CAT_Action_SendMessageMultipleReceivers;
function CAT_Action_SendMessageMultipleReceivers() {
    CAT_Action.call(this);
    this.eventReceivers = [];
    this.methodToCall = "";
    this.useParam = false;
    this.paramString = ""
}
CAT_Action_SendMessageMultipleReceivers.prototype.OnStateChanged_Running = function() {
    for (var i in this.eventReceivers)
        MessageSender.SendMessage(new MessageData(this.eventReceivers[i],this.methodToCall,this.useParam,this.paramString));
    this.ChangeState(CATState.Finished)
}
;
goog.require("UHT.Component");
goog.require("UHT.MessageSender");
SendMessageToChildren.prototype = Object.create(Component.prototype);
SendMessageToChildren.prototype.constructor = SendMessageToChildren;
function SendMessageToChildren() {
    Component.call(this);
    this.broadcastToFirstChildOnly = true
}
SendMessageToChildren.prototype.SendToChildren = function(message) {
    var ind1 = message.indexOf("(");
    var ind2 = message.indexOf(")");
    var methodToCall = message.substring(0, ind1);
    var param = message.substring(ind1 + 1, ind2);
    for (var i = 0; i < (this.broadcastToFirstChildOnly ? 1 : this.gameObject.transform.childCount); i++) {
        var msg = new MessageData(this.gameObject.transform.children[i].gameObject,methodToCall,!_string.IsNullOrEmpty(param),param);
        MessageSender.SendMessage(msg)
    }
}
;
goog.provide("UHT.TwoFloatsAnimatedMonoBehaviour");
goog.require("UHT.Component");
CurveTwoValuesAnimator.prototype = Object.create(Component.prototype);
CurveTwoValuesAnimator.prototype.constructor = CurveTwoValuesAnimator;
TwoFloatsAnimatedMonoBehaviour.prototype = Object.create(Component.prototype);
TwoFloatsAnimatedMonoBehaviour.prototype.constructor = TwoFloatsAnimatedMonoBehaviour;
function CurveTwoValuesAnimator() {
    Component.call(this);
    this.animatedMemberTarget = null;
    this.curve_1 = null;
    this.curve_2 = null;
    this.Loop_1 = true;
    this.Loop_2 = true;
    this.isStarted_1 = false;
    this.startTime_1 = 0;
    this.lastKeyTime_1 = 0;
    this.isStarted_2 = false;
    this.startTime_2 = 0;
    this.lastKeyTime_2 = 0
}
function TwoFloatsAnimatedMonoBehaviour() {
    Component.call(this)
}
TwoFloatsAnimatedMonoBehaviour.prototype.SetAnimatedF_1 = function(val) {}
;
TwoFloatsAnimatedMonoBehaviour.prototype.SetAnimatedF_2 = function(val) {}
;
TwoFloatsAnimatedMonoBehaviour.prototype.ResetF_1 = function() {}
;
TwoFloatsAnimatedMonoBehaviour.prototype.ResetF_2 = function() {}
;
CurveTwoValuesAnimator.prototype.Awake = function() {
    this.lastKeyTime_1 = this.curve_1.keys[this.curve_1.keys.length - 1].time;
    this.lastKeyTime_2 = this.curve_2.keys[this.curve_2.keys.length - 1].time
}
;
CurveTwoValuesAnimator.prototype.StartCurveAnimation_1 = function() {
    this.isStarted_1 = true;
    this.startTime_1 = Time.time
}
;
CurveTwoValuesAnimator.prototype.StopCurveAnimation_1 = function() {
    this.isStarted_1 = false;
    this.animatedMemberTarget.ResetF_1()
}
;
CurveTwoValuesAnimator.prototype.StartCurveAnimation_2 = function() {
    this.isStarted_2 = true;
    this.startTime_2 = Time.time
}
;
CurveTwoValuesAnimator.prototype.StopCurveAnimation_2 = function() {
    this.isStarted_2 = false;
    this.animatedMemberTarget.ResetF_2()
}
;
CurveTwoValuesAnimator.prototype.Update = function() {
    var current_time = Time.time;
    if (this.isStarted_1) {
        if (this.isStarted_1) {
            var animF1 = this.curve_1.Evaluate(this.Loop_1 ? (current_time - this.startTime_1) % this.lastKeyTime_1 : UHTMath.clamp(current_time - this.startTime_1, 0, this.lastKeyTime_2));
            this.animatedMemberTarget.SetAnimatedF_1(animF1)
        }
        if (!this.Loop_1)
            if (current_time - this.startTime_1 > this.lastKeyTime_1)
                this.isStarted_1 = false
    }
    if (this.isStarted_2) {
        if (this.isStarted_2) {
            var animF2 = this.curve_2.Evaluate(this.Loop_2 ? (current_time - this.startTime_2) % this.lastKeyTime_2 : UHTMath.clamp(current_time - this.startTime_2, 0, this.lastKeyTime_2));
            this.animatedMemberTarget.SetAnimatedF_2(animF2)
        }
        if (!this.Loop_2)
            if (current_time - this.startTime_2 > this.lastKeyTime_2)
                this.isStarted_2 = false
    }
}
;
goog.provide("UHT.Globals");
function Globals() {}
Globals.InputBlocked = true;
Globals.timeChannels = [];
Globals.isMobile = false;
Globals.isMini = false;
Globals.GamePaused = false;
Globals.SetLayerRecursively = function(obj, layer) {
    if (obj.layer != layer)
        obj.transform.SetAllDirtyUserFlags();
    obj.layer = layer;
    for (var i = 0; i < obj.transform.children.length; i++)
        Globals.SetLayerRecursively(obj.transform.children[i].gameObject, layer)
}
;
Globals.GetCameraForObject = function(go) {
    var allCameras = Camera.allCameras;
    var layerMask = 1 << go.layer;
    for (var i = 0; i < allCameras.length; i++)
        if (allCameras[i].cullingMask == layerMask)
            return allCameras[i];
    return null
}
;
Globals.RegisterToTimeChannel = function(mb, id) {
    for (var i = 0; i < Globals.timeChannels.length; i++)
        if (Globals.timeChannels[i].id == id) {
            for (var jm = 0; jm < Globals.timeChannels[i].members.length; jm++)
                if (Globals.timeChannels[i].members[jm] == mb)
                    return Globals.timeChannels[i];
            Globals.timeChannels[i].members.push(mb);
            return Globals.timeChannels[i]
        }
    var tc = new TimeChannel(id);
    tc.members.push(mb);
    Globals.timeChannels.push(tc);
    return tc
}
;
Globals.UnregisterFromTimeChannel = function(mb, id) {
    for (var i = 0; i < Globals.timeChannels.length; i++)
        if (Globals.timeChannels[i].id == id) {
            var idx = Globals.timeChannels[i].members.indexOf(mb);
            Globals.timeChannels[i].members.splice(idx, 1);
            if (Globals.timeChannels[i].members.length == 0)
                Globals.timeChannels.splice(i, 1);
            return
        }
}
;
function TimeChannel(id) {
    this.id = id;
    this.members = [];
    this.currentTime = 0
}
TimeChannel.prototype.IsChannelMaster = function(mb) {
    return this.members[0] == mb
}
;
goog.provide("UHT.UICamera");
goog.require("UHT.Component");
goog.require("UHT.Collider");
goog.require("UHT.Globals");
UICamera.prototype = Object.create(Component.prototype);
UICamera.prototype.constructor = UICamera;
function UICamera() {
    Component.call(this);
    this.eventReceiverMask = null;
    this.target = null;
    this.mousePosOnPress = null;
    this.mouseWasPressed = false;
    this.mouseWasDragged = false;
    this.mouseIsOverTarget = false;
    this.cachedCamera = null;
    this.mustGoFullscreen = false
}
UICamera.messageHover = "OnHover";
UICamera.messagePress = "OnPress";
UICamera.messageClick = "OnClick";
UICamera.allUICameras = [];
UICamera.lastProcessedFrameCount = -1;
UICamera.prototype.OnEnable = function() {
    this.cachedCamera = this.GetComponent(Camera);
    var pos = 0;
    for (var i = 0; i < UICamera.allUICameras.length; i++)
        if (UICamera.allUICameras[i].cachedCamera.depth < this.cachedCamera.depth)
            pos++;
        else
            break;
    UICamera.allUICameras.splice(pos, 0, this)
}
;
UICamera.prototype.OnDisable = function() {
    for (var i = 0; i < UICamera.allUICameras.length; i++)
        if (UICamera.allUICameras[i] == this) {
            UICamera.allUICameras.splice(i, 1);
            break
        }
}
;
UICamera.prototype.Update = function() {
    if (Time.frameCount != UICamera.lastProcessedFrameCount) {
        UICamera.lastProcessedFrameCount = Time.frameCount;
        for (var i = UICamera.allUICameras.length - 1; i >= 0; i--) {
            if (Globals.InputBlocked && !UICamera.allUICameras[i].cachedCamera.ignoreInputBlocked)
                continue;
            var stop = UICamera.allUICameras[i].UpdateCamera();
            if (stop)
                break
        }
    }
}
;
UICamera.prototype.UpdateCamera = function() {
    var hoveredCollider = null;
    var skipGettingCollider = false;
    if (this.cachedCamera.IsClippingInput()) {
        var TL = new UHTMath.Vector3(-this.cachedCamera.extraCameraSettings.clipLeft,this.cachedCamera.extraCameraSettings.clipUp,0);
        var BR = new UHTMath.Vector3(this.cachedCamera.extraCameraSettings.clipRight,-this.cachedCamera.extraCameraSettings.clipDown,0);
        var TLW = this.gameObject.transform.transformPoint(TL);
        var BRW = this.gameObject.transform.transformPoint(BR);
        var TLS = this.cachedCamera.WorldToScreenPoint(TLW);
        var BRS = this.cachedCamera.WorldToScreenPoint(BRW);
        if (Input.mousePosition.x < TLS.x || Input.mousePosition.y < TLS.y || Input.mousePosition.x > BRS.x || Input.mousePosition.y > BRS.y)
            skipGettingCollider = true
    }
    if (!skipGettingCollider)
        hoveredCollider = globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), this.eventReceiverMask);
    if (Input.GetMouseButton(0)) {
        this.mouseWasPressed = true;
        if (Input.GetMouseButtonDown(0)) {
            if (this.target == null)
                this.target = hoveredCollider;
            if (this.target != null)
                this.target.gameObject.SendMessage(UICamera.messagePress, true);
            this.mousePosOnPress = new UHTMath.Vector3(Input.mousePosition);
            this.mouseWasDragged = false;
            this.mouseIsOverTarget = true
        }
    } else if (this.mouseWasPressed == true) {
        this.mouseWasPressed = false;
        if (this.target != null) {
            this.target.gameObject.SendMessage(UICamera.messagePress, false);
            if (hoveredCollider == this.target) {
                if (Input.lastUsedInputDeviceIsTouch == false)
                    this.target.gameObject.SendMessage(UICamera.messageHover, true);
                if (this.mouseWasDragged == false)
                    this.target.gameObject.SendMessage(UICamera.messageClick)
            }
            this.target = null
        }
    } else if (Input.lastUsedInputDeviceIsTouch == false && hoveredCollider != this.target) {
        if (this.target != null)
            this.target.gameObject.SendMessage(UICamera.messageHover, false);
        this.target = hoveredCollider;
        if (this.target != null)
            this.target.gameObject.SendMessage(UICamera.messageHover, true)
    }
    return hoveredCollider != null
}
;
goog.provide("UHT.Engine");
goog.require("UHT.Tracking");
goog.require("UHT.Globals");
goog.require("UHT.System.Misc.Utils");
goog.require("UHT.Component");
goog.require("UHT.GameObject");
goog.require("UHT.AnimationUtils");
goog.require("UHT.TextAsset");
goog.require("UHT.Input");
goog.require("UHT.UHTScreen");
goog.require("UHT.Animation");
goog.require("UHT.UIUtils");
goog.require("UHT.UIAtlas");
goog.require("UHT.UILabel");
goog.require("UHT.UICamera");
goog.require("UHT.UIPanel");
goog.require("UHT.UISprite");
goog.require("UHT.UIZoomSprite");
goog.require("UHT.UIButton");
goog.require("UHT.UIRoot");
goog.require("UHT.UIFont");
goog.require("UHT.UIButtonScale");
goog.require("UHT.UIInput");
goog.require("UHT.Gradient");
goog.require("UHT.UHTEngine");
goog.require("UHT.Engine");
goog.require("UHT.CAT_Action");
goog.require("UHT.AnimationUtils");
CAT_Action_StartAnim.prototype = Object.create(CAT_Action.prototype);
CAT_Action_StartAnim.prototype.constructor = CAT_Action_StartAnim;
function CAT_Action_StartAnim() {
    CAT_Action.call(this);
    this.target = null;
    this.animClipName = "";
    this.mode = WrapMode.Default;
    this.speed = 1
}
CAT_Action_StartAnim.prototype.OnStateChanged_Running = function() {
    if (this.target == null || this.animClipName == "" || this.target.animation == null) {
        this.ChangeState(CATState.Finished);
        return
    }
    if (!this.target.activeInHierarchy)
        console.error("Trying to start an animation on an inactive object (" + this.target.name + "). This is undefined behaviour!");
    var anim = this.target.animation;
    anim.Stop();
    anim.GetAnimationState(this.animClipName).wrapMode = this.mode;
    anim.GetAnimationState(this.animClipName).speed = this.speed;
    if (this.speed < 0)
        anim.GetAnimationState(this.animClipName).time = anim.GetAnimationState(this.animClipName).length;
    anim.Play(this.animClipName)
}
;
CAT_Action_StartAnim.prototype.OnStateChanged_Stopping = function() {
    if (this.target != null && this.target.animation != null && this.target.animation.isPlaying)
        this.target.animation.Stop();
    this.ChangeState(CATState.Finished)
}
;
CAT_Action_StartAnim.prototype.CATUpdate = function() {
    if (this.GetState() == CATState.Running)
        if (this.target.animation.isPlaying == false)
            this.ChangeState(CATState.Finished)
}
;
goog.require("UHT.Engine");
goog.require("UHT.CAT_Action");
CAT_Action_SwitchLayer.prototype = Object.create(CAT_Action.prototype);
CAT_Action_SwitchLayer.prototype.constructor = CAT_Action_SwitchLayer;
function CAT_Action_SwitchLayer() {
    CAT_Action.call(this);
    this.newLayer = null;
    this.root = null
}
CAT_Action_SwitchLayer.prototype.OnStateChanged_Running = function() {
    Globals.SetLayerRecursively(this.root, this.newLayer.value());
    this.ChangeState(CATState.Finished)
}
;
goog.require("UHT.Engine");
var BehaviourMessage2CATMessage = {
    None: 0,
    Awake: 1,
    Start: 2,
    Update: 3,
    LateUpdate: 4,
    Disable: 5,
    Enable: 6
};
var BehaviourMessage2CATActionType = {
    None: 0,
    StartOnMessage: 1,
    StopOnMessage: 2
};
function BehaviourMessage2CATLink() {
    this.cat = null;
    this.message = BehaviourMessage2CATMessage.None;
    this.actionType = BehaviourMessage2CATActionType.None
}
BehaviourMessage2CAT.prototype = Object.create(Component.prototype);
BehaviourMessage2CAT.prototype.constructor = BehaviourMessage2CAT;
function BehaviourMessage2CAT() {
    Component.call(this);
    this.cats = null
}
BehaviourMessage2CAT.prototype.Awake = function() {
    this.DoIt(BehaviourMessage2CATMessage.Awake)
}
;
BehaviourMessage2CAT.prototype.Start = function() {
    this.DoIt(BehaviourMessage2CATMessage.Start)
}
;
BehaviourMessage2CAT.prototype.Update = function() {
    this.DoIt(BehaviourMessage2CATMessage.Update)
}
;
BehaviourMessage2CAT.prototype.LateUpdate = function() {
    this.DoIt(BehaviourMessage2CATMessage.LateUpdate)
}
;
BehaviourMessage2CAT.prototype.OnDisable = function() {
    this.DoIt(BehaviourMessage2CATMessage.Disable)
}
;
BehaviourMessage2CAT.prototype.OnEnable = function() {
    this.DoIt(BehaviourMessage2CATMessage.Enable)
}
;
BehaviourMessage2CAT.prototype.DoIt = function(msg) {
    for (var i = 0; i < this.cats.length; ++i) {
        if (this.cats[i].message != msg || this.cats[i].cat == null)
            continue;
        if (this.cats[i].actionType == BehaviourMessage2CATActionType.StartOnMessage)
            this.cats[i].cat.Start();
        if (this.cats[i].actionType == BehaviourMessage2CATActionType.StopOnMessage)
            this.cats[i].cat.Stop()
    }
}
;
goog.require("UHT.Engine");
CatTestHelper.prototype = Object.create(Component.prototype);
CatTestHelper.prototype.constructor = CatTestHelper;
function CatTestHelper() {
    Component.call(this);
    this.eventIdToTest = 0
}
CatTestHelper.prototype.Awake = function() {
    var cat = this.gameObject.GetComponent(CAT_Container);
    if (cat != null) {
        this.eventIdToTest = new CATLink;
        this.eventIdToTest.cat = cat
    }
}
;
CatTestHelper.prototype.Start = function() {}
;
goog.provide("UHT.CAT_ContainerInterface");
goog.require("UHT.Engine");
CAT_ContainerInterface.prototype = Object.create(Component.prototype);
CAT_ContainerInterface.prototype.constructor = CAT_ContainerInterface;
function CAT_ContainerInterface() {
    Component.call(this)
}
CAT_ContainerInterface.prototype.IsEventRunning = function(id) {}
;
CAT_ContainerInterface.prototype.StartEvent = function(id) {}
;
CAT_ContainerInterface.prototype.StopEvent = function(id) {}
;
CAT_ContainerInterface.prototype.StopAllRunningEvents = function() {}
;
CAT_ContainerInterface.prototype.RegisterCallback = function(eventId, newCallback, object) {}
;
CAT_ContainerInterface.prototype.UnregisterCallback = function(eventId, toRemoveCallback, object) {}
;
CAT_ContainerInterface.prototype.StartEventByMessage = function(id) {
    this.StartEvent(_number.otoi(id))
}
;
goog.require("UHT.CAT_ContainerInterface");
CAT_Container.prototype = Object.create(CAT_ContainerInterface.prototype);
CAT_Container.prototype.constructor = CAT_Container;
function CAT_Container() {
    CAT_ContainerInterface.call(this);
    this.events = [];
    this.runningEvents = []
}
CAT_Container.prototype.scriptUpdatePriority = 9;
CAT_Container.prototype.IsEventRunning = function(id) {
    return this.GetEventByID(id).isRunning
}
;
CAT_Container.prototype.StartEvent = function(id) {
    this.GetEventByID(id).Start()
}
;
CAT_Container.prototype.StopEvent = function(id) {
    this.GetEventByID(id).Stop()
}
;
CAT_Container.prototype.StopAllRunningEvents = function() {
    for (var i = 0; i < this.runningEvents.length; i++)
        this.runningEvents[i].Stop()
}
;
CAT_Container.prototype.Awake = function() {
    for (var evIndex = 0; evIndex < this.events.length; evIndex++)
        for (var evtIndex = evIndex + 1; evtIndex < this.events.length; evtIndex++)
            if (this.events[evIndex].id == this.events[evtIndex].id)
                console.error("Cat_Container " + this.gameObject.name + " has duplicate Event IDs!")
}
;
CAT_Container.prototype.OnEnable = function() {
    for (var i = 0; i < this.events.length; i++)
        if (this.events[i].playAutomatically)
            this.events[i].Start()
}
;
CAT_Container.prototype.OnDisable = function() {
    this.StopAllRunningEvents()
}
;
CAT_Container.prototype.Update = function() {
    var i = this.runningEvents.length;
    while (i--)
        this.runningEvents[i].Update()
}
;
CAT_Container.prototype.RegisterCallback = function(eventId, newCallback, object) {
    this.GetEventByID(eventId).RegisterCallback(newCallback, object)
}
;
CAT_Container.prototype.UnregisterCallback = function(eventId, toRemoveCallback, object) {
    this.GetEventByID(eventId).UnregisterCallback(toRemoveCallback, object)
}
;
CAT_Container.prototype.GetEventByID = function(id) {
    for (var i = 0; i < this.events.length; i++)
        if (this.events[i].id == id)
            return this.events[i];
    return null
}
;
CAT_Container.prototype.AddRunningEvent = function(event) {
    this.runningEvents.push(event)
}
;
CAT_Container.prototype.RemoveRunningEvent = function(event) {
    if (this.runningEvents.indexOf(event) != -1)
        this.runningEvents.splice(this.runningEvents.indexOf(event), 1)
}
;
CAT_Container.prototype.AfterDeserialize = function() {
    for (var i = 0; i < this.events.length; i++)
        this.events[i].SetParent(this)
}
;
CAT_Container.prototype.DisableEvent = function(id) {
    this.GetEventByID(Number(id)).isEnabled = false
}
;
goog.require("UHT.CAT_ContainerInterface");
CAT_Container_Proxy.prototype = Object.create(CAT_ContainerInterface.prototype);
CAT_Container_Proxy.prototype.constructor = CAT_Container_Proxy;
function CAT_Container_Proxy() {
    CAT_ContainerInterface.call(this);
    this.con = null
}
CAT_Container_Proxy.prototype.IsEventRunning = function(id) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null)
        return this.con.IsEventRunning(id);
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject);
    return false
}
;
CAT_Container_Proxy.prototype.StartEvent = function(id) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.StartEvent(id);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
}
;
CAT_Container_Proxy.prototype.StopEvent = function(id) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.StopEvent(id);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
}
;
CAT_Container_Proxy.prototype.StopAllRunningEvents = function() {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.StopAllRunningEvents();
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
}
;
CAT_Container_Proxy.prototype.RegisterCallback = function(eventId, newCallback, object) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.RegisterCallback(eventId, newCallback, object);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
}
;
CAT_Container_Proxy.prototype.UnregisterCallback = function(eventId, toRemoveCallback, object) {
    this.con = this.GetComponentInChildren(CAT_Container);
    if (this.con != null) {
        this.con.UnregisterCallback(eventId, toRemoveCallback, object);
        return
    }
    console.log("CAT_Container_Proxy: No container found in children!" + this.gameObject)
}
;
goog.require("UHT.Engine");
XTButton.prototype = Object.create(Component.prototype);
XTButton.prototype.constructor = XTButton;
var XTButtonAction = {
    OnClick: 0,
    OnPress: 1
};
function XTButton() {
    Component.call(this);
    this.action = XTButtonAction.OnClick;
    this.eventToCode = null;
    this.useParam = false;
    this.param = null;
    this.paramValue = 0
}
XTButton.prototype.OnClick = function() {
    if (this.action == XTButtonAction.OnClick) {
        var cd = this.gameObject.GetComponent(ClickDelay);
        if (cd == null || cd.CanClick())
            this.DoIt()
    }
}
;
XTButton.prototype.OnPress = function(isPressed) {
    if (isPressed && this.action == XTButtonAction.OnPress)
        this.DoIt()
}
;
XTButton.prototype.DoIt = function() {
    if (this.useParam)
        XT.SetInt(this.param.name, this.paramValue);
    XT.TriggerEvent(this.eventToCode.name)
}
;
goog.provide("UHT.XTLink");
goog.require("UHT.Engine");
XTLink.prototype = Object.create(Component.prototype);
XTLink.prototype.constructor = XTLink;
function XTLink() {
    Component.call(this);
    this.isRegisteredAndInited = false;
    this.xtEnabled = true
}
XTLink.prototype.XTRegisterCallbacksBase = function() {
    this.isRegisteredAndInited = true;
    this.XTRegisterCallbacks()
}
;
XTLink.prototype.XTRegisterCallbacks = function() {}
;
XTLink.prototype.XTInitVariablesAndEvents = function() {}
;
XTLink.prototype.OnDestroy = function() {}
;
XTLink.prototype.Awake = function() {
    if (XT.RegisterAndInitDone && !this.isRegisteredAndInited) {
        this.XTRegisterCallbacksBase();
        this.XTInitVariablesAndEvents()
    }
}
;
goog.require("UHT.XTLink");
function StageTransition2CATDesc() {
    this.cat = null;
    this.fromStage = UHTStageName.No_Stage;
    this.toStage = UHTStageName.No_Stage
}
StageTransition2CAT.prototype = Object.create(XTLink.prototype);
StageTransition2CAT.prototype.constructor = StageTransition2CAT;
function StageTransition2CAT() {
    XTLink.call(this);
    this.transitions = null
}
StageTransition2CAT.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.ToStageName, this.OnToStageChanged, this)
}
;
StageTransition2CAT.prototype.OnToStageChanged = function(toStageName) {
    var fromStageName = XT.GetObject(Vars.FromStageName);
    for (var i = 0; i < this.transitions.length; ++i)
        if (this.transitions[i].fromStage == fromStageName && this.transitions[i].toStage == toStageName && this.transitions[i].cat != null)
            this.transitions[i].cat.Start()
}
;
goog.require("UHT.XTLink");
XT2CAT.prototype = Object.create(XTLink.prototype);
XT2CAT.prototype.constructor = XT2CAT;
function XT2CAT() {
    XTLink.call(this);
    this.actionType = XT2CAT.ActionType.StartOnEvent;
    this.xtEventName = null;
    this.catLink = null
}
XT2CAT.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(this.xtEventName.name, this.OnEventTriggered, this)
}
;
XT2CAT.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnEventTriggered, this)
}
;
XT2CAT.prototype.OnEventTriggered = function() {
    if (!this.gameObject.activeInHierarchy)
        return;
    if (this.actionType == XT2CAT.ActionType.StartOnEvent)
        this.catLink.Start();
    else if (this.actionType == XT2CAT.ActionType.StopOnEvent)
        this.catLink.Stop()
}
;
XT2CAT.ActionType = {
    None: 0,
    StartOnEvent: 1,
    StopOnEvent: 2
};
goog.require("UHT.XTLink");
var XTVariable2CATType = {
    XT_Double: 0,
    XT_Float: 1,
    XT_Int: 2,
    XT_Bool: 3,
    XT_Object: 4,
    XT_String: 5,
    None: 6
};
var XTVariable2CATActionType = {
    None: 0,
    StartOnCondition: 1,
    StopOnCondition: 2
};
XTVariable2CAT.prototype = Object.create(XTLink.prototype);
XTVariable2CAT.prototype.constructor = XTVariable2CAT;
function XTVariable2CAT() {
    XTLink.call(this);
    this.actionType = XTVariable2CATActionType.StartOnCondition;
    this.variableType = XTVariable2CATType.None;
    this.variableName = "";
    this.value = "";
    this.less = null;
    this.lessOrEquals = null;
    this.equals = null;
    this.notEquals = null;
    this.greaterOrEquals = null;
    this.greater = null;
    this.isNull = null;
    this.isNotNull = null;
    this.valueDouble = 0;
    this.valueFloat = 0;
    this.valueInt = 0;
    this.valueBool = false
}
XTVariable2CAT.prototype.XTRegisterCallbacks = function() {
    switch (this.variableType) {
    case XTVariable2CATType.XT_Bool:
        this.valueBool = _bool.Parse(this.value);
        XT.RegisterCallbackBool(this.variableName, this.CallbackBool, this);
        break;
    case XTVariable2CATType.XT_Double:
        this.valueDouble = _number.otod(this.value);
        XT.RegisterCallbackDouble(this.variableName, this.CallbackDouble, this);
        break;
    case XTVariable2CATType.XT_Float:
        this.valueFloat = _number.otod(this.value);
        XT.RegisterCallbackFloat(this.variableName, this.CallbackFloat, this);
        break;
    case XTVariable2CATType.XT_Int:
        this.valueInt = _number.otoi(this.value);
        XT.RegisterCallbackInt(this.variableName, this.CallbackInt, this);
        break;
    case XTVariable2CATType.XT_Object:
        XT.RegisterCallbackObject(this.variableName, this.CallbackObject, this);
        break;
    case XTVariable2CATType.XT_String:
        XT.RegisterCallbackString(this.variableName, this.CallbackString, this);
        break
    }
}
;
XTVariable2CAT.prototype.CallbackBool = function(param) {
    this.DoIt(this.equals, param == this.valueBool);
    this.DoIt(this.notEquals, param != this.valueBool)
}
;
XTVariable2CAT.prototype.CallbackObject = function(param) {
    this.DoIt(this.isNull, param == null);
    this.DoIt(this.isNotNull, param != null)
}
;
XTVariable2CAT.prototype.CallbackString = function(param) {
    this.DoIt(this.equals, param == this.value);
    this.DoIt(this.notEquals, param != this.value);
    this.DoIt(this.isNull, param == null);
    this.DoIt(this.isNotNull, param != null)
}
;
XTVariable2CAT.prototype.CallbackInt = function(param) {
    this.DoIt(this.less, param < this.valueInt);
    this.DoIt(this.lessOrEquals, param <= this.valueInt);
    this.DoIt(this.equals, param == this.valueInt);
    this.DoIt(this.notEquals, param != this.valueInt);
    this.DoIt(this.greaterOrEquals, param >= this.valueInt);
    this.DoIt(this.greater, param > this.valueInt)
}
;
XTVariable2CAT.prototype.CallbackFloat = function(param) {
    this.DoIt(this.less, param < this.valueFloat);
    this.DoIt(this.lessOrEquals, param <= this.valueFloat);
    this.DoIt(this.equals, param == this.valueFloat);
    this.DoIt(this.notEquals, param != this.valueFloat);
    this.DoIt(this.greaterOrEquals, param >= this.valueFloat);
    this.DoIt(this.greater, param > this.valueFloat)
}
;
XTVariable2CAT.prototype.CallbackDouble = function(param) {
    this.DoIt(this.less, param < this.valueDouble);
    this.DoIt(this.lessOrEquals, param <= this.valueDouble);
    this.DoIt(this.equals, param == this.valueDouble);
    this.DoIt(this.notEquals, param != this.valueDouble);
    this.DoIt(this.greaterOrEquals, param >= this.valueDouble);
    this.DoIt(this.greater, param > this.valueDouble)
}
;
XTVariable2CAT.prototype.DoIt = function(cat, conditionMet) {
    if (cat == null || !conditionMet)
        return;
    switch (this.actionType) {
    case XTVariable2CATActionType.StartOnCondition:
        cat.Start();
        break;
    case XTVariable2CATActionType.StopOnCondition:
        cat.Stop();
        break
    }
}
;
goog.require("UHT.XTLink");
VarDisplayer.prototype = Object.create(XTLink.prototype);
VarDisplayer.prototype.constructor = VarDisplayer;
var VarType = {
    XT_Int: 0,
    XT_Float: 1,
    XT_Double: 2,
    XT_String: 3
};
function VarDisplayer() {
    XTLink.call(this);
    this.type = VarType.XT_Int;
    this.variable = null;
    this.label = null
}
VarDisplayer.prototype.XTRegisterCallbacks = function() {
    switch (this.type) {
    case VarType.XT_Int:
        XT.RegisterCallbackInt(this.variable.name, this.OnTargetValueChangedInt, this);
        break;
    case VarType.XT_Float:
        XT.RegisterCallbackFloat(this.variable.name, this.OnTargetValueChangedFloat, this);
        break;
    case VarType.XT_Double:
        XT.RegisterCallbackDouble(this.variable.name, this.OnTargetValueChangedFloat, this);
        break;
    case VarType.XT_String:
        XT.RegisterCallbackString(this.variable.name, this.OnTargetValueChangedString, this);
        break;
    default:
        console.warn("The " + this.type + " case was not implemented.");
        break
    }
}
;
VarDisplayer.prototype.OnDestroy = function() {
    switch (this.type) {
    case VarType.XT_Int:
        XT.UnregisterCallbackInt(this.OnTargetValueChangedInt, this);
        break;
    case VarType.XT_Float:
        XT.UnregisterCallbackFloat(this.OnTargetValueChangedFloat, this);
        break;
    case VarType.XT_Double:
        XT.UnregisterCallbackDouble(this.OnTargetValueChangedFloat, this);
        break;
    case VarType.XT_String:
        XT.UnregisterCallbackString(this.OnTargetValueChangedString, this);
        break;
    default:
        console.warn("The " + this.type + " case was not implemented.");
        break
    }
}
;
VarDisplayer.prototype.OnTargetValueChangedInt = function(newVal) {
    this.label.text = newVal.toString()
}
;
VarDisplayer.prototype.OnTargetValueChangedFloat = function(newVal) {
    this.label.text = newVal.toString()
}
;
VarDisplayer.prototype.OnTargetValueChangedString = function(newVal) {
    this.label.text = newVal
}
;
goog.require("UHT.Engine");
var XTLinkActivatorAction = {
    None: 0,
    ActivateAll: 1,
    DeactivateAll: 2
};
XTLinkActivator.prototype = Object.create(Component.prototype);
XTLinkActivator.prototype.constructor = XTLinkActivator;
function XTLinkActivator() {
    Component.call(this);
    this.list = null;
    this.includeChildren = true;
    this.excludeArrangeables = true;
    this.awakeAction = XTLinkActivatorAction.None
}
XTLinkActivator.prototype.Activate = function(index, enabled) {
    index = _number.otoi(index);
    enabled = enabled == undefined ? true : enabled;
    var links;
    if (this.includeChildren)
        links = this.list[index].GetComponentsInChildren(XTLink, true);
    else
        links = this.list[index].GetComponents(XTLink);
    for (var i = 0; i < links.length; ++i) {
        if (this.excludeArrangeables && links[i]instanceof ArrangeableBase)
            continue;
        links[i].xtEnabled = enabled
    }
}
;
XTLinkActivator.prototype.Deactivate = function(index) {
    this.Activate(index, false)
}
;
XTLinkActivator.prototype.ActivateAll = function() {
    for (var i = 0; i < this.list.length; ++i)
        this.Activate(i, true)
}
;
XTLinkActivator.prototype.DeactivateAll = function() {
    for (var i = 0; i < this.list.length; ++i)
        this.Activate(i, false)
}
;
XTLinkActivator.prototype.Awake = function() {
    switch (this.awakeAction) {
    case XTLinkActivatorAction.ActivateAll:
        this.ActivateAll();
        break;
    case XTLinkActivatorAction.DeactivateAll:
        this.DeactivateAll();
        break
    }
}
;
goog.provide("UHT.ArrangeableBase");
goog.require("UHT.XTLink");
ArrangeableBase.prototype = Object.create(XTLink.prototype);
ArrangeableBase.prototype.constructor = ArrangeableBase;
function ArrangeableBase() {
    XTLink.call(this);
    this.useOnMobile = true;
    this.useOnDesktop = false
}
ArrangeableBase.prototype.XTRegisterCallbacks = function() {
    if (this.useOnMobile && Globals.isMobile || this.useOnDesktop && !Globals.isMobile) {
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout, this.OnSwitchToLandscape, this);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.OnSwitchToLandscapeWide, this);
        XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.OnSwitchToLandscapeWideFull, this);
        if (this.useOnMobile && Globals.isMobile) {
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout, this.OnSwitchToPortrait, this);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone, this.OnSwitchToPortraitIPhone, this);
            XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.OnSwitchToPortraitIPad, this)
        }
    }
}
;
ArrangeableBase.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSwitchToLandscape, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToLandscapeWide, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToPortrait, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToPortraitIPhone, this);
    XT.UnregisterCallbackEvent(this.OnSwitchToPortraitIPad, this)
}
;
ArrangeableBase.prototype.OnSwitchToPortrait = function() {}
;
ArrangeableBase.prototype.OnSwitchToLandscape = function() {}
;
ArrangeableBase.prototype.OnSwitchToLandscapeWide = function() {
    this.OnSwitchToLandscape()
}
;
ArrangeableBase.prototype.OnSwitchToLandscapeWideFull = function() {
    this.OnSwitchToLandscapeWide()
}
;
ArrangeableBase.prototype.OnSwitchToPortraitIPhone = function() {
    this.OnSwitchToPortrait()
}
;
ArrangeableBase.prototype.OnSwitchToPortraitIPad = function() {
    this.OnSwitchToPortraitIPhone()
}
;
goog.require("UHT.ArrangeableBase");
ArrangeableActive.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableActive.prototype.constructor = ArrangeableActive;
function ArrangeableActive() {
    ArrangeableBase.call(this);
    this.activeInLandscape = false;
    this.activeInPortrait = false
}
ArrangeableActive.prototype.OnSwitchToPortrait = function() {
    this.gameObject.SetActive(this.activeInPortrait)
}
;
ArrangeableActive.prototype.OnSwitchToLandscape = function() {
    this.gameObject.SetActive(this.activeInLandscape)
}
;
goog.require("UHT.ArrangeableBase");
ArrangeableCameraSettings.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableCameraSettings.prototype.constructor = ArrangeableCameraSettings;
function ArrangeableCameraSettings() {
    ArrangeableBase.call(this);
    this._extraCameraSettings = null;
    this._landscapeClipUp = -1;
    this._landscapeClipDown = -1;
    this._landscapeClipLeft = -1;
    this._landscapeClipRight = -1;
    this._portraitClipUp = -1;
    this._portraitClipDown = -1;
    this._portraitClipLeft = -1;
    this._portraitClipRight = -1;
    this.separateForIPhone = false;
    this._portraitIPhoneClipUp = -1;
    this._portraitIPhoneClipDown = -1;
    this._portraitIPhoneClipLeft = -1;
    this._portraitIPhoneClipRight = -1;
    this.separateForIPad = false;
    this._portraitIPadClipUp = -1;
    this._portraitIPadClipDown = -1;
    this._portraitIPadClipLeft = -1;
    this._portraitIPadClipRight = -1;
    this.separateForLandscapeWide = false;
    this._landscapeWideClipUp = -1;
    this._landscapeWideClipDown = -1;
    this._landscapeWideClipLeft = -1;
    this._landscapeWideClipRight = -1;
    this.separateForLandscapeWideFull = false;
    this._landscapeWideFullClipUp = -1;
    this._landscapeWideFullClipDown = -1;
    this._landscapeWideFullClipLeft = -1;
    this._landscapeWideFullClipRight = -1;
    this.curMode = LayoutManager.Mode.Invalid;
    Object.defineProperties(this, {
        "extraCameraSettings": {
            get: function() {
                if (this._extraCameraSettings == null)
                    this._extraCameraSettings = this.GetComponent(ExtraCameraSettings);
                return this._extraCameraSettings
            },
            set: function(value) {
                this._extraCameraSettings = value
            }
        },
        "landscapeClipUp": {
            get: function() {
                return this._landscapeClipUp
            },
            set: function(value) {
                this._landscapeClipUp = value;
                if (this.curMode == LayoutManager.Mode.Landscape)
                    this.extraCameraSettings.clipUp = this._landscapeClipUp
            }
        },
        "landscapeClipDown": {
            get: function() {
                return this._landscapeClipDown
            },
            set: function(value) {
                this._landscapeClipDown = value;
                if (this.curMode == LayoutManager.Mode.Landscape)
                    this.extraCameraSettings.clipDown = this._landscapeClipDown
            }
        },
        "landscapeClipLeft": {
            get: function() {
                return this._landscapeClipLeft
            },
            set: function(value) {
                this._landscapeClipLeft = value;
                if (this.curMode == LayoutManager.Mode.Landscape)
                    this.extraCameraSettings.clipLeft = this._landscapeClipLeft
            }
        },
        "landscapeClipRight": {
            get: function() {
                return this._landscapeClipRight
            },
            set: function(value) {
                this._landscapeClipRight = value;
                if (this.curMode == LayoutManager.Mode.Landscape)
                    this.extraCameraSettings.clipRight = this._landscapeClipRight
            }
        },
        "portraitClipUp": {
            get: function() {
                return this._portraitClipUp
            },
            set: function(value) {
                this._portraitClipUp = value;
                if (this.curMode == LayoutManager.Mode.Portrait)
                    this.extraCameraSettings.clipUp = this._portraitClipUp
            }
        },
        "portraitClipDown": {
            get: function() {
                return this._portraitClipDown
            },
            set: function(value) {
                this._portraitClipDown = value;
                if (this.curMode == LayoutManager.Mode.Portrait)
                    this.extraCameraSettings.clipDown = this._portraitClipDown
            }
        },
        "portraitClipLeft": {
            get: function() {
                return this._portraitClipLeft
            },
            set: function(value) {
                this._portraitClipLeft = value;
                if (this.curMode == LayoutManager.Mode.Portrait)
                    this.extraCameraSettings.clipLeft = this._portraitClipLeft
            }
        },
        "portraitClipRight": {
            get: function() {
                return this._portraitClipRight
            },
            set: function(value) {
                this._portraitClipRight = value;
                if (this.curMode == LayoutManager.Mode.Portrait)
                    this.extraCameraSettings.clipRight = this._portraitClipRight
            }
        },
        "portraitIPhoneClipUp": {
            get: function() {
                return this._portraitIPhoneClipUp
            },
            set: function(value) {
                this._portraitIPhoneClipUp = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPhone)
                    this.extraCameraSettings.clipUp = this._portraitIPhoneClipUp
            }
        },
        "portraitIPhoneClipDown": {
            get: function() {
                return this._portraitIPhoneClipDown
            },
            set: function(value) {
                this._portraitIPhoneClipDown = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPhone)
                    this.extraCameraSettings.clipDown = this._portraitIPhoneClipDown
            }
        },
        "portraitIPhoneClipLeft": {
            get: function() {
                return this._portraitIPhoneClipLeft
            },
            set: function(value) {
                this._portraitIPhoneClipLeft = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPhone)
                    this.extraCameraSettings.clipLeft = this._portraitIPhoneClipLeft
            }
        },
        "portraitIPhoneClipRight": {
            get: function() {
                return this._portraitIPhoneClipRight
            },
            set: function(value) {
                this._portraitIPhoneClipRight = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPhone)
                    this.extraCameraSettings.clipRight = this._portraitIPhoneClipRight
            }
        },
        "portraitIPadClipUp": {
            get: function() {
                return this._portraitIPadClipUp
            },
            set: function(value) {
                this._portraitIPadClipUp = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPad)
                    this.extraCameraSettings.clipUp = this._portraitIPadClipUp
            }
        },
        "portraitIPadClipDown": {
            get: function() {
                return this._portraitIPadClipDown
            },
            set: function(value) {
                this._portraitIPadClipDown = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPad)
                    this.extraCameraSettings.clipDown = this._portraitIPadClipDown
            }
        },
        "portraitIPadClipLeft": {
            get: function() {
                return this._portraitIPadClipLeft
            },
            set: function(value) {
                this._portraitIPadClipLeft = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPad)
                    this.extraCameraSettings.clipLeft = this._portraitIPadClipLeft
            }
        },
        "portraitIPadClipRight": {
            get: function() {
                return this._portraitIPadClipRight
            },
            set: function(value) {
                this._portraitIPadClipRight = value;
                if (this.curMode == LayoutManager.Mode.PortraitIPad)
                    this.extraCameraSettings.clipRight = this._portraitIPadClipRight
            }
        },
        "landscapeWideClipUp": {
            get: function() {
                return this._landscapeWideClipUp
            },
            set: function(value) {
                this._landscapeWideClipUp = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWide)
                    this.extraCameraSettings.clipUp = this._landscapeWideClipUp
            }
        },
        "landscapeWideClipDown": {
            get: function() {
                return this._landscapeWideClipDown
            },
            set: function(value) {
                this._landscapeWideClipDown = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWide)
                    this.extraCameraSettings.clipDown = this._landscapeWideClipDown
            }
        },
        "landscapeWideClipLeft": {
            get: function() {
                return this._landscapeWideClipLeft
            },
            set: function(value) {
                this._landscapeWideClipLeft = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWide)
                    this.extraCameraSettings.clipLeft = this._landscapeWideClipLeft
            }
        },
        "landscapeWideClipRight": {
            get: function() {
                return this._landscapeWideClipRight
            },
            set: function(value) {
                this._landscapeWideClipRight = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWide)
                    this.extraCameraSettings.clipRight = this._landscapeWideClipRight
            }
        },
        "landscapeWideFullClipUp": {
            get: function() {
                return this._landscapeWideFullClipUp
            },
            set: function(value) {
                this._landscapeWideFullClipUp = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWideFull)
                    this.extraCameraSettings.clipUp = this._landscapeWideFullClipUp
            }
        },
        "landscapeWideFullClipDown": {
            get: function() {
                return this._landscapeWideFullClipDown
            },
            set: function(value) {
                this._landscapeWideFullClipDown = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWideFull)
                    this.extraCameraSettings.clipDown = this._landscapeWideFullClipDown
            }
        },
        "landscapeWideFullClipLeft": {
            get: function() {
                return this._landscapeWideFullClipLeft
            },
            set: function(value) {
                this._landscapeWideFullClipLeft = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWideFull)
                    this.extraCameraSettings.clipLeft = this._landscapeWideFullClipLeft
            }
        },
        "landscapeWideFullClipRight": {
            get: function() {
                return this._landscapeWideFullClipRight
            },
            set: function(value) {
                this._landscapeWideFullClipRight = value;
                if (this.curMode == LayoutManager.Mode.LandscapeWideFull)
                    this.extraCameraSettings.clipRight = this._landscapeWideFullClipRight
            }
        }
    })
}
ArrangeableCameraSettings.prototype.extraCameraSettings = null;
ArrangeableCameraSettings.prototype.landscapeClipUp = -1;
ArrangeableCameraSettings.prototype.landscapeClipDown = -1;
ArrangeableCameraSettings.prototype.landscapeClipLeft = -1;
ArrangeableCameraSettings.prototype.landscapeClipRight = -1;
ArrangeableCameraSettings.prototype.portraitClipUp = -1;
ArrangeableCameraSettings.prototype.portraitClipDown = -1;
ArrangeableCameraSettings.prototype.portraitClipLeft = -1;
ArrangeableCameraSettings.prototype.portraitClipRight = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipUp = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipDown = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipLeft = -1;
ArrangeableCameraSettings.prototype.portraitIPhoneClipRight = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipUp = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipDown = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipLeft = -1;
ArrangeableCameraSettings.prototype.portraitIPadClipRight = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipUp = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipDown = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipLeft = -1;
ArrangeableCameraSettings.prototype.landscapeWideClipRight = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipUp = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipDown = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipLeft = -1;
ArrangeableCameraSettings.prototype.landscapeWideFullClipRight = -1;
ArrangeableCameraSettings.prototype.OnSwitchToPortrait = function() {
    this.OnLayoutChanged(LayoutManager.Mode.Portrait, this.portraitClipUp, this.portraitClipDown, this.portraitClipLeft, this.portraitClipRight)
}
;
ArrangeableCameraSettings.prototype.OnSwitchToPortraitIPhone = function() {
    if (this.separateForIPhone)
        this.OnLayoutChanged(LayoutManager.Mode.PortraitIPhone, this.portraitIPhoneClipUp, this.portraitIPhoneClipDown, this.portraitIPhoneClipLeft, this.portraitIPhoneClipRight);
    else
        this.OnSwitchToPortrait()
}
;
ArrangeableCameraSettings.prototype.OnSwitchToPortraitIPad = function() {
    if (this.separateForIPad)
        this.OnLayoutChanged(LayoutManager.Mode.PortraitIPad, this.portraitIPadClipUp, this.portraitIPadClipDown, this.portraitIPadClipLeft, this.portraitIPadClipRight);
    else
        this.OnSwitchToPortraitIPhone()
}
;
ArrangeableCameraSettings.prototype.OnSwitchToLandscape = function() {
    this.OnLayoutChanged(LayoutManager.Mode.Landscape, this.landscapeClipUp, this.landscapeClipDown, this.landscapeClipLeft, this.landscapeClipRight)
}
;
ArrangeableCameraSettings.prototype.OnSwitchToLandscapeWide = function() {
    if (this.separateForLandscapeWide)
        this.OnLayoutChanged(LayoutManager.Mode.LandscapeWide, this.landscapeWideClipUp, this.landscapeWideClipDown, this.landscapeWideClipLeft, this.landscapeWideClipRight);
    else
        this.OnSwitchToLandscape()
}
;
ArrangeableCameraSettings.prototype.OnSwitchToLandscapeWideFull = function() {
    if (this.separateForLandscapeWideFull)
        this.OnLayoutChanged(LayoutManager.Mode.LandscapeWideFull, this.landscapeWideFullClipUp, this.landscapeWideFullClipDown, this.landscapeWideFullClipLeft, this.landscapeWideFullClipRight);
    else
        this.OnSwitchToLandscapeWide()
}
;
ArrangeableCameraSettings.prototype.OnLayoutChanged = function(mode, clipUp, clipDown, clipLeft, clipRight) {
    this.curMode = mode;
    this.extraCameraSettings.clipUp = clipUp;
    this.extraCameraSettings.clipDown = clipDown;
    this.extraCameraSettings.clipLeft = clipLeft;
    this.extraCameraSettings.clipRight = clipRight
}
;
goog.require("UHT.ArrangeableBase");
ArrangeableMLAnchor.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableMLAnchor.prototype.constructor = ArrangeableMLAnchor;
function ArrangeableMLAnchor() {
    ArrangeableBase.call(this);
    this.anchors = null;
    this.maxWidthLandscape = 0;
    this.separateForLandscapeWide = false;
    this.maxWidthLandscapeWide = 0;
    this.separateForLandscapeWideFull = false;
    this.maxWidthLandscapeWideFull = 0;
    this.maxWidthPortrait = 0;
    this.separateForIPhone = false;
    this.maxWidthIPhonePortrait = 0;
    this.separateForIPad = false;
    this.maxWidthIPadPortrait = 0
}
ArrangeableMLAnchor.prototype.OnSwitchToPortrait = function() {
    this.OnLayoutChanged(this.maxWidthPortrait)
}
;
ArrangeableMLAnchor.prototype.OnSwitchToPortraitIPhone = function() {
    if (this.separateForIPhone)
        this.OnLayoutChanged(this.maxWidthIPhonePortrait);
    else
        this.OnSwitchToPortrait()
}
;
ArrangeableMLAnchor.prototype.OnSwitchToPortraitIPad = function() {
    if (this.separateForIPad)
        this.OnLayoutChanged(this.maxWidthIPadPortrait);
    else
        this.OnSwitchToPortraitIPhone()
}
;
ArrangeableMLAnchor.prototype.OnSwitchToLandscape = function() {
    this.OnLayoutChanged(this.maxWidthLandscape)
}
;
ArrangeableMLAnchor.prototype.OnSwitchToLandscapeWide = function() {
    if (this.separateForLandscapeWide)
        this.OnLayoutChanged(this.maxWidthLandscapeWide);
    else
        this.OnSwitchToLandscape()
}
;
ArrangeableMLAnchor.prototype.OnSwitchToLandscapeWideFull = function() {
    if (this.separateForLandscapeWideFull)
        this.OnLayoutChanged(this.maxWidthLandscapeWideFull);
    else
        this.OnSwitchToLandscapeWide()
}
;
ArrangeableMLAnchor.prototype.OnLayoutChanged = function(maxWidth) {
    for (var i = 0; i < this.anchors.length; ++i) {
        this.anchors[i].maxWidth = maxWidth;
        this.anchors[i].ForceNextUpdate()
    }
}
;
goog.require("UHT.ArrangeableBase");
ArrangeableTransform.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableTransform.prototype.constructor = ArrangeableTransform;
function ArrangeableTransform() {
    ArrangeableBase.call(this);
    this.localPositionLandscape = null;
    this.localScaleLandscape = null;
    this.separateForLandscapeWide = false;
    this.localPositionLandscapeWide = null;
    this.localScaleLandscapeWide = null;
    this.separateForLandscapeWideFull = false;
    this.localPositionLandscapeWideFull = null;
    this.localScaleLandscapeWideFull = null;
    this.localPositionPortrait = null;
    this.localScalePortrait = null;
    this.separateForIPhone = false;
    this.localPositionIPhonePortrait = null;
    this.localScaleIPhonePortrait = null;
    this.separateForIPad = false;
    this.localPositionIPadPortrait = null;
    this.localScaleIPadPortrait = null
}
ArrangeableTransform.prototype.OnSwitchToPortrait = function() {
    this.gameObject.transform.localPosition(this.localPositionPortrait);
    this.gameObject.transform.localScale(this.localScalePortrait)
}
;
ArrangeableTransform.prototype.OnSwitchToPortraitIPhone = function() {
    if (this.separateForIPhone) {
        this.gameObject.transform.localPosition(this.localPositionIPhonePortrait);
        this.gameObject.transform.localScale(this.localScaleIPhonePortrait)
    } else
        this.OnSwitchToPortrait()
}
;
ArrangeableTransform.prototype.OnSwitchToPortraitIPad = function() {
    if (this.separateForIPad) {
        this.gameObject.transform.localPosition(this.localPositionIPadPortrait);
        this.gameObject.transform.localScale(this.localScaleIPadPortrait)
    } else
        this.OnSwitchToPortraitIPhone()
}
;
ArrangeableTransform.prototype.OnSwitchToLandscape = function() {
    this.gameObject.transform.localPosition(this.localPositionLandscape);
    this.gameObject.transform.localScale(this.localScaleLandscape)
}
;
ArrangeableTransform.prototype.OnSwitchToLandscapeWide = function() {
    if (this.separateForLandscapeWide) {
        this.gameObject.transform.localPosition(this.localPositionLandscapeWide);
        this.gameObject.transform.localScale(this.localScaleLandscapeWide)
    } else
        this.OnSwitchToLandscape()
}
;
ArrangeableTransform.prototype.OnSwitchToLandscapeWideFull = function() {
    if (this.separateForLandscapeWideFull) {
        this.gameObject.transform.localPosition(this.localPositionLandscapeWideFull);
        this.gameObject.transform.localScale(this.localScaleLandscapeWideFull)
    } else
        this.OnSwitchToLandscapeWide()
}
;
goog.require("UHT.ArrangeableBase");
ArrangeableUIRoot.prototype = Object.create(ArrangeableBase.prototype);
ArrangeableUIRoot.prototype.constructor = ArrangeableUIRoot;
function ArrangeableUIRoot() {
    ArrangeableBase.call(this);
    this.manualWidthLandscape = 1444;
    this.manualHeightLandscape = 999;
    this.manualWidthPortrait = 1444;
    this.manualHeightPortrait = 2567
}
ArrangeableUIRoot.prototype.OnSwitchToPortrait = function() {
    var uiRoot = this.GetComponent(UIRoot);
    uiRoot.manualWidth = this.manualWidthPortrait;
    uiRoot.manualHeight = this.manualHeightPortrait
}
;
ArrangeableUIRoot.prototype.OnSwitchToLandscape = function() {
    var uiRoot = this.GetComponent(UIRoot);
    uiRoot.manualWidth = this.manualWidthLandscape;
    uiRoot.manualHeight = this.manualHeightLandscape
}
;
goog.require("UHT.XTLink");
LayoutManager.prototype = Object.create(XTLink.prototype);
LayoutManager.prototype.constructor = LayoutManager;
function LayoutManager() {
    XTLink.call(this);
    this.curWidth = -1;
    this.curHeight = -1;
    this.curMode = LayoutManager.Mode.Invalid;
    this.isInit = false;
    this.LandscapeWideRatio = 1.57;
    this.LandscapeWideFullRatio = 1.77;
    this.PortraitIPhoneRatio = .59;
    this.PortraitIPadRatio = .74;
    this.isMobile = true;
    this.isMini = false
}
LayoutManager.Mode = {
    Invalid: 0,
    Landscape: 1,
    Portrait: 2,
    LandscapeWide: 3,
    PortraitIPhone: 4,
    PortraitIPad: 5,
    LandscapeWideFull: 6
};
LayoutManager.layoutMode = LayoutManager.Mode.Invalid;
LayoutManager.prototype.XTRegisterCallbacks = function() {
    this.isInit = true
}
;
var BT_ORIENTATION_InitialSent = false;
var BT_ORIENTATION_lastTime = 0;
var BT_ORIENTATION_timers = [0, 0];
var BT_ORIENTATION_currentMode;
var BT_OrientationUpdateTimers = function() {
    var cTime = (new Date).getTime();
    BT_ORIENTATION_timers[BT_ORIENTATION_currentMode] += cTime - BT_ORIENTATION_lastTime;
    BT_ORIENTATION_lastTime = cTime
};
var BT_OrientationSendTimers = function() {
    BT_OrientationUpdateTimers();
    if (BT_ORIENTATION_timers[0] != 0) {
        globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_time_landscape", BT_ORIENTATION_timers[0], "BehaviourTracker");
        BT_ORIENTATION_timers[0] = 0
    }
    if (BT_ORIENTATION_timers[1] != 0) {
        globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_time_portrait", BT_ORIENTATION_timers[1], "BehaviourTracker");
        BT_ORIENTATION_timers[1] = 0
    }
};
var BT_OrientationSwitched = function(mode) {
    BT_OrientationUpdateTimers();
    BT_ORIENTATION_currentMode = mode
};
LayoutManager.prototype.Awake = function() {
    XTLink.prototype.Awake.call(this);
    Globals.isMobile = this.isMobile;
    Globals.isMini = this.isMini
}
;
LayoutManager.prototype.Update = function() {
    if (this.isInit && (UHTScreen.width != this.curWidth || UHTScreen.height != this.curHeight)) {
        this.curWidth = UHTScreen.width;
        this.curHeight = UHTScreen.height;
        var c = null;
        var s = null;
        var i = 0;
        var ratio = UHTScreen.width / UHTScreen.height;
        if (this.isMini) {
            if (this.curMode != LayoutManager.Mode.Landscape) {
                console.log("-- LayoutManager - switched to Landscape!");
                this.curMode = LayoutManager.Mode.Landscape;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout)
            }
        } else if (this.isMobile)
            if (this.curWidth >= this.curHeight && ratio < this.LandscapeWideRatio && this.curMode != LayoutManager.Mode.Landscape) {
                console.log("-- LayoutManager - switched to Landscape!");
                this.curMode = LayoutManager.Mode.Landscape;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout)
            } else if (this.curWidth >= this.curHeight && ratio >= this.LandscapeWideRatio && ratio < this.LandscapeWideFullRatio && this.curMode != LayoutManager.Mode.LandscapeWide) {
                console.log("-- LayoutManager - switched to Landscape Wide!");
                this.curMode = LayoutManager.Mode.LandscapeWide;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide)
            } else if (this.curWidth >= this.curHeight && ratio >= this.LandscapeWideFullRatio && this.curMode != LayoutManager.Mode.LandscapeWideFull) {
                console.log("-- LayoutManager - switched to Landscape Wide Full!");
                this.curMode = LayoutManager.Mode.LandscapeWideFull;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull)
            } else if (this.curWidth < this.curHeight && ratio < this.PortraitIPhoneRatio && this.curMode != LayoutManager.Mode.Portrait) {
                console.log("-- LayoutManager - switched to Portrait!");
                this.curMode = LayoutManager.Mode.Portrait;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToPortraitLayout)
            } else if (this.curWidth < this.curHeight && ratio >= this.PortraitIPhoneRatio && ratio < this.PortraitIPadRatio && this.curMode != LayoutManager.Mode.PortraitIPhone) {
                console.log("-- LayoutManager - switched to Portrait IPhone!");
                this.curMode = LayoutManager.Mode.PortraitIPhone;
                XT.TriggerEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone)
            } else {
                if (this.curWidth < this.curHeight && ratio >= this.PortraitIPadRatio && this.curMode != LayoutManager.Mode.PortraitIPad) {
                    console.log("-- LayoutManager - switched to Portrait IPad!");
                    this.curMode = LayoutManager.Mode.PortraitIPad;
                    XT.TriggerEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad)
                }
            }
        else if (ratio < this.LandscapeWideRatio && this.curMode != LayoutManager.Mode.Landscape) {
            console.log("-- LayoutManager - switched to Landscape!");
            this.curMode = LayoutManager.Mode.Landscape;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout)
        } else if (ratio >= this.LandscapeWideRatio && ratio < this.LandscapeWideFullRatio && this.curMode != LayoutManager.Mode.LandscapeWide) {
            console.log("-- LayoutManager - switched to Landscape Wide!");
            this.curMode = LayoutManager.Mode.LandscapeWide;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide)
        } else if (ratio >= this.LandscapeWideFullRatio && this.curMode != LayoutManager.Mode.LandscapeWideFull) {
            console.log("-- LayoutManager - switched to Landscape Wide Full!");
            this.curMode = LayoutManager.Mode.LandscapeWideFull;
            XT.TriggerEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull)
        }
        LayoutManager.layoutMode = this.curMode;
        if (UHT_DEVICE_TYPE.DESKTOP == false)
            if (!BT_ORIENTATION_InitialSent) {
                if (this.curMode == LayoutManager.Mode.Landscape || this.curMode == LayoutManager.Mode.LandscapeWide)
                    globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_initial_landscape", 1, "BehaviourTracker");
                else
                    globalTracking.SendEvent("uht_behaviour", "ORIENTATION_MOBILE_initial_portrait", 1, "BehaviourTracker");
                BT_ORIENTATION_InitialSent = true;
                BT_ORIENTATION_lastTime = (new Date).getTime();
                BT_ORIENTATION_currentMode = this.curMode - 1;
                setInterval(BT_OrientationSendTimers, 3E5)
            } else
                BT_OrientationSwitched(this.curMode - 1)
    }
}
;
goog.require("UHT.XTLink");
LobbyCategoriesManager.prototype = Object.create(XTLink.prototype);
LobbyCategoriesManager.prototype.constructor = LobbyCategoriesManager;
function LobbyCategoriesManager() {
    XTLink.call(this);
    this.catEnable = null;
    this.catHide = null;
    this.catCategories = null;
    this.scrollableListLandscape = null;
    this.scrollableListPortrait = null;
    this.categories = null;
    this.categoryIndex = 0;
    this.indicesLandscape = null;
    this.indicesPortrait = null;
    this.scrollLandscape = null;
    this.scrollPortrait = null;
    this.isEnabled = false
}
LobbyCategoriesManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(LobbyVars.LobbyCategories, this.OnCategoriesChanged, this);
    XT.RegisterCallbackInt(LobbyVars.LobbyCategoryIndex, this.OnCategoryIndexChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this)
}
;
LobbyCategoriesManager.prototype.OnVSGameStateChanged = function() {
    if (!this.isEnabled)
        return;
    var state = VSGameStateManager.GetState();
    if (state == VSGameState.Spin || state == VSGameState.SpinBonusRounds)
        this.catHide.Start()
}
;
LobbyCategoriesManager.prototype.OnCategoriesChanged = function(param) {
    this.categories = param;
    this.OnCategoryIndexChanged(XT.GetInt(LobbyVars.LobbyCategoryIndex))
}
;
LobbyCategoriesManager.prototype.OnCategoryIndexChanged = function(index) {
    if (this.categories == null)
        return;
    if (!this.isEnabled) {
        this.catEnable.Start();
        this.isEnabled = true;
        this.indicesLandscape = [];
        this.indicesPortrait = [];
        this.scrollLandscape = [];
        this.scrollPortrait = [];
        for (var i = 0; i < this.categories.length; ++i) {
            this.indicesLandscape.push(0);
            this.indicesPortrait.push(0);
            this.scrollLandscape.push(0);
            this.scrollPortrait.push(0)
        }
    } else {
        this.indicesLandscape[this.categoryIndex] = this.scrollableListLandscape.items[0].valueIdx;
        this.scrollLandscape[this.categoryIndex] = this.scrollableListLandscape.scrollRemain;
        if (this.scrollableListPortrait != null) {
            this.indicesPortrait[this.categoryIndex] = this.scrollableListPortrait.items[0].valueIdx;
            this.scrollPortrait[this.categoryIndex] = this.scrollableListPortrait.scrollRemain
        }
    }
    this.scrollableListLandscape.SetValues(this.categories[index].listLandscape.slice());
    this.scrollableListLandscape.scrollRemain = this.scrollLandscape[index];
    this.scrollableListLandscape.UpdateValuesAndIndex(null, this.indicesLandscape[index], true);
    if (this.scrollableListPortrait != null) {
        this.scrollableListPortrait.SetValues(this.categories[index].listPortrait.slice());
        this.scrollableListPortrait.scrollRemain = this.scrollPortrait[index];
        this.scrollableListPortrait.UpdateValuesAndIndex(null, this.indicesPortrait[index], true)
    }
    this.catCategories[index].Start();
    this.categoryIndex = index
}
;
goog.require("UHT.XTLink");
function LobbyGame() {
    this.name = "";
    this.symbol = "";
    this.launchURL = "";
    this.atlas = null;
    this.sprite = ""
}
function LobbyCategory() {
    this.name = "";
    this.games = null;
    this.listLandscape = null;
    this.listPortrait = null
}
var LobbyVars = {
    LobbyCategories: "LobbyCategories",
    LobbyCategoryIndex: "LobbyCategoryIndex"
};
LobbyConnection.prototype = Object.create(XTLink.prototype);
LobbyConnection.prototype.constructor = LobbyConnection;
function LobbyConnection() {
    XTLink.call(this);
    this.gamesPerLineLandscape = 0;
    this.gamesPerLinePortrait = 0;
    this.urlQuery = "";
    this.categoriesURL = "";
    this.gameLaunchURL = "";
    this.gameIconsURL = "";
    this.categories = null;
    this.categoriesOrder = ["New", "Hot", "Popular"];
    this.errorMessage = "LobbyAPI Parsing Error (lobby/game/list)";
    this.atlases = {};
    this.loadedTexturesCount = 0;
    this.texturesLoaded = false;
    this.retryCount = 0
}
LobbyConnection.Keys = {
    gameLaunchURL: "gameLaunchURL",
    gameIconsURL: "gameIconsURL",
    lobbyCategories: "lobbyCategories",
    categorySymbol: "categorySymbol",
    lobbyGames: "lobbyGames",
    name: "name",
    symbol: "symbol"
};
LobbyConnection.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_InitReceived, this.OnInitReceived, this)
}
;
LobbyConnection.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(LobbyVars.LobbyCategories, null);
    XT.SetInt(LobbyVars.LobbyCategoryIndex, 0)
}
;
LobbyConnection.prototype.OnInitReceived = function() {
    var categoriesURL = UHT_GAME_CONFIG_SRC["ingameLobbyApiURL"];
    if (categoriesURL == undefined)
        return;
    this.urlQuery = GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    this.categoriesURL = categoriesURL + "?" + this.urlQuery;
    this.LoadCategories()
}
;
LobbyConnection.prototype.LoadCategories = function() {
    var req = new ServerRequest;
    req.Url = this.categoriesURL;
    req.Handler = new EventHandler(this,this.OnCategoriesLoaded);
    req.Method = "GET";
    RequestManager.AddRequest(req)
}
;
LobbyConnection.prototype.OnCategoriesLoaded = function(param, statusCode) {
    if (statusCode != 200 && this.retryCount++ < 5) {
        this.LoadCategories();
        return
    }
    var dict;
    try {
        dict = JSON.parse(param)
    } catch (e) {
        console.error(e.message);
        return
    }
    var response = TournamentProtocol.TournamentParser.ParseResponse(dict);
    if (response == null || response.error != TournamentProtocol.ErrorCode.None) {
        console.error(this.errorMessage);
        return
    }
    if (dict[LobbyConnection.Keys.gameLaunchURL] == undefined || dict[LobbyConnection.Keys.gameIconsURL] == undefined || dict[LobbyConnection.Keys.lobbyCategories] == undefined) {
        console.error(this.errorMessage);
        return
    }
    this.gameLaunchURL = String(dict[LobbyConnection.Keys.gameLaunchURL]);
    this.gameLaunchURL += (this.gameLaunchURL.indexOf("?") > -1 ? "&" : "?") + this.urlQuery + "&gameSymbol=";
    this.gameIconsURL = String(dict[LobbyConnection.Keys.gameIconsURL]);
    if (this.gameIconsURL[this.gameIconsURL.length - 1] != "/")
        this.gameIconsURL += "/";
    this.categories = this.ParseCategories(dict[LobbyConnection.Keys.lobbyCategories]);
    for (var i in this.atlases)
        if (this.atlases.hasOwnProperty(i))
            this.LoadTexture(i)
}
;
LobbyConnection.prototype.ParseCategories = function(list) {
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var ret = new Array(this.categoriesOrder.length);
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[LobbyConnection.Keys.categorySymbol] == undefined || dict[LobbyConnection.Keys.lobbyGames] == undefined) {
            console.error(this.errorMessage);
            continue
        }
        var category = new LobbyCategory;
        category.name = String(dict[LobbyConnection.Keys.categorySymbol]);
        category.games = this.ParseGames(dict[LobbyConnection.Keys.lobbyGames]);
        var idx = this.categoriesOrder.indexOf(category.name);
        if (idx > -1)
            ret[idx] = category
    }
    return ret
}
;
LobbyConnection.prototype.ParseGames = function(list) {
    if (list == null) {
        console.error(this.errorMessage);
        return null
    }
    var ret = [];
    for (var i = 0; i < list.length; ++i) {
        var dict = list[i];
        if (dict == null || dict[LobbyConnection.Keys.name] == undefined || dict[LobbyConnection.Keys.symbol] == undefined) {
            console.error(this.errorMessage);
            continue
        }
        var game = new LobbyGame;
        game.name = String(dict[LobbyConnection.Keys.name]);
        game.symbol = String(dict[LobbyConnection.Keys.symbol]);
        game.launchURL = this.gameLaunchURL + game.symbol;
        if (!this.atlases.hasOwnProperty(game.symbol))
            this.atlases[game.symbol] = null;
        ret.push(game)
    }
    return ret
}
;
LobbyConnection.prototype.LoadTexture = function(symbol) {
    var languageSpecificSuffix = "";
    if (window["UHTLobbySeparateIcons"] != undefined)
        if (window["UHTLobbySeparateIcons"][UHT_GAME_CONFIG["LANGUAGE"]] != undefined)
            languageSpecificSuffix = window["UHTLobbySeparateIcons"][UHT_GAME_CONFIG["LANGUAGE"]];
    var url = this.gameIconsURL + languageSpecificSuffix + symbol + "/" + symbol + ".png";
    var image = new Image;
    var atlas = null;
    var self = this;
    image.onload = function() {
        try {
            var spriteName = "s_" + symbol;
            var sprite = {
                borderBottom: 0,
                borderLeft: 0,
                borderRight: 0,
                borderTop: 0,
                paddingBottom: 0,
                paddingLeft: 0,
                paddingRight: 0,
                paddingTop: 0,
                width: image.width,
                height: image.height,
                x: 0,
                y: 0
            };
            atlas = new UIAtlas;
            atlas.isInit = true;
            atlas.pixiTexture = new PIXI.Texture(new PIXI.BaseTexture(image));
            atlas.spriteList[spriteName] = sprite;
            atlas.cachedSprites[symbol] = sprite;
            atlas.cachedSpriteNames[symbol] = spriteName
        } catch (e) {
            atlas = null;
            console.error("Failed to load texture for " + symbol + ". Error: " + e.message)
        }
        self.OnTextureLoaded(symbol, atlas)
    }
    ;
    image.onerror = function() {
        console.error("Failed to load texture for " + symbol);
        self.OnTextureLoaded(symbol, atlas)
    }
    ;
    image.src = url
}
;
LobbyConnection.prototype.OnTextureLoaded = function(symbol, atlas) {
    this.atlases[symbol] = atlas;
    this.loadedTexturesCount++;
    this.texturesLoaded = this.loadedTexturesCount == Object.keys(Object(this.atlases)).length
}
;
LobbyConnection.prototype.Update = function() {
    if (!this.texturesLoaded)
        return;
    this.texturesLoaded = false;
    for (var i = 0; i < this.categories.length; ++i) {
        var category = this.categories[i];
        category.listLandscape = [];
        category.listPortrait = [];
        var listL = null;
        var listP = null;
        for (var j = 0; j < category.games.length; ++j) {
            var game = category.games[j];
            game.atlas = this.atlases[game.symbol];
            game.sprite = game.symbol;
            var idxL = j % this.gamesPerLineLandscape;
            var idxP = j % this.gamesPerLinePortrait;
            if (idxL == 0) {
                if (listL != null)
                    category.listLandscape.push(listL);
                listL = []
            }
            if (idxP == 0) {
                if (listP != null)
                    category.listPortrait.push(listP);
                listP = []
            }
            listL.push(game);
            listP.push(game)
        }
        if (listL != null)
            category.listLandscape.push(listL);
        if (listP != null)
            category.listPortrait.push(listP)
    }
    XT.SetObject(LobbyVars.LobbyCategories, this.categories)
}
;
goog.require("UHT.Engine");
LobbyGameButton.prototype = Object.create(Component.prototype);
LobbyGameButton.prototype.constructor = LobbyGameButton;
function LobbyGameButton() {
    Component.call(this);
    this.icon = null;
    this.altIcon = null;
    this.label = null;
    this.root = null;
    this.threshold = 0;
    this.gameData = null;
    this.cachedCamera = null;
    this.pressPos = null
}
LobbyGameButton.prototype.UpdateValue = function(value) {
    this.gameData = value;
    this.gameObject.SetActive(value != null);
    if (value == null)
        return;
    if (value.atlas != null) {
        this.icon.atlas = value.atlas;
        this.icon.SetSpriteName(value.sprite)
    }
    this.icon.gameObject.SetActive(value.atlas != null);
    this.altIcon.SetActive(value.atlas == null);
    this.label.text = value.name
}
;
LobbyGameButton.prototype.OnPress = function(isPressed) {
    if (this.cachedCamera == null)
        this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var pos = this.root.inverseTransformPoint(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition));
    if (isPressed) {
        this.pressPos = pos;
        return
    }
    var posDelta = UHTMath.Vector3.sub(pos, this.pressPos);
    if (Math.abs(posDelta.y) > this.threshold)
        return;
    console.log("Lobby game clicked. Symbol: " + this.gameData.symbol);
    location.assign(this.gameData.launchURL)
}
;
goog.provide("UHT.CurrencyPatch");
goog.require("UHT.Engine");
function CurrencyProperties() {
    this.CurrencyDecimalSeparator = ".";
    this.CurrencyGroupSeparator = ",";
    this.CurrencyGroupSizes = [3];
    this.CurrencyDecimalDigits = 2;
    this.CurrencySymbol = "$";
    this.CurrencyPositivePattern = 3;
    this.CurrencyNegativePattern = 3
}
function CurrencyFontDescriptor() {
    this.id = 0;
    this.trueTypeFont = "";
    this.bitmapFont = ""
}
CurrencyPatch.prototype = Object.create(Component.prototype);
CurrencyPatch.prototype.constructor = CurrencyPatch;
function CurrencyPatch() {
    Component.call(this);
    this.currencyFile = null;
    this.languageFormatFile = null;
    this.currencyName = "USD";
    this.languageName = "en";
    this.localeName = "en";
    this.fonts = null;
    this.revisionNumber = 0;
    this.currencies = null;
    this.languageFormats = null
}
var testCurrencyPatch = false;
CurrencyPatch.prototype.Update = function() {
    if (testCurrencyPatch) {
        testCurrencyPatch = false;
        LocaleManager.Init(this)
    }
}
;
CurrencyPatch.prototype.InitCurrencies = function(args) {
    console.info("Initializating currency prefab with revision " + this.revisionNumber);
    this.ReadFiles();
    args.currencyInfo = this.InitCurrencyInfo(this.languageName, this.currencyName, this.localeName);
    args.jackpotCurrencyInfo = this.InitCurrencyInfo(this.languageName, "USD", this.localeName)
}
;
CurrencyPatch.prototype.InitCurrency = function(currencyName) {
    return this.InitCurrencyInfo(this.languageName, currencyName, this.localeName)
}
;
CurrencyPatch.prototype.InitCurrencyInfo = function(_languageName, _currencyName, _localeName) {
    var currencyInfo = new CurrencyProperties;
    currencyInfo.CurrencySymbol = _currencyName;
    if (this.currencies[_currencyName + "sym"] != undefined)
        currencyInfo.CurrencySymbol = this.currencies[_currencyName + "sym"];
    if (this.languageFormats[_localeName + "_dsep"] != undefined)
        this.InitLanguageFormat(currencyInfo, _localeName);
    else if (this.languageFormats[_languageName + "_dsep"] != undefined)
        this.InitLanguageFormat(currencyInfo, _languageName);
    return currencyInfo
}
;
CurrencyPatch.prototype.InitLanguageFormat = function(currencyInfo, _languageName) {
    currencyInfo.CurrencyDecimalSeparator = this.languageFormats[_languageName + "_dsep"];
    currencyInfo.CurrencyGroupSeparator = this.languageFormats[_languageName + "_gsep"];
    var groupSize = this.languageFormats[_languageName + "_gnum"];
    var groupSizes = groupSize.split(" ");
    var groupSizesList = [];
    for (var str in groupSizes)
        groupSizesList.push(_number.otoi(groupSizes[str]));
    currencyInfo.CurrencyGroupSizes = groupSizesList;
    currencyInfo.CurrencyDecimalDigits = _number.otoi(this.languageFormats[_languageName + "_dnum"]);
    currencyInfo.CurrencyPositivePattern = _number.otoi(this.languageFormats[_languageName + "_symp"]);
    currencyInfo.CurrencyNegativePattern = currencyInfo.CurrencyPositivePattern
}
;
CurrencyPatch.prototype.ReadFiles = function() {
    this.currencies = this.ReadFileInDictionary(this.currencyFile);
    this.languageFormats = this.ReadFileInDictionary(this.languageFormatFile)
}
;
CurrencyPatch.prototype.ReadFileInDictionary = function(textAsset) {
    return Object(textAsset.text)
}
;
goog.provide("UHT.LocaleManager");
goog.require("UHT.CurrencyPatch");
function FormatOptions() {
    this.hasCurrency = true;
    this.hasJackpotCurrency = false;
    this.hasCustomCurrency = false;
    this.customCurrency = "";
    this.fontId = -1
}
var LocaleManager = {};
LocaleManager.currencyInfo = new CurrencyProperties;
LocaleManager.jackpotCurrencyInfo = new CurrencyProperties;
LocaleManager.patchData = null;
LocaleManager.customCurrencyInfo = {};
LocaleManager.isInit = false;
LocaleManager.decimalsAllowed = true;
LocaleManager.FormatValue = function(val, formatInfo) {
    if (formatInfo.hasCustomCurrency)
        return LocaleManager.FormatValueWithCustomCurrency(val, formatInfo.customCurrency);
    var ci = formatInfo.hasJackpotCurrency ? LocaleManager.jackpotCurrencyInfo : LocaleManager.currencyInfo;
    var ret = LocaleManager.InternalFormatValue(val, ci.CurrencyDecimalDigits, ci.CurrencyDecimalSeparator, ci.CurrencyGroupSeparator);
    if (formatInfo.hasCurrency)
        ret = LocaleManager.FormatCurrency(ret, ci.CurrencySymbol, ci.CurrencyPositivePattern);
    return ret
}
;
LocaleManager.FormatValueWithCustomCurrency = function(val, currencyName) {
    var ci = LocaleManager.currencyInfo;
    if (LocaleManager.patchData != null) {
        if (LocaleManager.customCurrencyInfo[currencyName] == undefined)
            LocaleManager.customCurrencyInfo[currencyName] = LocaleManager.patchData.InitCurrency(currencyName);
        ci = LocaleManager.customCurrencyInfo[currencyName]
    }
    var ret = LocaleManager.InternalFormatValue(val, ci.CurrencyDecimalDigits, ci.CurrencyDecimalSeparator, ci.CurrencyGroupSeparator);
    return LocaleManager.FormatCurrency(ret, ci.CurrencySymbol, ci.CurrencyPositivePattern)
}
;
LocaleManager.FormatCurrency = function(value, symbol, pattern) {
    var ret = "";
    switch (pattern) {
    case 0:
        ret = symbol + value;
        break;
    case 1:
        ret = value + symbol;
        break;
    case 2:
        ret = symbol + " " + value;
        break;
    case 3:
        ret = value + " " + symbol;
        break;
    case 4:
        ret = value;
        break
    }
    return ret
}
;
LocaleManager.InternalFormatValue = function(n, c, d, t) {
    var s = n < 0 ? "-" : "";
    n = Math.abs(+n || 0);
    var aftercomma = "";
    if (!IS_UCBROWSER)
        n = n.toFixed(c);
    else {
        var toFixedN = n.toFixed(c);
        var rounderMul = Math.pow(10, c);
        n *= rounderMul;
        n += .5;
        n /= rounderMul;
        var tfs = n.toString().split(".");
        if (tfs.length == 1)
            tfs.push("");
        while (tfs[1].length < c)
            tfs[1] += "0";
        tfs[1] = tfs[1].slice(0, 2);
        aftercomma = c ? tfs[1] : "";
        n = tfs[0] + (c ? "." + tfs[1] : "");
        if (n != toFixedN)
            console.error("      WRONG COMPUTATION, should be " + n + " but it's " + toFixedN)
    }
    var i = parseInt(n, 10) + "";
    var j = i.length;
    j = j > 3 ? j % 3 : 0;
    if (!IS_UCBROWSER)
        aftercomma = Math.abs(n - i).toFixed(c).slice(2);
    return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (LocaleManager.decimalsAllowed ? d + aftercomma : "")
}
;
LocaleManager.ApplyFontToLabel = function(fontID, l) {}
;
LocaleManager.Init = function(newData) {
    LocaleManager.patchData = newData;
    if (LocaleManager.patchData != null) {
        var args = {
            currencyInfo: LocaleManager.currencyInfo,
            jackpotCurrencyInfo: LocaleManager.jackpotCurrencyInfo
        };
        LocaleManager.patchData.InitCurrencies(args);
        LocaleManager.currencyInfo = args.currencyInfo;
        LocaleManager.jackpotCurrencyInfo = args.jackpotCurrencyInfo
    }
    if (UHT_GAME_CONFIG_SRC["allowDecimals"] != undefined)
        LocaleManager.decimalsAllowed = UHT_GAME_CONFIG_SRC["allowDecimals"];
    LocaleManager.isInit = true;
    XT.TriggerEvent(Vars.Evt_Internal_LocaleChanged)
}
;
LocaleManager.GetCurrencySymbol = function() {
    return LocaleManager.currencyInfo.CurrencySymbol
}
;
goog.require("UHT.Engine");
LocalizationRoot.prototype = Object.create(Component.prototype);
LocalizationRoot.prototype.constructor = LocalizationRoot;
function LocalizationRoot() {
    Component.call(this)
}
goog.require("UHT.XTLink");
LocalizedLabels.prototype = Object.create(XTLink.prototype);
LocalizedLabels.prototype.constructor = LocalizedLabels;
function LocalizedLabels() {
    XTLink.call(this);
    this.localizedLabel = null;
    this.labels = null;
    this.useIncludedLanguages = false;
    this.includedLanguages = null;
    this.useExcludedLanguages = false;
    this.excludedLanguages = null;
    this.applyFontSize = false;
    this.cat = null
}
LocalizedLabels.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
}
;
LocalizedLabels.prototype.OnGameInit = function() {
    var canUpdate = true;
    if (this.useIncludedLanguages)
        canUpdate = this.includedLanguages.indexOf(ServerOptions.language) != -1;
    if (this.useExcludedLanguages)
        canUpdate = this.excludedLanguages.indexOf(ServerOptions.language) == -1;
    if (!canUpdate)
        return;
    for (var i = 0; i < this.labels.length; ++i) {
        if (this.applyFontSize)
            this.labels[i].fontSize = this.localizedLabel.fontSize;
        this.labels[i].text = this.localizedLabel.text;
        this.labels[i].fontName = this.localizedLabel.fontName;
        this.labels[i].Prepare()
    }
    if (this.cat != null)
        this.cat.Start()
}
;
goog.require("UHT.Engine");
goog.require("UHT.ModificationsManager_XChange");
goog.require("UHTMath.Vector3");
ModificationsManager.prototype = Object.create(Component.prototype);
ModificationsManager.prototype.constructor = ModificationsManager;
function ModificationsManager() {
    Component.call(this);
    this.root = null;
    this.EditMode = false;
    this.Atlases = null;
    this.Transforms = null;
    this.Labels = null;
    this.revisionNumber = 0
}
ModificationsManager.prototype.Start = function() {
    if (this.EditMode)
        this.Init()
}
;
ModificationsManager.prototype.Update = function() {
    if (this.EditMode)
        this.UpdateAllValuesFromScene()
}
;
ModificationsManager.prototype.OnDrawGizmos = function() {}
;
ModificationsManager.prototype.Init = function() {
    console.info("Initializating localization prefab with revision " + this.revisionNumber);
    this.root = Component.FindObjectOfType(LocalizationRoot).gameObject.transform;
    this.UpdatePrefabReferences();
    if (this.Atlases != null && this.Atlases.length != 0)
        this.ApplyAtlases();
    if (this.Labels != null && this.Labels.length != 0)
        this.ApplyLabels();
    if (this.Transforms != null && this.Transforms.length != 0)
        this.ApplyTransforms();
    if (!this.EditMode)
        console.warn("We're NOT in edit mode, we destroy this prefab...")
}
;
ModificationsManager.prototype.UpdatePrefabReferences = function() {
    var i;
    for (i = 0; i < this.Transforms.length; ++i) {
        var _transform = this.Transforms[i];
        if (_transform.Target == null)
            _transform.Target = this.root.Find(_transform.path)
    }
    for (i = 0; i < this.Atlases.length; ++i) {
        var _atlas = this.Atlases[i];
        if (_atlas.Target == null)
            _atlas.Target = this.root.Find(_atlas.oldPath)
    }
    for (i = 0; i < this.Labels.length; ++i) {
        var _label = this.Labels[i];
        _label.Target = this.root.Find(_label.path)
    }
}
;
ModificationsManager.prototype.UpdateAllValuesFromScene = function() {
    var i;
    for (i = 0; i < this.Atlases.length; ++i) {
        var atlas = this.Atlases[i];
        this.UpdateAtlasValues(atlas)
    }
    for (i = 0; i < this.Transforms.length; ++i) {
        var transform = this.Transforms[i];
        this.UpdateTransformValues(transform)
    }
    for (i = 0; i < this.Labels.length; ++i) {
        var label = this.Labels[i];
        this.UpdateLabelValues(label)
    }
}
;
ModificationsManager.prototype.GetNamePath = function(target) {
    var path = target.gameObject.name;
    while (target.parent != this.root) {
        if (target.parent == null)
            return "";
        path = target.parent.gameObject.name + "/" + path;
        target = target.parent
    }
    return path
}
;
ModificationsManager.prototype.UpdateLabelValues = function(_label) {}
;
ModificationsManager.CopyFromLabelToLabel = function(copyFrom, copyTo, alsoCopyText, copyEffects) {
    if (alsoCopyText)
        copyTo.text = copyFrom.text;
    copyTo.fontName = copyFrom.fontName;
    var val = copyFrom.fontSize * copyTo.resize;
    copyTo.fontSize = Math.round(Math.max(2, val));
    copyTo.currentFontSize = copyFrom.currentFontSize;
    copyTo.anchorX = copyFrom.anchorX;
    copyTo.anchorY = copyFrom.anchorY;
    copyTo.overflow = copyFrom.overflow;
    copyTo.alignment = copyFrom.alignment;
    copyTo.maxLines = copyFrom.maxLines;
    copyTo.spacingY = copyFrom.spacingY * copyTo.resize;
    copyTo.mArcRadius = copyFrom.mArcRadius * copyTo.resize;
    if (copyEffects)
        ModificationsManager.CopyEffectsAndColors(copyFrom, copyTo);
    if (copyFrom.overflow == UILabel.Overflow.ShrinkContent || copyFrom.overflow == UILabel.Overflow.ClampContent) {
        val = copyFrom.width * copyTo.resize;
        copyTo.width = Math.round(Math.max(2, val));
        val = copyFrom.height * copyTo.resize;
        copyTo.height = Math.round(Math.max(2, val))
    } else if (copyFrom.overflow == UILabel.Overflow.ResizeHeight) {
        val = copyFrom.width * copyTo.resize;
        copyTo.width = Math.round(Math.max(2, val))
    }
    copyTo.Prepare()
}
;
ModificationsManager.CopyEffectsAndColors = function(copyFrom, copyTo) {
    copyTo.effectStyle = copyFrom.effectStyle;
    copyTo.effectColor = copyFrom.effectColor;
    copyTo.effectWidth = copyFrom.effectWidth * copyTo.resize;
    copyTo.mBlurShadow = copyFrom.mBlurShadow;
    copyTo.mBlurShadowSize = copyFrom.mBlurShadowSize * copyTo.resize;
    copyTo.mBlurShadowOffsetX = copyFrom.mBlurShadowOffsetX * copyTo.resize;
    copyTo.mBlurShadowOffsetY = copyFrom.mBlurShadowOffsetY * copyTo.resize;
    copyTo.mBlurShadowColor = copyFrom.mBlurShadowColor;
    copyTo.mOutline = copyFrom.mOutline;
    copyTo.mOutlineColor = copyFrom.mOutlineColor;
    copyTo.mFillCenter = copyFrom.mFillCenter
}
;
ModificationsManager.prototype.UpdateTransformValues = function(_transform) {
    if (_transform.Target == null)
        return;
    var targetPath = this.GetNamePath(_transform.Target);
    if (targetPath != _transform.path) {
        _transform.path = targetPath;
        _transform.TransformData = [];
        _transform.TransformData.push(new TransformInfo);
        _transform.TransformData[0].SetPosition(_transform.Target.localPosition());
        _transform.TransformData[0].SetScale(_transform.Target.localScale());
        _transform.TransformData[0].SetRotation(_transform.Target.localEulerAngles().z);
        _transform.isSet = true;
        this.ApplyTransforms()
    } else {
        _transform.TransformData[0].SetPosition(_transform.Target.localPosition());
        _transform.TransformData[0].SetScale(_transform.Target.localScale());
        _transform.TransformData[0].SetRotation(_transform.Target.localEulerAngles().z)
    }
}
;
ModificationsManager.prototype.UpdateAtlasValues = function(_atlas) {
    if (_atlas.Target == null)
        return;
    var targetSprite = _atlas.Target.GetComponentsInChildren(UISprite, true);
    if (targetSprite.length == 0) {
        console.error("This transform does not contain an UISprite, you need to select another!");
        _atlas.Target = null;
        _atlas.isSet = false
    } else {
        _atlas.oldPath = this.GetNamePath(targetSprite[0].transform);
        _atlas.isSet = true;
        this.ApplyAtlases()
    }
}
;
ModificationsManager.prototype.ApplyLabels = function() {
    for (var i = 0; i < this.Labels.length; ++i) {
        var _label = this.Labels[i];
        if (!_label.isSet)
            continue;
        if (_label.Target == null) {
            console.error("Could not find target at path\n" + _label.path);
            continue
        }
        if (this.EditMode)
            _label.oldContent = _label.Target.GetComponent(UILabel).text;
        _label.SetValuesToLabel()
    }
}
;
ModificationsManager.prototype.ApplyTransforms = function() {
    for (var i = 0; i < this.Transforms.length; ++i) {
        var _transform = this.Transforms[i];
        if (_transform.Target == null)
            _transform.Target = this.root.Find(_transform.path);
        if (_transform.Target != null)
            _transform.SetValuesToElement(this.EditMode);
        else
            console.error("Transform not found at path: " + _transform.path)
    }
}
;
ModificationsManager.prototype.ApplyAtlases = function() {
    for (var i = 0; i < this.Atlases.length; ++i) {
        var _atlas = this.Atlases[i];
        if (!_atlas.isSet)
            continue;
        var targetAtlas = this.root.Find(_atlas.oldPath).GetComponent(UISprite).atlas;
        var sprites = this.root.GetComponentsInChildren(UISprite, true);
        var j;
        for (j = 0; j < sprites.length; ++j) {
            var sprite = sprites[j];
            if (sprite.atlas == targetAtlas) {
                sprite.atlas = _atlas.NewAtlas;
                sprite.SetSpriteName(sprite.spriteName)
            }
        }
    }
}
;
goog.provide("UHT.GenericPoolObject");
goog.require("UHT.XTLink");
GenericPoolObject.prototype = Object.create(XTLink.prototype);
GenericPoolObject.prototype.constructor = GenericPoolObject;
function GenericPoolObject() {
    XTLink.call(this);
    this.Id = 0
}
GenericPoolObject.prototype.Reset = function() {}
;
goog.provide("UHT.GenericObjectPooler");
goog.require("UHT.GenericPoolObject");
GenericObjectPooler.prototype = Object.create(XTLink.prototype);
GenericObjectPooler.prototype.constructor = GenericObjectPooler;
function GenericObjectPooler() {
    XTLink.call(this);
    this.pool = null;
    this.poolObjects = [];
    this.objectIdToIndexMap = null;
    this.pooledObjects = null;
    this.disablePoolNextFrame = false;
    this.defaultBufferAmount = 10;
    this.initializing = false;
    this.currentInitObject = -1
}
GenericObjectPooler.prototype.Init = function() {
    this.initializing = true;
    this.PerformSanityCheck();
    this.BuildObjectIdToIndexMap();
    this.pooledObjects = [];
    this.pool.SetActive(true)
}
;
GenericObjectPooler.prototype.Update = function() {
    if (this.initializing)
        if (this.currentInitObject < this.poolObjects.length) {
            if (this.currentInitObject >= 0) {
                var id = this.poolObjects[this.currentInitObject].Id;
                this.pooledObjects[id] = [];
                for (var n = 0; n < this.defaultBufferAmount; n++) {
                    var newObj = instantiate(this.poolObjects[this.currentInitObject].gameObject);
                    newObj.SetActive(true);
                    this.PoolObject(id, newObj.GetComponent(GenericPoolObject))
                }
            }
            this.currentInitObject++
        } else {
            this.disablePoolNextFrame = false;
            this.initializing = false
        }
}
;
GenericObjectPooler.prototype.PerformSanityCheck = function() {
    var foundIds = [];
    for (var i = 0; i < this.poolObjects.length; ++i) {
        var s = this.poolObjects[i];
        if (foundIds.indexOf(s.Id) != -1)
            console.error("More than one obj registered with ID = " + s.Id);
        foundIds.push(s.Id)
    }
}
;
GenericObjectPooler.prototype.BuildObjectIdToIndexMap = function() {
    this.objectIdToIndexMap = [];
    for (var i = 0; i < this.poolObjects.length; i++)
        this.objectIdToIndexMap[this.poolObjects[i].Id] = i
}
;
GenericObjectPooler.prototype.GetFromPool = function(id, parent) {
    if (this.pooledObjects[id].length == 0) {
        console.log("Object pool capacity is too small! ID = " + id);
        this.pooledObjects[id].push(instantiate(this.poolObjects[this.objectIdToIndexMap[id]].gameObject).GetComponent(GenericPoolObject));
        this.pooledObjects[id][this.pooledObjects[id].length - 1].gameObject.SetActive(true)
    }
    var pooledObject = this.pooledObjects[id][0];
    this.pooledObjects[id].splice(0, 1);
    pooledObject.gameObject.transform.SetParent(parent.transform, false);
    pooledObject.gameObject.transform.localPosition(UHTMath.Vector3.zero);
    pooledObject.gameObject.transform.localRotation(UHTMath.Quaternion.euler(UHTMath.Vector3.zero));
    pooledObject.gameObject.transform.localScale(UHTMath.Vector3.one);
    return pooledObject
}
;
GenericObjectPooler.prototype.PoolObject = function(id, obj) {
    obj.Reset();
    obj.gameObject.transform.SetParent(this.pool.transform, false);
    this.pooledObjects[id].push(obj)
}
;
GenericObjectPooler.prototype.GetObject = function(objId, parent) {
    return this.GetFromPool(objId, parent)
}
;
GenericObjectPooler.prototype.RecycleObject = function(obj) {
    this.PoolObject(obj.Id, obj)
}
;
GenericObjectPooler.prototype.LateUpdate = function() {
    if (this.pool.activeSelf && !this.initializing) {
        if (!this.disablePoolNextFrame) {
            this.disablePoolNextFrame = true;
            return
        }
        this.pool.SetActive(false)
    }
}
;
goog.provide("UHT.OfflineServer");
goog.require("UHT.Engine");
OfflineServer.prototype = Object.create(Component.prototype);
OfflineServer.prototype.constructor = OfflineServer;
function OfflineServer() {
    Component.call(this);
    this.configFile = null;
    this.responseLog = null;
    this.responseString = "";
    this.index = 0;
    this.slotHeight = 0;
    this.numberOfReels = 0;
    this.stopOffset = 1;
    this.coinValue = .01;
    this.lines = 0;
    this.balance = 1E5;
    this.reelSymbols = null;
    this.screenSymbols = null;
    this.payoutData = null;
    this.stopPositions = null;
    this.linesDef = null;
    this.totalWin = 0;
    this.isFreeSpins = false;
    this.currentFreeSpin = 0;
    this.maxFreeSpins = 0;
    this.totalFreeSpins = 0;
    this.freeSpinsCurrentMultiplier = 0;
    this.freeSpinsTotalMultiplier = 0;
    this.freeSpinCurrentWin = 0;
    this.freeSpinTotalWin = 0;
    this.freeSpinCurrentWinMultiplied = 0;
    this.freeSpinTotalWinMultiplied = 0;
    this.scatterFSAwards = null;
    this.scatterFSMultipliers = null;
    this.scatterFSAdditional = null;
    this.linesDefString = "5,6,7,8,9~0,1,2,3,4~10,11,12,13,14~0,6,12,8,4~10,6,2,8,14~5,1,2,3,9~5,11,12,13,9~0,1,7,13,14~10,11,7,3,4~5,11,7,3,9~5,1,7,13,9~0,6,7,8,4~10,6,7,8,14~0,6,2,8,4~10,6,12,8,14~5,6,2,8,9~5,6,12,8,9~0,1,12,3,4~10,11,2,13,14~0,11,12,13,4~10,1,2,3,14~5,11,2,13,9~5,1,12,3,9~0,11,2,13,4~10,1,12,3,14";
    this.ID_DELIMITER = "::"
}
OfflineServer.prototype.Start = function() {
    RequestProvider.Instance.ParseOfflineResponse(this.responseLog.text, true);
    this.ProcessLinesDefinitions()
}
;
OfflineServer.prototype.ParseConfig = function() {
    var tempString = "";
    var parser = new DOMParser;
    var config = parser.parseFromString(this.configFile.text, "text/xml");
    var winLines = config.getElementsByTagName("slot")[0];
    this.lines = _number.otoi(winLines.getAttribute("lines"));
    this.AddParameterToResonse(GameProtocolDictionary.line + "=" + this.lines, false);
    var initScreenSymbols = config.getElementsByTagName("screen");
    this.AddParameterToResonse(GameProtocolDictionary.winSymbols + "=" + initScreenSymbols[0].getAttribute("array"), false);
    var reels = config.getElementsByTagName("reel");
    this.stopPositions = new Array;
    this.numberOfReels = reels.length;
    var reelsInitPositions = "";
    this.reelSymbols = new Array;
    for (var reelIdx = 0; reelIdx < reels.length; reelIdx++) {
        tempString = "";
        tempString += GameProtocolDictionary.reel(reelIdx) + "=" + reels[reelIdx].getAttribute("symbols");
        this.AddParameterToResonse(tempString, false);
        this.stopPositions.push(0);
        reelsInitPositions += this.stopPositions[reelIdx] + (reelIdx < reels.length - 1 ? "," : "");
        var currentReelSymbols = new Array;
        var values = reels[reelIdx].getAttribute("symbols").split(",");
        for (var symbolIdx = 0; symbolIdx < values.length; symbolIdx++)
            currentReelSymbols.push(_number.otoi(values[symbolIdx]));
        this.reelSymbols.push(currentReelSymbols)
    }
    this.AddParameterToResonse(GameProtocolDictionary.reelsPosition + "=" + reelsInitPositions, false);
    this.AddParameterToResonse(GameProtocolDictionary.slotHeight + "=" + initScreenSymbols[0].getAttribute("array").split(",").length / this.numberOfReels, false);
    this.slotHeight = initScreenSymbols[0].getAttribute("array").split(",").length / this.numberOfReels;
    this.screenSymbols = new Array;
    for (var i = 0; i < this.numberOfReels; i++) {
        this.screenSymbols.push(new Array);
        for (var j = 0; j < this.slotHeight; j++)
            this.screenSymbols[i].push(0)
    }
    var payouts = config.getElementsByTagName("symbol");
    tempString = "";
    tempString += GameProtocolDictionary.paytable + "=";
    this.payoutData = new Array;
    for (var symbolIdx = 0; symbolIdx < payouts.length; symbolIdx++) {
        var currentPayouts = new Array;
        var values = payouts[symbolIdx].getAttribute("payout").split(",");
        for (var i = 0; i < values.length / 2; i++) {
            tempString += values[2 * i];
            currentPayouts.push(_number.otoi(values[2 * i]));
            if (i < values.length / 2 - 1)
                tempString += ","
        }
        if (symbolIdx < payouts.length - 1)
            tempString += ";";
        currentPayouts.reverse();
        this.payoutData.push(currentPayouts)
    }
    this.AddParameterToResonse(tempString, false);
    var scatterSettings = new Array;
    this.scatterFSAwards = JSON.parse("[" + config.getElementsByTagName("spin")[0].getAttribute("array") + "]");
    scatterSettings.push(config.getElementsByTagName("spin")[0]);
    this.scatterFSAwards.reverse();
    this.scatterFSMultipliers = JSON.parse("[" + config.getElementsByTagName("spin_mul")[0].getAttribute("array") + "]");
    scatterSettings.push(config.getElementsByTagName("spin_mul")[0]);
    this.scatterFSMultipliers.reverse();
    this.scatterFSAdditional = JSON.parse("[" + config.getElementsByTagName("more_spins")[0].getAttribute("array") + "]");
    scatterSettings.push(config.getElementsByTagName("more_spins")[0]);
    this.scatterFSAdditional.reverse();
    tempString = "";
    tempString += GameProtocolDictionary.scatters + "=";
    var scatterId = 1;
    for (var symbolIdx = 0; symbolIdx < payouts.length; symbolIdx++)
        if (payouts[symbolIdx].getAttribute["name"].toLowerCase() == "scatter")
            scatterId = _number.otoi(payouts[symbolIdx].getAttribute["i"]);
    tempString += scatterId;
    for (var scatterSettingsIdx = 0; scatterSettingsIdx < scatterSettings.length; scatterSettingsIdx++)
        if (scatterSettingsIdx < scatterSettings.length - 1)
            tempString += "~" + scatterSettings[scatterSettingsIdx].getAttribute("array");
    this.AddParameterToResonse(tempString, false)
}
;
OfflineServer.prototype.AddParameterToResonse = function(parameter, isLast) {
    this.responseString += parameter + (isLast ? "" : "&")
}
;
OfflineServer.prototype.HandleRequest = function(postData) {
    if (postData == null) {
        console.warn("Null post data");
        return
    }
    var args = postData.split("&");
    for (var i = 0; i < args.length; ++i) {
        var arg = args[i].split("=");
        if (arg[0] == GameProtocolDictionary.coin)
            if (arg.length > 1)
                this.coinValue = _number.otod(arg[1])
    }
    for (var i = 0; i < args.length; ++i) {
        var arg = args[i].split("=");
        if (arg[0] == GameProtocolDictionary.Actions.action)
            if (arg.length > 1)
                this.SendResponse(arg[1]);
            else
                console.warn("Invalid post data " + postData)
    }
}
;
OfflineServer.prototype.SendResponse = function(gameAction) {
    this.responseString = "";
    this.index++;
    switch (gameAction) {
    case GameProtocolDictionary.Actions.doInit:
        this.responseString = this.GenerateInitResponse();
        break;
    case GameProtocolDictionary.Actions.doSpin:
        this.responseString = this.GenerateSpinResponse();
        break;
    case GameProtocolDictionary.Actions.doCollect:
        this.responseString = this.GenerateCollectResponse();
        break;
    default:
        console.warn("Got response for unknown action " + gameAction);
        break
    }
    console.log(this.responseString);
    RequestProvider.Instance.ParseOfflineResponse(this.responseString, false)
}
;
OfflineServer.prototype.GenerateInitResponse = function() {
    this.AddParameterToResonse(GameProtocolDictionary.Actions.doInit + this.ID_DELIMITER, true);
    this.ParseConfig();
    this.AddParameterToResonse("", false);
    this.AddParameterToResonse(GameProtocolDictionary.coin + "=" + this.coinValue.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.balance + "=" + this.balance.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.index + "=" + this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.counter + "=" + 2 * this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.time + "=" + this.GenerateTimeStamp(), true);
    return this.responseString
}
;
OfflineServer.prototype.GenerateSpinResponse = function() {
    this.GenerateTimeStamp();
    this.AddParameterToResonse(GameProtocolDictionary.Actions.doSpin + this.ID_DELIMITER, true);
    if (!this.isFreeSpins)
        this.balance -= this.coinValue * this.lines;
    this.AddParameterToResonse(GameProtocolDictionary.coin + "=" + this.coinValue.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.balance + "=" + this.balance.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.line + "=" + this.lines, false);
    this.AddParameterToResonse("sver=5&sh=3&b=0", false);
    this.AddParameterToResonse(GameProtocolDictionary.index + "=" + this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.counter + "=" + 2 * this.index, false);
    var reelsStopPositions = "";
    for (var i = 0; i < this.numberOfReels; i++) {
        this.stopPositions[i] = Math.floor(Math.random() * this.reelSymbols[i].length);
        reelsStopPositions += this.stopPositions[i] + (i < this.numberOfReels - 1 ? "," : "")
    }
    this.AddParameterToResonse(GameProtocolDictionary.reelsPosition + "=" + reelsStopPositions, false);
    this.ComputeScreenSymbols();
    var screenWinList = this.ComputeScreenWins();
    this.totalWin = 0;
    for (var screenWinIdx = 0; screenWinIdx < screenWinList.length; screenWinIdx++) {
        var lineWin = this.payoutData[screenWinList[screenWinIdx].dominatingSymbol][screenWinList[screenWinIdx].Positions.length - 1] * this.coinValue;
        this.totalWin += lineWin;
        var lineWinString = "l" + screenWinIdx + "=" + (screenWinList[screenWinIdx].Id - 1) + "~" + lineWin + "~";
        for (var posIdx = 0; posIdx < screenWinList[screenWinIdx].Positions.length; posIdx++)
            lineWinString += screenWinList[screenWinIdx].Positions[posIdx] + (posIdx < screenWinList[screenWinIdx].Positions.length - 1 ? "~" : "");
        this.AddParameterToResonse(lineWinString, false)
    }
    var tmp = "";
    var scattersOnScreen = 0;
    for (var i = 0; i < this.slotHeight; i++)
        for (var j = 0; j < this.numberOfReels; j++) {
            tmp += this.screenSymbols[j][i] + (i == this.slotHeight - 1 && j == this.numberOfReels - 1 ? "" : ",");
            if (this.screenSymbols[j][i] == 1)
                scattersOnScreen++
        }
    if (scattersOnScreen > 2)
        if (!this.isFreeSpins)
            this.InitFreeSpins(scattersOnScreen);
    if (this.isFreeSpins) {
        this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentNumber + "=" + this.currentFreeSpin, false);
        this.currentFreeSpin++;
        this.freeSpinTotalWin += this.totalWin;
        this.freeSpinCurrentWinMultiplied = this.totalWin * this.freeSpinsCurrentMultiplier;
        if (this.currentFreeSpin <= this.maxFreeSpins) {
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentMultiplier + "=" + this.freeSpinsCurrentMultiplier, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinMaxNumber + "=" + this.maxFreeSpins, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentWin + "=" + this.freeSpinTotalWin.toFixed(2), false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinCurrentWinMultiplied + "=" + this.freeSpinTotalWin.toFixed(2), false)
        } else {
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalMultipl + "=" + this.freeSpinsCurrentMultiplier, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalNumber + "=" + this.maxFreeSpins, false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalWin + "=" + this.freeSpinTotalWin.toFixed(2), false);
            this.AddParameterToResonse(GameProtocolDictionary.freeSpinTotalWinMultiplied + "=" + this.freeSpinTotalWin.toFixed(2), false)
        }
    }
    if (this.totalWin > 0)
        if (this.isFreeSpins)
            if (this.currentFreeSpin - 1 == this.maxFreeSpins)
                this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Collect, false);
            else
                this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Spin, false);
        else
            this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Collect, false);
    else
        this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Spin, false);
    this.AddParameterToResonse(GameProtocolDictionary.winAmountShort + "=" + this.totalWin.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.spinCycleWin + "=" + (this.isFreeSpins ? this.freeSpinTotalWin.toFixed(2) : this.totalWin.toFixed(2)), false);
    this.AddParameterToResonse(GameProtocolDictionary.winSymbols + "=" + tmp, false);
    this.AddParameterToResonse(GameProtocolDictionary.time + "=" + this.GenerateTimeStamp(), true);
    if (this.currentFreeSpin - 1 == this.maxFreeSpins)
        this.ResetFreeSpins();
    return this.responseString
}
;
OfflineServer.prototype.GenerateCollectResponse = function() {
    this.AddParameterToResonse(GameProtocolDictionary.Actions.doCollect + this.ID_DELIMITER, true);
    this.balance += this.totalWin;
    this.AddParameterToResonse(GameProtocolDictionary.balance + "=" + this.balance.toFixed(2), false);
    this.AddParameterToResonse("a=0&gs=0&sver=5&sh=3", false);
    this.AddParameterToResonse(GameProtocolDictionary.index + "=" + this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.counter + "=" + 2 * this.index, false);
    this.AddParameterToResonse(GameProtocolDictionary.NextActions.nextAction + "=" + GameProtocolDictionary.NextActions.Spin, false);
    this.AddParameterToResonse(GameProtocolDictionary.winAmountShort + "=" + this.totalWin.toFixed(2), false);
    this.AddParameterToResonse(GameProtocolDictionary.time + "=" + this.GenerateTimeStamp(), true);
    return this.responseString
}
;
OfflineServer.prototype.GenerateTimeStamp = function() {
    var timeStamp = Math.round((new Date).getTime() / 1E3);
    return timeStamp
}
;
OfflineServer.prototype.ProcessLinesDefinitions = function() {
    var buf = this.linesDefString.split("~");
    this.linesDef = new Array;
    for (var lineIdx = 0; lineIdx < buf.length; lineIdx++) {
        var tmp = new Array;
        for (var posIdx = 0; posIdx < buf[lineIdx].split(",").length; posIdx++)
            tmp.push(_number.otoi(buf[lineIdx].split(",")[posIdx]));
        this.linesDef.push(tmp)
    }
}
;
OfflineServer.prototype.ComputeScreenSymbols = function() {
    for (var i = 0; i < this.screenSymbols.length; i++)
        for (var j = 0; j < this.screenSymbols[i].length; j++) {
            var currentIdx = (this.stopPositions[i] - this.stopOffset + j + (this.reelSymbols[i].length - 1)) % (this.reelSymbols[i].length - 1);
            this.screenSymbols[i][j] = this.reelSymbols[i][currentIdx]
        }
}
;
OfflineServer.prototype.GetSymbolFromReel = function(pos, reel) {
    return this.screenSymbols[reel][pos]
}
;
OfflineServer.prototype.SymbolIsWild = function(id) {
    return id == 2
}
;
OfflineServer.prototype.InitFreeSpins = function(numberOfScatters) {
    this.isFreeSpins = true;
    this.currentFreeSpin = 1;
    this.maxFreeSpins = this.scatterFSAwards[numberOfScatters - 1];
    this.totalFreeSpins = this.scatterFSAwards[numberOfScatters - 1];
    this.freeSpinsCurrentMultiplier = this.scatterFSMultipliers[numberOfScatters - 1];
    this.freeSpinsTotalMultiplier = this.scatterFSMultipliers[numberOfScatters - 1];
    this.freeSpinCurrentWin = 0;
    this.freeSpinTotalWin = 0;
    this.freeSpinCurrentWinMultiplied = 0;
    this.freeSpinTotalWinMultiplied = 0
}
;
OfflineServer.prototype.ResetFreeSpins = function() {
    this.isFreeSpins = false;
    this.currentFreeSpin = 0;
    this.maxFreeSpins = 0;
    this.totalFreeSpins = 0;
    this.freeSpinsCurrentMultiplier = 0;
    this.freeSpinsTotalMultiplier = 0;
    this.freeSpinCurrentWin = 0;
    this.freeSpinTotalWin = 0;
    this.freeSpinCurrentWinMultiplied = 0;
    this.freeSpinTotalWinMultiplied = 0
}
;
OfflineServer.prototype.ComputeScreenWins = function() {
    var betLines = new Array;
    for (var i = 0; i < this.lines; i++) {
        betLines[i] = new WinLineInfo;
        betLines[i].Id = i + 1;
        betLines[i].Positions = new Array;
        betLines[i].containsWild = false;
        for (var j = 0; j < this.numberOfReels; j++)
            betLines[i].Positions.push(this.linesDef[i][j])
    }
    for (var betLinesIdx = 0; betLinesIdx < betLines.length; betLinesIdx++) {
        var winningsymbol = 2;
        var actualwinningsymbol = -1;
        var leadingWilds = 0;
        for (var i = 0; i < betLines[betLinesIdx].Positions.length; i++) {
            var pos = betLines[betLinesIdx].Positions[i];
            var reelIdx = pos % this.numberOfReels;
            var reelPosIdx = Math.floor(pos / this.numberOfReels);
            var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx);
            if (actualwinningsymbol == -1)
                actualwinningsymbol = symbol;
            if (!this.SymbolIsWild(symbol))
                if (symbol != winningsymbol && !this.SymbolIsWild(winningsymbol) || symbol < 2) {
                    var newLength = i;
                    if (leadingWilds > 0)
                        if (this.payoutData[2][leadingWilds - 1] > this.payoutData[winningsymbol][newLength - 1]) {
                            newLength = leadingWilds;
                            winningsymbol = 2
                        }
                    var newPos = new Array;
                    for (var j = 0; j < newLength; j++)
                        newPos[j] = betLines[betLinesIdx].Positions[j];
                    betLines[betLinesIdx].Positions = newPos
                } else {
                    winningsymbol = symbol;
                    actualwinningsymbol = symbol
                }
            else if (leadingWilds == i)
                leadingWilds++;
            if (!betLines[betLinesIdx].containsWild)
                betLines[betLinesIdx].containsWild = this.SymbolIsWild(symbol)
        }
        betLines[betLinesIdx].dominatingSymbol = winningsymbol
    }
    var lineWins = new Array;
    for (var betLinesIdx = 0; betLinesIdx < betLines.length; betLinesIdx++)
        if (betLines[betLinesIdx].Positions.length >= 3)
            lineWins.push(betLines[betLinesIdx]);
    return lineWins
}
;
goog.provide("UHT.UHTAction");
goog.require("UHT.Engine");
var UHTStageName = {
    No_Stage: 0,
    Init: 1,
    Result: 2,
    Spin: 3,
    ResultFreeSpin: 4,
    Gamble: 5,
    Bonus: 6,
    FSBG: 7,
    Transition: 8
};
function UHTAction(_continue, _next) {
    this.continueRunning = _continue;
    this.nextStage = _next
}
UHTAction.NoAction = function() {
    return new UHTAction(true,UHTStageName.No_Stage)
}
;
UHTAction.ChangeStage = function(nextStage) {
    return new UHTAction(false,nextStage)
}
;
GameLogicRuntime.prototype = Object.create(Component.prototype);
GameLogicRuntime.prototype.constructor = GameLogicRuntime;
function GameLogicRuntime() {
    Component.call(this);
    this.listOfStages = [];
    this.startingStage = UHTStageName.No_Stage;
    this.debugHistory = [];
    this.dict = [];
    this.currentStage = null;
    this.currentStageStarted = false
}
GameLogicRuntime.prototype.Start = function() {
    this.dict = [];
    for (var i = 0; i < this.listOfStages.length; i++) {
        var stageName = this.listOfStages[i].GetStageName();
        if (this.dict[stageName] == undefined)
            this.dict[stageName] = [];
        this.listOfStages[i].UHTInit();
        this.dict[stageName].push(this.listOfStages[i])
    }
    this.currentStage = this.GetStage(this.startingStage);
    this.currentStageStarted = false
}
;
GameLogicRuntime.prototype.Update = function() {
    if (Globals.GamePaused)
        return;
    var act = this.currentStage.UHTUpdateBase(!this.currentStageStarted);
    if (this.currentStage.GetStageName() == UHTStageName.Bonus && !this.currentStageStarted && XT.GetBool(Vars.MustOpenAnotherBonus)) {
        XT.SetBool(Vars.MustOpenBonus, true);
        XT.SetBool(Vars.MustOpenAnotherBonus, false)
    }
    this.currentStageStarted = true;
    if (act.continueRunning == false) {
        this.currentStage.UHTFinish();
        if (this.dict[act.nextStage] == undefined)
            console.error("GameLogicRuntime: Trying to start an invalid stage (" + act.nextStage + ")");
        this.currentStage = this.GetStage(act.nextStage);
        this.currentStageStarted = false
    }
}
;
GameLogicRuntime.prototype.GetStage = function(stageName) {
    if (this.dict[stageName].length > 1) {
        var featureID = 0;
        if (stageName == UHTStageName.Bonus)
            featureID = XT.GetObject(Vars.BonusData).GameID;
        for (var i = 0; i < this.dict[stageName].length; ++i)
            if (this.dict[stageName][i].featureID == featureID)
                return this.dict[stageName][i]
    }
    return this.dict[stageName][0]
}
;
goog.require("UHT.XTLink");
goog.require("UHT.UHTAction");
goog.provide("UHT.UHTStage");
UHTStage.prototype = Object.create(XTLink.prototype);
UHTStage.prototype.constructor = UHTStage;
function UHTStage() {
    XTLink.call(this);
    this.featureID = 0;
    this.catBeforeFirstUpdate = null
}
UHTStage.prototype.GetStageName = function() {
    return UHTStageName.No_Stage
}
;
UHTStage.prototype.UHTInit = function() {}
;
UHTStage.prototype.UHTUpdateBase = function(isFirstFrame) {
    if (isFirstFrame && this.catBeforeFirstUpdate != null)
        this.catBeforeFirstUpdate.Start();
    return this.UHTUpdate(isFirstFrame)
}
;
UHTStage.prototype.UHTUpdate = function(isFirstFrame) {
    return UHTAction.NoAction()
}
;
UHTStage.prototype.UHTFinish = function() {}
;
goog.require("UHT.Engine");
goog.require("UHT.BaseDataStructures");
function JackpotInformation(id, order, amount, name, jackpotGroupType, jackpotStatus, JackpotMinBet, JackpotMinBetUSD, JackpotRTP) {
    this.JackpotID = id || -1;
    this.JackpotOrder = order || -1;
    this.JackpotAmount = amount || 0;
    this.JackpotName = name || "";
    this.JackpotGroupType = jackpotGroupType || "";
    this.JackpotStatus = jackpotStatus || "";
    this.JackpotMinBet = JackpotMinBet || -69;
    this.JackpotMinBetUSD = JackpotMinBetUSD || -69;
    this.JackpotRTP = JackpotRTP || -69
}
JackpotInformation.prototype.Clone = function() {
    return new JackpotInformation(this.JackpotID,this.JackpotOrder,this.JackpotAmount,this.JackpotName,this.JackpotGroupType,this.JackpotStatus,this.JackpotMinBet,this.JackpotMinBetUSD,this.JackpotRTP)
}
;
goog.require("UHT.Engine");
goog.provide("UHT.Adapter");
goog.require("UHT.BalanceManager");
goog.require("UHT.EventManager");
goog.require("UHT.Globals");
function Adapter() {
    this.methods = {};
    this.messageOpen = false;
    this.fullscreenOverlayShown = false;
    UHTEventBroker.AddHandler(UHTEventBroker.Type.Game, new UHTEventBroker.Handler(this,this.Endpoint))
}
Adapter.prototype.Init = function() {
    this.InitAdapterMethods();
    EventManager.AddHandler(ApplicationEvents.evtRequestAppConfiguration, this.OnRequestConfiguration, this);
    EventManager.AddHandler(ApplicationEvents.evtGameLoadingFinished, this.HandleGameReady, this);
    EventManager.AddHandler(ApplicationEvents.evtServerResponse, this.HandleServerResponse, this);
    EventManager.AddHandler(AdapterEvents.evtGetConfiguration, this.HandleGetConfiguration, this);
    EventManager.AddHandler(AdapterEvents.evtOpenCashier, this.HandleOpenCashier, this);
    EventManager.AddHandler(AdapterEvents.evtServerRequest, this.HandleServerRequest, this);
    EventManager.AddHandler(AdapterEvents.evtShowMessage, this.HandleShowMessage, this);
    EventManager.AddHandler(AdapterEvents.evtCloseGame, this.HandleCloseGame, this);
    EventManager.AddHandler(AdapterEvents.evtReload, this.HandleReloadGame, this)
}
;
Adapter.prototype.OnRequestConfiguration = function(param) {
    this.ExternalCall(AdapterEvents.evtGetConfiguration, null)
}
;
Adapter.prototype.ExternalCall = function(notification, args) {
    var mainArgs = {};
    mainArgs[AdapterParameters.Notify] = notification;
    mainArgs[AdapterParameters.Arguments] = args;
    mainArgs[AdapterParameters.type] = AdapterParameters.unity;
    var serializedArgs = JSON.stringify(mainArgs);
    UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, serializedArgs)
}
;
Adapter.prototype.ExternalEvent = function(notification, args) {
    var mainArgs = {};
    mainArgs[AdapterParameters.Notify] = notification;
    mainArgs[AdapterParameters.Arguments] = args;
    var serializedArgs = JSON.stringify(mainArgs);
    UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, serializedArgs)
}
;
Adapter.prototype.InitAdapterMethods = function() {
    this.methods[AdapterEvents.evtGetConfiguration] = new EventHandler(this,this.OnConfigReceived);
    this.methods[AdapterEvents.evtUpdateBalance] = new EventHandler(this,this.OnUpdateBalance);
    this.methods[AdapterEvents.evtSound] = new EventHandler(this,this.OnSoundStateChanged);
    this.methods[AdapterEvents.evtGameStatus] = new EventHandler(this,this.OnGameStatusChanged);
    this.methods[AdapterEvents.evtMessageOpened] = new EventHandler(this,this.OnFlashMessageOpened);
    this.methods[AdapterEvents.evtMessageClosed] = new EventHandler(this,this.OnFlashMessageClosed);
    this.methods[AdapterEvents.evtFullscreenOverlayShown] = new EventHandler(this,this.OnFullscreenOverlayShown);
    this.methods[AdapterEvents.evtFullscreenOverlayHidden] = new EventHandler(this,this.OnFullscreenOverlayHidden)
}
;
Adapter.prototype.NIYMethod = function(param) {}
;
Adapter.prototype.OnConfigReceived = function(parsedArgs) {
    if (parsedArgs[AdapterParameters.Config] != null)
        this.HandleGetConfiguration(parsedArgs[AdapterParameters.Config]);
    else
        console.error("OnConfigReceived - config xml is missing!")
}
;
Adapter.prototype.Endpoint = function(param) {
    console.warn("Endpoint " + param);
    var parsedArgs = JSON.parse(param);
    if (parsedArgs == null) {
        console.error("ParseExternalCall - parsedArgs are null!");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param);
        return
    }
    if (parsedArgs[AdapterParameters.Notify] === undefined) {
        console.error("ParseExternalCall - no action was specified!");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param);
        return
    }
    if (parsedArgs[AdapterParameters.Arguments] === undefined) {
        console.error("ParseExternalCall - no parameters were specified!");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param);
        return
    }
    var actionName = _string.Trim(parsedArgs[AdapterParameters.Notify]);
    var parameters = parsedArgs[AdapterParameters.Arguments];
    if (this.methods[actionName] != undefined)
        this.methods[actionName].call(parameters);
    else {
        console.info("Unhandled method " + actionName + " ... sending to wapper");
        UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, param)
    }
}
;
Adapter.prototype.HandleBalanceUpdate = function(bd) {
    if (bd != null) {
        var data = {};
        data[AdapterParameters.Balance] = String(bd.Balance);
        data[AdapterParameters.BalanceUpdateTime] = String(bd.Time);
        this.ExternalCall(AdapterEvents.evtUpdateBalance, data)
    }
}
;
Adapter.prototype.HandleGetConfiguration = function(configStr) {
    console.info("HandleGetConfiguration", configStr);
    EventManager.Trigger(ApplicationEvents.evtAppConfigurationReceived, configStr)
}
;
Adapter.prototype.HandleCloseGame = function(args) {
    this.ExternalCall(AdapterEvents.evtCloseGame, null)
}
;
Adapter.prototype.HandleReloadGame = function(args) {
    this.ExternalCall(AdapterEvents.evtReload, null)
}
;
Adapter.prototype.OnUpdateBalance = function(args) {
    var data = {};
    for (var pair in args)
        data[pair] = String(args[pair]);
    var balanceData;
    if (XT.GetBool(Vars.Jurisdiction_SplitBalance))
        balanceData = GameProtocolCommonParser.BuildBalanceData(_number.otod(args[GameProtocolDictionary.cashBalance]), _number.otod(args[GameProtocolDictionary.bonusBalance]), _number.otod(args[GameProtocolDictionary.time]));
    else
        balanceData = GameProtocolCommonParser.BuildBalanceData(_number.otod(args[GameProtocolDictionary.balance]), 0, _number.otod(args[GameProtocolDictionary.time]));
    if (balanceData != null)
        EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData)
}
;
Adapter.prototype.OnSoundStateChanged = function(args) {
    if (args[AdapterParameters.GameSymbol] != undefined && args[AdapterParameters.SoundState] != undefined) {
        var gameSymbol = args[AdapterParameters.GameSymbol];
        var soundState = new CasinoSoundState;
        soundState.state = _number.otoi(args[AdapterParameters.SoundState]);
        EventManager.Trigger(GameEvents.evtSoundState + gameSymbol, soundState)
    }
}
;
Adapter.prototype.OnGameStatusChanged = function(args) {
    if (args[AdapterParameters.GameSymbol] != undefined && args[AdapterParameters.GameActive] != undefined) {
        var gameSymbol = String(args[AdapterParameters.GameSymbol]);
        var active = _number.otoi(args[AdapterParameters.GameActive]);
        var isGameActive = active == 1;
        EventManager.Trigger(GameEvents.evtGameStatus + gameSymbol, isGameActive)
    }
}
;
Adapter.prototype.HandleServerRequest = function(request) {
    var data = {};
    data[AdapterParameters.MethodType] = request.Fields[GameProtocolDictionary.Actions.action];
    data[AdapterParameters.GameSymbol] = request.Fields[GameProtocolDictionary.symbol];
    this.ExternalCall(AdapterEvents.evtServerRequest, data)
}
;
Adapter.prototype.HandleGameReady = function(param) {
    var gameSymbol = param;
    var data = {};
    data[AdapterParameters.GameSymbol] = gameSymbol;
    this.ExternalCall(AdapterEvents.evtGameLoadComplited, data);
    FlashWrapperHelper.HandleGameReady(gameSymbol)
}
;
Adapter.prototype.HandleOpenCashier = function(param) {
    this.ExternalCall(AdapterEvents.evtOpenCashier, null)
}
;
Adapter.prototype.HandleServerResponse = function(param) {
    FlashWrapperHelper.HandleServerResponse(param)
}
;
Adapter.prototype.OnFlashMessageOpened = function(param) {
    this.messageOpen = true;
    Globals.InputBlocked = true;
    console.info("OnFlashMessageOpened - Globals.InputBlocked " + String(Globals.InputBlocked))
}
;
Adapter.prototype.OnFlashMessageClosed = function(param) {
    this.messageOpen = false;
    if (!this.IsGlobalInputBlocked())
        Globals.InputBlocked = false;
    console.info("OnFlashMessageClosed - Globals.InputBlocked " + String(Globals.InputBlocked))
}
;
Adapter.prototype.OnFullscreenOverlayShown = function(param) {
    this.fullscreenOverlayShown = true;
    Globals.InputBlocked = true;
    console.info("OnFullscreenOverlayShown - Globals.InputBlocked " + String(Globals.InputBlocked))
}
;
Adapter.prototype.OnFullscreenOverlayHidden = function(param) {
    this.fullscreenOverlayShown = false;
    if (!this.IsGlobalInputBlocked())
        Globals.InputBlocked = false;
    console.info("OnFullscreenOverlayHidden - Globals.InputBlocked " + String(Globals.InputBlocked))
}
;
Adapter.prototype.IsGlobalInputBlocked = function() {
    return this.messageOpen || this.fullscreenOverlayShown
}
;
Adapter.prototype.HandleShowMessage = function(param) {
    console.info("HandleShowMessage " + param);
    FlashWrapperHelper.HandleShowMessage(param)
}
;
var FlashWrapperHelper = {};
FlashWrapperHelper.ExternalEvent = function(notification, args) {
    var mainArgs = {};
    mainArgs[AdapterParameters.Notify] = notification;
    mainArgs[AdapterParameters.Arguments] = args;
    var serializedArgs = JSON.stringify(mainArgs);
    UHTEventBroker.Trigger(UHTEventBroker.Type.Wrapper, serializedArgs)
}
;
FlashWrapperHelper.HandleGameReady = function(param) {
    FlashWrapperHelper.ExternalEvent(AdapterEvents.evtGameReady, null)
}
;
FlashWrapperHelper.HandleServerResponse = function(resp) {
    if (resp == null)
        return;
    var args = {};
    args[AdapterParameters.ResponseData] = resp.Response;
    args[AdapterParameters.ResponseStatusCode] = resp.StatusCode;
    FlashWrapperHelper.ExternalEvent(AdapterEvents.evtServerResponse, args)
}
;
FlashWrapperHelper.HandleShowMessage = function(messageType) {
    if (messageType != null) {
        var args = {};
        args[AdapterParameters.messageType] = messageType;
        FlashWrapperHelper.ExternalEvent(AdapterEvents.evtShowMessage, args)
    }
}
;
goog.require("UHT.ServerOptions");
goog.require("UHT.Component");
goog.require("UHT.OfflineRequest");
goog.require("UHT.OfflineServer");
RequestProvider.prototype = Object.create(Component.prototype);
RequestProvider.prototype.constructor = RequestProvider;
function RequestProvider() {
    Component.call(this);
    this.log = null;
    this.responseDelay = .5;
    this.offlineServer = null;
    this.requests = null;
    this.requestIDs = null;
    this.responses = null;
    this.responseIndices = null;
    this.ID_DELIMITER = "::";
    this.RESPONSE_DELIMITER = "\n";
    this.firstRequest = true
}
RequestProvider.Instance = null;
RequestProvider.prototype.Start = function() {
    RequestProvider.Instance = this;
    if (ServerOptions.isOnline)
        ;
    else
        this.ParseLog()
}
;
RequestProvider.prototype.NewRequest = function(settings) {
    return ServerOptions.isOnline ? new SimpleWebRequest(settings) : new OfflineRequest(settings)
}
;
RequestProvider.prototype.OfflineRequest = function(url, postData, request) {
    var self = this;
    setTimeout(function() {
        self.CompleteOfflineRequest(url, postData, request)
    }, self.responseDelay * 1E3);
    if (this.offlineServer != null)
        this.offlineServer.HandleRequest(postData)
}
;
RequestProvider.prototype.CompleteOfflineRequest = function(url, postData, request) {
    var id = url.indexOf(ServerOptions.gameServiceUri) >= 0 ? this.GameServiceRequestID(postData) : this.OtherRequestID(url);
    if (this.responses[id] != undefined) {
        var data = this.responses[id][this.responseIndices[id]];
        if (/_JSON$/.test(id))
            data = atob(data);
        request.OnRequestDone(data);
        this.responseIndices[id]++;
        if (this.offlineServer == null)
            this.responseIndices[id] %= this.responses[id].length
    } else
        console.error("Response not found for id " + id)
}
;
RequestProvider.prototype.GameServiceRequestID = function(postData) {
    var args = (postData || "").split("&");
    for (var i = 0; i < args.length; ++i) {
        var arg = args[i].split("=");
        if (arg[0] == GameProtocolDictionary.Actions.action)
            return arg.length > 1 ? arg[1] : null
    }
    return null
}
;
RequestProvider.prototype.OtherRequestID = function(url) {
    var urlNoParams = url.split("?")[0];
    var parts = urlNoParams.split("/");
    if (parts.indexOf("promo") > -1 || parts.indexOf("lobby") > -1) {
        var split = urlNoParams.split("gs2c");
        if (split.length > 1)
            return split[1].replace(/^\/+|\/+$/g, "").split("/").join("_") + "_JSON"
    }
    for (var i = parts.length - 1; i >= 0; --i)
        if (!_string.IsNullOrEmpty(parts[i]))
            return parts[i];
    return null
}
;
RequestProvider.prototype.ParseLog = function() {
    this.responses = {};
    this.responseIndices = {};
    var str_responses = this.log.text.split(this.RESPONSE_DELIMITER);
    for (var i = 0; i < str_responses.length; ++i)
        if (!_string.IsNullOrEmpty(str_responses[i])) {
            var str_response = str_responses[i].split(this.ID_DELIMITER);
            var id = str_response[0];
            var data = str_response.length > 1 ? str_response[1] : "";
            var list = this.responses[id] != undefined ? this.responses[id] : [];
            list.push(data);
            if (this.responses[id] == undefined) {
                this.responses[id] = list;
                this.responseIndices[id] = 0
            }
        }
}
;
RequestProvider.prototype.ParseOfflineResponse = function(response, isInit) {
    if (isInit) {
        this.responses = {};
        this.responseIndices = {}
    }
    var str_responses = response.split(this.RESPONSE_DELIMITER);
    for (var i = 0; i < str_responses.length; ++i)
        if (!_string.IsNullOrEmpty(str_responses[i])) {
            var str_response = str_responses[i].split(this.ID_DELIMITER);
            var id = str_response[0];
            var data = str_response.length > 1 ? str_response[1] : "";
            var list = this.responses[id] != undefined ? this.responses[id] : [];
            list.push(data);
            if (this.responses[id] == undefined) {
                this.responses[id] = list;
                this.responseIndices[id] = 0
            }
        }
}
;
goog.require("UHT.XTLink");
PromotionContentSwitcher.prototype = Object.create(XTLink.prototype);
PromotionContentSwitcher.prototype.constructor = PromotionContentSwitcher;
function PromotionContentSwitcher() {
    XTLink.call(this);
    this.switchesByStatus = true;
    this.startsSoonContent = null;
    this.openContent = null;
    this.closedContent = null;
    this.switchesByType = true;
    this.raceContents = null;
    this.tournamentContents = null;
    this.switchesByStyle = true;
    this.asiaContents = null;
    this.europeContents = null;
    this.switchOnPromoSelectionChange = false;
    this.onlyIfActive = false
}
PromotionContentSwitcher.prototype.XTRegisterCallbacks = function() {
    if (this.switchOnPromoSelectionChange)
        XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged, this)
}
;
PromotionContentSwitcher.prototype.OnSelectedTournamentIDChanged = function(uid) {
    if (!this.CanSwitch(this.switchOnPromoSelectionChange))
        return;
    var t = PromotionsHelper.FindPromotion(uid);
    if (t == null)
        return;
    this.SwitchByStatus(t.status);
    this.SwitchByType(t.type);
    this.SwitchByStyle(t.clientStyle)
}
;
PromotionContentSwitcher.prototype.SwitchByStatus = function(status) {
    if (!this.CanSwitch(this.switchesByStatus))
        return;
    this.startsSoonContent.SetActive(status == TournamentProtocol.StatusCode.StartsSoon);
    this.openContent.SetActive(status == TournamentProtocol.StatusCode.Open);
    this.closedContent.SetActive(status == TournamentProtocol.StatusCode.Closed)
}
;
PromotionContentSwitcher.prototype.SwitchByType = function(type) {
    if (!this.CanSwitch(this.switchesByType))
        return;
    for (var i = 0; i < this.tournamentContents.length; ++i)
        this.tournamentContents[i].SetActive(type == TournamentProtocol.PromoType.Tournament);
    for (var i = 0; i < this.raceContents.length; ++i)
        this.raceContents[i].SetActive(type == TournamentProtocol.PromoType.Race)
}
;
PromotionContentSwitcher.prototype.SwitchByStyle = function(style) {
    if (!this.CanSwitch(this.switchesByStyle))
        return;
    for (var i = 0; i < this.asiaContents.length; ++i)
        this.asiaContents[i].SetActive(style == TournamentProtocol.ClientStyle.Asia);
    for (var i = 0; i < this.europeContents.length; ++i)
        this.europeContents[i].SetActive(style == TournamentProtocol.ClientStyle.Europe)
}
;
PromotionContentSwitcher.prototype.CanSwitch = function(condition) {
    return (!this.onlyIfActive || this.gameObject.activeInHierarchy) && condition
}
;
goog.require("UHT.GenericPoolObject");
PromotionRuleUnit.prototype = Object.create(GenericPoolObject.prototype);
PromotionRuleUnit.prototype.constructor = PromotionRuleUnit;
function PromotionRuleUnit() {
    GenericPoolObject.call(this);
    this.labels = null;
    this.textContent = null;
    this.linkContentVisited = null;
    this.linkContentUnvisited = null;
    this.isVisible = false;
    this.data = null;
    this.mustUpdateLinkContent = false
}
PromotionRuleUnit.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Visited, this.OnPromotionRuleLinkVisited, this)
}
;
PromotionRuleUnit.prototype.OnPromotionRuleLinkVisited = function() {
    this.mustUpdateLinkContent = this.gameObject.activeInHierarchy && this.data.isLink
}
;
PromotionRuleUnit.prototype.UpdateValue = function(unit) {
    this.data = unit;
    for (var i = 0; i < this.labels.length; ++i)
        this.labels[i].text = unit.text;
    this.textContent.SetActive(!unit.isLink);
    this.UpdateLinkContent()
}
;
PromotionRuleUnit.prototype.UpdateLinkContent = function() {
    this.data.CheckVisited();
    this.linkContentVisited.SetActive(this.data.isLink && this.data.isVisited);
    this.linkContentUnvisited.SetActive(this.data.isLink && !this.data.isVisited)
}
;
PromotionRuleUnit.prototype.Update = function() {
    if (this.mustUpdateLinkContent) {
        this.mustUpdateLinkContent = false;
        this.UpdateLinkContent()
    }
}
;
PromotionRuleUnit.prototype.UnitButtonClicked = function() {
    if (this.data.isLink && this.isVisible) {
        window.open(this.data.url, encodeURIComponent(this.data.url));
        if (!this.data.isVisited) {
            this.data.SetVisited();
            XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Visited)
        }
    }
}
;
goog.require("UHT.XTLink");
PromotionRuleUnitButton.prototype = Object.create(XTLink.prototype);
PromotionRuleUnitButton.prototype.constructor = PromotionRuleUnitButton;
function PromotionRuleUnitButton() {
    XTLink.call(this);
    this.unit = null;
    this.hoveredFrame = 0;
    this.pressedFrame = 0;
    this.cachedCamera = null
}
PromotionRuleUnitButton.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOn, this.OnPromotionLinkHoveredOn, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOff, this.OnPromotionLinkHoveredOff, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Pressed, this.OnPromotionLinkPressed, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionRuleLink_Released, this.OnPromotionLinkReleased, this);
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(this,this.OnTouchEnd))
}
;
PromotionRuleUnitButton.prototype.OnPromotionLinkHoveredOn = function() {
    this.InternalSendMessage(false, true)
}
;
PromotionRuleUnitButton.prototype.OnPromotionLinkHoveredOff = function() {
    this.InternalSendMessage(false, false)
}
;
PromotionRuleUnitButton.prototype.OnPromotionLinkPressed = function() {
    this.InternalSendMessage(true, true)
}
;
PromotionRuleUnitButton.prototype.OnPromotionLinkReleased = function() {
    this.InternalSendMessage(true, false)
}
;
PromotionRuleUnitButton.prototype.InternalSendMessage = function(isPressed, value) {
    if (this.gameObject.activeInHierarchy && XT.GetString(TournamentVars.PromotionRuleLinkID) == this.unit.data.uid)
        this.gameObject.SendMessage(isPressed ? "OnPress" : "OnHover", value)
}
;
PromotionRuleUnitButton.prototype.OnTouchEnd = function() {
    if (!this.gameObject.activeInHierarchy)
        return;
    if (this.cachedCamera == null)
        this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var mask = new LayerMask;
    mask.mask = 1 << this.gameObject.layer;
    if (this.gameObject.collider != globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask))
        return;
    this.unit.UnitButtonClicked()
}
;
PromotionRuleUnitButton.prototype.OnHover = function(value) {
    if (this.hoveredFrame == Time.frameCount)
        return;
    this.hoveredFrame = Time.frameCount;
    XT.SetString(TournamentVars.PromotionRuleLinkID, this.unit.data.uid);
    XT.TriggerEvent(value ? TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOn : TournamentVars.Evt_Internal_PromotionRuleLink_HoveredOff)
}
;
PromotionRuleUnitButton.prototype.OnPress = function(value) {
    if (this.pressedFrame == Time.frameCount)
        return;
    this.pressedFrame = Time.frameCount;
    XT.SetString(TournamentVars.PromotionRuleLinkID, this.unit.data.uid);
    XT.TriggerEvent(value ? TournamentVars.Evt_Internal_PromotionRuleLink_Pressed : TournamentVars.Evt_Internal_PromotionRuleLink_Released)
}
;
goog.require("UHT.GenericObjectPooler");
PromotionRuleUnitsPooler.prototype = Object.create(GenericObjectPooler.prototype);
PromotionRuleUnitsPooler.prototype.constructor = PromotionRuleUnitsPooler;
function PromotionRuleUnitsPooler() {
    GenericObjectPooler.call(this)
}
PromotionRuleUnitsPooler.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.Init, this)
}
;
PromotionRuleUnitsPooler.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(TournamentVars.PromotionRuleUnitsPooler, this)
}
;
goog.require("UHT.XTLink");
function PromotionsAnnouncerExtraLayout() {
    this.displayer = null;
    this.rules = null;
    this.label = null
}
PromotionsAnnouncer.prototype = Object.create(XTLink.prototype);
PromotionsAnnouncer.prototype.constructor = PromotionsAnnouncer;
function PromotionsAnnouncer() {
    XTLink.call(this);
    this.displayer = null;
    this.rules = null;
    this.label = null;
    this.catShow = null;
    this.catShowFull = null;
    this.catHide = null;
    this.hasExtraLayout = false;
    this.extraLayout = null;
    this.catShowWin = null;
    this.winContentSwitcher = null;
    this.resultDisplayerLoopStartsPriority = 0;
    this.announcements = [];
    this.uid = "";
    this.isVisible = false;
    this.mustShowWin = false;
    this.rq = null;
    this.spinBlocked = false
}
PromotionsAnnouncer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Prepare, this.OnPrepare, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Announce, this.OnAnnounce, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_PrepareForWin, this.OnPrepareForWin, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_ShowWin, this.OnShowWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_InjectRQIOnResultDisplayerLoopStarts, this.OnResultDisplayerLoopStarts, this, this.resultDisplayerLoopStartsPriority);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this)
}
;
PromotionsAnnouncer.prototype.OnTournamentsUpdated = function() {
    if (this.isVisible && !PromotionsHelper.PromotionAvailable(this.uid))
        this.NextAnnouncement()
}
;
PromotionsAnnouncer.prototype.OnResultDisplayerLoopStarts = function() {
    if (this.mustShowWin) {
        if (this.rq == null)
            this.rq = XT.GetObject(Vars.RQManagerObject);
        this.rq.AddRoutineQueueItem(new RQIWaitForXTEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_WinShown))
    }
}
;
PromotionsAnnouncer.prototype.OnPrepare = function() {
    this.BlockSpin()
}
;
PromotionsAnnouncer.prototype.OnPrepareForWin = function() {
    this.OnPrepare();
    this.mustShowWin = true
}
;
PromotionsAnnouncer.prototype.OnAnnounce = function() {
    this.BlockSpin();
    var list = PromotionsHelper.GetAnnouncements();
    for (var i = 0; i < list.length; ++i)
        this.announcements.push(list[i]);
    if (!this.isVisible)
        this.NextAnnouncement()
}
;
PromotionsAnnouncer.prototype.NextAnnouncement = function() {
    if (this.announcements.length == 0) {
        this.rules.SetVisible(false);
        if (this.hasExtraLayout)
            this.extraLayout.rules.SetVisible(false);
        this.catHide.Start();
        this.isVisible = false;
        this.UnblockSpin();
        return
    }
    this.uid = this.announcements[0].uid;
    if (!PromotionsHelper.PromotionAvailable(this.uid)) {
        this.announcements.splice(0, 1);
        this.NextAnnouncement();
        return
    }
    this.displayer.UpdateTournament(this.uid);
    this.label.text = this.announcements[0].description;
    this.rules.SetVisible(false);
    if (this.hasExtraLayout) {
        this.extraLayout.label.text = this.label.text;
        this.extraLayout.displayer.UpdateTournament(this.uid);
        this.extraLayout.rules.SetVisible(false)
    }
    this.catShow.Start();
    this.isVisible = true;
    this.announcements.splice(0, 1)
}
;
PromotionsAnnouncer.prototype.OnShowWin = function() {
    this.BlockSpin();
    XT.SetDouble(TournamentVars.Promotion_WinDisplayed, 0);
    this.winContentSwitcher.SwitchByStyle(PromotionsHelper.FindPromotion(XT.GetString(TournamentVars.Promotion_WinID)).clientStyle);
    this.catShowWin.Start()
}
;
PromotionsAnnouncer.prototype.ShowWinEnded = function() {
    this.mustShowWin = false;
    XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_WinShown);
    this.UnblockSpin()
}
;
PromotionsAnnouncer.prototype.UpdateDisplayedWin = function() {
    XT.SetDouble(TournamentVars.Promotion_WinDisplayed, XT.GetDouble(TournamentVars.Promotion_WinReceived))
}
;
PromotionsAnnouncer.prototype.OptIn = function() {
    PromotionsHelper.OptIn(this.uid)
}
;
PromotionsAnnouncer.prototype.OptOut = function() {
    PromotionsHelper.OptOut(this.uid)
}
;
PromotionsAnnouncer.prototype.FullRules = function() {
    this.rules.SetVisible(true);
    this.rules.UpdateRulesManually(this.uid);
    if (this.hasExtraLayout) {
        this.extraLayout.rules.SetVisible(true);
        this.extraLayout.rules.UpdateRulesManually(this.uid)
    }
    this.catShowFull.Start()
}
;
PromotionsAnnouncer.prototype.BlockSpin = function() {
    if (!this.spinBlocked) {
        this.spinBlocked = true;
        XT.TriggerEvent(Vars.Evt_DataToCode_BlockSpin)
    }
}
;
PromotionsAnnouncer.prototype.UnblockSpin = function() {
    if (this.spinBlocked) {
        this.spinBlocked = false;
        XT.TriggerEvent(Vars.Evt_DataToCode_UnblockSpin)
    }
}
;
goog.require("UHT.Engine");
ScrollableList.prototype = Object.create(Component.prototype);
ScrollableList.prototype.constructor = ScrollableList;
function ScrollableList() {
    Component.call(this);
    this.itemHeight = 0;
    this.mouseWheelItems = 0;
    this.items = null;
    this.itemValues = null;
    this.scrollbar = null;
    this.scrollbarThumb = null;
    this.clickThreshold = 0;
    this.clickEvents = null;
    this.hasExtraItem = false;
    this.enabledContent = null;
    this.enabledContents = null;
    this.enabledColliders = null;
    this.hasInertia = false;
    this.inertiaCurve = null;
    this.inertiaTime = 0;
    this.isInertia = false;
    this.cachedCamera = null;
    this.wasPressed = false;
    this.wasHover = false;
    this.startMousePos = UHTMath.Vector3.zero;
    this.prevMousePos = UHTMath.Vector3.zero;
    this.firstItemPos = null;
    this.firstItemPosInited = false;
    this.isEnabled = false;
    this.scrollRemain = 0;
    this.wheelDelta = 0;
    this.scrollDelta = 0
}
ScrollableList.prototype.Awake = function() {
    var self = this;
    var mwl = function(e) {
        return self.OnMouseWheel(e)
    };
    window.addEventListener("mousewheel", mwl, false);
    window.addEventListener("DOMMouseScroll", mwl, false)
}
;
ScrollableList.prototype.OnMouseWheel = function(e) {
    if (!this.isEnabled || !this.wasHover || Globals.InputBlocked && !(this.cachedCamera != null && this.cachedCamera.ignoreInputBlocked))
        return;
    this.wheelDelta = e.wheelDelta ? -e.wheelDelta : e.detail;
    this.wheelDelta = UHTMath.clamp(this.wheelDelta, -1, 1);
    this.scrollDelta = 0
}
;
ScrollableList.prototype.CachedCamera = function() {
    if (this.cachedCamera == null)
        this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    return this.cachedCamera
}
;
ScrollableList.prototype.OnHover = function(isHover) {
    this.wasHover = isHover;
    if (this.wasPressed && !isHover)
        this.OnPress(false)
}
;
ScrollableList.prototype.OnPress = function(isPressed) {
    this.wasPressed = isPressed;
    if (!this.hasInertia)
        this.scrollRemain = 0;
    if (isPressed) {
        this.startMousePos = this.prevMousePos = this.gameObject.transform.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
        return
    } else if (this.isEnabled && this.hasInertia && this.scrollDelta != 0) {
        this.inertiaTime = 0;
        this.isInertia = true
    }
    this.UpdateItems(this.items[0].valueIdx);
    if (this.clickEvents.length == 0)
        return;
    var pos = this.gameObject.transform.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
    var posDelta = UHTMath.Vector3.sub(pos, this.startMousePos);
    if (Math.abs(posDelta.y) > this.clickThreshold)
        return;
    if (!this.firstItemPosInited) {
        this.firstItemPosInited = true;
        this.firstItemPos = this.gameObject.transform.inverseTransformPoint(this.items[0].gameObject.transform.position())
    }
    var clickedIdx = -1;
    for (var i = 0; i < this.items.length; ++i) {
        var itemY = this.firstItemPos.y - this.itemHeight * i;
        if (pos.y <= itemY && pos.y > itemY - this.itemHeight) {
            clickedIdx = i;
            break
        }
    }
    if (clickedIdx < 0)
        return;
    var paramString = String(clickedIdx);
    for (var i = 0; i < this.clickEvents.length; ++i) {
        if (this.clickEvents[i].useParam)
            this.clickEvents[i].paramString = paramString;
        MessageSender.SendMessage(this.clickEvents[i])
    }
}
;
ScrollableList.prototype.Update = function() {
    if (!this.isEnabled)
        return;
    var isWheelScroll = false;
    if (this.wasHover)
        if (this.wheelDelta != 0) {
            this.ScrollItems(this.wheelDelta * this.mouseWheelItems * this.itemHeight, true);
            this.wheelDelta = 0;
            isWheelScroll = true
        }
    if (this.wasPressed) {
        var pos = this.gameObject.transform.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
        var posDelta = UHTMath.Vector3.sub(pos, this.prevMousePos);
        this.prevMousePos = pos;
        if (posDelta.y != 0)
            this.ScrollItems(posDelta.y)
    } else if (!isWheelScroll)
        if (this.isInertia) {
            var scrollAmount = this.inertiaCurve.Evaluate(this.inertiaTime) * this.scrollDelta;
            if (Math.abs(scrollAmount) < .001 || this.inertiaTime > this.inertiaCurve.keys[this.inertiaCurve.keys.length - 1].time) {
                this.isInertia = false;
                this.scrollDelta = 0
            }
            this.ScrollItems(scrollAmount);
            this.inertiaTime += Time.deltaTime
        }
}
;
ScrollableList.prototype.ScrollItems = function(scrollAmount, isWheelScroll) {
    if (isWheelScroll != true)
        this.scrollDelta = scrollAmount;
    this.scrollRemain += scrollAmount;
    if (this.items[0].valueIdx == 0 && this.scrollRemain < 0 || this.items[0].valueIdx + this.items.length == this.itemValues.length && this.scrollRemain > 0)
        this.scrollRemain = 0;
    var numItems = Math.round(this.scrollRemain / this.itemHeight);
    this.scrollRemain -= numItems * this.itemHeight;
    if (numItems < 0)
        for (var i = 0; i < Math.abs(numItems); ++i) {
            var idx = this.items[0].valueIdx - 1;
            if (idx >= 0) {
                this.items[this.items.length - 1].UpdateIndexAndValue(idx, this.itemValues[idx]);
                this.items.unshift(this.items[this.items.length - 1]);
                this.items.pop()
            }
        }
    else if (numItems > 0)
        for (var i = 0; i < numItems; ++i) {
            var idx = this.items[this.items.length - 1].valueIdx + 1;
            if (idx < this.itemValues.length) {
                this.items[0].UpdateIndexAndValue(idx, this.itemValues[idx]);
                this.items.push(this.items[0]);
                this.items.shift()
            }
        }
    this.UpdateItems(this.items[0].valueIdx)
}
;
ScrollableList.prototype.UpdateItems = function(startValIdx) {
    if (startValIdx < 0)
        startValIdx = 0;
    var minY = -this.itemHeight * (this.items.length - 1);
    for (var i = 0; i < this.items.length; ++i) {
        var idx = startValIdx + i;
        if (idx < this.itemValues.length)
            this.items[i].UpdateIndexAndValue(idx, this.itemValues[idx]);
        else
            this.items[i].UpdateIndexAndValue(idx, null);
        var y = i * -this.itemHeight + (this.isEnabled ? this.scrollRemain : 0);
        this.items[i].gameObject.transform.localPosition(new UHTMath.Vector3(0,y,0));
        this.items[i].SetVisible(y > minY)
    }
    if (this.isEnabled) {
        var extraY = this.hasInertia ? this.scrollRemain / this.itemHeight : 0;
        var thumbY = this.scrollbar.height * (startValIdx + extraY) / (this.itemValues.length - 1);
        this.scrollbarThumb.gameObject.transform.localPosition(new UHTMath.Vector3(0,-thumbY,0))
    }
}
;
ScrollableList.prototype.InternalSetValues = function(values) {
    if (values != null && values.length > 0) {
        this.itemValues = values;
        if (this.itemValues[this.itemValues.length - 1] != null) {
            this.itemValues.push(null);
            if (this.hasExtraItem)
                this.itemValues.unshift(null)
        }
        this.isEnabled = this.items.length < this.itemValues.length
    } else {
        this.itemValues = [];
        this.isEnabled = false
    }
    if (this.isEnabled)
        this.scrollbarThumb.height = _number.otoi(this.scrollbar.height * (this.items.length - 1) / (this.itemValues.length - 1));
    this.scrollbar.gameObject.SetActive(this.isEnabled);
    this.scrollbarThumb.gameObject.SetActive(this.isEnabled);
    if (this.enabledContent != null)
        this.enabledContent.SetActive(this.isEnabled);
    if (this.enabledContents != null)
        for (var i = 0; i < this.enabledContents.length; ++i)
            this.enabledContents[i].SetActive(this.isEnabled);
    if (this.enabledColliders != null)
        for (var i = 0; i < this.enabledColliders.length; ++i)
            this.enabledColliders[i].enabled = this.isEnabled
}
;
ScrollableList.prototype.SetValues = function(values, updateItems) {
    if (updateItems == undefined)
        updateItems = true;
    this.InternalSetValues(values);
    if (updateItems)
        this.UpdateItems(0)
}
;
ScrollableList.prototype.UpdateValues = function(values) {
    this.InternalSetValues(values);
    this.UpdateItems(this.items[0].valueIdx)
}
;
ScrollableList.prototype.UpdateValuesAndIndex = function(values, valueIndex, justUpdateItems) {
    if (justUpdateItems == undefined)
        justUpdateItems = false;
    if (!justUpdateItems)
        this.InternalSetValues(values);
    this.UpdateItems(valueIndex)
}
;
ScrollableList.prototype.isScrollable = function() {
    return this.isEnabled
}
;
ScrollableList.prototype.ThumbDragged = function(scrollAmount) {
    this.ScrollItems(-scrollAmount / this.scrollbar.height * this.itemHeight * (this.itemValues.length - 1))
}
;
ScrollableList.prototype.BarClicked = function() {
    var clickedPos = this.scrollbarThumb.gameObject.transform.parent.inverseTransformPoint(this.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
    var thumbPos = this.scrollbarThumb.gameObject.transform.localPosition();
    this.ScrollItems(this.itemHeight * (this.items.length - 1) * (clickedPos.y < thumbPos.y ? 1 : -1))
}
;
goog.provide("UHT.ScrollableListItem");
goog.require("UHT.XTLink");
ScrollableListItem.prototype = Object.create(XTLink.prototype);
ScrollableListItem.prototype.constructor = ScrollableListItem;
function ScrollableListItem() {
    XTLink.call(this);
    this.valueIdx = -1
}
ScrollableListItem.prototype.UpdateIndexAndValue = function(idx, value) {
    this.valueIdx = idx;
    this.UpdateValue(value)
}
;
ScrollableListItem.prototype.UpdateValue = function(value) {}
;
ScrollableListItem.prototype.SetVisible = function(isVisible) {}
;
goog.require("UHT.ScrollableListItem");
LobbyGameButtons.prototype = Object.create(ScrollableListItem.prototype);
LobbyGameButtons.prototype.constructor = LobbyGameButtons;
function LobbyGameButtons() {
    ScrollableListItem.call(this);
    this.animator = null;
    this.buttons = null
}
LobbyGameButtons.prototype.UpdateValue = function(list) {
    var i = 0;
    if (list != null) {
        for (i = 0; i < list.length; ++i)
            this.buttons[i].UpdateValue(list[i]);
        this.animator.Sample(list.length / this.buttons.length)
    }
    for (; i < this.buttons.length; ++i)
        this.buttons[i].UpdateValue(null)
}
;
goog.require("UHT.ScrollableListItem");
PromotionRuleLine.prototype = Object.create(ScrollableListItem.prototype);
PromotionRuleLine.prototype.constructor = PromotionRuleLine;
function PromotionRuleLine() {
    ScrollableListItem.call(this);
    this.labelsAnchor = null;
    this.unitId = 0;
    this.unitsPooler = null;
    this.units = []
}
PromotionRuleLine.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.PromotionRuleUnitsPooler, this.OnPromotionRuleUnitsPooler, this)
}
;
PromotionRuleLine.prototype.OnPromotionRuleUnitsPooler = function(param) {
    this.unitsPooler = param
}
;
PromotionRuleLine.prototype.UpdateValue = function(value) {
    this.gameObject.SetActive(value != null);
    if (value == null) {
        this.RecycleUnits(this.units.length);
        return
    }
    var line = value;
    var prevCount = this.units.length;
    this.RecycleUnits(this.units.length - line.units.length);
    for (var i = 0; i < this.units.length; ++i)
        this.units[i].UpdateValue(line.units[i]);
    for (var i = this.units.length; i < line.units.length; ++i) {
        this.units.push(this.unitsPooler.GetObject(this.unitId, this.gameObject));
        this.units[i].UpdateValue(line.units[i]);
        this.labelsAnchor.labels = this.labelsAnchor.labels.concat(this.units[i].labels)
    }
    if (prevCount != this.units.length)
        this.labelsAnchor.DiscardCache()
}
;
PromotionRuleLine.prototype.SetVisible = function(isVisible) {
    for (var i = 0; i < this.units.length; ++i)
        this.units[i].isVisible = isVisible
}
;
PromotionRuleLine.prototype.RecycleUnits = function(count) {
    if (count < 0)
        return;
    for (var i = 0; i < count; ++i) {
        this.unitsPooler.RecycleObject(this.units[i]);
        this.labelsAnchor.labels.splice(0, this.units[i].labels.length)
    }
    var rest = [];
    for (var i = count; i < this.units.length; ++i)
        rest.push(this.units[i]);
    this.units = rest
}
;
goog.require("UHT.Engine");
ScrollableListThumb.prototype = Object.create(Component.prototype);
ScrollableListThumb.prototype.constructor = ScrollableListThumb;
function ScrollableListThumb() {
    Component.call(this);
    this.scrollableList = null;
    this.wasPressed = false;
    this.prevMousePos = UHTMath.Vector3.zero
}
ScrollableListThumb.prototype.OnHover = function(isHover) {
    if (this.wasPressed && !isHover)
        this.OnPress(false)
}
;
ScrollableListThumb.prototype.OnPress = function(isPressed) {
    this.wasPressed = isPressed;
    if (isPressed)
        this.prevMousePos = this.scrollableList.gameObject.transform.inverseTransformPoint(this.scrollableList.CachedCamera().ScreenToWorldPoint(Input.mousePosition))
}
;
ScrollableListThumb.prototype.Update = function() {
    if (this.wasPressed) {
        var pos = this.scrollableList.gameObject.transform.inverseTransformPoint(this.scrollableList.CachedCamera().ScreenToWorldPoint(Input.mousePosition));
        var posDelta = UHTMath.Vector3.sub(pos, this.prevMousePos);
        this.prevMousePos = pos;
        if (posDelta.y != 0)
            this.scrollableList.ThumbDragged(posDelta.y)
    }
}
;
goog.provide("UHT.Tournament");
goog.require("UHT.ScrollableListItem");
Tournament.prototype = Object.create(ScrollableListItem.prototype);
Tournament.prototype.constructor = Tournament;
function Tournament() {
    ScrollableListItem.call(this);
    this.selectedContent = null;
    this.unselectedContent = null;
    this.nameLabel = null;
    this.statusLabel = null;
    this.statusLabels = null;
    this.localizedStartsInLabel_0 = null;
    this.localizedStartsInLabel_1 = null;
    this.localizedOpenLabel_0 = null;
    this.localizedOpenLabel_1 = null;
    this.localizedCloseLabel = null;
    this.localizedDayLabel_0 = null;
    this.localizedDayLabel_1 = null;
    this.localizedDaysLabel_0 = null;
    this.localizedDaysLabel_1 = null;
    this.localizedHourLabel_0 = null;
    this.localizedHourLabel_1 = null;
    this.localizedHoursLabel_0 = null;
    this.localizedHoursLabel_1 = null;
    this.localizedMinuteLabel_0 = null;
    this.localizedMinuteLabel_1 = null;
    this.localizedMinutesLabel_0 = null;
    this.localizedMinutesLabel_1 = null;
    this.localizedSecondLabel_0 = null;
    this.localizedSecondLabel_1 = null;
    this.localizedSecondsLabel_0 = null;
    this.localizedSecondsLabel_1 = null;
    this.localizedLineBreakLabel_0 = null;
    this.localizedLineBreakLabel_1 = null;
    this.localizedRaceOpenLabel_0 = null;
    this.localizedRaceOpenLabel_1 = null;
    this.shortFormat = false;
    this.contentSwitcher = null;
    this.showRank = false;
    this.rankLabels = null;
    this.rankedContent = null;
    this.notRankedContent = null;
    this.tournamentData = null
}
Tournament.prototype.UpdateValue = function(value) {
    this.gameObject.SetActive(value != null);
    this.tournamentData = value;
    if (this.tournamentData == null)
        return;
    this.nameLabel.text = this.tournamentData.name;
    this.UpdateTournamentStatus();
    this.UpdateSelectedTournamentID(XT.GetString(TournamentVars.SelectedTournamentID))
}
;
Tournament.prototype.SetVisible = function(isVisible) {
    if (this.tournamentData == null)
        return;
    this.gameObject.SetActive(isVisible)
}
;
Tournament.prototype.UpdateSelectedTournamentID = function(newID) {
    if (this.tournamentData == null)
        return;
    this.selectedContent.SetActive(newID == this.tournamentData.uid);
    if (this.unselectedContent != null)
        this.unselectedContent.SetActive(newID != this.tournamentData.uid)
}
;
Tournament.prototype.UpdateTournamentStatus = function() {
    if (this.tournamentData == null)
        return;
    var status = this.tournamentData.status;
    var deltaTime = 0;
    if (status == TournamentProtocol.StatusCode.StartsSoon) {
        deltaTime = this.tournamentData.startDate - XT.GetInt(TournamentVars.ServerTime);
        if (deltaTime <= 0)
            status = TournamentProtocol.StatusCode.Open
    } else if (this.tournamentData.status == TournamentProtocol.StatusCode.Open) {
        deltaTime = this.tournamentData.endDate - XT.GetInt(TournamentVars.ServerTime);
        if (deltaTime <= 0)
            status = TournamentProtocol.StatusCode.Closed
    }
    var rankText = "";
    if (status == TournamentProtocol.StatusCode.StartsSoon)
        this.statusLabel.text = this.ProcessText(this.localizedStartsInLabel_0.text + this.SecondsToString(deltaTime) + this.localizedStartsInLabel_1.text);
    else if (status == TournamentProtocol.StatusCode.Open) {
        var details = PromotionsHelper.FindDetails(this.tournamentData.uid);
        var hasPrizes = details != null && details.prizePool != null;
        if (this.tournamentData.type == TournamentProtocol.PromoType.Race && hasPrizes && !this.shortFormat)
            this.statusLabel.text = this.ProcessText(this.localizedRaceOpenLabel_0.text + this.SecondsToString(deltaTime) + this.localizedRaceOpenLabel_1.text).replace("{0}", String(details.prizePool.totalCount));
        else
            this.statusLabel.text = this.ProcessText(this.localizedOpenLabel_0.text + this.SecondsToString(deltaTime) + this.localizedOpenLabel_1.text);
        if (this.showRank && this.tournamentData.type == TournamentProtocol.PromoType.Race && hasPrizes && details.prizePool.totalCount > 0)
            rankText = String(details.prizePool.totalCount)
    } else if (status == TournamentProtocol.StatusCode.Closed)
        this.statusLabel.text = this.localizedCloseLabel.text;
    if (this.statusLabels != null)
        for (var i = 0; i < this.statusLabels.length; ++i)
            this.statusLabels[i].text = this.statusLabel.text;
    if (this.showRank) {
        if (this.tournamentData.type == TournamentProtocol.PromoType.Tournament) {
            var leaderboard = PromotionsHelper.FindLeaderboard(this.tournamentData.uid);
            if (leaderboard != null && leaderboard.playerIndex > -1)
                rankText = String(leaderboard.playerPosition)
        }
        for (var i = 0; i < this.rankLabels.length; ++i)
            this.rankLabels[i].text = rankText;
        var isRanked = !_string.IsNullOrEmpty(rankText);
        this.rankedContent.SetActive(isRanked);
        this.notRankedContent.SetActive(!isRanked)
    }
    this.contentSwitcher.SwitchByStatus(status);
    this.contentSwitcher.SwitchByType(this.tournamentData.type);
    this.contentSwitcher.SwitchByStyle(this.tournamentData.clientStyle);
    this.tournamentData.status = status
}
;
Tournament.prototype.Update = function() {
    this.UpdateTournamentStatus()
}
;
Tournament.prototype.SecondsToString = function(seconds) {
    var d = Math.floor(seconds / 86400);
    seconds %= 86400;
    var h = Math.floor(seconds / 3600);
    seconds %= 3600;
    var m = Math.floor(seconds / 60);
    var s = seconds % 60;
    var ret = "";
    if (d == 1)
        ret += this.localizedDayLabel_0.text + String(d) + this.localizedDayLabel_1.text;
    else if (d > 1)
        ret += this.localizedDaysLabel_0.text + String(d) + this.localizedDaysLabel_1.text;
    if (h == 1)
        ret += this.localizedHourLabel_0.text + String(h) + this.localizedHourLabel_1.text;
    else if (d > 0 || h > 1)
        ret += this.localizedHoursLabel_0.text + String(h) + this.localizedHoursLabel_1.text;
    var b = !this.shortFormat || d == 0;
    if (b)
        if (m == 1)
            ret += this.localizedMinuteLabel_0.text + String(m) + this.localizedMinuteLabel_1.text;
        else if (d > 0 || h > 0 || m > 1)
            ret += this.localizedMinutesLabel_0.text + String(m) + this.localizedMinutesLabel_1.text;
    b = !this.shortFormat || d == 0 && h == 0;
    if (b)
        if (d == 0)
            if (s == 1)
                ret += this.localizedSecondLabel_0.text + String(s) + this.localizedSecondLabel_1.text;
            else if (d > 0 || h > 0 || m > 0 || s > 1)
                ret += this.localizedSecondsLabel_0.text + String(s) + this.localizedSecondsLabel_1.text;
    return this.localizedLineBreakLabel_0.text + ret + this.localizedLineBreakLabel_1.text
}
;
Tournament.prototype.ProcessText = function(text) {
    var split = text.split("\n");
    for (var i = 0; i < split.length; ++i) {
        split[i] = split[i].replace(/\s\s/g, " ");
        split[i] = _string.Trim(split[i])
    }
    return split.join("\n")
}
;
goog.provide("UHT.TournamentDetails");
goog.require("UHT.XTLink");
TournamentDetails.prototype = Object.create(XTLink.prototype);
TournamentDetails.prototype.constructor = TournamentDetails;
function TournamentDetails() {
    XTLink.call(this);
    this.scrollableList = null;
    this.details = null;
    this.mustUpdateDetails = false
}
TournamentDetails.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.TournamentDetails, this.OnTournamentDetailsUpdatedInternal, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChangedInternal, this)
}
;
TournamentDetails.prototype.OnTournamentDetailsUpdatedInternal = function(param) {
    this.details = param;
    this.OnTournamentDetailsUpdated();
    if (this.mustUpdateDetails) {
        this.mustUpdateDetails = false;
        this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
    }
}
;
TournamentDetails.prototype.OnSelectedTournamentIDChangedInternal = function(selectedTournamentID) {
    var details = PromotionsHelper.FindDetails(selectedTournamentID);
    this.mustUpdateDetails = details == null;
    this.OnSelectedTournamentIDChanged(selectedTournamentID)
}
;
TournamentDetails.prototype.OnTournamentDetailsUpdated = function() {}
;
TournamentDetails.prototype.OnSelectedTournamentIDChanged = function(selectedTournamentID) {}
;
goog.provide("UHT.TournamentDisplayer");
goog.require("UHT.Tournament");
TournamentDisplayer.prototype = Object.create(Tournament.prototype);
TournamentDisplayer.prototype.constructor = TournamentDisplayer;
function TournamentDisplayer() {
    Tournament.call(this)
}
TournamentDisplayer.prototype.UpdateTournament = function(id) {
    this.UpdateValue(PromotionsHelper.FindPromotion(id))
}
;
goog.require("UHT.TournamentDisplayer");
SelectedTournament.prototype = Object.create(TournamentDisplayer.prototype);
SelectedTournament.prototype.constructor = SelectedTournament;
function SelectedTournament() {
    TournamentDisplayer.call(this)
}
SelectedTournament.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.Tournaments, this.OnTournamentsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.UpdateTournament, this)
}
;
SelectedTournament.prototype.OnTournamentsUpdated = function(param) {
    this.UpdateTournament(XT.GetString(TournamentVars.SelectedTournamentID))
}
;
goog.require("UHT.XTLink");
TournamentLeaderboard.prototype = Object.create(XTLink.prototype);
TournamentLeaderboard.prototype.constructor = TournamentLeaderboard;
function TournamentLeaderboard() {
    XTLink.call(this);
    this.scrollableList = null
}
TournamentLeaderboard.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(TournamentVars.TournamentLeaderboards, this.OnTournamentLeaderboardsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged, this)
}
;
TournamentLeaderboard.prototype.OnTournamentLeaderboardsUpdated = function(param) {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
}
;
TournamentLeaderboard.prototype.OnSelectedTournamentIDChanged = function(newID) {
    var lb = PromotionsHelper.FindLeaderboard(newID);
    if (lb != null)
        if (lb.items != null) {
            this.scrollableList.SetValues(lb.items.slice(), false);
            var firstValueIdx = 0;
            if (this.scrollableList.isScrollable()) {
                for (var i = 0; i < lb.items.length; ++i)
                    if (lb.items[i].isPlayer) {
                        firstValueIdx = i;
                        break
                    }
                var lastIdx = firstValueIdx + (this.scrollableList.items.length - 1);
                var lastValueIdx = this.scrollableList.itemValues.length - 1;
                firstValueIdx -= lastIdx > lastValueIdx ? lastIdx - lastValueIdx : 0
            }
            this.scrollableList.UpdateValuesAndIndex(null, firstValueIdx, true);
            return
        }
    this.scrollableList.SetValues(null)
}
;
TournamentLeaderboard.prototype.ScrollToPlayer = function() {
    this.OnTournamentLeaderboardsUpdated(XT.GetObject(TournamentVars.TournamentLeaderboards))
}
;
goog.require("UHT.ScrollableListItem");
TournamentLeaderboardItem.prototype = Object.create(ScrollableListItem.prototype);
TournamentLeaderboardItem.prototype.constructor = TournamentLeaderboardItem;
function TournamentLeaderboardItem() {
    ScrollableListItem.call(this);
    this.placeLabel = null;
    this.playerLabel = null;
    this.scoreLabel = null;
    this.colorYou = null;
    this.colorNotYou = null;
    this.localizedYouLabel = null;
    this.oddContents = null
}
TournamentLeaderboardItem.prototype.UpdateValue = function(lbi) {
    this.gameObject.SetActive(lbi != null);
    if (lbi == null)
        return;
    var isYou = lbi.isPlayer;
    var color = isYou ? this.colorYou : this.colorNotYou;
    this.placeLabel.text = String(lbi.position);
    this.scoreLabel.text = String(lbi.score);
    this.playerLabel.text = isYou ? this.localizedYouLabel.text : String(lbi.playerID);
    this.placeLabel.SetColor(color);
    this.scoreLabel.SetColor(color);
    this.playerLabel.SetColor(color);
    if (this.oddContents != null)
        this.oddContents.SetActive(this.valueIdx % 2 == 1)
}
;
goog.require("UHT.ScrollableListItem");
TournamentPrize.prototype = Object.create(ScrollableListItem.prototype);
TournamentPrize.prototype.constructor = TournamentPrize;
function TournamentPrize() {
    ScrollableListItem.call(this);
    this.currency = "";
    this.placeLabel = null;
    this.prizeLabel = null;
    this.localizedToLabel_0 = null;
    this.localizedToLabel_1 = null;
    this.localizedToLabel_2 = null;
    this.oddContents = null
}
TournamentPrize.prototype.UpdateValue = function(prize) {
    this.gameObject.SetActive(prize != null);
    if (prize == null)
        return;
    var promo = PromotionsHelper.FindPromotion(XT.GetString(TournamentVars.SelectedTournamentID));
    var type = promo.type;
    var prizeLbl = this.prizeLabel;
    if (type == TournamentProtocol.PromoType.Tournament)
        if (prize.placeFrom == prize.placeTo)
            this.placeLabel.text = String(prize.placeFrom);
        else
            this.placeLabel.text = this.localizedToLabel_0.text + prize.placeFrom + this.localizedToLabel_1.text + prize.placeTo + this.localizedToLabel_2.text;
    else if (type == TournamentProtocol.PromoType.Race) {
        prizeLbl = this.placeLabel;
        this.prizeLabel.text = String(prize.count)
    }
    if (_string.IsNullOrEmpty(prize.gift))
        prizeLbl.text = LocaleManager.FormatValueWithCustomCurrency(prize.amount, this.currency);
    else
        prizeLbl.text = prize.gift;
    if (this.oddContents != null)
        this.oddContents.SetActive(this.valueIdx % 2 == 1)
}
;
goog.require("UHT.TournamentDetails");
TournamentPrizes.prototype = Object.create(TournamentDetails.prototype);
TournamentPrizes.prototype.constructor = TournamentPrizes;
function TournamentPrizes() {
    TournamentDetails.call(this);
    this.prizes = null;
    this.contents = null;
    this.alternativeContents = null;
    this.hasAlternativeContents = false
}
TournamentPrizes.prototype.OnTournamentDetailsUpdated = function() {
    this.OnSelectedTournamentIDChanged(XT.GetString(TournamentVars.SelectedTournamentID))
}
;
TournamentPrizes.prototype.OnSelectedTournamentIDChanged = function(newID) {
    var details = PromotionsHelper.FindDetails(newID);
    this.UpdateContents(details);
    if (details != null) {
        for (var i = 0; i < this.prizes.length; ++i)
            this.prizes[i].currency = details.prizePool.currency;
        if (details.prizePool.prizesList != null) {
            this.scrollableList.SetValues(details.prizePool.prizesList.slice());
            return
        }
    }
    this.scrollableList.SetValues(null)
}
;
TournamentPrizes.prototype.UpdateContents = function(details) {
    if (!this.hasAlternativeContents)
        return;
    var hasContents = details != null && details.prizePool != null && details.prizePool.prizesList != null && details.prizePool.prizesList.length > 0;
    for (var i = 0; i < this.contents.length; ++i)
        this.contents[i].SetActive(hasContents);
    for (var i = 0; i < this.alternativeContents.length; ++i)
        this.alternativeContents[i].SetActive(!hasContents)
}
;
goog.require("UHT.TournamentDetails");
goog.require("UHT.PromotionRule");
TournamentRules.prototype = Object.create(TournamentDetails.prototype);
TournamentRules.prototype.constructor = TournamentRules;
function TournamentRules() {
    TournamentDetails.call(this);
    this.maxNumberOfLinesFirstUpdate = 0;
    this.maxNumberOfLinesPerUpdate = 0;
    this.maxLabelWidth = 0;
    this.sampleLabel = null;
    this.isManual = false;
    this.tournamentID = "";
    this.tournamentIDs = [];
    this.tournamentRules = [];
    this.tournamentRulesIndices = [];
    this.needUpdate = false;
    this.isTournamentsVisible = false;
    this.isRulesVisible = true;
    this.isFirstUpdate = false;
    this.isManualUpdate = false
}
TournamentRules.prototype.OnTournamentDetailsUpdated = function() {
    if (this.details == null)
        return;
    for (var i = 0; i < this.details.length; ++i) {
        var idx = this.tournamentIDs.indexOf(this.details[i].uid);
        if (idx < 0) {
            this.needUpdate = true;
            var tr = new PromotionRule;
            tr.uid = this.details[i].uid;
            tr.sampleLabel = this.sampleLabel;
            tr.maxLabelWidth = this.maxLabelWidth;
            tr.UpdateRules(this.details[i].htmlRules);
            this.tournamentIDs.push(this.details[i].uid);
            this.tournamentRules.push(tr);
            this.tournamentRulesIndices.push(0)
        } else if (this.tournamentRules[idx].rules != this.details[i].htmlRules) {
            this.needUpdate = true;
            this.tournamentRules[idx].UpdateRules(this.details[i].htmlRules)
        }
    }
}
;
TournamentRules.prototype.OnSelectedTournamentIDChanged = function(newID) {
    if (this.isManual && !this.isManualUpdate)
        return;
    var idx = this.tournamentIDs.indexOf(this.tournamentID);
    if (idx >= 0)
        this.tournamentRulesIndices[idx] = this.scrollableList.items[0].valueIdx;
    this.tournamentID = newID;
    this.needUpdate = true;
    idx = this.tournamentIDs.indexOf(this.tournamentID);
    if (idx >= 0)
        if (this.tournamentRules[idx].isSplit) {
            this.scrollableList.UpdateValuesAndIndex(this.tournamentRules[idx].GetSplitLines().slice(), this.tournamentRulesIndices[idx]);
            return
        } else if (this.tournamentRules[idx].splitRules.length < this.maxNumberOfLinesFirstUpdate) {
            this.isFirstUpdate = true;
            return
        }
    this.scrollableList.SetValues(null)
}
;
TournamentRules.prototype.Update = function() {
    if (!this.isTournamentsVisible || !this.isRulesVisible || !this.needUpdate)
        return;
    var idx = this.tournamentIDs.indexOf(this.tournamentID);
    if (idx >= 0)
        if (!this.tournamentRules[idx].isSplit) {
            if (this.isFirstUpdate) {
                this.isFirstUpdate = false;
                this.tournamentRules[idx].maxNumberOfLines = this.maxNumberOfLinesFirstUpdate;
                this.scrollableList.UpdateValuesAndIndex(this.tournamentRules[idx].GetSplitLines().slice(), this.tournamentRulesIndices[idx])
            } else {
                this.tournamentRules[idx].maxNumberOfLines = this.maxNumberOfLinesPerUpdate;
                this.scrollableList.UpdateValues(this.tournamentRules[idx].GetSplitLines().slice())
            }
            return
        }
    this.needUpdate = false
}
;
TournamentRules.prototype.RulesVisible = function(param) {
    this.isRulesVisible = _bool.Parse(param)
}
;
TournamentRules.prototype.TournamentsVisible = function(param) {
    this.isTournamentsVisible = _bool.Parse(param)
}
;
TournamentRules.prototype.SetVisible = function(isVisible) {
    this.isRulesVisible = isVisible;
    this.isTournamentsVisible = isVisible
}
;
TournamentRules.prototype.UpdateRulesManually = function(uid) {
    this.isManualUpdate = true;
    this.OnSelectedTournamentIDChanged(uid);
    this.isManualUpdate = false
}
;
goog.require("UHT.ScrollableListItem");
TournamentRulesItem.prototype = Object.create(ScrollableListItem.prototype);
TournamentRulesItem.prototype.constructor = TournamentRulesItem;
function TournamentRulesItem() {
    ScrollableListItem.call(this);
    this.label = null
}
TournamentRulesItem.prototype.UpdateValue = function(value) {
    this.gameObject.SetActive(value != null);
    if (value == null)
        return;
    this.label.text = value
}
;
goog.require("UHT.XTLink");
TournamentsManager.prototype = Object.create(XTLink.prototype);
TournamentsManager.prototype.constructor = TournamentsManager;
function TournamentsManager() {
    XTLink.call(this);
    this.scrollableList = null;
    this.tournaments = null;
    this.catEnableTournaments = null;
    this.catDisableTournaments = null;
    this.catShowTournaments = null;
    this.catHideTournaments = null;
    this.catShowDetails = null;
    this.catHideDetails = null;
    this.catDisableHiddenMode = null;
    this.catTournamentClicked = null;
    this.showOnlyDetailsIfOneTournament = false;
    this.catShowTournamentDetails = null;
    this.catHideTournamentDetails = null;
    this.serverTime = 0;
    this.isEnabled = true;
    this.isVisible = false;
    this.isHiddenMode = true;
    this.enableBtnTimer = 0;
    this.enableBtnClickedTimes = 0;
    this.visibleTournamentsCount = 0
}
TournamentsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackInt(TournamentVars.ServerTime, this.OnServerTimeUpdated, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this);
    XT.RegisterCallbackString(TournamentVars.SelectedTournamentID, this.OnSelectedTournamentIDChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen, this.HideTournaments, this)
}
;
TournamentsManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetString(TournamentVars.SelectedTournamentID, "")
}
;
TournamentsManager.prototype.OnVSGameStateChanged = function() {
    var state = VSGameStateManager.GetState();
    if (state == VSGameState.Spin || state == VSGameState.SpinBonusRounds)
        this.HideTournaments()
}
;
TournamentsManager.prototype.OnServerTimeUpdated = function(time) {
    this.serverTime = time
}
;
TournamentsManager.prototype.OnTournamentsUpdated = function() {
    this.UpdateTournaments(XT.GetObject(TournamentVars.Tournaments))
}
;
TournamentsManager.prototype.UpdateTournaments = function(tournamentsData) {
    this.visibleTournamentsCount = tournamentsData != null ? tournamentsData.length : 0;
    if (this.visibleTournamentsCount > 0) {
        this.EnableTournaments();
        this.scrollableList.UpdateValues(tournamentsData.slice());
        if (_string.IsNullOrEmpty(XT.GetString(TournamentVars.SelectedTournamentID)))
            XT.SetString(TournamentVars.SelectedTournamentID, tournamentsData[0].uid);
        if (this.isHiddenMode)
            this.DisableTournaments();
        return
    }
    this.scrollableList.UpdateValues(null);
    this.DisableTournaments()
}
;
TournamentsManager.prototype.OnSelectedTournamentIDChanged = function(newId) {
    for (var i = 0; i < this.tournaments.length; ++i)
        this.tournaments[i].UpdateSelectedTournamentID(newId)
}
;
TournamentsManager.prototype.OnScrollableListItemClicked = function(itemIndex) {
    var idx = _number.otoi(itemIndex);
    var t = this.scrollableList.items[idx];
    if (t.tournamentData == null)
        return;
    XT.SetString(TournamentVars.SelectedTournamentID, t.tournamentData.uid);
    if (this.catTournamentClicked != null) {
        if (this.catTournamentClicked.IsRunning())
            this.catTournamentClicked.Stop();
        this.catTournamentClicked.Start()
    }
}
;
TournamentsManager.prototype.Update = function() {
    this.serverTime += Time.deltaTime;
    XT.SetInt(TournamentVars.ServerTime, _number.otoi(this.serverTime));
    this.enableBtnTimer += Time.deltaTime
}
;
TournamentsManager.prototype.DisableTournaments = function() {
    if (this.isEnabled) {
        this.isEnabled = false;
        this.StopRunningEvents();
        this.catDisableTournaments.Start()
    }
}
;
TournamentsManager.prototype.EnableTournaments = function() {
    if (!this.isEnabled) {
        this.isEnabled = true;
        this.StopRunningEvents();
        this.catEnableTournaments.Start()
    }
}
;
TournamentsManager.prototype.ShowTournaments = function() {
    if (!this.isEnabled)
        return;
    if (!this.isVisible) {
        this.isVisible = true;
        this.StopRunningEvents();
        var cat = this.catShowTournaments;
        if (this.showOnlyDetailsIfOneTournament && this.visibleTournamentsCount == 1)
            cat = this.catShowTournamentDetails;
        cat.Start()
    }
}
;
TournamentsManager.prototype.HideTournaments = function() {
    if (!this.isEnabled)
        return;
    if (this.isVisible) {
        this.isVisible = false;
        this.StopRunningEvents();
        var cat = this.catHideTournaments;
        if (this.showOnlyDetailsIfOneTournament && this.visibleTournamentsCount == 1)
            cat = this.catHideTournamentDetails;
        cat.Start()
    }
}
;
TournamentsManager.prototype.StopRunningEvents = function() {
    if (this.catEnableTournaments.IsRunning())
        this.catEnableTournaments.Stop();
    if (this.catDisableTournaments.IsRunning())
        this.catDisableTournaments.Stop();
    if (this.catShowTournaments.IsRunning())
        this.catShowTournaments.Stop();
    if (this.catHideTournaments.IsRunning())
        this.catHideTournaments.Stop();
    if (this.showOnlyDetailsIfOneTournament) {
        if (this.catShowTournamentDetails.IsRunning())
            this.catShowTournamentDetails.Stop();
        if (this.catHideTournamentDetails.IsRunning())
            this.catHideTournamentDetails.Stop()
    }
}
;
TournamentsManager.prototype.StopRunningDetailsEvents = function() {
    if (this.catShowDetails.IsRunning())
        this.catShowDetails.Stop();
    if (this.catHideDetails.IsRunning())
        this.catHideDetails.Stop()
}
;
TournamentsManager.prototype.ShowDetails = function() {
    if (this.catShowTournaments.IsRunning()) {
        this.catShowTournaments.RegisterCallback(this.OnShowTournamentsEnded, this);
        return
    }
    this.StopRunningDetailsEvents();
    this.catShowDetails.Start()
}
;
TournamentsManager.prototype.HideDetails = function() {
    this.StopRunningDetailsEvents();
    this.catHideDetails.Start()
}
;
TournamentsManager.prototype.OnShowTournamentsEnded = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        this.ShowDetails();
        this.catShowTournaments.UnregisterCallback(this.OnShowTournamentsEnded, this)
    }
}
;
TournamentsManager.prototype.EnableBtnClicked = function() {
    if (this.enableBtnTimer > 1) {
        this.enableBtnTimer = 0;
        this.enableBtnClickedTimes = 0
    }
    this.enableBtnClickedTimes++;
    if (this.enableBtnClickedTimes == 5)
        this.DisableHiddenMode()
}
;
TournamentsManager.prototype.DisableHiddenMode = function() {
    this.isHiddenMode = false;
    this.catDisableHiddenMode.Start();
    this.UpdateTournaments(XT.GetObject(TournamentVars.Tournaments))
}
;
goog.require("UHT.XTLink");
TournamentsRank.prototype = Object.create(XTLink.prototype);
TournamentsRank.prototype.constructor = TournamentsRank;
function TournamentsRank() {
    XTLink.call(this);
    this.labels = null;
    this.catShowRank = null;
    this.catHideRank = null;
    this.catShowEndDate = null;
    this.tournament = null;
    this.contentSwitcher = null;
    this.isRankVisible = false;
    this.isEndDateVisible = false
}
TournamentsRank.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_TournamentsUpdated, this.OnTournamentsUpdated, this)
}
;
TournamentsRank.prototype.OnTournamentsUpdated = function() {
    var ri = PromotionsHelper.GetRankInfo();
    if (this.contentSwitcher != null) {
        this.contentSwitcher.SwitchByType(ri.type);
        this.contentSwitcher.SwitchByStyle(ri.style)
    }
    if (!_string.IsNullOrEmpty(ri.uid)) {
        var text = String(ri.value);
        for (var i = 0; i < this.labels.length; ++i)
            this.labels[i].text = text;
        if (this.tournament != null)
            this.tournament.UpdateTournament(ri.uid);
        if (ri.value < 0) {
            if (!this.isEndDateVisible) {
                this.isEndDateVisible = true;
                this.catShowEndDate.Start()
            }
        } else if (!this.isRankVisible) {
            this.isRankVisible = true;
            this.catShowRank.Start()
        }
    } else if (this.isRankVisible || this.isEndDateVisible) {
        this.isRankVisible = false;
        this.isEndDateVisible = false;
        this.catHideRank.Start()
    }
}
;
goog.require("UHT.Engine");
CameraClippingEnabler.prototype = Object.create(Component.prototype);
CameraClippingEnabler.prototype.constructor = CameraClippingEnabler;
function CameraClippingEnabler() {
    Component.call(this)
}
CameraClippingEnabler.prototype.EnableClipping = function() {
    this.gameObject.GetComponent(ExtraCameraSettings).enabled = true;
    this.gameObject.GetComponent(ExtraCameraSettings).dirtyFlag = true
}
;
CameraClippingEnabler.prototype.DisableClipping = function() {
    this.gameObject.GetComponent(ExtraCameraSettings).enabled = false
}
;
goog.require("UHT.Engine");
ColliderProxy.prototype = Object.create(Component.prototype);
ColliderProxy.prototype.constructor = ColliderProxy;
function ColliderProxy() {
    Component.call(this);
    this.boxColliders = [];
    this.sphereColliders = [];
    this.eventPress = null;
    this.eventRelease = null;
    this.eventClick = null;
    this.eventHoverOn = null;
    this.eventHoverOff = null;
    this.notifyPress = true;
    this.notifyRelease = true;
    this.notifyClick = true;
    this.notifyHoverOn = true;
    this.notifyHoverOff = true;
    this.notifyOnDisable = true;
    this.wasHover = false
}
ColliderProxy.prototype.OnDisable = function() {
    if (!this.notifyOnDisable)
        return;
    this.OnPress(false)
}
;
ColliderProxy.prototype.OnClick = function() {
    if (!this.notifyClick)
        return;
    var cd = this.gameObject.GetComponent(ClickDelay);
    if (cd == null || cd.CanClick()) {
        for (var i = 0; i < this.boxColliders.length; ++i)
            this.boxColliders[i].gameObject.SendMessage("OnClick");
        for (var i = 0; i < this.sphereColliders.length; ++i)
            this.sphereColliders[i].gameObject.SendMessage("OnClick");
        this.SendMessageData(this.eventClick)
    }
}
;
ColliderProxy.prototype.OnHover = function(isOver) {
    this.Notify("OnHover", isOver, isOver ? this.eventHoverOn : this.eventHoverOff);
    this.wasHover = isOver
}
;
ColliderProxy.prototype.OnPress = function(isPressed) {
    this.Notify("OnPress", isPressed, isPressed ? this.eventPress : this.eventRelease);
    if (this.wasHover)
        this.OnHover(false)
}
;
ColliderProxy.prototype.Notify = function(methodName, value, messageData) {
    var notify = methodName == "OnPress" && (this.notifyPress && value || this.notifyRelease && !value) || methodName == "OnHover" && (this.notifyHoverOn && value || this.notifyHoverOff && !value);
    if (!notify)
        return;
    for (var i = 0; i < this.boxColliders.length; ++i)
        this.boxColliders[i].gameObject.SendMessage(methodName, value);
    for (var i = 0; i < this.sphereColliders.length; ++i)
        this.sphereColliders[i].gameObject.SendMessage(methodName, value);
    this.SendMessageData(messageData)
}
;
ColliderProxy.prototype.SendMessageData = function(messageData) {
    for (var i = 0; i < messageData.length; ++i)
        MessageSender.SendMessage(messageData[i])
}
;
goog.require("UHT.Engine");
AnimClipChanger.prototype = Object.create(Component.prototype);
AnimClipChanger.prototype.constructor = AnimClipChanger;
function AnimClipChanger() {
    Component.call(this)
}
AnimClipChanger.prototype.PlayAnim = function(animName) {
    this.gameObject.animation.Play(animName)
}
;
goog.require("UHT.Engine");
ButtonEnabler.prototype = Object.create(Component.prototype);
ButtonEnabler.prototype.constructor = ButtonEnabler;
function ButtonEnabler() {
    Component.call(this);
    this.target = null;
    this.uibuttons = [];
    this.isInit = false
}
ButtonEnabler.prototype.Init = function() {
    this.uibuttons = this.target.GetComponents(UIButton);
    this.isInit = true
}
;
ButtonEnabler.prototype.EnableButton = function() {
    if (!this.isInit)
        this.Init();
    for (var i = 0; i < this.uibuttons.length; i++)
        this.uibuttons[i].SetEnabled(true)
}
;
ButtonEnabler.prototype.DisableButton = function() {
    if (!this.isInit)
        this.Init();
    for (var i = 0; i < this.uibuttons.length; i++)
        this.uibuttons[i].SetEnabled(false)
}
;
goog.require("UHT.Engine");
ColliderEnabler.prototype = Object.create(Component.prototype);
ColliderEnabler.prototype.constructor = ColliderEnabler;
function ColliderEnabler() {
    Component.call(this);
    this.includeChildren = false
}
ColliderEnabler.prototype.EnableCollider = function() {
    if (this.includeChildren) {
        var colliders = this.GetComponentsInChildren(Collider, true);
        for (var i = 0; i < colliders.length; ++i)
            colliders[i].enabled = true
    } else
        this.gameObject.collider.enabled = true
}
;
ColliderEnabler.prototype.DisableCollider = function() {
    if (this.includeChildren) {
        var colliders = this.GetComponentsInChildren(Collider, true);
        for (var i = 0; i < colliders.length; ++i)
            colliders[i].enabled = false
    } else
        this.gameObject.collider.enabled = false
}
;
goog.require("UHT.Engine");
MoveTransformToTarget.prototype = Object.create(Component.prototype);
MoveTransformToTarget.prototype.constructor = MoveTransformToTarget;
function MoveTransformToTarget() {
    Component.call(this);
    this.movingTransform = null;
    this.target = null;
    this.moveDuration = 1;
    this.resetAtTheEnd = false;
    this.resetStopsMovement = false;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.speedCurve = null;
    this.moving = false;
    this.myTimeChannel = null;
    this.currentTime = 0;
    this.totalCurveTime = 0;
    this.startPosition = UHTMath.Vector3.zero;
    this.resetPosition = UHTMath.Vector3.zero
}
MoveTransformToTarget.prototype.StartMoving = function() {
    this.moving = true;
    this.currentTime = 0;
    if (this.useTimeChannel)
        this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
    this.totalCurveTime = this.speedCurve.keys[this.speedCurve.keys.length - 1].time - this.speedCurve.keys[0].time;
    this.startPosition = new UHTMath.Vector3(this.movingTransform.position().x,this.movingTransform.position().y,this.movingTransform.position().z);
    this.resetPosition = new UHTMath.Vector3(this.movingTransform.localPosition().x,this.movingTransform.localPosition().y,this.movingTransform.localPosition().z)
}
;
MoveTransformToTarget.prototype.ResetPosition = function() {
    if (this.resetStopsMovement)
        this.moving = false;
    this.movingTransform.localPosition(this.resetPosition)
}
;
MoveTransformToTarget.prototype.Update = function() {
    if (this.moving) {
        var progress = this.currentTime / this.moveDuration;
        if (this.speedCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.speedCurve.Evaluate(curCurveTime + this.speedCurve.keys[0].time);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        if (progress >= 0 && progress <= 1)
            this.movingTransform.position(UHTMath.Vector3.lerp(this.startPosition, this.target.position(), progress));
        if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                if (this.currentTime < this.moveDuration)
                    this.currentTime += Time.deltaTime;
                this.myTimeChannel.currentTime = this.currentTime
            } else
                this.currentTime = this.myTimeChannel.currentTime;
        else if (this.currentTime < this.moveDuration)
            this.currentTime += Time.deltaTime;
        if (this.currentTime >= this.moveDuration) {
            if (this.useTimeChannel)
                Globals.UnregisterFromTimeChannel(this, this.timeChannelID);
            this.movingTransform.position(this.target.position());
            this.moving = false;
            if (this.resetAtTheEnd)
                this.ResetPosition()
        }
    }
}
;
goog.require("UHT.Engine");
MovieController.prototype = Object.create(Component.prototype);
MovieController.prototype.constructor = MovieController;
function MC_SerializeHelper() {
    this.id = [];
    this.cachedTex = []
}
function MovieController() {
    Component.call(this);
    this.FPS = 10;
    this.startFrame = 0;
    this.loop = true;
    this.playAutomatically = true;
    this.pausedUntilReady = false;
    this.deltaMovie = true;
    this.superTrimPlayInReverse = false;
    this.callback = null;
    this.fallback = null;
    this.isPlaying = false;
    this.atlases = [];
    this.frames = -1;
    this.numberOfPieces = [];
    this.atlasIdxPerFramePerPiece = [];
    this.color = null;
    this.width = 0;
    this.height = 0;
    this.currentFrame = 0;
    this.time = 0;
    this.frameBuffer = null;
    this.oldFrame = -1;
    this.panel = null;
    this.pixiObject = new PIXI.Container(null);
    this.pixiObjectContent = null;
    this.movieWidth = -1;
    this.movieHeight = -1;
    this.isInit = false;
    this.blendSteps = 1;
    this.currentSubFrame = 0;
    this.oldSubFrame = 0
}
MovieController.prototype.Init = function() {
    if (this.isInit)
        return;
    var atlasesLoaded = true;
    for (var fl = 0; fl < this.frames; fl++)
        for (var pl = 0; pl < this.numberOfPieces[fl]; pl++) {
            var atlasL = this.atlases[this.atlasIdxPerFramePerPiece[fl].id[pl]];
            if (!atlasL.isLoaded()) {
                atlasL.initAtlas();
                atlasesLoaded = false
            }
        }
    if (!atlasesLoaded)
        return;
    for (var f = 0; f < this.frames; f++) {
        this.atlasIdxPerFramePerPiece[f].cachedTex = _array.create(this.atlasIdxPerFramePerPiece[f].id.length);
        for (var p = 0; p < this.numberOfPieces[f]; p++) {
            var atlas = this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]];
            this.atlasIdxPerFramePerPiece[f].cachedTex[p] = atlas.getTextureForSimpleSprite(null, "Frame_" + f + "_p" + p)
        }
    }
    this.panel = this.gameObject.GetComponent(UIPanel);
    var tex0 = this.atlasIdxPerFramePerPiece[0].cachedTex[0];
    if (this.movieWidth > 0) {
        this.width = this.movieWidth;
        this.height = this.movieHeight
    } else {
        this.width = tex0.trim.width;
        this.height = tex0.trim.height
    }
    if (this.deltaMovie) {
        this.frameBuffer = new PIXI.RenderTexture(globalRenderer.renderer,this.width,this.height);
        this.pixiObjectContent = new PIXI.Sprite(this.frameBuffer);
        this.pixiObjectContent.blendMode = this.atlases[0].blendMode;
        this.pixiObjectContent.anchor.x = .5;
        this.pixiObjectContent.anchor.y = .5
    } else
        this.pixiObjectContent = new PIXI.Container(null);
    this.pixiObject.addChild(this.pixiObjectContent);
    this.isInit = true;
    if (this.fallback != null && this.fallback.activeSelf)
        this.fallback.SetActive(false)
}
;
MovieController.prototype.Start = function() {
    this.Init()
}
;
MovieController.prototype.OnWillRenderObject = function() {
    if (!this.isInit) {
        this.Init();
        if (!this.isInit)
            return
    }
    this.pixiObject.dirtyWT = true;
    if (this.deltaMovie) {
        var child = this.pixiObjectContent;
        child.tint = this.color.rgbAsHex;
        if (this.panel != null)
            child.alpha = this.color.a * this.panel.alpha;
        else
            child.alpha = this.color.a;
        child.worldAlpha = child.alpha;
        var hc = this.gameObject.transform;
        var parent = this.pixiObject;
        var hp = hc.parent.transform;
        parent.x = hp._dangerous_get_position().x;
        parent.y = -hp._dangerous_get_position().y;
        child.x = hc._dangerous_get_localPosition().x;
        child.y = -hc._dangerous_get_localPosition().y;
        parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
        child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
        parent.scale.x = hp._dangerous_get_scale().x;
        parent.scale.y = hp._dangerous_get_scale().y;
        child.width = this.width * hc._dangerous_get_localScale().x;
        child.height = this.height * hc._dangerous_get_localScale().y
    } else {
        if (this.oldFrame != this.currentFrame) {
            this.pixiObjectContent.children = [];
            var f = this.currentFrame;
            for (var p = 0; p < this.numberOfPieces[f]; p++) {
                var pixiSprite = new PIXI.Sprite(this.atlasIdxPerFramePerPiece[f].cachedTex[p]);
                var resize = this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]].resize / 100;
                pixiSprite.width = this.width / resize;
                pixiSprite.height = this.height / resize;
                pixiSprite.anchor.x = .5;
                pixiSprite.anchor.y = .5;
                pixiSprite.blendMode = this.atlases[0].blendMode;
                this.pixiObjectContent.addChild(pixiSprite)
            }
            this.oldFrame = this.currentFrame
        }
        var child = this.pixiObjectContent;
        for (var i = 0; i < child.children.length; i++) {
            var c = child.children[i];
            c.tint = this.color.rgbAsHex;
            if (this.panel != null)
                c.alpha = this.color.a * this.panel.alpha;
            else
                c.alpha = this.color.a;
            c.worldAlpha = c.alpha
        }
        var hc = this.gameObject.transform;
        var parent = this.pixiObject;
        var hp = hc.parent.transform;
        parent.x = hp._dangerous_get_position().x;
        parent.y = -hp._dangerous_get_position().y;
        child.x = hc._dangerous_get_localPosition().x;
        child.y = -hc._dangerous_get_localPosition().y;
        parent.rotation = -hp._dangerous_get_rotation().eulerAnglesRad().z;
        child.rotation = -hc._dangerous_get_localRotation().eulerAnglesRad().z;
        parent.scale.x = hp._dangerous_get_scale().x;
        parent.scale.y = hp._dangerous_get_scale().y;
        child.scale.x = hc._dangerous_get_localScale().x;
        child.scale.y = hc._dangerous_get_localScale().y
    }
}
;
MovieController.prototype.StartPlaying = function() {
    this.time = 0;
    this.currentFrame = this.startFrame;
    this.isPlaying = true
}
;
MovieController.prototype.OnEnable = function() {
    if (this.playAutomatically)
        this.StartPlaying();
    if (!this.isInit && this.fallback != null)
        this.fallback.SetActive(true)
}
;
MovieController.prototype.OnDisable = function() {
    if (this.fallback != null && this.fallback.activeSelf)
        this.fallback.SetActive(false)
}
;
MovieController.prototype.OnUpdateRenderTexture = function() {
    if (this.deltaMovie) {
        if (!this.isInit) {
            this.Init();
            if (!this.isInit)
                return
        }
        if (this.oldFrame > this.currentFrame)
            this.oldFrame = -1;
        var pieces, pixiSprite, resize, f, p;
        if (this.oldFrame != this.currentFrame) {
            pieces = new PIXI.Container(null);
            for (f = this.oldFrame + 1; f <= this.currentFrame; f++)
                for (p = 0; p < this.numberOfPieces[f]; p++) {
                    pixiSprite = new PIXI.Sprite(this.atlasIdxPerFramePerPiece[f].cachedTex[p]);
                    resize = this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]].resize / 100;
                    pixiSprite.width = this.width / resize;
                    pixiSprite.height = this.height / resize;
                    pieces.addChild(pixiSprite)
                }
            this.frameBuffer.render(pieces);
            this.oldFrame = this.currentFrame;
            this.oldSubFrame = this.currentSubFrame = 0
        }
        this.currentSubFrame = this.time / (1 / this.FPS / this.blendSteps) | 0;
        if (this.oldSubFrame != this.currentSubFrame) {
            var alpha = 1 / this.blendSteps;
            pieces = new PIXI.Container(null);
            f = this.currentFrame + 1;
            if (this.loop)
                f = f % this.frames;
            for (p = 0; p < this.numberOfPieces[f]; p++) {
                pixiSprite = new PIXI.Sprite(this.atlasIdxPerFramePerPiece[f].cachedTex[p]);
                resize = this.atlases[this.atlasIdxPerFramePerPiece[f].id[p]].resize / 100;
                pixiSprite.width = this.width / resize;
                pixiSprite.height = this.height / resize;
                pixiSprite.alpha = alpha;
                pieces.addChild(pixiSprite)
            }
            this.frameBuffer.render(pieces);
            this.oldSubFrame = this.currentSubFrame
        }
    }
}
;
MovieController.prototype.Update = function() {
    if (!this.isInit && this.pausedUntilReady)
        return;
    if (this.isPlaying) {
        this.time += Time.deltaTime;
        while (this.time > 1 / this.FPS) {
            if (this.superTrimPlayInReverse)
                this.currentFrame--;
            else
                this.currentFrame++;
            if (this.currentFrame == this.frames) {
                this.currentFrame--;
                if (!this.loop)
                    this.isPlaying = false;
                else
                    this.currentFrame = 0
            }
            if (this.currentFrame < 0) {
                this.currentFrame = 0;
                if (!this.loop)
                    this.isPlaying = false;
                else
                    this.currentFrame += this.frames
            }
            if (!this.isPlaying && this.callback != null)
                this.callback.Start();
            this.time = this.time - 1 / this.FPS
        }
    }
}
;
goog.require("UHT.Engine");
MultipleParticlesEnabler.prototype = Object.create(Component.prototype);
MultipleParticlesEnabler.prototype.constructor = MultipleParticlesEnabler;
function MultipleParticlesEnabler() {
    Component.call(this);
    this.particlesGenerators = null;
    this.generateParticlesOnStart = false
}
MultipleParticlesEnabler.prototype.Awake = function() {
    if (this.particlesGenerators.length == 0)
        this.particlesGenerators = this.gameObject.GetComponentsInChildren(ParticleSystem, true);
    for (var i = 0; i < this.particlesGenerators.length; i++) {
        this.particlesGenerators[i].enableEmission = this.generateParticlesOnStart;
        this.particlesGenerators[i].gameObject.SetActive(true)
    }
}
;
MultipleParticlesEnabler.prototype.EnableEmission = function() {
    this.ChangeEmissionState(true)
}
;
MultipleParticlesEnabler.prototype.DisableEmission = function() {
    this.ChangeEmissionState(false)
}
;
MultipleParticlesEnabler.prototype.ChangeEmissionState = function(_enable) {
    if (this.particlesGenerators == null)
        this.Awake();
    for (var i = 0; i < this.particlesGenerators.length; i++)
        this.particlesGenerators[i].enableEmission = _enable
}
;
goog.require("UHT.Engine");
ParticlesControlledActive.prototype = Object.create(Component.prototype);
ParticlesControlledActive.prototype.constructor = ParticlesControlledActive;
function ParticlesControlledActive() {
    Component.call(this);
    this.particles = null;
    this.objects = null;
    this.wasEnabled = false
}
ParticlesControlledActive.prototype.Update = function() {
    var enabled = false;
    var particlesCount = 0;
    for (var i = 0; i < this.particles.length; ++i)
        particlesCount += this.particles[i].particleCount;
    enabled = particlesCount > 0;
    if (enabled == this.wasEnabled)
        return;
    this.wasEnabled = enabled;
    for (var i = 0; i < this.objects.length; ++i)
        this.objects[i].SetActive(enabled)
}
;
goog.require("UHT.Engine");
ParticlesEnabler.prototype = Object.create(Component.prototype);
ParticlesEnabler.prototype.constructor = ParticlesEnabler;
function ParticlesEnabler() {
    Component.call(this);
    this.particles = null;
    this.pEnabled = false;
    this.disableIfNoEmission = false
}
ParticlesEnabler.prototype.Awake = function() {
    if (this.particles == null)
        this.particles = this.gameObject.GetComponentsInChildren(ParticleSystem, true)[0];
    this.pEnabled = this.particles.enableEmission;
    if (!this.pEnabled)
        this.particles.gameObject.SetActive(false)
}
;
ParticlesEnabler.prototype.OnDisable = function() {
    if (this.particles.gameObject !== this.gameObject)
        this.particles.gameObject.SetActive(this.pEnabled)
}
;
ParticlesEnabler.prototype.EnableEmission = function(_enable) {
    if (this.particles == null)
        this.Awake();
    this.pEnabled = _enable;
    this.particles.enableEmission = _enable;
    if (_enable)
        this.particles.gameObject.SetActive(true);
    else if (this.gameObject.activeInHierarchy)
        this.disableIfNoEmission = true
}
;
ParticlesEnabler.prototype.SetEmissionEnabled = function() {
    this.EnableEmission(true)
}
;
ParticlesEnabler.prototype.SetEmissionDisabled = function() {
    this.EnableEmission(false)
}
;
ParticlesEnabler.prototype.Update = function() {
    if (this.disableIfNoEmission)
        if (this.particles.particleCount == 0) {
            this.particles.gameObject.SetActive(false);
            this.disableIfNoEmission = false
        }
}
;
goog.require("UHT.Engine");
SpriteFramesAnimator.prototype = Object.create(Component.prototype);
SpriteFramesAnimator.prototype.constructor = SpriteFramesAnimator;
function SpriteFramesAnimator() {
    Component.call(this);
    this.animationTime = 1;
    this.spriteNamePrefix = "";
    this.playAutomatically = false;
    this.playReverse = false;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.Snap = true;
    this.StopOnDisable = true;
    this.SameFrameSize = false;
    this.noPauseAtPingPongEnd = false;
    this.playMode = SpriteFramesAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.animationAtlases = null;
    this.loopDelay = 0;
    this.timeScale = 1;
    this.mSprite = null;
    this.firstCurveKey = null;
    this.lastCurveKey = null;
    this.totalCurveTime = 0;
    this.currentTime = 0;
    this.direction = 1;
    this.playing = false;
    this.reset = false;
    this.mSpriteNames = null;
    this.myTimeChannel = null;
    this.elapsedDelay = 0
}
function SpriteNameAtlasPair(spriteName, sourceAtlas) {
    this.name = spriteName;
    this.atlas = sourceAtlas
}
SpriteFramesAnimator.PlayMode = {
    Default: 0,
    Loop: 1,
    PingPong: 2,
    DefaultThenFirstFrame: 3
};
SpriteFramesAnimator.prototype.Play = function() {
    this.playing = true
}
;
SpriteFramesAnimator.prototype.Pause = function() {
    this.playing = false
}
;
SpriteFramesAnimator.prototype.Stop = function() {
    this.playing = false;
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0
}
;
SpriteFramesAnimator.prototype.Reset = function() {
    this.reset = true;
    this.Stop();
    this.Update()
}
;
SpriteFramesAnimator.prototype.OnEnable = function() {
    if (this.playAutomatically)
        this.playing = true;
    if (this.useTimeChannel) {
        this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
        if (!this.myTimeChannel.IsChannelMaster(this)) {
            this.currentTime = this.myTimeChannel.currentTime;
            this.Update()
        }
    }
}
;
SpriteFramesAnimator.prototype.OnDisable = function() {
    if (this.StopOnDisable)
        this.Reset();
    if (this.useTimeChannel)
        Globals.UnregisterFromTimeChannel(this, this.timeChannelID)
}
;
SpriteFramesAnimator.prototype.Awake = function() {
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0;
    this.firstCurveKey = this.animationCurve.keys[0];
    this.lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = this.lastCurveKey.time - this.firstCurveKey.time;
    this.RebuildSpriteList()
}
;
SpriteFramesAnimator.prototype.Update = function() {
    if (this.AllAtlasesAreDownloaded() && (this.playing || this.reset) && this.mSpriteNames != null && this.mSpriteNames.length > 1) {
        if (this.reset)
            this.reset = false;
        else
            this.ComputeTime();
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        var currentSpriteFrame = Math.floor(progress * this.mSpriteNames.length);
        if (currentSpriteFrame > this.mSpriteNames.length - 1)
            currentSpriteFrame = this.mSpriteNames.length - 1;
        else if (currentSpriteFrame < 0)
            currentSpriteFrame = 0;
        this.ChangeAtlas(currentSpriteFrame);
        if (this.SameFrameSize)
            this.mSprite.SetSpriteNameForAnimation(this.mSpriteNames[currentSpriteFrame].name);
        else
            this.mSprite.SetSpriteName(this.mSpriteNames[currentSpriteFrame].name)
    }
}
;
SpriteFramesAnimator.prototype.AllAtlasesAreDownloaded = function() {
    for (var i = 0; i < this.animationAtlases.length; i++)
        if (!this.animationAtlases[i].isLoaded())
            return false;
    return true
}
;
SpriteFramesAnimator.prototype.ComputeTime = function() {
    if (this.direction > 0)
        if (this.currentTime >= this.animationTime)
            switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Loop:
                if (this.elapsedDelay >= this.loopDelay) {
                    this.elapsedDelay = 0;
                    this.currentTime -= this.animationTime
                } else
                    this.elapsedDelay += Time.deltaTime * this.timeScale;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.Stop();
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = -1;
                if (this.noPauseAtPingPongEnd)
                    this.currentTime -= this.animationTime / this.mSpriteNames.length + Time.deltaTime;
                break;
            default:
                this.Stop();
                this.currentTime = this.animationTime;
                break
            }
        else if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                this.currentTime += Time.deltaTime * this.timeScale;
                this.myTimeChannel.currentTime = this.currentTime
            } else
                this.currentTime = this.myTimeChannel.currentTime;
        else
            this.currentTime += Time.deltaTime * this.timeScale;
    if (this.direction < 0)
        if (this.currentTime <= 0)
            switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Loop:
                if (this.elapsedDelay >= this.loopDelay) {
                    this.elapsedDelay = 0;
                    this.currentTime += this.animationTime
                } else
                    this.elapsedDelay += Time.deltaTime * this.timeScale;
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = 1;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.Stop();
                break;
            default:
                this.Stop();
                this.currentTime = 0;
                break
            }
        else if (this.useTimeChannel)
            if (this.myTimeChannel.IsChannelMaster(this)) {
                this.currentTime -= Time.deltaTime * this.timeScale;
                this.myTimeChannel.currentTime = this.currentTime
            } else
                this.currentTime = this.myTimeChannel.currentTime;
        else
            this.currentTime -= Time.deltaTime * this.timeScale
}
;
SpriteFramesAnimator.prototype.RebuildSpriteList = function() {
    if (this.mSprite == null)
        this.mSprite = this.gameObject.GetComponent(UISprite);
    this.mSpriteNames = [];
    var tempAtlasList = [];
    if (this.animationAtlases.length == 0)
        tempAtlasList.push(this.mSprite.atlas);
    else
        tempAtlasList = this.animationAtlases.slice(0);
    for (var index = 0; index < tempAtlasList.length; index++)
        if (this.mSprite != null && tempAtlasList[index] != null) {
            var sprites = tempAtlasList[index].getSpriteNames();
            var imax = sprites.length;
            for (var i = 0; i < imax; ++i)
                if (_string.IsNullOrEmpty(this.spriteNamePrefix) || sprites[i].indexOf(this.spriteNamePrefix) == 0) {
                    var snap = new SpriteNameAtlasPair(sprites[i],tempAtlasList[index]);
                    this.mSpriteNames.push(snap)
                }
        }
    this.mSpriteNames.sort(function(a, b) {
        return a.name == b.name ? 0 : a.name > b.name ? 1 : -1
    })
}
;
SpriteFramesAnimator.prototype.ChangeAtlas = function(currentFrame) {
    if (this.mSprite.atlas != this.mSpriteNames[currentFrame].atlas)
        this.mSprite.atlas = this.mSpriteNames[currentFrame].atlas
}
;
goog.require("UHT.Engine");
SpriteSizeAnimator.prototype = Object.create(Component.prototype);
SpriteSizeAnimator.prototype.constructor = SpriteSizeAnimator;
function SpriteSizeAnimator() {
    Component.call(this);
    this.targetSprite = null;
    this.animationTime = 1;
    this.startSize = null;
    this.endSize = null;
    this.playAutomatically = false;
    this.resetOnDisable = false;
    this.playMode = SpriteFramesAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.affectsWidth = true;
    this.affectsHeight = true;
    this.targetCollider = null;
    this.extraSize = false;
    this.playing = false;
    this.mustStop = false;
    this.currentTime = 0;
    this.totalCurveTime = 1;
    this.direction = 1
}
SpriteSizeAnimator.prototype.Play = function() {
    this.playing = true
}
;
SpriteSizeAnimator.prototype.Pause = function() {
    this.playing = false
}
;
SpriteSizeAnimator.prototype.Stop = function() {
    this.playing = false;
    this.mustStop = false;
    this.direction = 1;
    this.currentTime = 0
}
;
SpriteSizeAnimator.prototype.Reset = function() {
    this.Stop();
    this.playing = true;
    this.Update()
}
;
SpriteSizeAnimator.prototype.Awake = function() {
    this.currentTime = 0;
    var firstCurveKey = this.animationCurve.keys[0];
    var lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = lastCurveKey.time - firstCurveKey.time
}
;
SpriteSizeAnimator.prototype.OnEnable = function() {
    if (this.playAutomatically)
        this.playing = true
}
;
SpriteSizeAnimator.prototype.OnDisable = function() {
    if (this.resetOnDisable)
        this.Reset()
}
;
SpriteSizeAnimator.prototype.Update = function() {
    if (this.playing) {
        this.ComputeTime();
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        var currentSpriteSize = UHTMath.Vector3.lerp(this.startSize, this.endSize, progress);
        this.targetSprite.width = Math.ceil(currentSpriteSize.x);
        this.targetSprite.height = Math.ceil(currentSpriteSize.y);
        if (this.mustStop)
            this.Stop()
    }
}
;
SpriteSizeAnimator.prototype.ComputeTime = function() {
    if (this.direction > 0)
        if (this.currentTime >= this.animationTime)
            switch (this.playMode) {
            case SpriteFramesAnimator.PlayMode.Default:
                this.currentTime = this.animationTime;
                this.mustStop = true;
                break;
            case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
                this.currentTime = 0;
                this.mustStop = true;
                break;
            case SpriteFramesAnimator.PlayMode.Loop:
                this.currentTime -= this.animationTime;
                break;
            case SpriteFramesAnimator.PlayMode.PingPong:
                this.direction = -1;
                break
            }
        else
            this.currentTime += Time.deltaTime;
    else if (this.currentTime <= 0)
        switch (this.playMode) {
        case SpriteFramesAnimator.PlayMode.Default:
            this.currentTime = 0;
            this.mustStop = true;
            break;
        case SpriteFramesAnimator.PlayMode.DefaultThenFirstFrame:
            this.currentTime = 0;
            this.mustStop = true;
            break;
        case SpriteFramesAnimator.PlayMode.Loop:
            this.currentTime += this.animationTime;
            break;
        case SpriteFramesAnimator.PlayMode.PingPong:
            this.direction = 1;
            break
        }
    else
        this.currentTime -= Time.deltaTime
}
;
SpriteSizeAnimator.prototype.Sample = function(normalizedTime) {
    normalizedTime = Number(normalizedTime);
    var curCurveTime = normalizedTime * this.totalCurveTime;
    normalizedTime = this.animationCurve.Evaluate(curCurveTime);
    normalizedTime = UHTMath.clamp(normalizedTime, 0, 1);
    var currentSpriteSize = UHTMath.Vector3.lerp(this.startSize, this.endSize, normalizedTime);
    if (this.affectsWidth) {
        if (this.targetSprite != null)
            this.targetSprite.width = Math.ceil(currentSpriteSize.x + (this.extraSize ? this.targetSprite.width : 0));
        if (this.targetCollider != null)
            this.targetCollider.size = new UHTMath.Vector3(currentSpriteSize.x + (this.extraSize ? this.targetCollider.size.x : 0),this.targetCollider.size.y,this.targetCollider.size.z)
    }
    if (this.affectsHeight) {
        if (this.targetSprite != null)
            this.targetSprite.height = Math.ceil(currentSpriteSize.y + (this.extraSize ? this.targetSprite.height : 0));
        if (this.targetCollider != null)
            this.targetCollider.size = new UHTMath.Vector3(this.targetCollider.size.x,currentSpriteSize.y + (this.extraSize ? this.targetCollider.size.y : 0),this.targetCollider.size.z)
    }
}
;
goog.provide("UHT.FloatAnimatedMonoBehaviour");
goog.require("UHT.Engine");
CurveValueAnimator.prototype = Object.create(Component.prototype);
CurveValueAnimator.prototype.constructor = CurveValueAnimator;
FloatAnimatedMonoBehaviour.prototype = Object.create(Component.prototype);
FloatAnimatedMonoBehaviour.prototype.constructor = FloatAnimatedMonoBehaviour;
function CurveValueAnimator() {
    Component.call(this);
    this.descriptiom = "";
    this.animatedMemberTargets = [];
    this.curve = null;
    this.Loop = true;
    this.isStarted = false;
    this.startTime = 0;
    this.lastKeyTime = 0
}
function FloatAnimatedMonoBehaviour() {
    Component.call(this);
    this.AnimatedF = 0
}
FloatAnimatedMonoBehaviour.prototype.ResetF = function() {}
;
CurveValueAnimator.prototype.Awake = function() {
    this.lastKeyTime = this.curve.keys[this.curve.keys.length - 1].time
}
;
CurveValueAnimator.prototype.StartCurveAnimation = function() {
    this.isStarted = true;
    this.startTime = Time.time
}
;
CurveValueAnimator.prototype.StopCurveAnimation = function() {
    this.isStarted = false;
    for (var i = 0; i < this.animatedMemberTargets.length; i++)
        this.animatedMemberTargets[i].ResetF()
}
;
CurveValueAnimator.prototype.Update = function() {
    var current_time = Time.time;
    if (!this.isStarted)
        return;
    for (var i = 0; i < this.animatedMemberTargets.length; i++)
        this.animatedMemberTargets[i].AnimatedF = this.curve.Evaluate(this.Loop ? (current_time - this.startTime) % this.lastKeyTime : UHTMath.clamp(current_time - this.startTime, 0, this.lastKeyTime));
    if (!this.Loop)
        if (current_time - this.startTime > this.lastKeyTime)
            this.isStarted = false
}
;
goog.require("UHT.Engine");
goog.require("UHT.FloatAnimatedMonoBehaviour");
AlphaAnimatedSprite.prototype = Object.create(FloatAnimatedMonoBehaviour.prototype);
AlphaAnimatedSprite.prototype.constructor = AlphaAnimatedSprite;
function AlphaAnimatedSprite() {
    FloatAnimatedMonoBehaviour.call(this);
    this.resetValue = .75;
    this.oldAlpha = -1;
    this.mySprite = null
}
AlphaAnimatedSprite.prototype.ResetF = function() {
    this.AnimatedF = this.resetValue;
    this.oldAlpha = this.resetValue;
    this.mySprite.color.a = UHTMath.clamp(this.resetValue, 0, 1)
}
;
AlphaAnimatedSprite.prototype.Awake = function() {
    this.mySprite = this.gameObject.GetComponent(UISprite)
}
;
AlphaAnimatedSprite.prototype.Update = function() {
    if (this.AnimatedF != this.oldAlpha) {
        this.mySprite.color.a = UHTMath.clamp(this.AnimatedF, 0, 1);
        this.oldAlpha = this.AnimatedF
    }
}
;
AlphaAnimatedSprite.prototype.CAT_GoToCustomValue = function(val) {
    this.AnimatedF = _number.otod(val);
    this.oldAlpha = this.AnimatedF;
    this.mySprite.color.a = UHTMath.clamp(this.AnimatedF, 0, 1)
}
;
goog.require("UHT.Globals");
goog.require("UHT.MessageSender");
CustomDragObject.prototype = Object.create(Component.prototype);
CustomDragObject.prototype.constructor = CustomDragObject;
function CustomDragObject() {
    Component.call(this);
    this.target = null;
    this.movement = null;
    this.messageDragStarts = null;
    this.messageDragEnds = null;
    this.swipeOverridesDrag = false;
    this.swipeMaxTime = .3;
    this.swipeMinDistance = .05;
    this.messageSwipeUp = null;
    this.messageSwipeDown = null;
    this.messageSwipeLeft = null;
    this.messageSwipeRight = null;
    this.swipeStartTime = 0;
    this.cachedCamera = null;
    this.lastMousePosition = null;
    this.mouseTotalDelta = null;
    this.isPressed = false;
    this.isStarted = false;
    this.isHover = false;
    this.limitPosition = false;
    this.localPositionLimitMin = null;
    this.localPositionLimitMax = null;
    this.useScrollWheel = false;
    this.scrollWheelMovement = null;
    this.wheelDirection = 0;
    this.useOnlyScrollWheel = false
}
CustomDragObject.prototype.Awake = function() {
    var self = this;
    var mwl = function(e) {
        return self.OnMouseWheel(e)
    };
    window.addEventListener("mousewheel", mwl, false);
    window.addEventListener("DOMMouseScroll", mwl, false)
}
;
CustomDragObject.prototype.OnMouseWheel = function(e) {
    if (!this.gameObject.activeInHierarchy || !this.isHover || Globals.InputBlocked && !(this.cachedCamera != null && this.cachedCamera.ignoreInputBlocked))
        return;
    this.wheelDirection = e.wheelDelta ? -e.wheelDelta : e.detail;
    this.wheelDirection = UHTMath.clamp(this.wheelDirection, -1, 1)
}
;
CustomDragObject.prototype.OnEnable = function() {
    if (this.cachedCamera == null)
        this.cachedCamera = Globals.GetCameraForObject(this.target.gameObject);
    this.isPressed = false;
    this.isStarted = false
}
;
CustomDragObject.prototype.OnPress = function(pressed) {
    this.isPressed = pressed;
    if (pressed) {
        this.lastMousePosition = Input.mousePosition;
        this.mouseTotalDelta = new UHTMath.Vector3(0,0,0);
        this.isStarted = false
    } else if (this.isStarted) {
        this.isStarted = false;
        var isSwipe = false;
        if (Time.time - this.swipeStartTime <= this.swipeMaxTime) {
            if (this.mouseTotalDelta.x > this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeRight);
                isSwipe = true
            } else if (this.mouseTotalDelta.x < -this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeLeft);
                isSwipe = true
            }
            if (this.mouseTotalDelta.y > this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeDown);
                isSwipe = true
            } else if (this.mouseTotalDelta.y < -this.swipeMinDistance * UHTScreen.height) {
                MessageSender.SendMessage(this.messageSwipeUp);
                isSwipe = true
            }
        }
        if (!this.swipeOverridesDrag || !isSwipe)
            MessageSender.SendMessage(this.messageDragEnds)
    }
}
;
CustomDragObject.prototype.Update = function() {
    if (!this.isPressed) {
        if (this.isHover)
            if (this.wheelDirection != 0) {
                this.ScrollWheel(this.wheelDirection);
                this.wheelDirection = 0
            }
        return
    }
    if (this.useOnlyScrollWheel)
        return;
    var mouseDeltaPos = UHTMath.Vector3.sub(Input.mousePosition, this.lastMousePosition);
    this.mouseTotalDelta.add(mouseDeltaPos);
    this.lastMousePosition = Input.mousePosition;
    if (!this.isStarted)
        if (this.mouseTotalDelta.sqrMagnitude() > 20) {
            this.isStarted = true;
            this.swipeStartTime = Time.time;
            MessageSender.SendMessage(this.messageDragStarts)
        }
    if (this.isStarted) {
        if (this.cachedCamera == null)
            this.cachedCamera = Globals.GetCameraForObject(this.target.gameObject);
        var targetDeltaPos = UHTMath.Vector3.sub(this.cachedCamera.ScreenToWorldPoint(this.lastMousePosition), this.cachedCamera.ScreenToWorldPoint(UHTMath.Vector3.add(this.lastMousePosition, mouseDeltaPos)));
        targetDeltaPos.x *= this.movement.x;
        targetDeltaPos.y *= this.movement.y;
        targetDeltaPos.z *= this.movement.z;
        this.target.position(this.GetPosition(UHTMath.Vector3.sub(this.target.position(), targetDeltaPos)))
    }
}
;
CustomDragObject.prototype.OnHover = function(hover) {
    this.isHover = hover
}
;
CustomDragObject.prototype.ScrollWheel = function(direction) {
    if (this.useScrollWheel)
        this.target.position(this.GetPosition(UHTMath.Vector3.add(this.target.position(), UHTMath.Vector3.scale(this.scrollWheelMovement, direction))))
}
;
CustomDragObject.prototype.GetPosition = function(pos) {
    if (this.limitPosition) {
        var posMin = this.target.parent.transformPoint(this.localPositionLimitMin);
        var posMax = this.target.parent.transformPoint(this.localPositionLimitMax);
        var x = UHTMath.clamp(pos.x, posMin.x, posMax.x);
        var y = UHTMath.clamp(pos.y, posMin.y, posMax.y);
        var z = UHTMath.clamp(pos.z, posMin.z, posMax.z);
        return new UHTMath.Vector3(x,y,z)
    }
    return pos
}
;
goog.require("UHT.Engine");
goog.require("UHT.TwoFloatsAnimatedMonoBehaviour");
ElementsFader.prototype = Object.create(TwoFloatsAnimatedMonoBehaviour.prototype);
ElementsFader.prototype.constructor = ElementsFader;
function ElementsFader() {
    TwoFloatsAnimatedMonoBehaviour.call(this);
    this.labelsToFade = [];
    this.spritesToFade = [];
    this.resetValue_1 = 1;
    this.resetValue_2 = 1;
    this.alphaValue = -1;
    this.oldAlpha = -1
}
ElementsFader.prototype.SetAnimatedF_1 = function(val) {
    this.alphaValue = val;
    this.Update()
}
;
ElementsFader.prototype.SetAnimatedF_2 = function(val) {
    this.alphaValue = val;
    this.Update()
}
;
ElementsFader.prototype.ResetF_1 = function() {
    this.alphaValue = this.resetValue_1;
    this.Update()
}
;
ElementsFader.prototype.ResetF_2 = function() {
    this.alphaValue = this.resetValue_2;
    this.Update()
}
;
ElementsFader.prototype.Update = function() {
    if (this.oldAlpha != this.alphaValue) {
        this.alphaValue = UHTMath.clamp(this.alphaValue, 0, 1);
        for (var i = 0; i < this.labelsToFade.length; i++) {
            if (this.alphaValue < .05) {
                this.labelsToFade[i].enabled = false;
                continue
            }
            if (!this.labelsToFade[i].enabled)
                this.labelsToFade[i].enabled = true;
            var col = this.labelsToFade[i].GetColor();
            col.a = this.alphaValue;
            this.labelsToFade[i].SetColor(col)
        }
        for (var j = 0; j < this.spritesToFade.length; j++) {
            if (this.alphaValue < .05) {
                this.spritesToFade[j].enabled = false;
                continue
            }
            if (!this.spritesToFade[j].enabled)
                this.spritesToFade[j].enabled = true;
            this.spritesToFade[j].color.a = this.alphaValue
        }
        this.oldAlpha = this.alphaValue
    }
}
;
goog.require("UHT.XTLink");
GameWindow.prototype = Object.create(XTLink.prototype);
GameWindow.prototype.constructor = GameWindow;
function GameWindow() {
    XTLink.call(this);
    this.isEnabled = true;
    this.showOnEvents = [];
    this.hideOnEvents = [];
    this.triggerAfterShow = [];
    this.triggerAfterHide = [];
    this.cat = null;
    this.showEventId = null;
    this.hideEventId = null;
    this.waitForBigWin = false;
    this.waitForWinCount = false;
    this.showAfterWinCount = false;
    this.showAfterBigWinClear = false
}
GameWindow.prototype.XTRegisterCallbacks = function() {
    if (!this.isEnabled)
        return;
    for (var i = 0; i < this.showOnEvents.length; i++)
        XT.RegisterCallbackEvent(this.showOnEvents[i].name, this.OnShowWindow, this);
    for (var j = 0; j < this.hideOnEvents.length; j++)
        XT.RegisterCallbackEvent(this.hideOnEvents[j].name, this.OnHideWindow, this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BigWinHasFinished, this.OnBigWinHasFinished, this)
}
;
GameWindow.prototype.OnDestroy = function() {
    if (!this.isEnabled)
        return;
    XT.UnregisterCallbackEvent(this.OnShowWindow, this);
    XT.UnregisterCallbackEvent(this.OnHideWindow, this);
    XT.UnregisterCallbackBool(this.OnLastWinIsCountingChanged, this)
}
;
GameWindow.prototype.OnCloseButtonPressed = function() {
    if (!this.isEnabled)
        return;
    this.OnHideWindow()
}
;
GameWindow.prototype.OnShowWindow = function() {
    if (!this.isEnabled)
        return;
    if (this.waitForBigWin && XT.GetBool(Vars.WaitInResultForBigWin))
        this.showAfterBigWinClear = true;
    else if (this.waitForWinCount && XT.GetBool(Vars.LastWinIsCounting))
        this.showAfterWinCount = true;
    else
        this.ShowWindow()
}
;
GameWindow.prototype.OnHideWindow = function() {
    if (this.cat != null && this.hideEventId.cat != null) {
        if (this.showEventId != null && this.showEventId.IsRunning())
            this.showEventId.Stop();
        this.cat.RegisterCallback(this.hideEventId.id, this.HideEventFinished, this);
        this.cat.StartEvent(this.hideEventId.id)
    } else {
        this.gameObject.SetActive(false);
        for (var i = 0; i < this.triggerAfterHide.length; i++)
            XT.TriggerEvent(this.triggerAfterHide[i].name)
    }
}
;
GameWindow.prototype.ShowEventFinished = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        for (var i = 0; i < this.triggerAfterShow.length; i++)
            XT.TriggerEvent(this.triggerAfterShow[i].name);
        if (this.cat != null)
            this.cat.UnregisterCallback(this.showEventId.id, this.ShowEventFinished, this)
    }
}
;
GameWindow.prototype.HideEventFinished = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        this.gameObject.SetActive(false);
        for (var i = 0; i < this.triggerAfterHide.length; i++)
            XT.TriggerEvent(this.triggerAfterHide[i].name);
        if (this.cat != null)
            this.cat.UnregisterCallback(this.hideEventId.id, this.HideEventFinished, this)
    }
}
;
GameWindow.prototype.OnLastWinIsCountingChanged = function(value) {
    if (!this.isEnabled)
        return;
    if (this.showAfterWinCount && !value) {
        this.ShowWindow();
        this.showAfterWinCount = false
    }
}
;
GameWindow.prototype.OnBigWinHasFinished = function() {
    if (!this.isEnabled)
        return;
    if (this.showAfterBigWinClear) {
        this.ShowWindow();
        this.showAfterBigWinClear = false
    }
}
;
GameWindow.prototype.ShowWindow = function() {
    if (!this.isEnabled)
        return;
    this.gameObject.SetActive(true);
    if (this.cat != null && this.showEventId.cat != null) {
        this.cat.RegisterCallback(this.showEventId.id, this.ShowEventFinished, this);
        this.cat.StartEvent(this.showEventId.id)
    }
}
;
goog.require("UHT.XTLink");
JurisdictionCustomization.prototype = Object.create(XTLink.prototype);
JurisdictionCustomization.prototype.constructor = JurisdictionCustomization;
function JurisdictionCustomization() {
    XTLink.call(this);
    this.jurisdiction = "";
    this.jurisdictionRequirement = null;
    this.jurisdictionCustomization = null
}
JurisdictionCustomization.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this)
}
;
JurisdictionCustomization.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
}
;
JurisdictionCustomization.prototype.OnGUIInit = function() {
    var varValue = false;
    var varName = this.jurisdictionRequirement.name;
    if (varName != null && varName != "" && varName != "*None*")
        varValue = XT.GetBool(varName);
    if (ServerOptions.jurisdiction == this.jurisdiction || varValue)
        this.jurisdictionCustomization.Start()
}
;
goog.require("UHT.Engine");
MoveSource.prototype = Object.create(Component.prototype);
MoveSource.prototype.constructor = MoveSource;
function MoveSource() {
    Component.call(this);
    this.targetID = MoveTargetID.Invalid
}
MoveSource.prototype.Awake = function() {
    var roots = globalRuntime.sceneRoots;
    for (var i = 0; i < roots.length; ++i) {
        var targets = roots[i].GetComponentsInChildren(MoveTarget, true);
        for (var j = 0; j < targets.length; ++j)
            if (targets[j].targetID == this.targetID) {
                this.gameObject.transform.position(targets[j].transform.position());
                break
            }
    }
}
;
goog.require("UHT.Engine");
var MoveTargetID = {
    Invalid: 0,
    SpinButton: 1
};
MoveTarget.prototype = Object.create(Component.prototype);
MoveTarget.prototype.constructor = MoveTarget;
function MoveTarget() {
    Component.call(this);
    this.targetID = MoveTargetID.Invalid
}
goog.require("UHT.XTLink");
ObjectsDisablerByPath.prototype = Object.create(XTLink.prototype);
ObjectsDisablerByPath.prototype.constructor = ObjectsDisablerByPath;
function ObjectsDisablerByPath() {
    XTLink.call(this);
    this.paths = null;
    this.useOnGameInit = true
}
ObjectsDisablerByPath.prototype.XTRegisterCallbacks = function() {
    if (this.useOnGameInit)
        XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
}
;
ObjectsDisablerByPath.prototype.OnGameInit = function() {
    var roots = globalRuntime.sceneRoots;
    for (var r = 0; r < roots.length; ++r)
        for (var i = 0; i < this.paths.length; ++i) {
            var t = roots[r].transform.Find(this.paths[i]);
            if (t != null)
                t.gameObject.SetActive(false)
        }
}
;
goog.require("UHT.XTLink");
PageFlipper.prototype = Object.create(XTLink.prototype);
PageFlipper.prototype.constructor = PageFlipper;
var MobilePageContentType = {
    Normal: 0,
    Jackpot: 1
};
function PageFlipper() {
    XTLink.call(this);
    this.topPages = [];
    this.bottomPages = [];
    this.pageContentType = [];
    this.gambleTopPageIndex = -1;
    this.gambleBottomPageIndex = -1;
    this.dragObject = null;
    this.dragMovementOffset = 300;
    this.flippingPanelDepth = 1;
    this.staticPanelDepth = 0;
    this.pageSpringStrength = 5;
    this.animationTime = 0;
    this.followDragObject = false;
    this.topPageIsFlipping = false;
    this.bottomPageIsFlipping = false;
    this.flippingPage = null;
    this.currentSpring = null;
    this.cachedCamera = null;
    this.dragReleaseTime = 0;
    this.lastDragObjHeight = 0;
    this.isDragged = false;
    this.fakeIsNotDraggedUp = false;
    this.fakeIsNotDraggedDown = false;
    this.isFlippingEnabled = true;
    this.jpData = null
}
PageFlipper.visibleTopPage = 0;
PageFlipper.visibleBottomPage = 0;
PageFlipper.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableMobileUpdatePages, this.OnMustUpdatePages, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    EventManager.AddHandler(JackpotEvents.evtJackpotStateChanged, this.OnJackpotStateChanged, this)
}
;
PageFlipper.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnMustUpdatePages, this);
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
}
;
PageFlipper.prototype.OnJackpotStateChanged = function(param) {
    this.jpData = param
}
;
PageFlipper.prototype.OnGUIInit = function() {
    if (XT.GetBool(Vars.CanGamble_Spin) == false && this.gambleTopPageIndex >= 0 && this.gambleBottomPageIndex >= 0) {
        this.topPages.splice(this.gambleTopPageIndex, 1);
        this.bottomPages.splice(this.gambleBottomPageIndex, 1)
    }
    this.ProcessJackpotPages()
}
;
PageFlipper.prototype.ProcessJackpotPages = function() {
    if (this.jpData != null && !this.jpData.IsActive && this.pageContentType.indexOf(PageContentType.Jackpot) != -1) {
        var removalCount = 0;
        for (var i = 0; i < this.pageContentType.length; i++) {
            this.topPages[i - removalCount].gameObject.SetActive(false);
            this.bottomPages[i - removalCount].gameObject.SetActive(false);
            if (this.pageContentType[i] == PageContentType.Jackpot) {
                this.topPages.splice(i - removalCount, 1);
                this.bottomPages.splice(i - removalCount, 1);
                removalCount++
            }
        }
        for (var j = 0; j < this.topPages.length; j++) {
            this.topPages[j].gameObject.SetActive(j == 0);
            this.bottomPages[j].gameObject.SetActive(j == 0)
        }
    }
}
;
PageFlipper.prototype.OnMustUpdatePages = function() {
    for (var i = 0; i < this.topPages.length; i++)
        this.topPages[i].gameObject.SetActive(PageFlipper.visibleTopPage == i);
    for (var j = 0; j < this.bottomPages.length; j++)
        this.bottomPages[j].gameObject.SetActive(PageFlipper.visibleBottomPage == j)
}
;
PageFlipper.prototype.OnDisable = function() {
    if (!this.isFlippingEnabled)
        return;
    if (this.flippingPage != null) {
        this.dragObject.localPosition(new UHTMath.Vector3(0,0,0));
        this.SpringPositionFinised()
    }
    this.isDragged = false;
    this.topPageIsFlipping = false;
    this.bottomPageIsFlipping = false;
    for (var i = 0; i < this.topPages.length; i++)
        if (this.topPages[i].gameObject.activeSelf)
            PageFlipper.visibleTopPage = i;
    for (var j = 0; j < this.bottomPages.length; j++)
        if (this.bottomPages[j].gameObject.activeSelf)
            PageFlipper.visibleBottomPage = j;
    XT.TriggerEvent(Vars.Evt_Internal_PaytableMobileUpdatePages)
}
;
PageFlipper.prototype.Update = function() {
    if (!this.isFlippingEnabled)
        return;
    if (this.followDragObject) {
        this.animationTime = this.dragObject.localPosition().y / this.dragMovementOffset;
        if (this.animationTime > 0) {
            if (this.topPageIsFlipping)
                if (this.isDragged && !this.fakeIsNotDraggedUp) {
                    if (this.lastDragObjHeight > this.dragObject.localPosition().y)
                        this.dragObject.localPosition(new UHTMath.Vector3(0,0,0));
                    this.animationTime = 0
                } else {
                    this.fakeIsNotDraggedUp = false;
                    this.StopFlippingTopPage()
                }
            else if (this.animationTime > 1) {
                if (this.flippingPage == null) {
                    this.dragObject.localPosition(this.dragObject.localPosition().x, 0, this.dragObject.localPosition().z);
                    return
                }
                this.fakeIsNotDraggedDown = false;
                this.fakeIsNotDraggedUp = false;
                this.SwitchFromBotToTopPageFlipping();
                var dragObjPos1 = new UHTMath.Vector3(this.dragObject.localPosition().x,-(this.dragMovementOffset - 1),this.dragObject.localPosition().z);
                this.dragObject.localPosition(dragObjPos1.x, dragObjPos1.y, dragObjPos1.z);
                this.animationTime = this.dragObject.localPosition().y / this.dragMovementOffset;
                if (this.animationTime < 0)
                    this.animationTime *= -1;
                this.SampleAnimation(this.flippingPage.gameObject.animation, this.animationTime);
                return
            }
            if (this.flippingPage == null)
                this.BottomPageStartsFlipping()
        }
        if (this.animationTime < 0) {
            this.animationTime *= -1;
            if (this.bottomPageIsFlipping)
                if (this.isDragged && !this.fakeIsNotDraggedDown) {
                    if (this.lastDragObjHeight < this.dragObject.localPosition().y)
                        this.dragObject.localPosition(new UHTMath.Vector3(0,0,0));
                    this.animationTime = 0
                } else {
                    this.fakeIsNotDraggedDown = false;
                    this.StopFlippingBottomPage()
                }
            else if (this.animationTime > 1) {
                if (this.flippingPage == null) {
                    this.dragObject.localPosition(this.dragObject.localPosition().x, 0, this.dragObject.localPosition().z);
                    return
                }
                this.fakeIsNotDraggedDown = false;
                this.fakeIsNotDraggedUp = false;
                this.SwitchFromTopToBottomPageFlipping();
                var dragObjPos2 = new UHTMath.Vector3(this.dragObject.localPosition().x,this.dragMovementOffset - 1,this.dragObject.localPosition().z);
                this.dragObject.localPosition(dragObjPos2.x, dragObjPos2.y, dragObjPos2.z);
                this.animationTime = this.dragObject.localPosition().y / this.dragMovementOffset;
                if (this.animationTime < 0)
                    this.animationTime *= -1;
                this.SampleAnimation(this.flippingPage.gameObject.animation, this.animationTime);
                return
            }
            if (this.flippingPage == null)
                this.TopPageStartsFlipping()
        }
        this.lastDragObjHeight = this.dragObject.localPosition().y;
        if (this.flippingPage != null)
            this.SampleAnimation(this.flippingPage.gameObject.animation, this.animationTime)
    }
}
;
PageFlipper.prototype.OnClick = function() {
    if (!this.isFlippingEnabled)
        return;
    if (Time.time - this.dragReleaseTime < .2)
        return;
    if (this.cachedCamera == null)
        this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var worldClickPos = this.cachedCamera.ScreenToWorldPoint(Input.mousePosition);
    var colliderYCenter = this.gameObject.collider.center;
    colliderYCenter = this.gameObject.transform.transformPoint(colliderYCenter);
    if (worldClickPos.y <= colliderYCenter.y) {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0,this.dragMovementOffset * 1.7,0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this;
        this.followDragObject = true
    } else {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0,-this.dragMovementOffset * 1.7,0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this;
        this.followDragObject = true
    }
}
;
PageFlipper.prototype.OnDragStarts = function() {
    this.isDragged = true;
    this.followDragObject = true;
    if (this.currentSpring != null && this.currentSpring.enabled) {
        if (this.animationTime < .2) {
            if (this.topPageIsFlipping)
                this.fakeIsNotDraggedUp = true;
            else if (this.bottomPageIsFlipping)
                this.fakeIsNotDraggedDown = true;
            this.dragObject.localPosition(new UHTMath.Vector3(0,0,0))
        }
        this.currentSpring.enabled = false
    }
}
;
PageFlipper.prototype.OnDragEnds = function() {
    this.isDragged = false;
    this.dragReleaseTime = Time.time;
    if (this.animationTime < .05) {
        this.dragObject.localPosition(new UHTMath.Vector3(0,0,0));
        this.SpringPositionFinised()
    } else {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0,0,0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this
    }
}
;
PageFlipper.prototype.OnSwipe = function(direction) {
    this.isDragged = false;
    this.dragReleaseTime = Time.time;
    var _sign = 1;
    if (direction == "DOWN")
        _sign = -1;
    if (this.animationTime < .05) {
        this.dragObject.localPosition(new UHTMath.Vector3(0,0,0));
        this.SpringPositionFinised()
    }
    if (_sign > 0 && this.topPageIsFlipping || _sign < 0 && this.bottomPageIsFlipping)
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0,0,0), this.pageSpringStrength);
    else
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0,_sign * this.dragMovementOffset * 1.7,0), this.pageSpringStrength);
    this.currentSpring.callWhenFinished = "SpringPositionFinised";
    this.currentSpring.eventReceiver = this
}
;
PageFlipper.prototype.SpringPositionFinised = function() {
    this.followDragObject = false;
    if (this.topPageIsFlipping)
        this.StopFlippingTopPage();
    else if (this.bottomPageIsFlipping)
        this.StopFlippingBottomPage()
}
;
PageFlipper.prototype.StopFlippingTopPage = function() {
    this.topPageIsFlipping = false;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.topPages.length; i++)
        if (this.flippingPage == this.topPages[i]) {
            if (i == 0)
                this.topPages[this.topPages.length - 1].gameObject.SetActive(false);
            else
                this.topPages[i - 1].gameObject.SetActive(false);
            this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
            this.flippingPage = null;
            break
        }
}
;
PageFlipper.prototype.StopFlippingBottomPage = function() {
    this.bottomPageIsFlipping = false;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.bottomPages.length; i++)
        if (this.flippingPage == this.bottomPages[i]) {
            if (i == this.bottomPages.length - 1)
                this.bottomPages[0].gameObject.SetActive(false);
            else
                this.bottomPages[i + 1].gameObject.SetActive(false);
            this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
            this.flippingPage = null;
            break
        }
}
;
PageFlipper.prototype.SwitchFromBotToTopPageFlipping = function() {
    this.bottomPageIsFlipping = false;
    this.topPageIsFlipping = true;
    this.flippingPage.gameObject.SetActive(false);
    this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.topPages.length; i++)
        if (this.topPages[i].gameObject.activeSelf) {
            if (i == this.topPages.length - 1)
                this.flippingPage = this.topPages[0];
            else
                this.flippingPage = this.topPages[i + 1];
            var p = this.flippingPage.GetComponent(UIPanel);
            p.depth = this.flippingPanelDepth;
            this.flippingPage.gameObject.SetActive(true);
            break
        }
    if (this.currentSpring != null && this.currentSpring.enabled) {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0,0,0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this
    }
}
;
PageFlipper.prototype.SwitchFromTopToBottomPageFlipping = function() {
    this.topPageIsFlipping = false;
    this.bottomPageIsFlipping = true;
    this.flippingPage.gameObject.SetActive(false);
    this.flippingPage.GetComponent(UIPanel).depth = this.staticPanelDepth;
    this.SampleAnimation(this.flippingPage.gameObject.animation, 0);
    for (var i = 0; i < this.bottomPages.length; i++)
        if (this.bottomPages[i].gameObject.activeSelf) {
            if (i == 0)
                this.flippingPage = this.bottomPages[this.bottomPages.length - 1];
            else
                this.flippingPage = this.bottomPages[i - 1];
            var p = this.flippingPage.GetComponent(UIPanel);
            p.depth = this.flippingPanelDepth;
            this.flippingPage.gameObject.SetActive(true);
            break
        }
    if (this.currentSpring != null && this.currentSpring.enabled) {
        this.currentSpring = SpringPosition.Begin(this.dragObject.gameObject, new UHTMath.Vector3(0,0,0), this.pageSpringStrength);
        this.currentSpring.callWhenFinished = "SpringPositionFinised";
        this.currentSpring.eventReceiver = this
    }
}
;
PageFlipper.prototype.BottomPageStartsFlipping = function() {
    this.bottomPageIsFlipping = true;
    this.topPageIsFlipping = false;
    for (var i = 0; i < this.bottomPages.length; i++)
        if (this.bottomPages[i].gameObject.activeSelf) {
            this.flippingPage = this.bottomPages[i];
            this.flippingPage.GetComponent(UIPanel).depth = this.flippingPanelDepth;
            if (i == this.bottomPages.length - 1)
                this.bottomPages[0].gameObject.SetActive(true);
            else
                this.bottomPages[i + 1].gameObject.SetActive(true);
            break
        }
}
;
PageFlipper.prototype.TopPageStartsFlipping = function() {
    this.topPageIsFlipping = true;
    this.bottomPageIsFlipping = false;
    for (var i = 0; i < this.topPages.length; i++)
        if (this.topPages[i].gameObject.activeSelf) {
            this.flippingPage = this.topPages[i];
            this.flippingPage.GetComponent(UIPanel).depth = this.flippingPanelDepth;
            if (i == 0)
                this.topPages[this.topPages.length - 1].gameObject.SetActive(true);
            else
                this.topPages[i - 1].gameObject.SetActive(true);
            break
        }
}
;
PageFlipper.prototype.SampleAnimation = function(anim, animationTime) {
    var animationState = anim.GetAnimationState(anim.clip.name);
    animationState.enabled = true;
    animationState.weight = 1;
    animationState.time = animationTime;
    anim.Sample();
    animationState.enabled = false
}
;
goog.require("UHT.Engine");
PanelAlphaProxy.prototype = Object.create(Component.prototype);
PanelAlphaProxy.prototype.constructor = PanelAlphaProxy;
function PanelAlphaProxy() {
    Component.call(this);
    this.alpha = -1;
    this.includeChildren = true;
    this.oldAlpha = -1;
    this.panels = null;
    this.mustGetPanels = true
}
PanelAlphaProxy.prototype.Start = function() {
    this.FindPanels()
}
;
PanelAlphaProxy.prototype.FindPanels = function() {
    if (this.includeChildren)
        this.panels = this.gameObject.GetComponentsInChildren(UIPanel, true);
    else
        this.panels = this.gameObject.GetComponents(UIPanel)
}
;
PanelAlphaProxy.prototype.Update = function() {
    if (Math.abs(this.alpha - this.oldAlpha) > .001) {
        if (this.mustGetPanels) {
            this.FindPanels();
            this.mustGetPanels = false
        }
        this.oldAlpha = this.alpha;
        for (var i = 0; i < this.panels.length; i++)
            this.panels[i].alpha = this.alpha
    } else
        this.mustGetPanels = true
}
;
goog.require("UHT.Engine");
goog.require("UHT.TwoFloatsAnimatedMonoBehaviour");
PanelFader.prototype = Object.create(TwoFloatsAnimatedMonoBehaviour.prototype);
PanelFader.prototype.constructor = PanelFader;
function PanelFader() {
    TwoFloatsAnimatedMonoBehaviour.call(this);
    this.panelToFade = null;
    this.resetValue_1 = 1;
    this.resetValue_2 = 1;
    this.alphaValue = -1;
    this.oldAlpha = -1
}
PanelFader.prototype.SetAnimatedF_1 = function(val) {
    this.alphaValue = UHTMath.clamp(val, 0, 1)
}
;
PanelFader.prototype.SetAnimatedF_2 = function(val) {
    this.alphaValue = UHTMath.clamp(val, 0, 1)
}
;
PanelFader.prototype.ResetF_1 = function() {
    this.alphaValue = UHTMath.clamp(this.resetValue_1, 0, 1)
}
;
PanelFader.prototype.ResetF_2 = function() {
    this.alphaValue = UHTMath.clamp(this.resetValue_2, 0, 1)
}
;
PanelFader.prototype.Update = function() {
    if (this.oldAlpha != this.alphaValue) {
        if (this.alphaValue < .05) {
            this.panelToFade.enabled = false;
            return
        }
        if (!this.panelToFade.enabled)
            this.panelToFade.enabled = true;
        this.panelToFade.alpha = this.alphaValue;
        this.oldAlpha = this.alphaValue
    }
}
;
goog.require("UHT.Engine");
ParticleScaleFromLabel.prototype = Object.create(Component.prototype);
ParticleScaleFromLabel.prototype.constructor = ParticleScaleFromLabel;
function ParticleScaleFromLabel() {
    Component.call(this);
    this.targetLabel = null;
    this.extraScaleX = 1;
    this.extraScaleY = 1;
    this.extraSizeX = 0;
    this.extraSizeY = 0
}
ParticleScaleFromLabel.prototype.OnEnable = function() {
    var newScale = new UHTMath.Vector3(this.targetLabel.GetWidth() * this.extraScaleX + this.extraSizeX,this.targetLabel.GetHeight() * this.extraScaleY + this.extraSizeY,1);
    this.gameObject.transform.localScale(newScale)
}
;
goog.require("UHT.Engine");
RandomGameObjectActivator.prototype = Object.create(Component.prototype);
RandomGameObjectActivator.prototype.constructor = RandomGameObjectActivator;
function RandomGameObjectActivator() {
    Component.call(this);
    this.targetGameObject = null;
    this.minActiveDuration = 1;
    this.maxActiveDuration = 1;
    this.minInactiveDuration = 1;
    this.maxInactiveDuration = 5;
    this.useRandomScaleOnEnable = false;
    this.minScaleMultiplier = 1;
    this.maxScaleMultiplier = 2;
    this.timer = 0;
    this.duration = 0;
    this.isInactive = true;
    this.initialScale = new UHTMath.Vector3(1,1,1)
}
RandomGameObjectActivator.prototype.Start = function() {
    this.isInactive = Random.Range(0, 2) > 0;
    this.initialScale = new UHTMath.Vector3(this.targetGameObject.transform.localScale().x,this.targetGameObject.transform.localScale().y,this.targetGameObject.transform.localScale().z);
    this.UpdateState()
}
;
RandomGameObjectActivator.prototype.Update = function() {
    if (this.timer >= this.duration)
        this.UpdateState();
    else
        this.timer += Time.deltaTime
}
;
RandomGameObjectActivator.prototype.UpdateState = function() {
    if (this.isInactive) {
        this.duration = Random.Range(this.minActiveDuration, this.maxActiveDuration);
        if (this.useRandomScaleOnEnable) {
            var scaleMultiplier = Random.Range(this.minScaleMultiplier, this.maxScaleMultiplier);
            this.targetGameObject.transform.localScale(this.initialScale.x * scaleMultiplier, this.initialScale.y * scaleMultiplier, this.initialScale.z * scaleMultiplier)
        }
    } else
        this.duration = Random.Range(this.minInactiveDuration, this.maxInactiveDuration);
    this.targetGameObject.SetActive(this.isInactive);
    this.isInactive = !this.isInactive;
    this.timer = 0
}
;
goog.require("UHT.Engine");
RandomIntervalCATLink.prototype = Object.create(Component.prototype);
RandomIntervalCATLink.prototype.constructor = RandomIntervalCATLink;
function RandomIntervalCATLink() {
    Component.call(this);
    this.catLink = null;
    this.minInterval = 0;
    this.maxInterval = 0;
    this.timer = 0;
    this.targetTimer = 0
}
RandomIntervalCATLink.prototype.StartCATLink = function() {
    this.catLink.Start();
    this.timer = 0;
    this.targetTimer = Random.Range(this.minInterval, this.maxInterval)
}
;
RandomIntervalCATLink.prototype.Start = function() {
    this.targetTimer = Random.Range(this.minInterval, this.maxInterval)
}
;
RandomIntervalCATLink.prototype.Update = function() {
    if (this.timer >= this.targetTimer)
        this.StartCATLink();
    this.timer += Time.deltaTime
}
;
goog.require("UHT.Engine");
SpriteFillProxy.prototype = Object.create(Component.prototype);
SpriteFillProxy.prototype.constructor = SpriteFillProxy;
function SpriteFillProxy() {
    Component.call(this);
    this.targetSprite = null;
    this.fillAmount = 0;
    this.topFillAmount = 0;
    this.bottomFillAmount = 0;
    this.leftFillAmount = 0;
    this.rightFillAmount = 0;
    this.previousFillAmount = 0;
    this.previousTopFillAmount = 0;
    this.previousBottomFillAmount = 0;
    this.previousLeftFillAmount = 0;
    this.previousRightFillAmount = 0;
    this.fillChanged = false
}
SpriteFillProxy.prototype.Update = function() {
    this.fillChanged = false;
    if (Math.abs(this.previousFillAmount - this.fillAmount) > .001) {
        this.previousFillAmount = this.fillAmount;
        this.targetSprite.fillAmount = this.fillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousTopFillAmount - this.topFillAmount) > .001) {
        this.previousTopFillAmount = this.topFillAmount;
        this.targetSprite.fillAmountTop = this.topFillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousBottomFillAmount - this.bottomFillAmount) > .001) {
        this.previousBottomFillAmount = this.bottomFillAmount;
        this.targetSprite.fillAmountBottom = this.bottomFillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousLeftFillAmount - this.leftFillAmount) > .001) {
        this.previousLeftFillAmount = this.leftFillAmount;
        this.targetSprite.fillAmountLeft = this.leftFillAmount;
        this.fillChanged = true
    }
    if (Math.abs(this.previousRightFillAmount - this.rightFillAmount) > .001) {
        this.previousRightFillAmount = this.rightFillAmount;
        this.targetSprite.fillAmountRight = this.rightFillAmount;
        this.fillChanged = true
    }
    if (this.fillChanged)
        this.targetSprite.SetSpriteName(this.targetSprite.spriteName)
}
;
goog.require("UHT.Engine");
AnimationController.prototype = Object.create(Component.prototype);
AnimationController.prototype.constructor = AnimationController;
function AnimationController() {
    Component.call(this);
    this.target = null;
    this.clip = null;
    this.animationTime = 0;
    this.playOnEnable = false;
    this.callWhenFinished = null;
    this.normalizedTimeCurve = null;
    this.useNormalizedTimeCurve = false;
    this.randomClips = null;
    this.isPlaying = false;
    this.startNormalizedTime = 0;
    this.targetNormalizedTime = 0;
    this.deltaAnimationTime = 0;
    this.curNormalizedTime = 0;
    this.curAnimationTime = 0;
    this.randomIndex = -1;
    this.randomIndices = []
}
AnimationController.prototype.ChooseRandomClip = function() {
    if (this.randomIndices.length <= 0)
        for (var i = 0; i < this.randomClips.length; ++i)
            if (this.randomIndex != i)
                this.randomIndices.push(i);
    var idx = Random.Range(0, this.randomIndices.length);
    this.randomIndex = this.randomIndices[idx];
    this.randomIndices.splice(idx, 1);
    this.clip = this.randomClips[this.randomIndex]
}
;
AnimationController.prototype.Sample = function(normalizedTime) {
    this.curNormalizedTime = Number(normalizedTime);
    var animationState = this.target.GetAnimationState(this.clip.name);
    animationState.enabled = true;
    animationState.weight = 1;
    animationState.time = this.curNormalizedTime * animationState.length;
    this.target.Sample();
    animationState.enabled = false
}
;
AnimationController.prototype.Play = function() {
    if (this.animationTime <= 0)
        this.Sample(1);
    else {
        var animationState = this.target.GetAnimationState(this.clip.name);
        animationState.speed = this.clip.length / this.animationTime;
        animationState.time = 0;
        this.target.Play(this.clip.name)
    }
}
;
AnimationController.prototype.Stop = function() {
    this.target.Stop()
}
;
AnimationController.prototype.IsPlaying = function() {
    return this.isPlaying || this.target.IsPlaying(this.clip.name)
}
;
AnimationController.prototype.PlayTo = function(normalizedTime) {
    this.startNormalizedTime = this.curNormalizedTime;
    this.targetNormalizedTime = Number(normalizedTime);
    this.deltaAnimationTime = Math.abs(this.targetNormalizedTime - this.startNormalizedTime) * this.animationTime;
    this.isPlaying = true;
    this.curAnimationTime = 0
}
;
AnimationController.prototype.Update = function() {
    if (this.isPlaying)
        if (this.curAnimationTime >= this.deltaAnimationTime) {
            this.Sample(this.targetNormalizedTime);
            this.isPlaying = false;
            if (this.callWhenFinished != null)
                this.callWhenFinished.Start()
        } else {
            if (this.deltaAnimationTime == 0) {
                console.error("AnimationController.Update - Gonna divide by 0 ... aborting");
                return
            }
            var time = this.curAnimationTime / this.deltaAnimationTime;
            if (this.useNormalizedTimeCurve)
                time = this.normalizedTimeCurve.Evaluate(time);
            this.Sample(UHTMath.lerp(this.startNormalizedTime, this.targetNormalizedTime, time));
            this.curAnimationTime += Time.deltaTime
        }
}
;
AnimationController.prototype.OnEnable = function() {
    if (this.playOnEnable)
        this.Play()
}
;
AnimationController.prototype.GetNormalizedTime = function() {
    return this.curNormalizedTime
}
;
goog.require("UHT.Random");
goog.require("UHT.Engine");
goog.provide("UHT.ExtraParticleModule");
ExtraParticleModule.prototype = Object.create(Component.prototype);
ExtraParticleModule.prototype.constructor = ExtraParticleModule;
function ExtraParticleModule() {
    Component.call(this)
}
ExtraParticleModule.prototype.SupportsFastParticleContainer = function() {
    return true
}
;
ExtraParticleModule.prototype.OnNewParticle = function(particle) {}
;
ExtraParticleModule.prototype.OnUpdateParticle = function(particle) {}
;
goog.require("UHT.Random");
goog.require("UHT.Engine");
goog.require("UHT.ExtraParticleModule");
AnimatedParticleFrames.prototype = Object.create(ExtraParticleModule.prototype);
AnimatedParticleFrames.prototype.constructor = AnimatedParticleFrames;
function AnimatedParticleFrames() {
    ExtraParticleModule.call(this);
    this.atlas = null;
    this.FPS = 15;
    this.frameInfo = []
}
AnimatedParticleFrames.prototype.Awake = function() {
    this.BuildSprites()
}
;
AnimatedParticleFrames.prototype.BuildSprites = function() {
    var mSpriteNames = this.atlas.getSpriteNames();
    mSpriteNames.sort(function(a, b) {
        return a == b ? 0 : a > b ? 1 : -1
    });
    for (var i = 0; i < mSpriteNames.length; i++)
        this.frameInfo.push(this.atlas.getTextureForSimpleSprite(null, mSpriteNames[i]))
}
;
AnimatedParticleFrames.prototype.SupportsFastParticleContainer = function() {
    return false
}
;
AnimatedParticleFrames.prototype.OnNewParticle = function(particle) {
    particle._epm_apf_frame = Random.Range(0, this.frameInfo.length - 1);
    particle._epm_apf_frameTime = Random.Range(.01, 1 / this.FPS);
    particle.sprite = new PIXI.Sprite(this.frameInfo[particle._epm_apf_frame])
}
;
AnimatedParticleFrames.prototype.OnUpdateParticle = function(particle) {
    particle._epm_apf_frameTime += Time.deltaTime;
    var newFrame = particle._epm_apf_frame;
    while (particle._epm_apf_frameTime > 1 / this.FPS) {
        particle._epm_apf_frameTime -= 1 / this.FPS;
        newFrame++
    }
    newFrame %= this.frameInfo.length;
    if (newFrame != particle._epm_apf_frame) {
        var index = -1;
        var pppc = particle.parent.pixiZOrderedContainer.children;
        for (var i = 0; i < pppc.length; i++)
            if (pppc[i] == particle.sprite)
                index = i;
        particle._epm_apf_frame = newFrame;
        particle.sprite = new PIXI.Sprite(this.frameInfo[particle._epm_apf_frame]);
        particle.sprite.blendMode = particle.parent.blendMode;
        particle.sprite.anchor.x = .5;
        particle.sprite.anchor.y = .5;
        if (index != -1) {
            particle.sprite.parent = particle.parent.pixiZOrderedContainer;
            pppc[index] = particle.sprite
        } else
            particle.parent.pixiZOrderedContainer.addChild(particle.sprite)
    }
}
;
goog.require("UHT.Random");
goog.require("UHT.Engine");
RandomAnimationPlayer.prototype = Object.create(Component.prototype);
RandomAnimationPlayer.prototype.constructor = RandomAnimationPlayer;
function RandomAnimationPlayer() {
    Component.call(this);
    this.anim = null;
    this.animationClips = [];
    this.resetClip = null;
    this.startOnEnable = false;
    this.useDelayOnStart = false;
    this.waitForPreviousClipToFinish = false;
    this.playResetAnimOnStop = true;
    this.minRandomTime = 1;
    this.maxRandomTime = 5;
    this.minRandomSpeed = 1;
    this.maxRandomSpeed = 5;
    this.noRepetition = false;
    this.isRunning = false;
    this.currentTime = 0;
    this.randomIndex = -1;
    this.randomIndices = []
}
RandomAnimationPlayer.prototype.GetRandomIndex = function() {
    if (this.randomIndices.length <= 0)
        for (var i = 0; i < this.animationClips.length; ++i)
            if (this.randomIndex != i)
                this.randomIndices.push(i);
    var idx = Random.Range(0, this.randomIndices.length);
    this.randomIndex = this.randomIndices[idx];
    this.randomIndices.splice(idx, 1);
    return this.randomIndex
}
;
RandomAnimationPlayer.prototype.OnEnable = function() {
    if (this.startOnEnable)
        this.StartAnimating()
}
;
RandomAnimationPlayer.prototype.PlayRandomClip = function() {
    var randomIndex = this.noRepetition ? this.GetRandomIndex() : Random.Range(0, this.animationClips.length);
    var randomSpeed = Random.Range(this.minRandomSpeed, this.maxRandomSpeed);
    if (!this.anim.IsPlaying(this.animationClips[randomIndex].name)) {
        this.anim.GetAnimationState(this.animationClips[randomIndex].name).speed = randomSpeed;
        this.anim.Play(this.animationClips[randomIndex].name)
    }
}
;
RandomAnimationPlayer.prototype.StartAnimating = function() {
    this.isRunning = true;
    if (this.useDelayOnStart)
        this.currentTime = Random.Range(this.minRandomTime, this.maxRandomTime);
    else
        this.currentTime = 0
}
;
RandomAnimationPlayer.prototype.StopAnimating = function() {
    this.isRunning = false;
    if (this.playResetAnimOnStop)
        this.anim.Play(this.resetClip.name)
}
;
RandomAnimationPlayer.prototype.Update = function() {
    if (this.isRunning && !(this.waitForPreviousClipToFinish && this.anim.isPlaying))
        if (this.currentTime <= 0) {
            this.currentTime = Random.Range(this.minRandomTime, this.maxRandomTime);
            this.PlayRandomClip()
        } else
            this.currentTime -= Time.deltaTime
}
;
goog.require("UHT.XTLink");
UILabelForceFallbackFont.prototype = Object.create(XTLink.prototype);
UILabelForceFallbackFont.prototype.constructor = UILabelForceFallbackFont;
function UILabelForceFallbackFont() {
    XTLink.call(this);
    this.fontFamily = "Verdana";
    this.labels = null;
    this.forceFontAfterLocalization = false;
    this.forceFontOnAwake = false
}
UILabelForceFallbackFont.prototype.XTRegisterCallbacks = function() {
    if (this.forceFontAfterLocalization)
        XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.ForceFallbackFont, this, 1)
}
;
UILabelForceFallbackFont.prototype.Awake = function() {
    FontLoader.LoadFont(this.fontFamily, null);
    if (!this.forceFontAfterLocalization || this.forceFontOnAwake)
        this.ForceFallbackFont()
}
;
UILabelForceFallbackFont.prototype.ForceFallbackFont = function() {
    for (var i = 0; i < this.labels.length; ++i) {
        this.labels[i].fontName = this.fontFamily;
        this.labels[i].Prepare()
    }
}
;
goog.require("UHT.Engine");
UILabelPropertyCopy.prototype = Object.create(Component.prototype);
UILabelPropertyCopy.prototype.constructor = UILabelPropertyCopy;
function UILabelPropertyCopy() {
    Component.call(this);
    this.FromLabel = null;
    this.ToLabel = null;
    this.CopyText = false;
    this.CopyColor = false
}
UILabelPropertyCopy.prototype.CopyProperties = function() {
    if (this.FromLabel == null || this.ToLabel == null)
        return;
    if (this.CopyText == true)
        this.ToLabel.text = this.FromLabel.text;
    if (this.CopyColor == true)
        this.ToLabel.SetColor(this.FromLabel.GetColor())
}
;
goog.require("UHT.Engine");
WidgetColorAnimator.prototype = Object.create(Component.prototype);
WidgetColorAnimator.prototype.constructor = WidgetColorAnimator;
function WidgetColorAnimator() {
    Component.call(this);
    this.targetWidgets = [];
    this.colorA = null;
    this.colorB = null;
    this.animationTime = 1;
    this.playAutomatically = false;
    this.playReverse = false;
    this.useAnimationCurve = true;
    this.useTimeChannel = false;
    this.timeChannelID = 0;
    this.playMode = WidgetColorAnimator.PlayMode.Default;
    this.animationCurve = null;
    this.firstCurveKey = null;
    this.lastCurveKey = null;
    this.totalCurveTime = 0;
    this.currentTime = 0;
    this.direction = 1;
    this.playing = false;
    this.reset = false;
    this.myTimeChannel = null
}
WidgetColorAnimator.PlayMode = {
    Default: 0,
    Loop: 1,
    PingPong: 2
};
WidgetColorAnimator.prototype.Play = function() {
    this.playing = true;
    this.direction = this.playReverse ? -1 : 1;
    if (!this.useAnimationCurve)
        this.Update()
}
;
WidgetColorAnimator.prototype.PlayReversed = function() {
    this.direction = -1;
    this.currentTime = this.animationTime - 1E-5;
    this.playing = true;
    if (!this.useAnimationCurve)
        this.Update()
}
;
WidgetColorAnimator.prototype.PlayReversedFromCurrentTime = function() {
    if (!this.playing)
        this.currentTime = this.animationTime - 1E-5;
    this.playing = true;
    this.direction = -1;
    if (!this.useAnimationCurve)
        this.Update()
}
;
WidgetColorAnimator.prototype.Pause = function() {
    this.playing = false
}
;
WidgetColorAnimator.prototype.Stop = function() {
    if (!this.playing)
        return;
    var undefined;
    if (this.useAnimationCurve)
        if (this.direction == 1)
            for (var widgetIndex = 0; widgetIndex < this.targetWidgets.length; widgetIndex++)
                Color.qLerp(this.targetWidgets[widgetIndex].color, this.colorA, this.colorB, this.animationCurve.keys[this.animationCurve.keys.length - 1].value);
        else
            for (var widgetIndex2 = 0; widgetIndex2 < this.targetWidgets.length; widgetIndex2++)
                Color.qLerp(this.targetWidgets[widgetIndex2].color, this.colorA, this.colorB, this.animationCurve.keys[0].value);
    this.playing = false;
    this.direction = this.playReverse ? -1 : 1;
    this.currentTime = this.playReverse ? this.animationTime - 1E-5 : 0
}
;
WidgetColorAnimator.prototype.Reset = function() {
    this.reset = true;
    this.Stop()
}
;
WidgetColorAnimator.prototype.OnEnable = function() {
    if (this.useTimeChannel)
        this.myTimeChannel = Globals.RegisterToTimeChannel(this, this.timeChannelID);
    if (this.playAutomatically) {
        this.playing = true;
        this.Update()
    }
}
;
WidgetColorAnimator.prototype.OnDisable = function() {
    this.Stop();
    if (this.useTimeChannel)
        Globals.UnregisterFromTimeChannel(this, this.timeChannelID)
}
;
WidgetColorAnimator.prototype.Start = function() {
    this.direction = this.playReverse ? -1 : 1;
    this.firstCurveKey = this.animationCurve.keys[0];
    this.lastCurveKey = this.animationCurve.keys[this.animationCurve.keys.length - 1];
    this.totalCurveTime = this.lastCurveKey.time - this.firstCurveKey.time
}
;
WidgetColorAnimator.prototype.Update = function() {
    if ((this.playing || this.reset) && this.targetWidgets.length > 0) {
        if (this.reset)
            this.reset = false;
        if (!this.useAnimationCurve)
            if (this.direction > 0)
                this.currentTime = this.animationTime;
            else
                this.currentTime = 0;
        var progress = this.currentTime / this.animationTime;
        if (this.animationCurve.keys.length >= 2) {
            var curCurveTime = progress * this.totalCurveTime;
            progress = this.animationCurve.Evaluate(curCurveTime);
            progress = UHTMath.clamp(progress, 0, 1)
        }
        if (progress >= 0 && progress <= 1)
            for (var i = 0; i < this.targetWidgets.length; i++)
                Color.qLerp(this.targetWidgets[i].color, this.colorA, this.colorB, progress);
        if (this.direction > 0) {
            if (this.useTimeChannel)
                if (this.myTimeChannel.IsChannelMaster(this)) {
                    if (this.currentTime < this.animationTime)
                        this.currentTime += Time.deltaTime;
                    this.myTimeChannel.currentTime = this.currentTime
                } else
                    this.currentTime = this.myTimeChannel.currentTime;
            else if (this.currentTime < this.animationTime)
                this.currentTime += Time.deltaTime;
            if (this.currentTime >= this.animationTime)
                switch (this.playMode) {
                case WidgetColorAnimator.PlayMode.Loop:
                    this.currentTime -= this.animationTime;
                    break;
                case WidgetColorAnimator.PlayMode.PingPong:
                    this.direction = -1;
                    break;
                default:
                    this.Stop();
                    break
                }
        }
        if (this.direction < 0) {
            if (this.useTimeChannel)
                if (this.myTimeChannel.IsChannelMaster(this)) {
                    if (this.currentTime > 0)
                        this.currentTime -= Time.deltaTime;
                    this.myTimeChannel.currentTime = this.currentTime
                } else
                    this.currentTime = this.myTimeChannel.currentTime;
            else if (this.currentTime > 0)
                this.currentTime -= Time.deltaTime;
            if (this.currentTime <= 0)
                switch (this.playMode) {
                case WidgetColorAnimator.PlayMode.Loop:
                    this.currentTime += this.animationTime;
                    break;
                case WidgetColorAnimator.PlayMode.PingPong:
                    this.direction = 1;
                    break;
                default:
                    this.Stop();
                    break
                }
        }
    }
}
;
WidgetColorAnimator.prototype.FindLabels = function() {
    var labels = this.gameObject.GetComponentsInChildren(UILabel, true);
    for (var i = 0; i < labels.length; ++i)
        if (this.targetWidgets.indexOf(labels[i]) < 0)
            this.targetWidgets.push(labels[i])
}
;
WidgetColorAnimator.prototype.Sample = function(normalizedTime) {
    for (var i = 0; i < this.targetWidgets.length; i++)
        Color.qLerp(this.targetWidgets[i].color, this.colorA, this.colorB, normalizedTime)
}
;
goog.require("UHT.Component");
WidgetMask.prototype = Object.create(Component.prototype);
WidgetMask.prototype.constructor = WidgetMask;
function WidgetMask() {
    Component.call(this)
}
goog.require("UHT.Engine");
WidgetsEnabler.prototype = Object.create(Component.prototype);
WidgetsEnabler.prototype.constructor = WidgetsEnabler;
function WidgetsEnabler() {
    Component.call(this);
    this.root = null;
    this.sprites = null;
    this.spritesActive = null;
    this.labels = null;
    this.labelsActive = null;
    this.isInit = false
}
WidgetsEnabler.prototype.EnableWidgets = function() {
    if (!this.isInit)
        this.FindWidgets();
    for (var i = 0; i < this.sprites.length; ++i)
        this.sprites[i].gameObject.SetActive(this.spritesActive[i]);
    for (var i = 0; i < this.labels.length; ++i)
        this.labels[i].gameObject.SetActive(this.labelsActive[i])
}
;
WidgetsEnabler.prototype.DisableWidgets = function() {
    if (!this.isInit)
        this.FindWidgets();
    for (var i = 0; i < this.sprites.length; ++i)
        this.sprites[i].gameObject.SetActive(false);
    for (var i = 0; i < this.labels.length; ++i)
        this.labels[i].gameObject.SetActive(false)
}
;
WidgetsEnabler.prototype.FindWidgets = function() {
    this.sprites = this.root.GetComponentsInChildren(UISprite, true);
    this.spritesActive = _array.create(this.sprites.length);
    for (var i = 0; i < this.sprites.length; ++i)
        this.spritesActive[i] = this.sprites[i].gameObject.activeSelf;
    this.labels = this.root.GetComponentsInChildren(UILabel, true);
    this.labelsActive = _array.create(this.labels.length);
    for (var i = 0; i < this.labels.length; ++i)
        this.labelsActive[i] = this.labels[i].gameObject.activeSelf;
    this.isInit = true
}
;
goog.provide("UHT.FOXLink");
goog.require("UHT.XTLink");
var FOXVars = {
    FOX_Response: "FOX_Response",
    Evt_FOX_InitReceived: "Evt_FOX_InitReceived",
    Evt_FOX_SpinReceived: "Evt_FOX_SpinReceived",
    Evt_FOX_CollectReceived: "Evt_FOX_CollectReceived",
    Evt_FOX_InitBonusReceived: "Evt_FOX_InitBonusReceived",
    Evt_FOX_PickBonusReceived: "Evt_FOX_PickBonusReceived",
    Evt_FOX_BonusRespinReceived: "Evt_FOX_BonusRespinReceived",
    Evt_FOX_CollectBonusReceived: "Evt_FOX_CollectBonusReceived",
    Evt_FOX_GambleReceived: "Evt_FOX_GambleReceived",
    Evt_FOX_GambleCollectReceived: "Evt_FOX_GambleCollectReceived",
    Evt_FOX_JackpotCollectReceived: "Evt_FOX_JackpotCollectReceived",
    Evt_FOX_PickFSOptionReceived: "Evt_FOX_PickFSOptionReceived",
    Evt_FOX_InitFSBGReceived: "Evt_FOX_InitFSBGReceived",
    Evt_FOX_PickFSBGReceived: "Evt_FOX_PickFSBGReceived",
    Evt_FOX_GetMysteryScatterReceived: "Evt_FOX_GetMysteryScatterReceived"
};
FOXLink.prototype = Object.create(XTLink.prototype);
FOXLink.prototype.constructor = FOXLink;
function FOXLink() {
    XTLink.call(this)
}
FOXLink.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitReceived, this.OnInitReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_SpinReceived, this.OnSpinReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_CollectReceived, this.OnCollectReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitBonusReceived, this.OnInitBonusReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_PickBonusReceived, this.OnPickBonusReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_BonusRespinReceived, this.OnBonusRespinReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_CollectBonusReceived, this.OnCollectBonusReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_GambleReceived, this.OnGambleReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_GambleCollectReceived, this.OnGambleCollectReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_JackpotCollectReceived, this.OnJackpotCollectReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_PickFSOptionReceived, this.OnPickFSOptionReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitFSBGReceived, this.OnInitFSBGReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_PickFSBGReceived, this.OnPickFSBGReceived, this);
    XT.RegisterCallbackEvent(FOXVars.Evt_FOX_GetMysteryScatterReceived, this.OnGetMysteryScatterReceived, this)
}
;
FOXLink.prototype.GetResponse = function() {
    return XT.GetObject(FOXVars.FOX_Response)
}
;
FOXLink.prototype.OnInitReceived = function() {
    this.HandleInitResponse(this.GetResponse())
}
;
FOXLink.prototype.OnSpinReceived = function() {
    this.HandleSpinResponse(this.GetResponse())
}
;
FOXLink.prototype.OnCollectReceived = function() {
    this.HandleCollectResponse(this.GetResponse())
}
;
FOXLink.prototype.OnInitBonusReceived = function() {
    this.HandleInitBonusResponse(this.GetResponse())
}
;
FOXLink.prototype.OnPickBonusReceived = function() {
    this.HandlePickBonusResponse(this.GetResponse())
}
;
FOXLink.prototype.OnBonusRespinReceived = function() {
    this.HandleBonusRespinResponse(this.GetResponse())
}
;
FOXLink.prototype.OnCollectBonusReceived = function() {
    this.HandleBonusCollectResponse(this.GetResponse())
}
;
FOXLink.prototype.OnGambleReceived = function() {
    this.HandleGambleResponse(this.GetResponse())
}
;
FOXLink.prototype.OnGambleCollectReceived = function() {
    this.HandleGambleCollectResponse(this.GetResponse())
}
;
FOXLink.prototype.OnJackpotCollectReceived = function() {
    this.HandleJackpotCollectResponse(this.GetResponse())
}
;
FOXLink.prototype.OnPickFSOptionReceived = function() {
    this.HandlePickFSOptionResponse(this.GetResponse())
}
;
FOXLink.prototype.OnInitFSBGReceived = function() {
    this.HandleInitFSBGResponse(this.GetResponse())
}
;
FOXLink.prototype.OnPickFSBGReceived = function() {
    this.HandlePickFSBGResponse(this.GetResponse())
}
;
FOXLink.prototype.OnGetMysteryScatterReceived = function() {
    this.HandleGetMysteryScatterResponse(this.GetResponse())
}
;
FOXLink.prototype.HandleInitResponse = function(param) {}
;
FOXLink.prototype.HandleSpinResponse = function(param) {}
;
FOXLink.prototype.HandleCollectResponse = function(param) {}
;
FOXLink.prototype.HandleInitBonusResponse = function(param) {}
;
FOXLink.prototype.HandlePickBonusResponse = function(param) {}
;
FOXLink.prototype.HandleBonusRespinResponse = function(param) {}
;
FOXLink.prototype.HandleBonusCollectResponse = function(param) {}
;
FOXLink.prototype.HandleGambleResponse = function(param) {}
;
FOXLink.prototype.HandleGambleCollectResponse = function(param) {}
;
FOXLink.prototype.HandleJackpotCollectResponse = function(param) {}
;
FOXLink.prototype.HandlePickFSOptionResponse = function(param) {}
;
FOXLink.prototype.HandleInitFSBGResponse = function(param) {}
;
FOXLink.prototype.HandlePickFSBGResponse = function(param) {}
;
FOXLink.prototype.HandleGetMysteryScatterResponse = function(param) {}
;
goog.require("UHT.FOXLink");
goog.require("UHT.TournamentConnection");
TournamentConnectionXTLayer.prototype = Object.create(FOXLink.prototype);
TournamentConnectionXTLayer.prototype.constructor = TournamentConnectionXTLayer;
function TournamentConnectionXTLayer() {
    FOXLink.call(this);
    this.connection = null;
    this.isFirstResult = true;
    this.useResultDisplayerDoLoop = true;
    this.isPrizeDrop = false
}
TournamentConnectionXTLayer.prototype.XTRegisterCallbacks = function() {
    FOXLink.prototype.XTRegisterCallbacks.call(this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_Prepare, this.OnResultDisplayerPrepare, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop, this.OnResultDisplayerDoLoop, this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this);
    XT.RegisterCallbackEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_WinShown, this.OnPromotionWinShown, this)
}
;
TournamentConnectionXTLayer.prototype.XTInitVariablesAndEvents = function() {
    XT.SetString(TournamentVars.Promotion_WinID, "");
    XT.SetDouble(TournamentVars.Promotion_WinReceived, 0);
    XT.SetString(TournamentVars.Promotion_GiftReceived, "");
    this.SetTournaments(null)
}
;
TournamentConnectionXTLayer.prototype.OnGameInit = function() {
    if (UHT_GAME_CONFIG["demoMode"])
        return;
    this.connection = new TournamentConnection;
    this.connection.xtLayer = this
}
;
TournamentConnectionXTLayer.prototype.OnResultDisplayerPrepare = function() {
    if (this.connection == null)
        return;
    if (this.isPrizeDrop)
        XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_PrepareForWin);
    if (this.connection.hasUpdates) {
        this.useResultDisplayerDoLoop = false;
        XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Prepare)
    }
    this.UpdatePromotions();
    if (this.isFirstResult) {
        this.isFirstResult = false;
        this.OnLastWinIsCountingChanged(XT.GetBool(Vars.LastWinIsCounting))
    }
}
;
TournamentConnectionXTLayer.prototype.OnResultDisplayerDoLoop = function() {
    if (!this.useResultDisplayerDoLoop || this.connection == null)
        return;
    if (this.connection.hasUpdates)
        this.OnResultDisplayerPrepare()
}
;
TournamentConnectionXTLayer.prototype.OnLastWinIsCountingChanged = function(isCounting) {}
;
TournamentConnectionXTLayer.prototype.UpdatePromotions = function() {
    if (this.isPrizeDrop)
        XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_ShowWin);
    else
        this.connection.canUpdate = true
}
;
TournamentConnectionXTLayer.prototype.OnPromotionWinShown = function() {
    this.connection.canUpdate = true;
    this.isPrizeDrop = false
}
;
TournamentConnectionXTLayer.prototype.Update = function() {
    if (this.connection != null)
        this.connection.Update()
}
;
TournamentConnectionXTLayer.prototype.SetServerTime = function(time) {
    XT.SetInt(TournamentVars.ServerTime, time)
}
;
TournamentConnectionXTLayer.prototype.SetTournaments = function(tournaments) {
    XT.SetObject(TournamentVars.Tournaments, tournaments);
    XT.TriggerEvent(TournamentVars.Evt_Internal_TournamentsUpdated)
}
;
TournamentConnectionXTLayer.prototype.SetDetails = function(details) {
    XT.SetObject(TournamentVars.TournamentDetails, details)
}
;
TournamentConnectionXTLayer.prototype.SetLeaderboards = function(leaderboards) {
    XT.SetObject(TournamentVars.TournamentLeaderboards, leaderboards)
}
;
TournamentConnectionXTLayer.prototype.AnnouncePromotions = function() {
    XT.TriggerEvent(TournamentVars.Evt_Internal_PromotionsAnnouncer_Announce)
}
;
TournamentConnectionXTLayer.prototype.HandleSpinResponse = function(dict) {
    this.isPrizeDrop = false;
    var promoWinUID = "";
    var promoWinAmount = 0;
    var promoWinGift = "";
    if (dict["ev"] != undefined) {
        var split = dict["ev"].split("~");
        if (split.length > 1 && split[0] == "MR") {
            split = split[1].split(",");
            if (split.length > 1) {
                var uid = PromotionsHelper.GetUID(_number.otoi(split[0]), TournamentProtocol.PromoType.Race);
                var promo = PromotionsHelper.FindPromotion(uid);
                if (promo != null && promo.clientMode == TournamentProtocol.ClientMode.Visible) {
                    if (split[1] == "A")
                        promoWinAmount = _number.otod(split[2]);
                    if (split[1] == "G")
                        promoWinGift = decodeURIComponent(atob(split[2]).split("").map(function(c) {
                            return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)
                        }).join(""));
                    promoWinUID = uid;
                    this.isPrizeDrop = true;
                    this.connection.racePrizesTimer = this.connection.reloadRacePrizesInterval
                }
            }
        }
    }
    XT.SetString(TournamentVars.Promotion_WinID, promoWinUID);
    XT.SetDouble(TournamentVars.Promotion_WinReceived, promoWinAmount);
    XT.SetString(TournamentVars.Promotion_GiftReceived, promoWinGift)
}
;
var BGVars = {
    Evt_Internal_ShowLevel: "Evt_Internal_ShowLevel",
    Evt_Internal_ResumeLevel: "Evt_Internal_ResumeLevel",
    Evt_DataToCode_BonusPickItemClicked: "Evt_DataToCode_BonusPickItemClicked",
    Evt_DataToCode_BonusMultiplierItemClicked: "Evt_DataToCode_BonusMultiplierItemClicked",
    Evt_ToServer_BonusPickedItem: "Evt_ToServer_BonusPickedItem",
    Evt_ToServer_BonusPickedCustomItem: "Evt_ToServer_BonusPickedCustomItem",
    Evt_ToServer_SendBonusRespin: "Evt_ToServer_SendBonusRespin",
    Evt_ToServer_BonusGameFinished: "Evt_ToServer_BonusGameFinished",
    BonusPickItemIndex: "BonusPickItemIndex",
    Evt_CodeToData_BonusResultWindowShow: "Evt_CodeToData_BonusResultWindowShow",
    Evt_DataToCode_BonusResultWindowCollect: "Evt_DataToCode_BonusResultWindowCollect",
    Evt_DataToCode_BonusResultWindowClosed: "Evt_DataToCode_BonusResultWindowClosed",
    Evt_CodeToData_BonusResultWindowClose: "Evt_CodeToData_BonusResultWindowClose",
    BonusRealWinDisplayed: "BonusRealWinDisplayed",
    BonusBetPerLine: "BonusBetPerLine",
    BonusDataReceived: "BonusDataReceived",
    HasMultipleLevelsNoItemMarkers: "HasMultipleLevelsNoItemMarkers",
    ShowResultAfterBigWin: "ShowResultAfterBigWin"
};
var Vars = {
    Evt_Internal_GameInit: "Evt_Internal_GameInit",
    Evt_Internal_Init_SoundManager: "Evt_Internal_Init_SoundManager",
    Evt_Internal_Init_SymbolManager: "Evt_Internal_Init_SymbolManager",
    Evt_Internal_Init_ReelsManager: "Evt_Internal_Init_ReelsManager",
    Evt_Internal_GUIInit: "Evt_Internal_GUIInit",
    GameHasCustomGamble: "GameHasCustomGamble",
    ScatterSymbolIsWild: "ScatterSymbolIsWild",
    DefaultGameWindowOverrideData: "DefaultGameWindowOverrideData",
    GameHasIntro: "GameHasIntro",
    ShouldDisplayIntro: "ShouldDisplayIntro",
    Evt_DataToCode_IntroClosePressed: "Evt_DataToCode_IntroClosePressed",
    MobileTapToStopMessageShowCount: "MobileTapToStopMessageShowCount",
    DesktopTurboSpinMessageShowCount: "DesktopTurboSpinMessageShowCount",
    GameIsRated: "GameIsRated",
    RatingSkipped: "RatingSkipped",
    BrowserWarningShown: "BrowserWarningShown",
    Evt_ToServer_UpdateSettingsOnServer: "Evt_ToServer_UpdateSettingsOnServer",
    SkipCooldownWhenUpdatingSettingsOnServer: "SkipCooldownWhenUpdatingSettingsOnServer",
    HasGameHistory: "HasGameHistory",
    Jurisdiction_LineByLineFreespin: "Jurisdiction_LineByLineFreespin",
    Jurisdiction_LineByLineGlobal: "Jurisdiction_LineByLineGlobal",
    Jurisdiction_ClientRevision: "Jurisdiction_ClientRevision",
    Jurisdiction_GameSymbol: "Jurisdiction_GameSymbol",
    HasAdvancedAutoplay: "HasAdvancedAutoplay",
    Jurisdiction_SpinLimit: "Jurisdiction_SpinLimit",
    Jurisdiction_SpinLimit_Value: "Jurisdiction_SpinLimit_Value",
    Jurisdiction_MandatoryAutoplayLossLimit: "Jurisdiction_MandatoryAutoplayLossLimit",
    Jurisdiction_ResultMinimumTime: "Jurisdiction_ResultMinimumTime",
    Jurisdiction_ResultMinimumTime_Value: "Jurisdiction_ResultMinimumTime_Value",
    Jurisdiction_ResultMinimumTimeTurbo: "Jurisdiction_ResultMinimumTimeTurbo",
    Jurisdiction_ResultMinimumTimeTurbo_Value: "Jurisdiction_ResultMinimumTimeTurbo_Value",
    Jurisdiction_ResultMinimumTimeBetweenSpins: "Jurisdiction_ResultMinimumTimeBetweenSpins",
    Jurisdiction_ResultMinimumTimeBetweenSpins_Value: "Jurisdiction_ResultMinimumTimeBetweenSpins_Value",
    SpinDuration: "SpinDuration",
    Jurisdiction_FinishCountersBeforeSpin: "Jurisdiction_FinishCountersBeforeSpin",
    Jurisdiction_Clock: "Jurisdiction_Clock",
    Jurisdiction_Clock_Server: "Jurisdiction_Clock_Server",
    Jurisdiction_ServerTime: "Jurisdiction_ServerTime",
    Jurisdiction_DisableAutoplay: "Jurisdiction_DisableAutoplay",
    Jurisdiction_GameTitle: "Jurisdiction_GameTitle",
    Jurisdiction_SplitBalance: "Jurisdiction_SplitBalance",
    Jurisdiction_PromotionURL: "Jurisdiction_PromotionURL",
    AdvancedAutoplaySettings: "AdvancedAutoplaySettings",
    BatterySaver: "BatterySaver",
    HasCoins: "HasCoins",
    FromServer_AllowCoins: "FromServer_AllowCoins",
    Evt_Internal_ChangeVSGameState: "Evt_Internal_ChangeVSGameState",
    KeepSpinning: "KeepSpinning",
    Evt_Internal_SpinStarted: "Evt_Internal_SpinStarted",
    Evt_Internal_SpinEnded: "Evt_Internal_SpinEnded",
    SpinNeedsConfirmation: "SpinNeedsConfirmation",
    CanUpdateLinkedLoopersPosition: "CanUpdateLinkedLoopersPosition",
    IsDifferentSpinType: "IsDifferentSpinType",
    StartDifferentSpin: "StartDifferentSpin",
    Evt_CodeToData_ShowSpinConfirmationWindow: "Evt_CodeToData_ShowSpinConfirmationWindow",
    Evt_DataToCode_ConfirmSpinStart: "Evt_DataToCode_ConfirmSpinStart",
    Evt_Internal_StartIdleSpinCounter: "Evt_Internal_StartIdleSpinCounter",
    Evt_Internal_StopIdleSpinCounter: "Evt_Internal_StopIdleSpinCounter",
    Evt_Internal_EnterIdleSpinState: "Evt_Internal_EnterIdleSpinState",
    Evt_Internal_ExitIdleSpinState: "Evt_Internal_ExitIdleSpinState",
    IdleStateActive: "IdleStateActive",
    LastExcitedReelIndex: "LastExcitedReelIndex",
    ReelsCanBeExcited: "ReelsCanBeExcited",
    LastStopEndedReelIndex: "LastStopEndedReelIndex",
    LastStartedReelIndices: "LastStartedReelIndices",
    LastStoppedReelIndices: "LastStoppedReelIndices",
    ReelsStartOrder: "ReelsStartOrder",
    ReelsStopOrder: "ReelsStopOrder",
    ReelsStartOrderDefault: "ReelsStartOrderDefault",
    ReelsStopOrderDefault: "ReelsStopOrderDefault",
    ReelsWinInfo: "ReelsWinInfo",
    ExtraReelDelayStop: "ExtraReelDelayStop",
    ExtraReelDelayStopDefault: "ExtraReelDelayStopDefault",
    ExtraReelDelayStart: "ExtraReelDelayStart",
    ExtraReelDelayStartDefault: "ExtraReelDelayStartDefault",
    PossibleWinComboSymbols: "PossibleWinComboSymbols",
    StillPossibleWinComboPerSymbol: "StillPossibleWinComboPerSymbol",
    StillPossibleWinComboBonus: "StillPossibleWinComboBonus",
    StillPossibleWinComboScatter: "StillPossibleWinComboScatter",
    StillPossibleWinComboWild: "StillPossibleWinComboWild",
    ExcitedImportantSymbols: "ExcitedImportantSymbols",
    Evt_Internal_ReelStarted: "Evt_Internal_ReelStarted",
    Evt_Internal_ReelStopStarted: "Evt_Internal_ReelStopStarted",
    Evt_Internal_ReelStopEnded: "Evt_Internal_ReelStopEnded",
    Evt_Internal_ExcitedReel: "Evt_Internal_ExcitedReel",
    ResultSymbolWinID: "ResultSymbolWinID",
    Evt_Internal_ResultSymbolWinPlaySound: "Evt_Internal_ResultSymbolWinPlaySound",
    Evt_Internal_StartVSLogicSounds: "Evt_Internal_StartVSLogicSounds",
    Evt_Internal_StopVSLogicSounds: "Evt_Internal_StopVSLogicSounds",
    Evt_Internal_StartBGLogicSounds: "Evt_Internal_StartBGLogicSounds",
    Evt_Internal_StopBGLogicSounds: "Evt_Internal_StopBGLogicSounds",
    Evt_Internal_StartFSBGLogicSounds: "Evt_Internal_StartFSBGLogicSounds",
    Evt_Internal_StopFSBGLogicSounds: "Evt_Internal_StopFSBGLogicSounds",
    ValueAnimatorSoundIndex: "ValueAnimatorSoundIndex",
    Evt_Internal_PlayValueAnimatorSound: "Evt_Internal_PlayValueAnimatorSound",
    Evt_Internal_StopValueAnimatorSound: "Evt_Internal_StopValueAnimatorSound",
    Evt_Internal_PlayGambleShuffleCard: "Evt_Internal_PlayGambleShuffleCard",
    Evt_Internal_PlayGambleShufflingStop: "Evt_Internal_PlayGambleShufflingStop",
    Evt_Internal_StopGambleShuffleCard: "Evt_Internal_StopGambleShuffleCard",
    Evt_DataToCode_PlayGambleNewProgressItem: "Evt_DataToCode_PlayGambleNewProgressItem",
    Evt_DataToCode_PlayGambleResultWin: "Evt_DataToCode_PlayGambleResultWin",
    Evt_DataToCode_PlayGambleResultLose: "Evt_DataToCode_PlayGambleResultLose",
    SoundManagerObject: "SoundManagerObject",
    TRexManagerObject: "TRexManagerObject",
    MusicLogicObject: "MusicLogicObject",
    MusicDuckByOneShotObject: "MusicDuckByOneShotObject",
    SoundState: "SoundState",
    MusicIsOn: "MusicIsOn",
    CanPlayReelStopSounds: "CanPlayReelStopSounds",
    Evt_Internal_SoundStateChanged: "Evt_Internal_SoundStateChanged",
    Evt_Internal_SwitchToFSSounds: "Evt_Internal_SwitchToFSSounds",
    Evt_CodeToData_SettingsWindowOpened: "Evt_CodeToData_SettingsWindowOpened",
    Evt_CodeToData_SettingsWindowClosed: "Evt_CodeToData_SettingsWindowClosed",
    Evt_Internal_MuteMusic: "Evt_Internal_MuteMusic",
    Evt_Internal_UnmuteMusic: "Evt_Internal_UnmuteMusic",
    Evt_DataToCode_Pressed_SoundBtn: "Evt_DataToCode_Pressed_SoundBtn",
    Evt_DataToCode_Pressed_MusicBtn: "Evt_DataToCode_Pressed_MusicBtn",
    Evt_DataToCode_Pressed_SoundFXBtn: "Evt_DataToCode_Pressed_SoundFXBtn",
    VSSoundLogic_IgnoreFastStop: "VSSoundLogic_IgnoreFastStop",
    Evt_Internal_LocaleChanged: "Evt_Internal_LocaleChanged",
    CustomGameStoredData: "CustomGameStoredData",
    Evt_Internal_CustomGameStoredDataReceived: "Evt_Internal_CustomGameStoredDataReceived",
    TotalNumberOfLines: "TotalNumberOfLines",
    Lines: "Lines",
    GameHasWaysInsteadOfLines: "GameHasWaysInsteadOfLines",
    LinesPaysBothWays: "LinesPaysBothWays",
    HasReelAwareSymbolContent: "HasReelAwareSymbolContent",
    HiddenMathematics: "HiddenMathematics",
    FastPlay: "FastPlay",
    ContinuousSpin: "ContinuousSpin",
    ForceContinuousSpin: "ForceContinuousSpin",
    AutoplayContinuousSpin: "AutoplayContinuousSpin",
    AutoplaySpinsRequested: "AutoplaySpinsRequested",
    AutoplaySpinsLeft: "AutoplaySpinsLeft",
    AutoplaySpinsLeftDisplayed: "AutoplaySpinsLeftDisplayed",
    InstantAutoplay: "InstantAutoplay",
    Evt_DataToCode_StartAutoplay: "Evt_DataToCode_StartAutoplay",
    Evt_DataToCode_StopAutoplay: "Evt_DataToCode_StopAutoplay",
    WinReceived: "WinReceived",
    WinDisplayed: "WinDisplayed",
    SpinCycleWinReceived: "SpinCycleWinReceived",
    SpinCycleWinDisplayed: "SpinCycleWinDisplayed",
    ExtraAwardWin: "ExtraAwardWin",
    RespinCycleWin: "RespinCycleWin",
    RespinCycleWinDisplayed: "RespinCycleWinDisplayed",
    TotalLinesWinReceived: "TotalLinesWinReceived",
    TotalLinesWinDisplayed: "TotalLinesWinDisplayed",
    TotalScattersWinDisplayed: "TotalScattersWinDisplayed",
    MysteryScatterWinDisplayed: "MysteryScatterWinDisplayed",
    BalanceReceived: "BalanceReceived",
    BalanceDisplayed: "BalanceDisplayed",
    BonusBalance: "BonusBalance",
    BonusBalanceReceived: "BonusBalanceReceived",
    BalanceDisplayedIsAnimating: "BalanceDisplayedIsAnimating",
    Evt_FromServer_BalanceUpdated: "Evt_FromServer_BalanceUpdated",
    IgnoreServerBalanceRequest: "IgnoreServerBalanceRequest",
    Evt_FromServer_BalanceUpdatedFromResult: "Evt_FromServer_BalanceUpdatedFromResult",
    Evt_Internal_FinalizeDisplayedWin: "Evt_Internal_FinalizeDisplayedWin",
    Evt_Internal_UpdateDisplayedWinInUI: "Evt_Internal_UpdateDisplayedWinInUI",
    Evt_Internal_UpdateDisplayedWin: "Evt_Internal_UpdateDisplayedWin",
    RespinData: "RespinData",
    ManualRespin: "ManualRespin",
    RespinsLeft: "RespinsLeft",
    RespinsAmountWon: "RespinsAmountWon",
    ProgressiveFeatureConfig: "ProgressiveFeatureConfig",
    ProgressiveFeatureData: "ProgressiveFeatureData",
    MoneySymbolConfig: "MoneySymbolConfig",
    MoneySymbolData: "MoneySymbolData",
    StickySymbolsData: "StickySymbolsData",
    MergingSymbolsData: "MergingSymbolsData",
    Bets: "Bets",
    TotalBets: "TotalBets",
    BetToTotalBetMultiplier: "BetToTotalBetMultiplier",
    NextBetIndex: "NextBetIndex",
    NumberOfBetLevels: "NumberOfBetLevels",
    CoinValues: "CoinValues",
    CoinValueIndex: "CoinValueIndex",
    Evt_Internal_CoinValueChanged: "Evt_Internal_CoinValueChanged",
    Evt_Internal_LastBetsChanged: "Evt_Internal_LastBetsChanged",
    Evt_Internal_BetChanged: "Evt_Internal_BetChanged",
    TotalBetDisplayed: "TotalBetDisplayed",
    BetDisplayed: "BetDisplayed",
    CoinValueDisplayed: "CoinValueDisplayed",
    Evt_DataToCode_RevertToLastBet: "Evt_DataToCode_RevertToLastBet",
    Evt_Internal_ForceUpdateBetValues: "Evt_Internal_ForceUpdateBetValues",
    MaxBetReached: "MaxBetReached",
    MinBetReached: "MinBetReached",
    MaxTotalBetFromServer: "MaxTotalBetFromServer",
    MinTotalBetFromServer: "MinTotalBetFromServer",
    Evt_DataToCode_IncreaseBet: "Evt_DataToCode_IncreaseBet",
    Evt_DataToCode_DecreaseBet: "Evt_DataToCode_DecreaseBet",
    MaxCoinValueReached: "MaxCoinValueReached",
    MinCoinValueReached: "MinCoinValueReached",
    Evt_DataToCode_IncreaseCoinValue: "Evt_DataToCode_IncreaseCoinValue",
    Evt_DataToCode_DecreaseCoinValue: "Evt_DataToCode_DecreaseCoinValue",
    Evt_DataToCode_SmartIncreaseBet: "Evt_DataToCode_SmartIncreaseBet",
    Evt_DataToCode_SmartDecreaseBet: "Evt_DataToCode_SmartDecreaseBet",
    MaxBetAndCoinValueReached: "MaxBetAndCoinValueReached",
    MinBetAndCoinValueReached: "MinBetAndCoinValueReached",
    AlternativeWager: "AlternativeWager",
    StackedSymbolIndex: "StackedSymbolIndex",
    ReelSets: "ReelSets",
    ReelSetIndexPrevious: "ReelSetIndexPrevious",
    ReelSetIndexCurrent: "ReelSetIndexCurrent",
    ReelSymbols: "ReelSymbols",
    NextReelSymbols: "NextReelSymbols",
    ReelInitialPositions: "ReelInitialPositions",
    ReelStopPositions: "ReelStopPositions",
    FirstScreenSymbols: "FirstScreenSymbols",
    ResultScreenSymbols: "ResultScreenSymbols",
    InitialResultScreenSymbols: "InitialResultScreenSymbols",
    CustomResultScreenSymbols: "CustomResultScreenSymbols",
    SymbolsAboveReels: "SymbolsAboveReels",
    SymbolsBelowReels: "SymbolsBelowReels",
    NextReelsSymbolsList: "NextReelsSymbolsList",
    ExtraScatters: "ExtraScatters",
    MarkedSymbolPositions: "MarkedSymbolPositions",
    AdditionalBonusScatters: "AdditionalBonusScatters",
    NudgedSymbols: "NudgedSymbols",
    LinesDefinitionsObject: "LinesDefinitionsObject",
    SpinExciterObject: "SpinExciterObject",
    Evt_Internal_ExciterComputeEnded: "Evt_Internal_ExciterComputeEnded",
    FloatingWinEventsObject: "FloatingWinEventsObject",
    ReelsManagerObject: "ReelsManagerObject",
    SymbolsManagerObject: "SymbolsManagerObject",
    ReceivedWinLines: "ReceivedWinLines",
    RQManagerObject: "RQManagerObject",
    Evt_Internal_InjectRQIOnResultDisplayerLoopStarts: "Evt_Internal_InjectRQIOnResultDisplayerLoopStarts",
    Evt_Internal_InjectRQIAfterBonusAnimate: "Evt_Internal_InjectRQIAfterBonusAnimate",
    Evt_Internal_InjectRQIBeforeLinesShow: "Evt_Internal_InjectRQIBeforeLinesShow",
    Evt_Internal_InjectRQIAfterLinesShow: "Evt_Internal_InjectRQIAfterLinesShow",
    Evt_Internal_InjectRQIBeforeEndOfDisplayLoop: "Evt_Internal_InjectRQIBeforeEndOfDisplayLoop",
    Evt_Internal_InjectRQIWhileShowingAllLines: "Evt_Internal_InjectRQIWhileShowingAllLines",
    SpinRoutineQueue: "SpinRoutineQueue",
    Evt_Internal_InjectRQIBeforeSpinStart: "Evt_Internal_InjectRQIBeforeSpinStart",
    StackedSymbolsData: "StackedSymbolsData",
    Evt_ToServer_OnShowResult: "Evt_ToServer_OnShowResult",
    Evt_ToServer_RequestInit: "Evt_ToServer_RequestInit",
    Evt_ToServer_RequestSpin: "Evt_ToServer_RequestSpin",
    Evt_FromServer_InitReceived: "Evt_FromServer_InitReceived",
    Evt_FromServer_SpinResultReceived: "Evt_FromServer_SpinResultReceived",
    NASymbolId: "NASymbolId",
    WildRandomLineMpConfig: "WildRandomLineMpConfig",
    WRLMResponse: "WRLMResponse",
    WRLMCurrentSets: "WRLMCurrentSets",
    RandomAwardsConfig: "RandomAwardsConfig",
    RandomAwardsResponse: "RandomAwardsResponse",
    FreeSpinsPurchaseConfig: "FreeSpinsPurchaseConfig",
    FreeSpinsPurchaseData: "FreeSpinsPurchaseData",
    BetLevelSettings: "BetLevelSettings",
    BetLevelChanged: "BetLevelChanged",
    RandomSymbolMultipliers: "RandomSymbolMultipliers",
    PossibleRandomSymbolMultipliers: "PossibleRandomSymbolMultipliers",
    FreeSpinsChainData: "FreeSpinsChainData",
    OpeningSymbolsData: "OpeningSymbolsData",
    RandomMysterySymbolId: "RandomMysterySymbolId",
    InitialMysterySymbolId: "InitialMysterySymbolId",
    InitBGItemValues: "InitBGItemValues",
    InitBGItemMasks: "InitBGItemMasks",
    PatternedMysterySymbols: "PatternedMysterySymbols",
    SpinOneReelData: "SpinOneReelData",
    ReelToBeSpun: "ReelToBeSpun",
    TumblingData: "TumblingData",
    RandomWildsData: "RandomWildsData",
    UpSymbols_RandomWilds: "UpSymbols_RandomWilds",
    Evt_Internal_RandomWildsDataSet: "Evt_Internal_RandomWildsDataSet",
    WildRandomMultipliers: "WildRandomMultipliers",
    Evt_Internal_WildRandomMultipliersReceived: "Evt_Internal_WildRandomMultipliersReceived",
    Evt_Internal_ShowStackedSymbols: "Evt_Internal_ShowStackedSymbols",
    CurrentAnimatingStackedReel: "CurrentAnimatingStackedReel",
    ExpandingSymbolsData: "ExpandingSymbolsData",
    ExpandableDelayNeededAtTheEnd: "ExpandableDelayNeededAtTheEnd",
    Evt_Internal_ExpandingSymbolsDataSet: "Evt_Internal_ExpandingSymbolsDataSet",
    Evt_Internal_ShowExpandingSymbol: "Evt_Internal_ShowExpandingSymbol",
    CurrentAnimatingExpandingSymbolID: "CurrentAnimatingExpandingSymbolID",
    FreeSpinOptions: "FreeSpinOptions",
    MustResumeFreeSpinOptions: "MustResumeFreeSpinOptions",
    Logic_IsFreeSpin: "Logic_IsFreeSpin",
    Evt_CodeToData_ShowFSWonBeforeResult: "Evt_CodeToData_ShowFSWonBeforeResult",
    FSStartNeedsConfirmation: "FSStartNeedsConfirmation",
    Evt_DataToCode_ConfirmFSStart: "Evt_DataToCode_ConfirmFSStart",
    Evt_Internal_FreeSpinsStarted: "Evt_Internal_FreeSpinsStarted",
    Evt_CodeToData_FreeSpinsShowWindowWin: "Evt_CodeToData_FreeSpinsShowWindowWin",
    Evt_CodeToData_FreeSpinsShowWindowLose: "Evt_CodeToData_FreeSpinsShowWindowLose",
    Evt_CodeToData_FreeSpinsCloseWindowWin: "Evt_CodeToData_FreeSpinsCloseWindowWin",
    Evt_CodeToData_FreeSpinsCloseWindowLose: "Evt_CodeToData_FreeSpinsCloseWindowLose",
    Evt_DataToCode_FreeSpinsWindowWinCollectPressed: "Evt_DataToCode_FreeSpinsWindowWinCollectPressed",
    Evt_DataToCode_FreeSpinsWindowLoseCollectPressed: "Evt_DataToCode_FreeSpinsWindowLoseCollectPressed",
    Evt_Internal_FreeSpinsEnded: "Evt_Internal_FreeSpinsEnded",
    Evt_ToServer_OnFreeSpinsClosed: "Evt_ToServer_OnFreeSpinsClosed",
    ReceivedFreeSpinsResponse: "ReceivedFreeSpinsResponse",
    TruncatedFreeSpinsResponse: "TruncatedFreeSpinsResponse",
    TruncateFSResponseDuringRespin: "TruncateFSResponseDuringRespin",
    UpdateFSResponseOnBonusPick: "UpdateFSResponseOnBonusPick",
    CurrentFreeSpinDisplayed: "CurrentFreeSpinDisplayed",
    FreeSpinsLeftDisplayed: "FreeSpinsLeftDisplayed",
    MaxFreeSpinsDisplayed: "MaxFreeSpinsDisplayed",
    AdditionalFreeSpinsWon: "AdditionalFreeSpinsWon",
    AdditionalFreeSpinsWonDisplayed: "AdditionalFreeSpinsWonDisplayed",
    TotalFreeSpinsDisplayed: "TotalFreeSpinsDisplayed",
    TotalFreeSpinsChainDisplayed: "TotalFreeSpinsChainDisplayed",
    FreeSpinsTotalMultiplierDisplayed: "FreeSpinsTotalMultiplierDisplayed",
    FreeSpinsWinDisplayed: "FreeSpinsWinDisplayed",
    FreeSpinsLastWinDisplayed: "FreeSpinsLastWinDisplayed",
    FreeSpinsWinMultipliedDisplayed: "FreeSpinsWinMultipliedDisplayed",
    FreeSpinsTotalWinDisplayed: "FreeSpinsTotalWinDisplayed",
    FreeSpinsTotalWinMultipliedDisplayed: "FreeSpinsTotalWinMultipliedDisplayed",
    FSResultWindowTotalWinMultipliedDisplayed: "FSResultWindowTotalWinMultipliedDisplayed",
    Evt_Internal_ReelManager_StopSpin: "Evt_Internal_ReelManager_StopSpin",
    Evt_Internal_ReelManager_SpinEnded: "Evt_Internal_ReelManager_SpinEnded",
    AllowFastStop: "AllowFastStop",
    Evt_DataToCode_Pressed_Spin: "Evt_DataToCode_Pressed_Spin",
    Evt_DataToCode_Pressed_Stop: "Evt_DataToCode_Pressed_Stop",
    Evt_CodeToData_NotEnoughMoneyForSpin: "Evt_CodeToData_NotEnoughMoneyForSpin",
    Evt_CodeToData_HideNoMoneyWindow: "Evt_CodeToData_HideNoMoneyWindow",
    Evt_DataToCode_NotEnoughMoney_pressedOK: "Evt_DataToCode_NotEnoughMoney_pressedOK",
    CurrentDisplayedWinLineId: "CurrentDisplayedWinLineId",
    Evt_Internal_ShowWinLine: "Evt_Internal_ShowWinLine",
    Evt_Internal_HideWinLine: "Evt_Internal_HideWinLine",
    ShowSymbolSquaresOnLineVisual: "ShowSymbolSquaresOnLineVisual",
    ResultDisplayerMinimalMode: "ResultDisplayerMinimalMode",
    Evt_Internal_ResultDisplayer_SkipNextLoopOccasion: "Evt_Internal_ResultDisplayer_SkipNextLoopOccasion",
    Evt_Internal_ResultDisplayer_Prepare: "Evt_Internal_ResultDisplayer_Prepare",
    Evt_Internal_ResultDisplayer_DoLoop: "Evt_Internal_ResultDisplayer_DoLoop",
    Evt_Internal_ResultDisplayer_DoCleanup: "Evt_Internal_ResultDisplayer_DoCleanup",
    Evt_Internal_ResultDisplayer_LoopDone: "Evt_Internal_ResultDisplayer_LoopDone",
    Evt_CodeToData_ShowAllLinesWin: "Evt_CodeToData_ShowAllLinesWin",
    Evt_CodeToData_HideAllLinesWin: "Evt_CodeToData_HideAllLinesWin",
    Evt_CodeToData_ShowJackpotWin: "Evt_CodeToData_ShowJackpotWin",
    Evt_CodeToData_HideJackpotWin: "Evt_CodeToData_HideJackpotWin",
    CurrentDisplayedWinLineIndex: "CurrentDisplayedWinLineIndex",
    CurrentDisplayedWinLineWin: "CurrentDisplayedWinLineWin",
    CurrentWinMultiplier: "CurrentWinMultiplier",
    Evt_CodeToData_ShowScattersWin: "Evt_CodeToData_ShowScattersWin",
    Evt_CodeToData_HideScattersWin: "Evt_CodeToData_HideScattersWin",
    Evt_Internal_UpdateCurrentDisplayedWinLineIndex: "Evt_Internal_UpdateCurrentDisplayedWinLineIndex",
    Evt_Internal_StartDisplayWinLine: "Evt_Internal_StartDisplayWinLine",
    Evt_Internal_StopDisplayWinLine: "Evt_Internal_StopDisplayWinLine",
    Evt_CodeToData_ShowMysteryScatterWin: "Evt_CodeToData_ShowMysteryScatterWin",
    Evt_CodeToData_HideMysteryScatterWin: "Evt_CodeToData_HideMysteryScatterWin",
    OrderedSymbolList: "OrderedSymbolList",
    OrderedSymbolHoldersList: "OrderedSymbolHoldersList",
    FromServer_CanGambleSpinWin: "FromServer_CanGambleSpinWin",
    ForceDisableGambleSpinWin: "ForceDisableGambleSpinWin",
    Evt_Internal_EnableGambleButton: "Evt_Internal_EnableGambleButton",
    Evt_Internal_DisableGambleButton: "Evt_Internal_DisableGambleButton",
    CanGamble_Spin: "CanGamble_Spin",
    CanGamble_FreeSpin: "CanGamble_FreeSpin",
    CanGamble_Bonus: "CanGamble_Bonus",
    Gamble_ColorMultiplier: "Gamble_ColorMultiplier",
    Gamble_SuitMultiplier: "Gamble_SuitMultiplier",
    Gamble_CurrentBalance: "Gamble_CurrentBalance",
    Gamble_CurrentBalanceDisplayed: "Gamble_CurrentBalanceDisplayed",
    Gamble_FinalBalanceDisplayed: "Gamble_FinalBalanceDisplayed",
    Gamble_ColorWinDisplayed: "Gamble_ColorWinDisplayed",
    Gamble_SuitWinDisplayed: "Gamble_SuitWinDisplayed",
    Evt_DataToCode_Pressed_Gamble: "Evt_DataToCode_Pressed_Gamble",
    Evt_DataToCode_Pressed_Gamble_FreeSpinsResult: "Evt_DataToCode_Pressed_Gamble_FreeSpinsResult",
    Evt_DataToCode_Pressed_Gamble_BonusResult: "Evt_DataToCode_Pressed_Gamble_BonusResult",
    Evt_DataToCode_Pressed_GamblePick: "Evt_DataToCode_Pressed_GamblePick",
    Evt_DataToCode_Pressed_GambleCollect: "Evt_DataToCode_Pressed_GambleCollect",
    FromServer_GambleResult: "FromServer_GambleResult",
    FromServer_GambleHistory: "FromServer_GambleHistory",
    Evt_Internal_Gamble_DisplayHistory: "Evt_Internal_Gamble_DisplayHistory",
    Evt_DataToCode_Gamble_DisplayProgress: "Evt_DataToCode_Gamble_DisplayProgress",
    Evt_Internal_Gamble_ClearProgress: "Evt_Internal_Gamble_ClearProgress",
    Gamble_CurrentProgressObject: "Gamble_CurrentProgressObject",
    Evt_Internal_Gamble_UpdateCurrentProgress: "Evt_Internal_Gamble_UpdateCurrentProgress",
    Evt_DataToCode_Gamble_UpdateDisplayedLabels: "Evt_DataToCode_Gamble_UpdateDisplayedLabels",
    Evt_CodeToData_Gamble_PickResult_Win: "Evt_CodeToData_Gamble_PickResult_Win",
    Evt_CodeToData_Gamble_PickResult_Lose: "Evt_CodeToData_Gamble_PickResult_Lose",
    Evt_CodeToData_Gamble_PickResult_WinLimit: "Evt_CodeToData_Gamble_PickResult_WinLimit",
    Gamble_PickResult_ItemID: "Gamble_PickResult_ItemID",
    Evt_Internal_Gamble_PickResult_Handled: "Evt_Internal_Gamble_PickResult_Handled",
    Gamble_Choice: "Gamble_Choice",
    Evt_ToServer_GamblePicked: "Evt_ToServer_GamblePicked",
    Evt_ToServer_RequestGambleOpen: "Evt_ToServer_RequestGambleOpen",
    Evt_ToServer_RequestGambleClose: "Evt_ToServer_RequestGambleClose",
    Evt_FromServer_GambleOpen: "Evt_FromServer_GambleOpen",
    Evt_FromServer_GambleClose: "Evt_FromServer_GambleClose",
    Evt_CodeToData_GambleShowResultWindowWin: "Evt_CodeToData_GambleShowResultWindowWin",
    Evt_CodeToData_GambleCloseResultWindowWin: "Evt_CodeToData_GambleCloseResultWindowWin",
    Evt_CodeToData_GambleShowResultWindowLose: "Evt_CodeToData_GambleShowResultWindowLose",
    Evt_CodeToData_GambleCloseResultWindowLose: "Evt_CodeToData_GambleCloseResultWindowLose",
    Evt_Internal_GambleCloseCurrentResultWindow: "Evt_Internal_GambleCloseCurrentResultWindow",
    Evt_CodeToData_ShowBonusWonBeforeResult: "Evt_CodeToData_ShowBonusWonBeforeResult",
    TriggerBonusBeforeResult: "TriggerBonusBeforeResult",
    BonusWinIsSeparated: "BonusWinIsSeparated",
    BonusData: "BonusData",
    BonusItemsIndexes: "BonusItemsIndexes",
    MustOpenBonus: "MustOpenBonus",
    MustOpenAnotherBonus: "MustOpenAnotherBonus",
    Evt_FromServer_BonusInitDone: "Evt_FromServer_BonusInitDone",
    Evt_BonusAfterInit: "Evt_BonusAfterInit",
    Evt_FromServer_BonusResponseReceived: "Evt_FromServer_BonusResponseReceived",
    Evt_DataToCode_Pressed_BonusPickItem: "Evt_DataToCode_Pressed_BonusPickItem",
    Evt_DataToCode_BonusGameLevelChange: "Evt_DataToCode_BonusGameLevelChange",
    Evt_DataToCode_BonusGameActNext: "Evt_DataToCode_BonusGameActNext",
    BonusPickItemIndex: "BonusPickItemIndex",
    Evt_ToServer_BonusPickItem: "Evt_ToServer_BonusPickItem",
    Evt_ToServer_BonusGameFinished: "Evt_ToServer_BonusGameFinished",
    BonusPickItemIndexLocal: "BonusPickItemIndexLocal",
    Evt_DataToCode_BonusResultShowWindow: "Evt_DataToCode_BonusResultShowWindow",
    Evt_DataToCode_BonusResultWindow_PressedCollect: "Evt_DataToCode_BonusResultWindow_PressedCollect",
    Evt_CodeToData_BonusResultShowWindow: "Evt_CodeToData_BonusResultShowWindow",
    Evt_CodeToData_BonusResultCloseWindow: "Evt_CodeToData_BonusResultCloseWindow",
    BonusRealWinDisplayed: "BonusRealWinDisplayed",
    BonusBetPerLine: "BonusBetPerLine",
    BonusTotalWinDisplayed: "BonusTotalWinDisplayed",
    BonusFSPremultipliedWinDisplayed: "BonusFSPremultipliedWinDisplayed",
    BonusFSPickMultiplierDisplayed: "BonusFSPickMultiplierDisplayed",
    BonusTriggersFSBG: "BonusTriggersFSBG",
    BonusTriggeredFSBGIsMystery: "BonusTriggeredFSBGIsMystery",
    OpenFSBGForMysteryScatter: "OpenFSBGForMysteryScatter",
    SendSeparateMysteryScatter: "SendSeparateMysteryScatter",
    Evt_ToServer_SendGetMysteryScatter: "Evt_ToServer_SendGetMysteryScatter",
    PaytablePayoutData: "PaytablePayoutData",
    Evt_Internal_PaytablePayoutUpdate: "Evt_Internal_PaytablePayoutUpdate",
    Evt_Internal_PaytableOpen: "Evt_Internal_PaytableOpen",
    Evt_Internal_PaytableClose: "Evt_Internal_PaytableClose",
    Evt_DataToCode_Pressed_PaytableClosed: "Evt_DataToCode_Pressed_PaytableClosed",
    Evt_DataToCode_Pressed_PaytableNext: "Evt_DataToCode_Pressed_PaytableNext",
    Evt_DataToCode_Pressed_PaytablePrevious: "Evt_DataToCode_Pressed_PaytablePrevious",
    Evt_Internal_PaytableMobileUpdatePages: "Evt_Internal_PaytableMobileUpdatePages",
    Evt_Internal_PlaySpinEndedBWSound: "Evt_Internal_PlaySpinEndedBWSound",
    SpinResultIsBigWin: "SpinResultIsBigWin",
    SpinResultBigWinLevel: "SpinResultBigWinLevel",
    BigWinLevel: "BigWinLevel",
    Evt_Internal_ShowBigWin: "Evt_Internal_ShowBigWin",
    Evt_Internal_ClearBigWin: "Evt_Internal_ClearBigWin",
    Evt_DataToCode_BigWinHasFinished: "Evt_DataToCode_BigWinHasFinished",
    WaitInResultForBigWin: "WaitInResultForBigWin",
    VAWBWCounters: "VAWBWCounters",
    LastWinIsCounting: "LastWinIsCounting",
    BalanceIsCounting: "BalanceIsCounting",
    SkipNextBigWin: "SkipNextBigWin",
    CanAnimateValues: "CanAnimateValues",
    CurrentCoinCountTarget: "CurrentCoinCountTarget",
    Evt_Internal_CoinCounterStart: "Evt_Internal_CoinCounterStart",
    Evt_Internal_CoinCounterStop: "Evt_Internal_CoinCounterStop",
    CoinCounterObject: "CoinCounterObject",
    FromStageName: "FromStageName",
    ToStageName: "ToStageName",
    Evt_Internal_UpdateJackpotUI: "Evt_Internal_UpdateJackpotUI",
    CurrentlyDisplayedJackpot: "CurrentlyDisplayedJackpot",
    FromServer_IsJackpotWin: "FromServer_IsJackpotWin",
    FromServer_JackpotAmountWon: "FromServer_JackpotAmountWon",
    FromServer_JackpotWonID: "FromServer_JackpotWonID",
    FromServer_JackpotWonOrder: "FromServer_JackpotWonOrder",
    FromServer_JackpotsInformation: "FromServer_JackpotsInformation",
    FromServer_LastValidJackpotsInformation: "FromServer_LastValidJackpotsInformation",
    DisplayedJackpotAmount: "DisplayedJackpotAmount",
    JackpotAmountWonDisplayed: "JackpotAmountWonDisplayed",
    Evt_DataToCode_CollectJackpotPressed: "Evt_DataToCode_CollectJackpotPressed",
    Evt_DataToCode_ContinueWithJackpot: "Evt_DataToCode_ContinueWithJackpot",
    Evt_Internal_InjectRQIForMysteryJackpotWin: "Evt_Internal_InjectRQIForMysteryJackpotWin",
    Evt_Internal_JackpotCounterStart: "Evt_Internal_JackpotCounterStart",
    Evt_Internal_JackpotCounterEnded: "Evt_Internal_JackpotCounterEnded",
    Evt_Internal_ShowMysteryJackpotWon: "Evt_Internal_ShowMysteryJackpotWon",
    Evt_Internal_HideMysteryJackpotWon: "Evt_Internal_HideMysteryJackpotWon",
    MustShowJackpotWon: "MustShowJackpotWon",
    CurrentJackpotAmountDisplayedMini: "CurrentJackpotAmountDisplayedMini",
    CurrentJackpotAmountDisplayedMaxi: "CurrentJackpotAmountDisplayedMaxi",
    CurrentJackpotAmountDisplayedMajor: "CurrentJackpotAmountDisplayedMajor",
    CurrentJackpotAmountDisplayedMega: "CurrentJackpotAmountDisplayedMega",
    MinimumJackpotBigWinDuration: "MinimumJackpotBigWinDuration",
    JackpotMinBetEligible: "JackpotMinBetEligible",
    ReturnToPlayerWithJackpot: "ReturnToPlayerWithJackpot",
    ReturnToPlayerMinWithJackpot: "ReturnToPlayerMinWithJackpot",
    JackpotVisualization: "JackpotVisualization",
    GoldSymbol: "GoldSymbol",
    SymbolReplacementData: "SymbolReplacementData",
    FromServer_MustOpenFSBG: "FromServer_MustOpenFSBG",
    Internal_FSBGJustClosed: "Internal_FSBGJustClosed",
    Evt_CodeToData_StartMysteryFSBG: "Evt_CodeToData_StartMysteryFSBG",
    Evt_CodeToData_StopMysteryFSBG: "Evt_CodeToData_StopMysteryFSBG",
    Evt_CodeToData_MysteryScatterIsVisible: "Evt_CodeToData_MysteryScatterIsVisible",
    Evt_DataToCode_StopMysteryFSBG: "Evt_DataToCode_StopMysteryFSBG",
    MysteryScatterSymbolId: "MysteryScatterSymbolId",
    MysteryScatterSymbol_GameObject: "MysteryScatterSymbol_GameObject",
    MysteryScatterSymbol_ParentGameObject: "MysteryScatterSymbol_ParentGameObject",
    Evt_Internal_MysteryScatterSymbol_Show: "Evt_Internal_MysteryScatterSymbol_Show",
    Evt_Internal_MysteryScatterSymbol_Hide: "Evt_Internal_MysteryScatterSymbol_Hide",
    PickedItemIndexLocal_FSBGPick: "PickedItemIndexLocal_FSBGPick",
    SpinsWon_FSBGPick: "SpinsWon_FSBGPick",
    MultiplierWon_FSBGPick: "MultiplierWon_FSBGPick",
    Evt_FromServer_InitFSBGPick: "Evt_FromServer_InitFSBGPick",
    Evt_FromServer_ResponseFSBGPick: "Evt_FromServer_ResponseFSBGPick",
    Evt_ToServer_ItemPickedFSBGPick: "Evt_ToServer_ItemPickedFSBGPick",
    Evt_CodeToData_ShowFSBGPick: "Evt_CodeToData_ShowFSBGPick",
    Evt_CodeToData_ResumeFSBGPick: "Evt_CodeToData_ResumeFSBGPick",
    Evt_CodeToData_InitReceivedFSBGPick: "Evt_CodeToData_InitReceivedFSBGPick",
    Evt_CodeToData_EndGameFSBGPick: "Evt_CodeToData_EndGameFSBGPick",
    Evt_DataToCode_InfoClosedFSBGPick: "Evt_DataToCode_InfoClosedFSBGPick",
    Evt_DataToCode_ShowGameOverFSBGPick: "Evt_DataToCode_ShowGameOverFSBGPick",
    Evt_DataToCode_ItemPickedFSBGPick: "Evt_DataToCode_ItemPickedFSBGPick",
    Evt_DataToCode_EndGameFSBGPick: "Evt_DataToCode_EndGameFSBGPick",
    Evt_DataToCode_FSBG_CloseConfirmation: "Evt_DataToCode_FSBG_CloseConfirmation",
    Evt_ToServer_OpenCashier: "Evt_ToServer_OpenCashier",
    Evt_ToServer_CloseGame: "Evt_ToServer_CloseGame",
    Evt_ToServer_ReloadGame: "Evt_ToServer_ReloadGame",
    CanSpin: "CanSpin",
    CanSpinAfterResultMinimumTime: "CanSpinAfterResultMinimumTime",
    SpinBlockingFeatureIsRunning: "SpinBlockingFeatureIsRunning",
    DynamicColorSet: "DynamicColorSet",
    BonusRoundsLeftDisplayed: "BonusRoundsLeftDisplayed",
    BonusRoundsWinDisplayed: "BonusRoundsWinDisplayed",
    BonusRoundsEvents: "BonusRoundsEvents",
    BonusRoundsData: "BonusRoundsData",
    Evt_Internal_BonusRoundsInfoUpdated: "Evt_Internal_BonusRoundsInfoUpdated",
    Evt_CodeToData_BonusRoundsStarted: "Evt_CodeToData_BonusRoundsStarted",
    Evt_CodeToData_BonusRoundsFinished: "Evt_CodeToData_BonusRoundsFinished",
    Evt_CodeToData_BonusRoundsError: "Evt_CodeToData_BonusRoundsError",
    Evt_CodeToData_CloseOtherOpenedBonusRoundsWindows: "Evt_CodeToData_CloseOtherOpenedBonusRoundsWindows",
    Evt_DataToCode_BonusRoundsOnContinuePressed: "Evt_DataToCode_BonusRoundsOnContinuePressed",
    ReturnToPlayer: "ReturnToPlayer",
    ReturnToPlayerMin: "ReturnToPlayerMin",
    LevelSymbolIndex: "LevelSymbolIndex",
    Evt_AnimateLevelIndicatorOnReel: "Evt_AnimateLevelIndicatorOnReel",
    LevelIndicatorAnimTarget: "LevelIndicatorAnimTarget",
    Autoplay_SkipScreens: "Autoplay_SkipScreens",
    Evt_CodeToData_IntroClosedOrSkipped: "Evt_CodeToData_IntroClosedOrSkipped",
    OpaqueInterface: "OpaqueInterface",
    ShowInGameTutorial: "ShowInGameTutorial",
    Evt_Internal_ProgressiveFeaturePickedSymbolPositionUpdated: "Evt_Internal_ProgressiveFeaturePickedSymbolPositionUpdated",
    ProgressiveFeaturePointsWon: "ProgressiveFeaturePointsWon",
    GambleV2Data: "GambleV2Data",
    MustOpenGambleV2: "MustOpenGambleV2",
    Evt_FromServer_GambleV2Response: "Evt_FromServer_GambleV2Response",
    Evt_Internal_GambleV2Closed: "Evt_Internal_GambleV2Closed",
    ShowedRandomWildPosition: "ShowedRandomWildPosition",
    Evt_Internal_ShowedRandomWild: "Evt_Internal_ShowedRandomWild",
    MobilePaytableObject: "MobilePaytableObject",
    SoundVolume: "SoundVolume",
    Evt_DataToCode_BlockSpin: "Evt_DataToCode_BlockSpin",
    Evt_DataToCode_UnblockSpin: "Evt_DataToCode_UnblockSpin",
    InitialScreen: "InitialScreen",
    IsNoMoneySpin: "IsNoMoneySpin",
    InitialRandomAward: "InitialRandomAward",
    GameTitle: "GameTitle"
};
function SoundState() {
    this.globalSoundIsOn = true;
    this.gameSoundIsOn = true;
    this.musicIsOn = true;
    this.soundFXIsOn = true;
    this.oldMusicIsOn = false;
    this.oldSoundFXIsOn = false
}
goog.provide("UHT.Paytable");
goog.require("UHT.Engine");
Paytable.prototype = Object.create(XTLink.prototype);
Paytable.prototype.constructor = Paytable;
var PageContentType = {
    Normal: 0,
    Jackpot: 1
};
function Paytable() {
    XTLink.call(this);
    this.cat = null;
    this.paytable = null;
    this.pages = [];
    this.pageContentType = [];
    this.gamblePageIndex = -1;
    this.jackpotPageCounter = 0;
    this.currentPageIndex = 1;
    this.pagesCount = 0;
    this.pageIndexLabel = null;
    this.paytableActive = false;
    this.pageIdx = 0;
    this.pageRoot = [];
    this.hasFeatureDependentPages = false;
    this.jpData = null
}
function CAT_Set() {
    this.show = null;
    this.hide = null
}
Paytable.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytableNext, this.OnPressedPaytableNext, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytablePrevious, this.OnPressedPaytablePrevious, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    EventManager.AddHandler(JackpotEvents.evtJackpotStateChanged, this.OnJackpotStateChanged, this)
}
;
Paytable.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.MobilePaytableObject, this)
}
;
Paytable.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnPressedPaytableOpen, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytableClose, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytableNext, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytablePrevious, this);
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
}
;
Paytable.prototype.OnJackpotStateChanged = function(param) {
    this.jpData = param
}
;
Paytable.prototype.OnGUIInit = function() {
    if (XT.GetBool(Vars.CanGamble_Spin) == false && this.gamblePageIndex >= 0)
        this.pages.splice(this.gamblePageIndex, 1);
    this.ProcessJackpotPages()
}
;
Paytable.prototype.ProcessJackpotPages = function() {
    if (!this.hasFeatureDependentPages && this.jpData != null && !this.jpData.IsActive && this.pageContentType.indexOf(PageContentType.Jackpot) != -1) {
        this.pageRoot = [];
        for (var pageID = 0; pageID < this.pages.length; pageID++)
            for (var evIdx = 0; evIdx < this.cat.events.length; evIdx++)
                if (this.cat.events[evIdx].id == this.pages[pageID].show.id) {
                    var action = this.cat.events[evIdx].actions[0];
                    if (action.ToEnableList.length > 0)
                        this.pageRoot.push(action.ToEnableList[0]);
                    break
                }
        this.hasFeatureDependentPages = true;
        this.jackpotPageCounter = 0;
        for (var j = 0; j < this.pageContentType.length; j++)
            if (this.pageContentType[j] != PageContentType.Normal)
                this.jackpotPageCounter++;
        var activePageID = 0;
        for (var pageID = 0; pageID < this.pageRoot.length; pageID++) {
            var childArray = this.pageRoot[pageID].transform.children;
            for (var cIdx = 0; cIdx < childArray.length; cIdx++)
                if (childArray[cIdx].gameObject.name == "PageIndicator") {
                    var removalCount = this.jackpotPageCounter;
                    var activePageWasSet = false;
                    var dotArray = childArray[cIdx].transform.children;
                    for (var dIdx = 0; dIdx < dotArray.length; dIdx++)
                        if (removalCount > 0) {
                            dotArray[dIdx].transform.gameObject.SetActive(false);
                            removalCount--
                        } else if (this.pageContentType[pageID] == PageContentType.Normal) {
                            var dotSprite = dotArray[dIdx].transform.gameObject.GetComponentsInChildren(UISprite, true)[0];
                            if (dotSprite == null)
                                break;
                            if (removalCount + activePageID == 0) {
                                dotSprite.spriteName = "PaytablePageDot_Over";
                                activePageID++;
                                activePageWasSet = true
                            } else
                                dotSprite.spriteName = "PaytablePageDot_Normal";
                            if (!activePageWasSet)
                                removalCount--
                        }
                }
        }
    }
    if (this.pageContentType.length != 0 && !this.hasFeatureDependentPages)
        this.pagesCount = this.pages.length;
    else
        this.pagesCount = this.pages.length - this.jackpotPageCounter;
    if (this.gameObject.transform.Find("PaytableCommonExtra/PageIndexHolder/PageIndexLabel") != null)
        this.pageIndexLabel = this.gameObject.transform.Find("PaytableCommonExtra/PageIndexHolder/PageIndexLabel").GetComponent(UILabel)
}
;
Paytable.prototype.ChangePaytableStatus = function(active) {
    if (this.paytableActive != active) {
        this.paytableActive = active;
        this.cat.StartEvent(active ? this.paytable.show.id : this.paytable.hide.id)
    }
}
;
Paytable.prototype.OnPressedPaytableOpen = function() {
    this.ChangePaytableStatus(true);
    this.currentPageIndex = 1;
    if (this.pageIndexLabel != null)
        this.pageIndexLabel.text = this.currentPageIndex + "/" + this.pagesCount
}
;
Paytable.prototype.OnPressedPaytableClose = function() {
    this.ChangePaytableStatus(false)
}
;
Paytable.prototype.OnPressedPaytableNext = function() {
    this.ShowPageInt(this.pageIdx + 1);
    if (this.currentPageIndex + 1 > this.pagesCount)
        this.currentPageIndex = 1;
    else
        this.currentPageIndex = this.currentPageIndex + 1;
    if (this.pageIndexLabel != null)
        this.pageIndexLabel.text = this.currentPageIndex + "/" + this.pagesCount
}
;
Paytable.prototype.OnPressedPaytablePrevious = function() {
    this.ShowPageInt(this.pageIdx - 1);
    if (this.currentPageIndex - 1 <= 0)
        this.currentPageIndex = this.pagesCount;
    else
        this.currentPageIndex = this.currentPageIndex - 1;
    if (this.pageIndexLabel != null)
        this.pageIndexLabel.text = this.currentPageIndex + "/" + this.pagesCount
}
;
Paytable.prototype.ShowPageInt = function(index) {
    if (!this.hasFeatureDependentPages) {
        this.cat.StartEvent(this.pages[this.pageIdx].hide.id);
        this.pageIdx = index < 0 ? this.pages.length - 1 : index % this.pages.length;
        this.cat.StartEvent(this.pages[this.pageIdx].show.id)
    } else {
        var next = 1;
        if (index < this.pageIdx)
            next *= -1;
        this.pageIdx = index < 0 ? this.pageRoot.length - 1 : index % this.pageRoot.length;
        if (this.pageContentType[this.pageIdx] != PageContentType.Normal) {
            this.ShowPageInt(this.pageIdx + next);
            return
        }
        for (var pageID = 0; pageID < this.pageRoot.length; pageID++)
            this.pageRoot[pageID].SetActive(pageID == this.pageIdx)
    }
}
;
Paytable.prototype.ShowPage = function(index) {
    this.ShowPageInt(_number.otoi(index))
}
;
goog.require("UHT.XTLink");
function PaytableScrollValues() {
    this.pagesOffset = new UHTMath.Vector3(0,-2385,0);
    this.topPageExtraOffset = new UHTMath.Vector3(0,0,0);
    this.bottomPageExtraOffset = new UHTMath.Vector3(0,1,0);
    this.firstPageExtraDrag = new UHTMath.Vector3(0,-50,0);
    this.lastPageExtraDrag = new UHTMath.Vector3(0,1475,0);
    this.scrollWheelMovement = new UHTMath.Vector3(0,200,0)
}
Paytable_mobile.prototype = Object.create(XTLink.prototype);
Paytable_mobile.prototype.constructor = Paytable_mobile;
function Paytable_mobile() {
    XTLink.call(this);
    this.miniScrollValues = null;
    this.miniPageFlipper = null;
    this.miniDragObject = null;
    this.miniInitialPos = null;
    this.portraitScrollValues = null;
    this.portraitPageFlipper = null;
    this.portraitDragObject = null;
    this.landscapeScrollValues = null;
    this.landscapePageFlipper = null;
    this.landscapeDragObject = null;
    this.hasAutoplayPages = true
}
Paytable_mobile.prototype.XTInitVariablesAndEvents = function() {
    this.UpdateZOrder();
    XT.SetObject(Vars.MobilePaytableObject, this)
}
;
Paytable_mobile.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this)
}
;
Paytable_mobile.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnPressedPaytableOpen, this);
    XT.UnregisterCallbackEvent(this.OnPressedPaytableClose, this)
}
;
Paytable_mobile.prototype.OnPressedPaytableOpen = function() {
    if (Globals.isMini)
        this.UpdateMini();
    else
        this.UpdateMobile();
    this.gameObject.SetActive(true)
}
;
Paytable_mobile.prototype.OnPressedPaytableClose = function() {
    this.gameObject.SetActive(false)
}
;
Paytable_mobile.prototype.UpdateMini = function() {
    if (this.miniPageFlipper == null)
        this.InitMini();
    this.miniDragObject.target.position(this.miniInitialPos)
}
;
Paytable_mobile.prototype.InitMini = function() {
    var pageFlippers = this.GetComponentsInChildren(PageFlipper, true);
    for (var i = 0; i < pageFlippers.length; ++i) {
        var arrangeable = pageFlippers[i].GetComponent(ArrangeableActive);
        if (arrangeable == null)
            continue;
        if (arrangeable.activeInLandscape) {
            arrangeable.activeInLandscape = false;
            arrangeable.gameObject.SetActive(false)
        }
        if (arrangeable.activeInPortrait) {
            arrangeable.activeInLandscape = true;
            arrangeable.gameObject.SetActive(true);
            this.miniPageFlipper = pageFlippers[i];
            this.miniDragObject = this.miniPageFlipper.GetComponent(CustomDragObject);
            this.miniInitialPos = this.miniDragObject.target.position();
            this.InitPageFlipper(this.miniPageFlipper, this.miniDragObject, this.miniScrollValues)
        }
    }
}
;
Paytable_mobile.prototype.UpdateMobile = function() {
    if (this.landscapePageFlipper == null)
        this.InitMobile();
    this.landscapeDragObject.target.position(this.landscapeDragObject.target.parent.transformPoint(this.landscapeDragObject.localPositionLimitMin));
    this.portraitDragObject.target.position(this.portraitDragObject.target.parent.transformPoint(this.portraitDragObject.localPositionLimitMin))
}
;
Paytable_mobile.prototype.InitMobile = function() {
    var pageFlippers = this.GetComponentsInChildren(PageFlipper, true);
    for (var i = 0; i < pageFlippers.length; ++i) {
        var arrangeable = pageFlippers[i].GetComponent(ArrangeableActive);
        if (arrangeable == null)
            continue;
        if (arrangeable.activeInLandscape) {
            this.landscapePageFlipper = pageFlippers[i];
            this.landscapeDragObject = this.landscapePageFlipper.GetComponent(CustomDragObject);
            this.landscapeScrollValues.pagesOffset = new UHTMath.Vector3(0,-854,0);
            this.landscapeScrollValues.firstPageExtraDrag = new UHTMath.Vector3(0,-50,0);
            if (this.hasAutoplayPages)
                this.landscapeScrollValues.lastPageExtraDrag = XT.GetBool(Vars.HasAdvancedAutoplay) ? new UHTMath.Vector3(0,-73,0) : new UHTMath.Vector3(0,-483,0);
            else
                this.landscapeScrollValues.lastPageExtraDrag = new UHTMath.Vector3(0,-56,0);
            this.landscapeScrollValues.scrollWheelMovement = new UHTMath.Vector3(0,7.95,0);
            this.InitPageFlipper(this.landscapePageFlipper, this.landscapeDragObject, this.landscapeScrollValues)
        }
        if (arrangeable.activeInPortrait) {
            this.portraitPageFlipper = pageFlippers[i];
            this.portraitDragObject = this.portraitPageFlipper.GetComponent(CustomDragObject);
            this.portraitScrollValues.firstPageExtraDrag = new UHTMath.Vector3(0,8.5,0);
            if (this.hasAutoplayPages)
                this.portraitScrollValues.lastPageExtraDrag = XT.GetBool(Vars.HasAdvancedAutoplay) ? new UHTMath.Vector3(0,0,0) : new UHTMath.Vector3(0,-1450,0);
            else
                this.portraitScrollValues.lastPageExtraDrag = new UHTMath.Vector3(0,0,0);
            this.portraitScrollValues.scrollWheelMovement = new UHTMath.Vector3(0,23.85,0);
            this.InitPageFlipper(this.portraitPageFlipper, this.portraitDragObject, this.portraitScrollValues)
        }
    }
}
;
Paytable_mobile.prototype.InitPageFlipper = function(flipper, drag, values) {
    var V3 = UHTMath.Vector3;
    flipper.isFlippingEnabled = false;
    if (!Globals.isMini)
        flipper.transform.localScale(new V3(.93,.93,1));
    drag.movement = new V3(0,1,0);
    drag.target = flipper.transform;
    drag.cachedCamera = null;
    drag.limitPosition = true;
    var flipperPos = drag.target.localPosition();
    drag.localPositionLimitMin = V3.add(flipperPos, values.firstPageExtraDrag);
    drag.localPositionLimitMax = V3.add(flipperPos, V3.add(values.lastPageExtraDrag, V3.scale(V3.scale(V3.scale(values.pagesOffset, -1), drag.target.localScale()), flipper.topPages.length - 1)));
    drag.useScrollWheel = true;
    drag.scrollWheelMovement = this.transform.transformPoint(values.scrollWheelMovement);
    var firstPagePos = flipper.topPages[0].localPosition();
    for (var j = 0; j < flipper.topPages.length; ++j) {
        flipper.topPages[j].gameObject.SetActive(true);
        flipper.topPages[j].localPosition(V3.add(V3.add(firstPagePos, values.topPageExtraOffset), V3.scale(values.pagesOffset, j)));
        flipper.bottomPages[j].gameObject.SetActive(true);
        flipper.bottomPages[j].localPosition(V3.add(V3.add(firstPagePos, values.bottomPageExtraOffset), V3.scale(values.pagesOffset, j)))
    }
    var c = flipper.GetComponent(Collider);
    c.size = new V3(c.size.x,Math.abs(values.pagesOffset.y) * flipper.topPages.length,c.size.z);
    c.center = new V3(c.center.x,values.pagesOffset.y / 2 * (flipper.topPages.length - 1),c.center.z);
    var line = flipper.transform.Find("middleLine").gameObject;
    if (line != null)
        line.SetActive(false);
    if (Globals.isMini)
        return;
    for (var i = 0; i < flipper.topPages.length; ++i)
        flipper.topPages[i].Find("Content/Background").gameObject.SetActive(false);
    for (var i = 0; i < flipper.bottomPages.length; ++i)
        flipper.bottomPages[i].Find("Content/Background").gameObject.SetActive(false)
}
;
Paytable_mobile.prototype.UpdateZOrder = function() {
    if (Globals.isMini)
        return;
    var colliders = this.GetComponentsInChildren(Collider, true);
    for (var i = 0; i < colliders.length; ++i) {
        var p = colliders[i].transform.localPosition();
        colliders[i].transform.localPosition(new UHTMath.Vector3(p.x,p.y,0));
        if (colliders[i].GetComponent(Paytable_mobile) != null || colliders[i].GetComponent(PageFlipper) != null)
            colliders[i].enabled = false
    }
}
;
goog.provide("UHT.VideoSlotsConnection");
goog.require("UHT.Engine");
goog.require("UHT.JackpotHelpers");
var VSCStagedHandler = {
    None: 0,
    Spin: 1
};
var VSCHandlerStage = {
    Stage_0: 0,
    Stage_1: 1,
    Stage_2: 2
};
VideoSlotsConnection.prototype = Object.create(Component.prototype);
VideoSlotsConnection.prototype.constructor = VideoSlotsConnection;
function VideoSlotsConnection() {
    Component.call(this);
    this.xtLayer = null;
    this.serverRequestSent = false;
    this.realMoney = false;
    this.isInit = true;
    this.lastResponse = null;
    this.fsbgLastResponse = null;
    this.fsgbResponse = null;
    this.storedPaytable = null;
    this.storedMaxFS = -1;
    this.Bets = null;
    this.gambleResponse = null;
    this.gambleColorMultiplier = -1;
    this.gambleSuitMultiplier = -1;
    this.gambleDiceMultiplier = -1;
    this.gambleCardHistory = null;
    this.canGamble = false;
    this.stagedHandler = VSCStagedHandler.None;
    this.handlerStage = VSCHandlerStage.Stage_0
}
VideoSlotsConnection.cleanupPreviousWin = false;
VideoSlotsConnection.isUnfinishedGame = false;
VideoSlotsConnection.prototype.Awake = function() {
    this.Bets = [.01, .02, .05, .1, .25, .5, 1, 3, 5]
}
;
VideoSlotsConnection.prototype.Update = function() {
    if (this.stagedHandler == VSCStagedHandler.None)
        return;
    switch (this.stagedHandler) {
    case VSCStagedHandler.Spin:
        this.HandlerSpinResult(this.lastResponse);
        break
    }
}
;
VideoSlotsConnection.prototype.AddServerCallbacks = function() {
    EventManager.AddHandler(GameEvents.evtInitResponse + this.xtLayer.gameSymbol, this.HandlerGameInit, this);
    EventManager.AddHandler(GameEvents.evtSpinResponse + this.xtLayer.gameSymbol, this.HandlerSpinResult, this);
    EventManager.AddHandler(GameEvents.evtNoMoneySpinResponse, this.HandlerNoMoneySpinResult, this);
    EventManager.AddHandler(GameEvents.evtConfigSwitchedResponse + this.xtLayer.gameSymbol, this.HandlerConfigSwitched, this);
    EventManager.AddHandler(GameEvents.evtGambleResponse + this.xtLayer.gameSymbol, this.HandlerGambleV2Response, this);
    EventManager.AddHandler(JackpotEvents.evtJackpotsUpdated, this.HandlerJackpotsUpdated, this);
    EventManager.AddHandler(GameEvents.evtFSBGInitResponse + this.xtLayer.gameSymbol, this.HandlerFSBGInit, this);
    EventManager.AddHandler(GameEvents.evtFSBGPickResponse + this.xtLayer.gameSymbol, this.HandlerFSBGResponse, this);
    EventManager.AddHandler(GameEvents.evtMysteryScatterResponse + this.xtLayer.gameSymbol, this.HandlerMysteryScatter, this);
    EventManager.AddHandler(GameEvents.evtFreeRoundsUpdate, this.HandlerFreeRoundUpdate, this);
    EventManager.AddHandler(GameEvents.evtFSOptionsUpdate + this.xtLayer.gameSymbol, this.HandlerFreeSpinOptionsUpdate, this);
    EventManager.AddHandler(GameEvents.evtServerTimeUpdate, this.HandlerServerTimeUpdate, this);
    EventManager.AddHandler(ApplicationEvents.evtServerOptionsParsed, this.OnServerOptionsParsed, this)
}
;
VideoSlotsConnection.prototype.OnServerOptionsParsed = function() {
    this.xtLayer.JurisdictionSetup()
}
;
VideoSlotsConnection.prototype.SpinPressed = function(lines, betPerLine) {
    var request = new VsRequest;
    request.Symbol = String(this.xtLayer.gameSymbol);
    request.Bet = betPerLine;
    request.Line = lines;
    var progressiveConfig = XT.GetObject(Vars.ProgressiveFeatureConfig);
    if (progressiveConfig != null && progressiveConfig.pickedSymbolPosition != -1)
        request.ProgressPick = progressiveConfig.pickedSymbolPosition;
    console.log("Sending spin request");
    this.serverRequestSent = true;
    EventManager.Trigger(GameEvents.evtSpinRequest + this.xtLayer.gameSymbol, request)
}
;
VideoSlotsConnection.prototype.InitReels = function() {
    this.xtLayer.InitReelSymbols(this.lastResponse.VsInitData.ReelSymbols);
    if (this.lastResponse.ReelPositions == null) {
        XT.SetBool(Vars.HiddenMathematics, true);
        this.lastResponse.ReelPositions = [];
        for (var i = 0; i < this.lastResponse.WinScreenSymbols.length; i++)
            this.lastResponse.ReelPositions.push(0)
    }
    this.xtLayer.InitReelsPositions(this.lastResponse.ReelPositions)
}
;
VideoSlotsConnection.prototype.InitNextReels = function() {
    var nextReelSymbols = [];
    if (this.lastResponse.ReelSetIndex >= 0) {
        var reelSets = XT.GetObject(Vars.ReelSets);
        nextReelSymbols = reelSets[this.lastResponse.ReelSetIndex]
    } else
        nextReelSymbols = this.lastResponse.VsInitData.NextReelSymbols;
    this.xtLayer.InitNextReelSymbols(nextReelSymbols)
}
;
VideoSlotsConnection.prototype.InitReelSets = function() {
    this.xtLayer.UpdateReelSetIndexes(this.lastResponse.ReelSetIndexCurrent);
    this.xtLayer.SetReelSets(this.lastResponse.VsInitData.ReelSets)
}
;
VideoSlotsConnection.prototype.Start = function() {}
;
VideoSlotsConnection.prototype.Init = function() {
    console.log("VideoSlotsConnection - Init")
}
;
VideoSlotsConnection.prototype.OnDestroy = function() {}
;
VideoSlotsConnection.prototype.OnShowResult = function() {}
;
VideoSlotsConnection.prototype.OnFreeSpinsClosed = function() {
    EventManager.Trigger(GameEvents.evtFreespinsFinished + this.xtLayer.gameSymbol, null)
}
;
VideoSlotsConnection.prototype.IsInit = function() {
    return this.isInit
}
;
VideoSlotsConnection.prototype.Vs_InitData = function() {
    return this.lastResponse.VsInitData
}
;
VideoSlotsConnection.prototype.GetSymbolPaytable = function(symbolId) {
    return this.storedPaytable[symbolId]
}
;
VideoSlotsConnection.prototype.WonTheJackpot = function() {
    if (this.lastResponse != null)
        return this.lastResponse.IsJackpotWin();
    else
        return false
}
;
VideoSlotsConnection.prototype.IsFreeSpin = function() {
    return this.lastResponse.IsFreeSpins() && this.lastResponse.VsFreeSpin.GetMaxNumber() != 0
}
;
VideoSlotsConnection.prototype.IsNeedMysteryScatter = function() {
    return this.lastResponse.VsFreeSpin.IsNeedGetMysteryScatter()
}
;
VideoSlotsConnection.prototype.HasMysteryScatter = function() {
    return this.lastResponse.IsFreeSpins() && this.lastResponse.VsFreeSpin.GetMysteryScatter() != -1
}
;
VideoSlotsConnection.prototype.GetMysteryScatter = function() {
    return this.lastResponse.VsFreeSpin.GetMysteryScatter()
}
;
VideoSlotsConnection.prototype.SetLastFreesSpinsNull = function() {
    this.lastResponse.SetVsFreeSpin(null)
}
;
VideoSlotsConnection.prototype.GetWinValue = function() {
    return this.lastResponse.Win
}
;
VideoSlotsConnection.prototype.IsFreeSpinWin = function() {
    if (this.IsFreeSpin())
        if (this.FreeSpinMaxNumber() > 0 && this.storedMaxFS < this.FreeSpinMaxNumber()) {
            this.storedMaxFS = this.FreeSpinMaxNumber();
            return true
        } else
            return false;
    this.storedMaxFS = -1;
    return false
}
;
VideoSlotsConnection.prototype.IsLastFreeSpin = function() {
    return this.lastResponse.IsFreeSpins() && this.lastResponse.VsFreeSpin.IsLastFreeSpin()
}
;
VideoSlotsConnection.prototype.FreeSpinTotalNumber = function() {
    return this.lastResponse.VsFreeSpin.GetTotalNumber()
}
;
VideoSlotsConnection.prototype.FreeSpinCurrentNumber = function() {
    return this.lastResponse.VsFreeSpin.GetCurrentNumber()
}
;
VideoSlotsConnection.prototype.FreeSpinMaxNumber = function() {
    return this.lastResponse.VsFreeSpin.GetMaxNumber()
}
;
VideoSlotsConnection.prototype.FreeSpinTotalMultipl = function() {
    return this.lastResponse.VsFreeSpin.GetTotalMultipl()
}
;
VideoSlotsConnection.prototype.FreeSpinCurrentWin = function() {
    return this.lastResponse.VsFreeSpin.GetCurrentWin()
}
;
VideoSlotsConnection.prototype.FreeSpinTotalWin = function() {
    return this.lastResponse.VsFreeSpin.GetTotalWin()
}
;
VideoSlotsConnection.prototype.FreeSpinCurrentWinMultiplied = function() {
    return this.lastResponse.VsFreeSpin.GetCurrentWinMultiplied()
}
;
VideoSlotsConnection.prototype.FreeSpinTotalWinMultiplied = function() {
    return this.lastResponse.VsFreeSpin.GetTotalWinMultiplied()
}
;
VideoSlotsConnection.prototype.GambleGetBalance = function() {
    return this.gambleResponse.Balance
}
;
VideoSlotsConnection.prototype.GambleGetCard = function() {
    return this.gambleResponse.Card
}
;
VideoSlotsConnection.prototype.GambleGetDice1 = function() {
    return this.gambleResponse.Dice1
}
;
VideoSlotsConnection.prototype.GambleGetDice2 = function() {
    return this.gambleResponse.Dice2
}
;
VideoSlotsConnection.prototype.GambleIsNoMoney = function() {
    return this.gambleResponse.NoMoney
}
;
VideoSlotsConnection.prototype.HasFreeSpinOptions = function() {
    return this.lastResponse.HasFreeSpinOptions()
}
;
VideoSlotsConnection.prototype.IsFreeSpinsBonusGame = function() {
    return this.lastResponse.IsFreeSpinBonusGame()
}
;
VideoSlotsConnection.prototype.FSBG_GameOver = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.GameOver
}
;
VideoSlotsConnection.prototype.FSBG_Lives = function() {
    return Number(this.fsbgLastResponse.VsFreeSpin.BonusGame.Lifes)
}
;
VideoSlotsConnection.prototype.FSBG_Level = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.Level
}
;
VideoSlotsConnection.prototype.FSBG_Items = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems
}
;
VideoSlotsConnection.prototype.FSBG_Close = function() {
    var vsfs = this.fsbgLastResponse.VsFreeSpin;
    vsfs.SetCurrentNumber(1);
    vsfs.SetMaxNumber(vsfs.BonusGame.SpinsWin);
    vsfs.SetTotalMultipl(vsfs.BonusGame.MultipliersWin);
    vsfs.BonusGame = null;
    this.lastResponse.SetVsFreeSpin(vsfs);
    this.IsFreeSpinWin()
}
;
VideoSlotsConnection.prototype.FSBG_WinMultipliers = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.MultipliersWin
}
;
VideoSlotsConnection.prototype.FSBG_WinSpins = function() {
    return this.fsbgLastResponse.VsFreeSpin.BonusGame.SpinsWin
}
;
VideoSlotsConnection.prototype.FSBG_InProgress = function() {
    if (this.fsbgLastResponse != null) {
        if (this.fsbgLastResponse.VsFreeSpin.BonusGame.GameOver)
            return true;
        if (this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems != null && this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems.length > 0)
            for (var i = 0; i < this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems.length; ++i)
                if (this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems[i].Status == VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Selected)
                    return true
    }
    return false
}
;
VideoSlotsConnection.prototype.InitFakeGambleState = function() {
    if (this.gambleResponse == null)
        this.gambleResponse = new VsGamblingResponse;
    this.gambleResponse.State = GamblingState.Win
}
;
VideoSlotsConnection.prototype.SendGambleOpen = function() {
    this.InitFakeGambleState();
    XT.TriggerEvent(Vars.Evt_FromServer_GambleOpen)
}
;
VideoSlotsConnection.prototype.SendGambleBack = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_GambleClose);
    EventManager.Trigger(GameEvents.evtGambleClose + this.xtLayer.gameSymbol, null)
}
;
VideoSlotsConnection.prototype.SendGambleChoice = function(choice) {
    var gambleRequest = new VsGamblingRequest;
    gambleRequest.Choice = choice;
    this.serverRequestSent = true;
    EventManager.Trigger(GameEvents.evtGambleRequest + this.xtLayer.gameSymbol, gambleRequest)
}
;
VideoSlotsConnection.prototype.FSOption_SendPick = function(itemIndex) {
    var choice = new VsBonusGamePlayerChoice(itemIndex);
    EventManager.Trigger(GameEvents.evtFSOptionPickRequest + this.xtLayer.gameSymbol, choice)
}
;
VideoSlotsConnection.prototype.FSBG_SendPick = function(itemIndex) {
    var choice = new VsBonusGamePlayerChoice(itemIndex);
    EventManager.Trigger(GameEvents.evtFSBGPickRequest + this.xtLayer.gameSymbol, choice)
}
;
VideoSlotsConnection.prototype.SendGetJackpots = function() {}
;
VideoSlotsConnection.prototype.SendGetJackpotsGames = function() {}
;
VideoSlotsConnection.prototype.HandlerJackpotsUpdated = function(jackpots) {
    this.xtLayer.SetJackpotsInfo(jackpots)
}
;
VideoSlotsConnection.prototype.HandlerGameInit = function(vsResponse) {
    console.log("VideoSlotsConnection - this.HandlerGameInit");
    this.isInit = true;
    this.lastResponse = vsResponse;
    if (this.lastResponse == null) {
        console.error("Null response from server!");
        return
    }
    if (VideoSlotsConnection.cleanupPreviousWin) {
        this.lastResponse.Win = 0;
        this.lastResponse.VsWinLines = [];
        if (!VideoSlotsConnection.isUnfinishedGame)
            this.lastResponse.SpinCycleWin = 0
    }
    this.storedPaytable = this.lastResponse.VsInitData.Paytable;
    this.xtLayer.SetPaytableInfo(this.storedPaytable);
    var gambleSettings = this.lastResponse.VsInitData.GamblingSettings;
    if (gambleSettings != null) {
        if (gambleSettings.GetGamblingSettings(GamblingType.CardColor) != null)
            this.gambleColorMultiplier = Number(gambleSettings.GetGamblingSettings(GamblingType.CardColor));
        if (gambleSettings.GetGamblingSettings(GamblingType.Suit) != null)
            this.gambleSuitMultiplier = Number(gambleSettings.GetGamblingSettings(GamblingType.Suit));
        var b1 = gambleSettings.IsOccasionEnable(GamblingOccasions.Spin);
        var b2 = gambleSettings.IsOccasionEnable(GamblingOccasions.FreeSpin);
        var b3 = gambleSettings.IsOccasionEnable(GamblingOccasions.Bonus);
        this.xtLayer.SetGambleSettings(b1, b2, b3, this.gambleColorMultiplier, this.gambleSuitMultiplier)
    }
    var gamblingHistory = this.lastResponse.VsInitData.GamblingHistory;
    if (gamblingHistory != null) {
        var gHistory = gamblingHistory.History;
        this.gambleCardHistory = [];
        for (var i = 0; i < gHistory.length; ++i)
            this.gambleCardHistory[i] = gHistory[i].Card;
        this.gambleResponse = gamblingHistory.History[gamblingHistory.History.length - 1];
        this.gambleResponse.Balance = gamblingHistory.WinAmount
    }
    this.xtLayer.SetGambleHistory(gamblingHistory);
    this.canGamble = this.lastResponse.VsGamblingButtonState.GamblingOnSpinAvailable;
    if (this.canGamble && gamblingHistory != null && gambleSettings.InitGamblingOccasion == GamblingOccasions.Spin)
        this.canGamble = false;
    this.xtLayer.SetCanGambleSpinWin(this.canGamble);
    var gameHasGamble = gambleSettings.IsOccasionEnable(GamblingOccasions.Bonus) || gambleSettings.IsOccasionEnable(GamblingOccasions.Spin) || gambleSettings.IsOccasionEnable(GamblingOccasions.FreeSpin);
    if (gameHasGamble && (gambleSettings.SkipGambleOnInit || this.lastResponse.Win <= 0))
        this.xtLayer.SkipResultDisplayOnInit();
    if (this.IsFreeSpin())
        this.storedMaxFS = this.FreeSpinMaxNumber();
    this.InitReels();
    this.InitReelSets();
    if (this.lastResponse.VsInitData != null && this.lastResponse.VsInitData.NextReelSymbols != null || this.lastResponse.ReelSetIndex >= 0)
        this.InitNextReels();
    this.xtLayer.SetStackedSymbolIndex(this.lastResponse.StackedSymbolIndex);
    this.xtLayer.SetBetLines(this.lastResponse.VsInitData.Line);
    this.xtLayer.SetRandomWildsData(this.lastResponse.RandomWildsData, this.lastResponse.UpSymbols);
    this.xtLayer.SetWildRandomLineMpConfig(this.lastResponse.VsInitData.WildRandomLineMpConfig);
    this.xtLayer.SetNASymbolId(this.lastResponse.VsInitData.naSymbolId);
    this.xtLayer.SetWRLMResponse(this.lastResponse.WRLMResponse);
    this.xtLayer.SetWRLMCurrentSets(this.lastResponse.WRLMCurrentSets);
    this.xtLayer.SetRandomAwardsConfig(this.lastResponse.VsInitData.RandomAwardConfig);
    this.xtLayer.SetRandomAwardResponse(this.lastResponse.RandomAwardResponse);
    this.xtLayer.SetRandomSymbolMultipliers(this.lastResponse.RandomSymbolMultipliers);
    this.xtLayer.SetPossibleRandomSymbolMultipliers(this.lastResponse.PossibleRandomSymbolMultipliers);
    this.xtLayer.SetFreeSpinsChainData(this.lastResponse.FreeSpinsChainData);
    this.xtLayer.SetOpeningSymbolsData(this.lastResponse.OpeningSymbolsData);
    this.xtLayer.SetRandomMysterySymbolId(this.lastResponse.RandomMysterySymbolId);
    this.xtLayer.SetPatternedMysterySymbols(this.lastResponse.PatternedMysterySymbols);
    this.xtLayer.SetInitialMysterySymbolId(this.lastResponse.VsInitData.InitialMysterySymbolId);
    this.xtLayer.SetInitialBGItemValues(this.lastResponse.VsInitData.BGItemValues);
    this.xtLayer.SetInitialBGItemMasks(this.lastResponse.VsInitData.BGItemMasks);
    this.xtLayer.InitFirstScreenSymbols(this.lastResponse.WinScreenSymbols);
    if (this.lastResponse.SymbolsBeforeExpanding != null && this.lastResponse.SymbolsBeforeExpanding.length > 0)
        this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.SymbolsBeforeExpanding);
    else
        this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.WinScreenSymbols);
    this.xtLayer.SetGoldSymbol(this.lastResponse.GoldSymbol);
    this.xtLayer.SetSymbolReplacementData(this.lastResponse.SymbolReplacementData);
    this.xtLayer.SetResultScreenSymbols(this.lastResponse.WinScreenSymbols);
    this.xtLayer.SetSymbolsAbove(this.lastResponse.SymbolsAbove);
    this.xtLayer.SetSymbolsBelow(this.lastResponse.SymbolsBelow);
    this.xtLayer.SetNextReelsSymbolsList(this.lastResponse.NextReelsSymbolsList);
    this.xtLayer.SetHasCoins(ServerOptions.amountType != "CURRENCY");
    this.Bets = this.lastResponse.VsInitData.Bets;
    this.xtLayer.SetBets(this.Bets, this.lastResponse.VsInitData.Bet, this.lastResponse.VsInitData.DefaultBet);
    this.xtLayer.SetBalance(this.lastResponse.Balance, false);
    this.xtLayer.SetWinValue(this.lastResponse.Win);
    this.xtLayer.SetSpinCycleWinValue(this.lastResponse.SpinCycleWin);
    this.xtLayer.SetExtraAwardWin(this.lastResponse.ExtraAwardWin);
    this.xtLayer.SetRespinCycleWin(this.lastResponse.RespinCycleWin);
    var linesWin = 0;
    for (var i = 0; i < this.lastResponse.VsWinLines.length; ++i) {
        var vswl = this.lastResponse.VsWinLines[i];
        linesWin += vswl.WinAmount
    }
    this.xtLayer.SetLinesWinValue(linesWin);
    this.xtLayer.SetWinLines(this.lastResponse.VsWinLines);
    var isGamble = this.lastResponse.isGambleV2();
    this.xtLayer.SetGambleV2Response(this.lastResponse.gambleV2Data);
    this.xtLayer.SetMustOpenGambleV2(isGamble);
    this.xtLayer.SetMustOpenBonus(this.lastResponse.IsBonus() && !isGamble, this.lastResponse.IsBonusGameOver() && this.lastResponse.NextGameActions.indexOf(NextGameAction.Bonus) > -1);
    this.isInit = false;
    this.xtLayer.SetExpandingSymbolsData(this.lastResponse.ExpandingSymbolsData);
    this.xtLayer.SetRespinData(this.lastResponse.Respin);
    this.xtLayer.SetProgressiveFeatureConfig(this.lastResponse.VsInitData.ProgressiveConfig);
    this.xtLayer.SetProgressiveFeatureData(this.lastResponse.ProgressiveData);
    this.xtLayer.SetMoneySymbolConfig(this.lastResponse.VsInitData.MoneySymbolConfig);
    this.xtLayer.SetMoneySymbolData(this.lastResponse.MoneySymbolData);
    this.xtLayer.SetStickySymbolsData(this.lastResponse.StickySymbols);
    this.xtLayer.SetMergingSymbolsData(this.lastResponse.MergingSymbols);
    this.xtLayer.SetJackpotState(this.lastResponse.VsJackpotData);
    if (this.WonTheJackpot()) {
        var jpData = this.lastResponse.VsJackpotData;
        this.xtLayer.SetJackpotWon(jpData.JackpotID, jpData.JackpotOrder, jpData.WinJackpotAmount)
    }
    this.xtLayer.SetJackpotVisualization(this.lastResponse.JackpotVisualisation);
    if (this.HasFreeSpinOptions())
        this.xtLayer.MustOpenFSOptions(this.lastResponse.FreeSpinsOptions);
    if (this.IsFreeSpinsBonusGame() && this.lastResponse.VsFreeSpin.BonusGame.GameOver) {
        this.fsgbResponse = this.lastResponse.Clone();
        this.fsgbResponse.VsFreeSpin.SetTotalMultipl(this.lastResponse.VsFreeSpin.BonusGame.MultipliersWin);
        this.fsgbResponse.VsFreeSpin.SetMaxNumber(this.lastResponse.VsFreeSpin.BonusGame.SpinsWin);
        this.fsgbResponse.VsFreeSpin.SetCurrentNumber(1);
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin)
    } else {
        this.xtLayer.SetFreeSpinResponseReceived(this.lastResponse.VsFreeSpin);
        if (XT.GetBool(Vars.TruncateFSResponseDuringRespin))
            this.xtLayer.SetTruncatedFSResponseReceived(this.lastResponse.TruncatedVsFreeSpin)
    }
    if ((this.lastResponse.GetVsFreeSpin() != null && this.lastResponse.GetVsFreeSpin().IsLastFreeSpin() || this.lastResponse.GetVsFreeSpin() == null) && XT.GetBool(Vars.OpenFSBGForMysteryScatter))
        this.xtLayer.SetStartFSBG(false);
    this.xtLayer.SetMysteryScatterSymbolId(-1);
    if (this.lastResponse.VsFreeSpin != null) {
        var ms = this.lastResponse.VsFreeSpin.GetMysteryScatter();
        if (ms != null)
            this.xtLayer.SetMysteryScatterSymbolId(ms)
    }
    if (this.IsFreeSpin() && this.IsNeedMysteryScatter()) {
        this.fsgbResponse = this.lastResponse.Clone();
        this.xtLayer.SetStartFSBG(true)
    } else if (this.IsFreeSpinsBonusGame() && !this.lastResponse.VsFreeSpin.BonusGame.GameOver) {
        this.fsgbResponse = this.lastResponse.Clone();
        this.xtLayer.SetStartFSBG(false)
    }
    this.xtLayer.SetWildRandomMultipliers(this.lastResponse.WildRandomMultipliers);
    this.xtLayer.UpdateBonusRoundsInfo(this.lastResponse);
    this.xtLayer.SetReturnToPlayer(this.lastResponse.ReturnToPlayer);
    this.xtLayer.SetReturnToPlayerMin(this.lastResponse.ReturnToPlayerMin);
    this.xtLayer.SetNudgedSymbolsData(this.lastResponse.NudgedSymbolsData);
    this.xtLayer.SetSpinOneReelValues(this.lastResponse.SpinOneReelData);
    this.xtLayer.SetTumblingData(this.lastResponse.TumblingData);
    this.xtLayer.SetBetLevelSettings(this.lastResponse.VsInitData.BetLevelSettings);
    this.xtLayer.SetFSPurchaseConfig(this.lastResponse.VsInitData.FreeSpinsPurchaseConfig);
    this.xtLayer.SetFSPurchaseData(this.lastResponse.FreeSpinsPurchaseData);
    this.xtLayer.InitReceived();
    this.xtLayer.SetBonusBalance(this.lastResponse.BonusBalance)
}
;
VideoSlotsConnection.prototype.HandlerConfigSwitched = function(arg) {
    console.log("VideoSlotsConnection - HandlerConfigSwitched");
    this.lastResponse = arg;
    if (this.lastResponse == null) {
        console.error("Null response from server!");
        return
    }
    this.storedPaytable = this.lastResponse.VsInitData.Paytable;
    this.xtLayer.SetPaytableInfo(this.storedPaytable);
    var gambleSettings = this.lastResponse.VsInitData.GamblingSettings;
    if (gambleSettings != null) {
        if (gambleSettings.GetGamblingSettings(GamblingType.CardColor) != null)
            this.gambleColorMultiplier = Number(gambleSettings.GetGamblingSettings(GamblingType.CardColor));
        if (gambleSettings.GetGamblingSettings(GamblingType.Suit) != null)
            this.gambleSuitMultiplier = Number(gambleSettings.GetGamblingSettings(GamblingType.Suit));
        var b1 = gambleSettings.IsOccasionEnable(GamblingOccasions.Spin);
        var b2 = gambleSettings.IsOccasionEnable(GamblingOccasions.FreeSpin);
        var b3 = gambleSettings.IsOccasionEnable(GamblingOccasions.Bonus);
        this.xtLayer.SetGambleSettings(b1, b2, b3, this.gambleColorMultiplier, this.gambleSuitMultiplier)
    }
    this.InitReels();
    this.InitReelSets();
    if (this.lastResponse.VsInitData != null && this.lastResponse.VsInitData.NextReelSymbols != null || this.lastResponse.ReelSetIndex >= 0)
        this.InitNextReels();
    this.xtLayer.SetStackedSymbolIndex(this.lastResponse.StackedSymbolIndex);
    this.xtLayer.SetReturnToPlayer(this.lastResponse.ReturnToPlayer);
    this.xtLayer.SetReturnToPlayerMin(this.lastResponse.ReturnToPlayerMin)
}
;
VideoSlotsConnection.prototype.HandlerSpinResult = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerSpinResult");
    this.serverRequestSent = false;
    this.lastResponse = arg;
    if (this.lastResponse != null)
        switch (this.handlerStage) {
        case VSCHandlerStage.Stage_0:
            if (this.lastResponse.VsInitData != null && this.lastResponse.VsInitData.ReelSymbols != null)
                this.InitReels();
            if (this.lastResponse.ReelSetIndexCurrent >= 0) {
                this.xtLayer.UpdateReelSetIndexes(this.lastResponse.ReelSetIndexCurrent);
                this.xtLayer.InitReelSymbols(XT.GetObject(Vars.ReelSets)[this.lastResponse.ReelSetIndexCurrent])
            }
            if (this.lastResponse.VsInitData != null && this.lastResponse.VsInitData.NextReelSymbols != null || this.lastResponse.ReelSetIndex >= 0)
                this.InitNextReels();
            this.canGamble = this.lastResponse.VsGamblingButtonState.GamblingOnSpinAvailable;
            this.xtLayer.SetStackedSymbolIndex(this.lastResponse.StackedSymbolIndex);
            this.xtLayer.SetCanGambleSpinWin(this.canGamble);
            this.xtLayer.SetWRLMResponse(this.lastResponse.WRLMResponse);
            this.xtLayer.SetWinLines(this.lastResponse.VsWinLines);
            if (this.lastResponse.ReelPositions == null) {
                this.lastResponse.ReelPositions = [];
                for (var i = 0; i < this.lastResponse.WinScreenSymbols.length; i++)
                    this.lastResponse.ReelPositions.push(0)
            }
            this.xtLayer.SetReelStopPositions(this.lastResponse.ReelPositions);
            this.xtLayer.SetExpandingSymbolsData(this.lastResponse.ExpandingSymbolsData);
            this.xtLayer.SetRandomWildsData(this.lastResponse.RandomWildsData, this.lastResponse.UpSymbols);
            this.xtLayer.SetWRLMCurrentSets(this.lastResponse.WRLMCurrentSets);
            this.xtLayer.SetRandomAwardResponse(this.lastResponse.RandomAwardResponse);
            this.xtLayer.SetRandomSymbolMultipliers(this.lastResponse.RandomSymbolMultipliers);
            this.xtLayer.SetPossibleRandomSymbolMultipliers(this.lastResponse.PossibleRandomSymbolMultipliers);
            this.xtLayer.SetFreeSpinsChainData(this.lastResponse.FreeSpinsChainData);
            this.xtLayer.SetOpeningSymbolsData(this.lastResponse.OpeningSymbolsData);
            this.xtLayer.SetSpinOneReelValues(this.lastResponse.SpinOneReelData);
            this.xtLayer.SetTumblingData(this.lastResponse.TumblingData);
            this.xtLayer.SetRandomMysterySymbolId(this.lastResponse.RandomMysterySymbolId);
            this.xtLayer.SetPatternedMysterySymbols(this.lastResponse.PatternedMysterySymbols);
            if (this.lastResponse.SymbolsBeforeExpanding != null && this.lastResponse.SymbolsBeforeExpanding.length > 0)
                this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.SymbolsBeforeExpanding);
            else
                this.xtLayer.SetInitialResultScreenSymbols(this.lastResponse.WinScreenSymbols);
            this.xtLayer.SetGoldSymbol(this.lastResponse.GoldSymbol);
            this.xtLayer.SetSymbolReplacementData(this.lastResponse.SymbolReplacementData);
            this.xtLayer.SetResultScreenSymbols(this.lastResponse.WinScreenSymbols);
            this.xtLayer.SetSymbolsAbove(this.lastResponse.SymbolsAbove);
            this.xtLayer.SetSymbolsBelow(this.lastResponse.SymbolsBelow);
            this.xtLayer.SetNextReelsSymbolsList(this.lastResponse.NextReelsSymbolsList);
            this.stagedHandler = VSCStagedHandler.Spin;
            this.handlerStage = VSCHandlerStage.Stage_1;
            break;
        case VSCHandlerStage.Stage_1:
            this.xtLayer.SetRespinData(this.lastResponse.Respin);
            this.xtLayer.SetProgressiveFeatureData(this.lastResponse.ProgressiveData);
            this.xtLayer.SetMoneySymbolData(this.lastResponse.MoneySymbolData);
            this.xtLayer.SetStickySymbolsData(this.lastResponse.StickySymbols);
            this.xtLayer.SetMergingSymbolsData(this.lastResponse.MergingSymbols);
            this.xtLayer.SetJackpotState(this.lastResponse.VsJackpotData);
            if (this.WonTheJackpot()) {
                var jpData = this.lastResponse.VsJackpotData;
                this.xtLayer.SetJackpotWon(jpData.JackpotID, jpData.JackpotOrder, jpData.WinJackpotAmount)
            }
            this.xtLayer.SetJackpotVisualization(this.lastResponse.JackpotVisualisation);
            this.xtLayer.SetBalance(this.lastResponse.Balance, true);
            this.xtLayer.SetBonusBalance(this.lastResponse.BonusBalance);
            this.xtLayer.SetWinValue(this.lastResponse.Win);
            this.xtLayer.SetSpinCycleWinValue(this.lastResponse.SpinCycleWin);
            this.xtLayer.SetExtraAwardWin(this.lastResponse.ExtraAwardWin);
            this.xtLayer.SetRespinCycleWin(this.lastResponse.RespinCycleWin);
            var linesWin = 0;
            for (var vswl in this.lastResponse.VsWinLines)
                linesWin += this.lastResponse.VsWinLines[vswl].WinAmount;
            this.xtLayer.SetLinesWinValue(linesWin);
            if (this.HasFreeSpinOptions())
                this.xtLayer.MustOpenFSOptions(this.lastResponse.FreeSpinsOptions);
            this.xtLayer.SetFreeSpinResponseReceived(this.lastResponse.GetVsFreeSpin());
            this.xtLayer.SetFSPurchaseData(this.lastResponse.FreeSpinsPurchaseData);
            if (XT.GetBool(Vars.TruncateFSResponseDuringRespin))
                this.xtLayer.SetTruncatedFSResponseReceived(this.lastResponse.TruncatedVsFreeSpin);
            if ((this.lastResponse.GetVsFreeSpin() != null && this.lastResponse.GetVsFreeSpin().IsLastFreeSpin() || this.lastResponse.GetVsFreeSpin() == null) && XT.GetBool(Vars.OpenFSBGForMysteryScatter))
                this.xtLayer.SetStartFSBG(false);
            if (this.IsFreeSpin() && this.IsNeedMysteryScatter()) {
                this.fsgbResponse = this.lastResponse.Clone();
                this.xtLayer.SetStartFSBG(true)
            } else if (this.IsFreeSpinsBonusGame()) {
                this.fsgbResponse = this.lastResponse.Clone();
                this.xtLayer.SetStartFSBG(false)
            }
            this.xtLayer.SetWildRandomMultipliers(this.lastResponse.WildRandomMultipliers);
            this.xtLayer.SetMustOpenBonus(this.lastResponse.IsBonus(), false);
            this.xtLayer.UpdateBonusRoundsInfo(this.lastResponse);
            this.xtLayer.SetGambleV2Response(this.lastResponse.gambleV2Data);
            this.xtLayer.SetNudgedSymbolsData(this.lastResponse.NudgedSymbolsData);
            this.handlerStage = VSCHandlerStage.Stage_2;
            break;
        case VSCHandlerStage.Stage_2:
            this.xtLayer.SpinResultReceived();
            this.stagedHandler = VSCStagedHandler.None;
            this.handlerStage = VSCHandlerStage.Stage_0;
            break
        }
}
;
VideoSlotsConnection.prototype.HandlerNoMoneySpinResult = function(param) {
    var response = new VsResponse;
    response.ReelPositions = this.lastResponse.ReelPositions;
    response.SymbolsAbove = this.lastResponse.SymbolsAbove;
    response.SymbolsBelow = this.lastResponse.SymbolsBelow;
    response.RandomAwardResponse = this.lastResponse.RandomAwardResponse;
    response.ProgressiveData = this.lastResponse.ProgressiveData;
    response.WinScreenSymbols = XT.GetObject(Vars.InitialScreen);
    if (response.WinScreenSymbols == null)
        response.WinScreenSymbols = XT.GetObject(Vars.FirstScreenSymbols);
    var rar = XT.GetObject(Vars.InitialRandomAward);
    if (rar != null) {
        response.RandomAwardResponse.awardIndex = rar.awardIndex;
        response.RandomAwardResponse.awardPositionInReel = rar.awardPositionInReel
    }
    XT.SetBool(Vars.IsNoMoneySpin, true);
    var dict = param;
    if (dict != null) {
        var balanceData = GameProtocolCommonParser.ParseBalance(dict);
        if (balanceData != null) {
            response.Balance = balanceData.Balance;
            response.BonusBalance = balanceData.BonusBalance
        }
    }
    this.HandlerSpinResult(response);
    this.HandlerSpinResult(response);
    this.HandlerSpinResult(response);
    XT.SetBool(Vars.IsNoMoneySpin, false);
    window["globalMustStopAutoplay"] = true
}
;
VideoSlotsConnection.prototype.HandlerMysteryScatter = function(arg) {
    console.log("VideoSlotsConnection - HandlerMysteryScatter");
    this.fsbgLastResponse = arg;
    if (this.fsbgLastResponse != null) {
        this.fsbgLastResponse.VsFreeSpin.BonusGame = new VsFreeSpinBonusGame;
        this.fsbgLastResponse.VsFreeSpin.BonusGame.SpinsWin = this.fsbgLastResponse.VsFreeSpin.GetMaxNumber();
        this.fsbgLastResponse.VsFreeSpin.BonusGame.MultipliersWin = this.fsbgLastResponse.VsFreeSpin.GetTotalMultipl();
        this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems = [];
        this.fsbgLastResponse.VsFreeSpin.BonusGame.BonusItems.push(new VsFreeSpinBonusGame.BonusItem(this.fsbgLastResponse.VsFreeSpin.GetMysteryScatter() || -1,VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Available,VsFreeSpinBonusGame.BonusItem.BonusItemType.Spin));
        if (this.fsgbResponse == null)
            this.fsgbResponse = this.fsbgLastResponse.Clone();
        this.fsgbResponse.VsFreeSpin.SetMysteryScatter(this.fsbgLastResponse.VsFreeSpin.GetMysteryScatter());
        this.fsgbResponse.VsFreeSpin.SetNeedGetMysteryScatter(false);
        this.xtLayer.SetMysteryScatterSymbolId(this.fsbgLastResponse.VsFreeSpin.GetMysteryScatter() || -1);
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin)
    }
}
;
VideoSlotsConnection.prototype.SendGetMysteryScatter = function() {
    EventManager.Trigger(GameEvents.evtMysteryScatterRequest + this.xtLayer.gameSymbol, null)
}
;
VideoSlotsConnection.prototype.HandlerGambleResponse = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerGambleResponse");
    this.serverRequestSent = false;
    this.gambleResponse = arg;
    if (this.gambleResponse != null)
        this.xtLayer.SetGambleResponse(this.gambleResponse)
}
;
VideoSlotsConnection.prototype.HandlerGambleStatus = function(arg) {
    console.log("VideoSlotsConnection - HandlerGambleStatus " + arg)
}
;
VideoSlotsConnection.prototype.HandlerResourceLoadingStarted = function(arg) {
    console.log("VideoSlotsConnection - HandlerResourceLoadingStarted")
}
;
VideoSlotsConnection.prototype.HandlerResourceLoadingFinished = function(arg) {
    console.log("VideoSlotsConnection - HandlerResourceLoadingFinished")
}
;
VideoSlotsConnection.prototype.HandlerResourceLoadingError = function(arg) {
    console.error("VideoSlotsConnection - HandlerResourceLoadingError");
    throw new Error("There was an error during resources loading!");
}
;
VideoSlotsConnection.prototype.HandlerFSBGInit = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerFSBGInit");
    this.fsbgLastResponse = arg;
    if (this.fsbgLastResponse != null) {
        this.fsgbResponse.VsFreeSpin.BonusGame = this.fsbgLastResponse.VsFreeSpin.Clone().BonusGame;
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin);
        this.xtLayer.SendFSBGInitDone()
    }
}
;
VideoSlotsConnection.prototype.HandlerFSBGResponse = function(arg) {
    console.log("VideoSlotsConnection - this.HandlerFSBGResponse");
    this.fsbgLastResponse = arg;
    if (this.fsbgLastResponse != null) {
        var bonus_game = this.fsbgLastResponse.VsFreeSpin.Clone().BonusGame;
        this.fsgbResponse.VsFreeSpin.BonusGame = bonus_game;
        if (bonus_game.GameOver) {
            this.fsgbResponse.VsFreeSpin.SetTotalMultipl(bonus_game.MultipliersWin);
            this.fsgbResponse.VsFreeSpin.SetMaxNumber(bonus_game.SpinsWin);
            this.fsgbResponse.VsFreeSpin.SetCurrentNumber(1)
        }
        this.xtLayer.SetFreeSpinResponseReceived(this.fsgbResponse.VsFreeSpin);
        this.xtLayer.SendFSBGResponseReceived()
    }
}
;
VideoSlotsConnection.prototype.HandlerFreeRoundUpdate = function(param) {
    var vsResponse = param;
    if (vsResponse != null)
        this.xtLayer.UpdateBonusRoundsInfo(vsResponse)
}
;
VideoSlotsConnection.prototype.HandlerFreeSpinOptionsUpdate = function(param) {
    var vsResponse = param;
    if (vsResponse != null)
        this.xtLayer.FreeSpinOptionsResponseReceived(vsResponse)
}
;
VideoSlotsConnection.prototype.UpdateBonusFSResponseValues = function(res) {
    if (res != null)
        this.fsgbResponse = res.Clone()
}
;
VideoSlotsConnection.prototype.SendGambleV2Choice = function(choice) {
    EventManager.Trigger(GameEvents.evtGambleRequest + this.xtLayer.gameSymbol, choice)
}
;
VideoSlotsConnection.prototype.HandlerGambleV2Response = function(arg) {
    console.log("VideoSlotsConnection - HandlerGambleV2Response");
    this.xtLayer.SetGambleV2Response(arg)
}
;
VideoSlotsConnection.prototype.HandlerServerTimeUpdate = function(param) {
    this.xtLayer.SetServerTime(param)
}
;
goog.provide("UHT.BonusPickConnection");
goog.require("UHT.Component");
BonusPickConnection.prototype = Object.create(Component.prototype);
BonusPickConnection.prototype.constructor = BonusPickConnection;
function BonusPickConnection() {
    Component.call(this);
    this.lastResponse = null;
    this.xtLayer = null
}
BonusPickConnection.prototype.Init = function() {}
;
BonusPickConnection.prototype.Coef = function() {
    return this.lastResponse.Coef
}
;
BonusPickConnection.prototype.GameOver = function() {
    return this.lastResponse.GameOver
}
;
BonusPickConnection.prototype.Level = function() {
    if (this.lastResponse.Level != -1) {
        if (this.lastResponse.GameOver)
            return this.lastResponse.Level - 1;
        return Number(this.lastResponse.Level)
    }
    return 0
}
;
BonusPickConnection.prototype.CurrentBonusRespin = function() {
    return this.lastResponse.currentBonusRespin
}
;
BonusPickConnection.prototype.MaxBonusRespins = function() {
    return this.lastResponse.maxBonusRespins
}
;
BonusPickConnection.prototype.RespinSymbols = function() {
    return this.lastResponse.respinSymbols
}
;
BonusPickConnection.prototype.Life = function() {
    var rv = 0;
    if (this.lastResponse.Life != null)
        rv = this.lastResponse.Life;
    return rv
}
;
BonusPickConnection.prototype.RealWin = function() {
    return this.lastResponse.RealWin
}
;
BonusPickConnection.prototype.WinPoints = function() {
    return this.lastResponse.WinPoints
}
;
BonusPickConnection.prototype.PossibleWins = function() {
    return this.lastResponse.IWins
}
;
BonusPickConnection.prototype.ItemsMarkers = function() {
    if (this.lastResponse.BonusTable.Markers != null)
        return this.lastResponse.BonusTable.Markers;
    return null
}
;
BonusPickConnection.prototype.ItemStatus = function(index) {
    return this.lastResponse.BonusTable.Status[index]
}
;
BonusPickConnection.prototype.ItemsStatus = function() {
    if (this.lastResponse.BonusTable.Status != null)
        return this.lastResponse.BonusTable.Status;
    return null
}
;
BonusPickConnection.prototype.ItemWin = function(index) {
    return this.lastResponse.BonusTable.Wins[index]
}
;
BonusPickConnection.prototype.ItemsWins = function() {
    if (this.lastResponse.BonusTable.Status != null)
        return this.lastResponse.BonusTable.Wins;
    return null
}
;
BonusPickConnection.prototype.WinsMask = function() {
    return this.lastResponse.BonusTable.WinsMask
}
;
BonusPickConnection.prototype.LifeWins = function() {
    return this.lastResponse.lifeWins
}
;
BonusPickConnection.prototype.MultipliersMarkers = function() {
    return this.lastResponse.MultipliersTable.Markers
}
;
BonusPickConnection.prototype.MultiplierStatus = function(index) {
    return this.lastResponse.MultipliersTable.Status[index]
}
;
BonusPickConnection.prototype.MultipliersStatus = function() {
    return this.lastResponse.MultipliersTable.Status
}
;
BonusPickConnection.prototype.MultiplierWin = function(index) {
    return this.lastResponse.MultipliersTable.Wins[index]
}
;
BonusPickConnection.prototype.MultipliersWins = function() {
    return this.lastResponse.MultipliersTable.Wins
}
;
BonusPickConnection.prototype.MultiplierStep = function() {
    return this.lastResponse.MultiplierStep
}
;
BonusPickConnection.prototype.MultipliedSymbolPositions = function() {
    return this.lastResponse.MultipliedSymbolPositions
}
;
BonusPickConnection.prototype.SendItemPick = function(itemId) {
    if (this.lastResponse.GameOver)
        console.error("You can't pick when the game is over!");
    else {
        var option = new VsBonusGamePlayerChoice(itemId);
        EventManager.Trigger(GameEvents.evtBonusPickRequest + this.xtLayer.gameSymbol, option)
    }
}
;
BonusPickConnection.prototype.SendCustomItemPick = function(itemId, pickType) {
    if (this.lastResponse.GameOver)
        console.error("You can't pick when the game is over!");
    else {
        var option = new VsBonusGamePlayerChoice(itemId);
        option.PickType = pickType;
        EventManager.Trigger(GameEvents.evtBonusPickRequest + this.xtLayer.gameSymbol, option)
    }
}
;
BonusPickConnection.prototype.SendBonusRespin = function() {
    if (this.lastResponse.GameOver || this.lastResponse.currentBonusRespin == this.lastResponse.maxBonusRespins)
        console.error("You can't request more bonus respins.");
    else
        EventManager.Trigger(GameEvents.evtBonusRespinRequest + this.xtLayer.gameSymbol, null)
}
;
BonusPickConnection.prototype.OnBonusGameFinished = function() {
    if (this.GameOver() || this.lastResponse.currentBonusRespin == this.lastResponse.maxBonusRespins && this.lastResponse.currentBonusRespin != 0 && this.lastResponse.maxBonusRespins != 0)
        EventManager.Trigger(GameEvents.evtBonusFinishRequest + this.xtLayer.gameSymbol, null);
    else
        console.error("You just broke bonus game, gratz!")
}
;
BonusPickConnection.prototype.SetupHandlers = function() {
    console.log("BonusPickConnection - Setup handlers");
    EventManager.AddHandler(GameEvents.evtBonusInitResponse + this.xtLayer.gameSymbol, this.HandlerBonusGameInit, this);
    EventManager.AddHandler(GameEvents.evtBonusPickResponse + this.xtLayer.gameSymbol, this.HandlerPlayerSelection, this);
    EventManager.AddHandler(GameEvents.evtBonusRespinResponse + this.xtLayer.gameSymbol, this.HandlerBonusRespin, this)
}
;
BonusPickConnection.prototype.OnDestroy = function() {}
;
BonusPickConnection.prototype.HandlerBonusGameInit = function(arg) {
    console.log("BonusPickConnection - this.HandlerBonusGameInit");
    this.lastResponse = arg.GetVsBonusGameData();
    if (this.lastResponse != null) {
        this.xtLayer.SetSpinCycleWinValue(arg.SpinCycleWin);
        this.xtLayer.SendBonusInitDone()
    }
}
;
BonusPickConnection.prototype.HandlerPlayerSelection = function(arg) {
    console.log("BonusPickConnection - this.HandlerPlayerSelection");
    this.xtLayer.SetProgressiveFeatureData(arg.ProgressiveData);
    if (XT.GetBool(Vars.UpdateFSResponseOnBonusPick))
        this.xtLayer.SetFreeSpinResponseReceived(arg.GetVsFreeSpin());
    this.lastResponse = arg.GetVsBonusGameData();
    if (this.lastResponse != null) {
        if (arg.IsBonusGameOver() && arg.NextGameActions.indexOf(NextGameAction.Bonus) > -1)
            this.xtLayer.SetMustOpenBonus(true, false);
        this.xtLayer.SetOpeningSymbolsData(arg.OpeningSymbolsData);
        this.xtLayer.SetSpinCycleWinValue(arg.SpinCycleWin);
        this.xtLayer.SendBonusResponse();
        this.xtLayer.UpdateBonusFSResponseValues(arg);
        var reelSets = XT.GetObject(Vars.ReelSets);
        if (reelSets != null && arg.ReelSetIndex >= 0)
            this.xtLayer.InitNextReelSymbols(reelSets[arg.ReelSetIndex]);
        this.xtLayer.SetGambleV2Response(arg.gambleV2Data)
    }
}
;
BonusPickConnection.prototype.HandlerBonusRespin = function(arg) {
    console.log("BonusPickConnection - this.HandlerBonusRespin");
    this.lastResponse = arg.GetVsBonusGameData();
    if (this.lastResponse != null) {
        this.xtLayer.SetSpinCycleWinValue(arg.SpinCycleWin);
        this.xtLayer.SetResultScreenSymbols(arg.WinScreenSymbols);
        this.xtLayer.SetWinLines(arg.VsWinLines);
        this.xtLayer.SetWinValue(this.lastResponse.RealWin);
        this.xtLayer.SetExtraAwardWin(arg.ExtraAwardWin);
        this.xtLayer.SendBonusResponse();
        this.xtLayer.SetMoneySymbolData(arg.MoneySymbolData);
        if (this.lastResponse.currentBonusRespin == this.lastResponse.maxBonusRespins) {
            var linesWin = 0;
            for (var vswl in arg.VsWinLines)
                linesWin += arg.VsWinLines[vswl].WinAmount;
            this.xtLayer.SetLinesWinValue(linesWin)
        }
    }
}
;
goog.provide("UHT.FreeSpinsResponse");
function FreeSpinsResponse() {
    this._currentSpin = 0;
    this._maxSpins = 0;
    this._oldMaxSpins = 0;
    this._additionalSpins = 0;
    this._totalSpins = 0;
    this._totalMultiplier = 0;
    this._currentWin = 0;
    this._currentWinMultiplied = 0;
    this._totalWin = 0;
    this._totalWinMultiplied = 0;
    this._pickedOptionIndex = -1;
    this._bonusGameData = null;
    this._mysteryScatter = null;
    this._needGetMysteryScatter = false;
    this._isFreeSpin = false;
    this._isFreeSpinsStart = false;
    this._isFreeSpinsGambled = false;
    Object.defineProperty(this, "CurrentSpin", {
        get: function() {
            return this._currentSpin
        }
    });
    Object.defineProperty(this, "MaxSpins", {
        get: function() {
            return this._maxSpins
        }
    });
    Object.defineProperty(this, "OldMaxSpins", {
        get: function() {
            return this._oldMaxSpins
        }
    });
    Object.defineProperty(this, "AdditionalSpins", {
        get: function() {
            return this._additionalSpins
        }
    });
    Object.defineProperty(this, "TotalSpins", {
        get: function() {
            return this._totalSpins
        }
    });
    Object.defineProperty(this, "TotalMultiplier", {
        get: function() {
            return this._totalMultiplier
        }
    });
    Object.defineProperty(this, "CurrentWin", {
        get: function() {
            return this._currentWin
        }
    });
    Object.defineProperty(this, "CurrentWinMultiplied", {
        get: function() {
            return this._currentWinMultiplied
        }
    });
    Object.defineProperty(this, "TotalWin", {
        get: function() {
            return this._totalWin
        }
    });
    Object.defineProperty(this, "TotalWinMultiplied", {
        get: function() {
            return this._totalWinMultiplied
        }
    });
    Object.defineProperty(this, "PickedOptionIndex", {
        get: function() {
            return this._pickedOptionIndex
        }
    });
    Object.defineProperty(this, "IsFreeSpin", {
        get: function() {
            return this._isFreeSpin
        }
    });
    Object.defineProperty(this, "IsFreeSpinsStart", {
        get: function() {
            return this._isFreeSpinsStart || this.IsFreeSpinsCollected && this._bonusGameData != null
        }
    });
    Object.defineProperty(this, "IsLastFreeSpin", {
        get: function() {
            return this.IsFreeSpin && this.TotalSpins > 0
        }
    });
    Object.defineProperty(this, "IsFreeSpinsCollected", {
        get: function() {
            return this.IsFreeSpin && this._currentSpin == 0 && this._maxSpins == 0 && this._totalSpins == 0
        }
    });
    Object.defineProperty(this, "IsFreeSpinsGambled", {
        get: function() {
            return this._isFreeSpinsGambled
        },
        set: function(value) {
            this._isFreeSpinsGambled = value
        }
    });
    Object.defineProperty(this, "IsNeedGetMysteryScatter", {
        get: function() {
            return this._needGetMysteryScatter
        }
    });
    Object.defineProperty(this, "BonusGameData", {
        get: function() {
            return this._bonusGameData
        },
        set: function(value) {
            this._bonusGameData = value
        }
    });
    Object.defineProperty(this, "MysteryScatter", {
        get: function() {
            return this._mysteryScatter
        }
    });
    this.FreeSpinsType = -1
}
FreeSpinsResponse.prototype.CurrentSpin = 0;
FreeSpinsResponse.prototype.MaxSpins = 0;
FreeSpinsResponse.prototype.OldMaxSpins = 0;
FreeSpinsResponse.prototype.AdditionalSpins = 0;
FreeSpinsResponse.prototype.TotalSpins = 0;
FreeSpinsResponse.prototype.TotalMultiplier = 0;
FreeSpinsResponse.prototype.CurrentWin = 0;
FreeSpinsResponse.prototype.CurrentWinMultiplied = 0;
FreeSpinsResponse.prototype.TotalWin = 0;
FreeSpinsResponse.prototype.TotalWinMultiplied = 0;
FreeSpinsResponse.prototype.PickedOptionIndex = 0;
FreeSpinsResponse.prototype.IsFreeSpin = false;
FreeSpinsResponse.prototype.IsFreeSpinsStart = false;
FreeSpinsResponse.prototype.IsLastFreeSpin = false;
FreeSpinsResponse.prototype.IsFreeSpinsCollected = false;
FreeSpinsResponse.prototype.IsFreeSpinsGambled = false;
FreeSpinsResponse.prototype.IsNeedGetMysteryScatter = false;
FreeSpinsResponse.prototype.BonusGameData = null;
FreeSpinsResponse.prototype.MysteryScatter = null;
FreeSpinsResponse.prototype.SetFreeSpinsResponse = function(_fsResponse) {
    if (_fsResponse == null) {
        this._isFreeSpin = false;
        this._isFreeSpinsStart = false;
        this._isFreeSpinsGambled = false;
        return
    }
    if (_fsResponse.BonusGame != null) {
        var cloned_bonus_game = _fsResponse.BonusGame.Clone();
        this._bonusGameData = new FreeSpinsResponse.BonusGame;
        this._bonusGameData.GameOver = cloned_bonus_game.GameOver;
        this._bonusGameData.Level = cloned_bonus_game.Level;
        this._bonusGameData.Lifes = cloned_bonus_game.Lifes;
        this._bonusGameData.MultipliersWin = cloned_bonus_game.MultipliersWin;
        this._bonusGameData.SpinsWin = cloned_bonus_game.SpinsWin;
        this._bonusGameData.SetBonusItems(cloned_bonus_game.BonusItems)
    } else
        this._bonusGameData = null;
    this._currentSpin = _fsResponse.GetCurrentNumber();
    this._oldMaxSpins = this._maxSpins;
    this._maxSpins = _fsResponse.GetMaxNumber();
    this._totalSpins = _fsResponse.GetTotalNumber();
    this._totalMultiplier = _fsResponse.GetTotalMultipl();
    this._currentWin = _fsResponse.GetCurrentWin();
    this._currentWinMultiplied = _fsResponse.GetCurrentWinMultiplied();
    this._totalWin = _fsResponse.GetTotalWin();
    this._totalWinMultiplied = _fsResponse.GetTotalWinMultiplied();
    this._pickedOptionIndex = _fsResponse.PickedOptionIndex;
    this._mysteryScatter = _fsResponse.GetMysteryScatter();
    this._needGetMysteryScatter = _fsResponse.IsNeedGetMysteryScatter();
    this._isFreeSpinsStart = this._currentSpin == 1;
    this._isFreeSpin = true;
    this.FreeSpinsType = _fsResponse.fstype;
    if (this._isFreeSpinsStart) {
        this._oldMaxSpins = 0;
        this._additionalSpins = 0
    } else {
        if (this._oldMaxSpins == 0)
            this._oldMaxSpins = this._maxSpins;
        this._additionalSpins = this._maxSpins - this._oldMaxSpins
    }
}
;
FreeSpinsResponse.BonusGame = function() {
    this._gameOver = false;
    this._level = 0;
    this._lifes = null;
    this._spinsWin = 0;
    this._multipliersWin = 0;
    this._bonusItems = [];
    Object.defineProperty(this, "GameOver", {
        get: function() {
            return this._gameOver
        },
        set: function(value) {
            this._gameOver = value
        }
    });
    Object.defineProperty(this, "Level", {
        get: function() {
            return this._level
        },
        set: function(value) {
            this._level = value
        }
    });
    Object.defineProperty(this, "Lifes", {
        get: function() {
            return this._lifes
        },
        set: function(value) {
            this._lifes = value
        }
    });
    Object.defineProperty(this, "SpinsWin", {
        get: function() {
            return this._spinsWin
        },
        set: function(value) {
            this._spinsWin = value
        }
    });
    Object.defineProperty(this, "MultipliersWin", {
        get: function() {
            return this._multipliersWin
        },
        set: function(value) {
            this._multipliersWin = value
        }
    });
    Object.defineProperty(this, "BonusItems", {
        get: function() {
            return this._bonusItems
        },
        set: function(value) {
            this._bonusItems = value
        }
    })
}
;
FreeSpinsResponse.BonusGame.prototype.GameOver = false;
FreeSpinsResponse.BonusGame.prototype.Level = 0;
FreeSpinsResponse.BonusGame.prototype.Lifes = null;
FreeSpinsResponse.BonusGame.prototype.SpinsWin = 0;
FreeSpinsResponse.BonusGame.prototype.MultipliersWin = 0;
FreeSpinsResponse.BonusGame.prototype.BonusItems = null;
FreeSpinsResponse.BonusGame.prototype.SetBonusItems = function(ngcBonusItems) {
    this._bonusItems = [];
    for (var i = 0; i < ngcBonusItems.length; ++i) {
        var ngc_bi = ngcBonusItems[i];
        var new_bi = new FreeSpinsResponse.BonusItem(ngc_bi.Value,FreeSpinsResponse.BonusItem.ParseNgcBonusItemStatus(ngc_bi.Status),FreeSpinsResponse.BonusItem.ParseNgcBonusItemType(ngc_bi.Type));
        this._bonusItems.push(new_bi)
    }
}
;
FreeSpinsResponse.BonusItem = function(value, status, type) {
    this._value = value;
    this._status = status;
    this._type = type;
    Object.defineProperty(this, "Status", {
        get: function() {
            return this._status
        },
        set: function(value) {
            this._status = value
        }
    });
    Object.defineProperty(this, "Type", {
        get: function() {
            return this._type
        },
        set: function(value) {
            this._type = value
        }
    });
    Object.defineProperty(this, "Value", {
        get: function() {
            return this._value
        },
        set: function(value) {
            this._value = value
        }
    })
}
;
FreeSpinsResponse.BonusItem.BonusItemStatus = {
    Available: 0,
    Selected: 1
};
FreeSpinsResponse.BonusItem.BonusItemType = {
    Spin: 0,
    Multiplier: 1
};
FreeSpinsResponse.BonusItem.ParseNgcBonusItemStatus = function(status) {
    switch (status) {
    case VsFreeSpinBonusGame.BonusItem.BonusItemStatus.Selected:
        return FreeSpinsResponse.BonusItem.BonusItemStatus.Selected;
    default:
        return FreeSpinsResponse.BonusItem.BonusItemStatus.Available
    }
}
;
FreeSpinsResponse.BonusItem.ParseNgcBonusItemType = function(type) {
    switch (type) {
    case VsFreeSpinBonusGame.BonusItem.BonusItemType.Multiplier:
        return FreeSpinsResponse.BonusItem.BonusItemType.Multiplier;
    default:
        return FreeSpinsResponse.BonusItem.BonusItemType.Spin
    }
}
;
FreeSpinsResponse.BonusItem.prototype.Status = FreeSpinsResponse.BonusItem.BonusItemStatus.Available;
FreeSpinsResponse.BonusItem.prototype.Type = FreeSpinsResponse.BonusItem.BonusItemType.Spin;
FreeSpinsResponse.BonusItem.prototype.Value = 0;
FreeSpinsResponse.BonusItem.prototype.ToString = function() {
    return "BonusItem {" + "Status=" + this._status + ", Type=" + this._type + ", Value=" + this._value + "}"
}
;
function BonusData() {
    this.Coef = 0;
    this.GameOver = false;
    this.Level = 0;
    this.Life = 0;
    this.RealWin = 0;
    this.WinPoints = 0;
    this.PossibleWins = null;
    this.ItemsMarkers = null;
    this.ItemsStatus = null;
    this.ItemsWins = null;
    this.WinsMask = null;
    this.MultipliersMarkers = null;
    this.MultipliersStatus = null;
    this.MultipliersWins = null;
    this.LifeWins = null;
    this.MultiplierStep = false;
    this.numberOfLevels = 0;
    this.isBonusGambled = false;
    this.currentBonusRespin = 0;
    this.maxBonusRespins = 0;
    this.respinSymbols = null;
    this.PremultipliedWin = 0;
    this.MultipliedSymbolPositions = null;
    this.RespinsTotalMultiplier = -1;
    this.ExtraRespinsWon = -1;
    this.BGItemValues = null;
    this.BGItemMasks = null;
    this.GameID = 0;
    this.WheelOfFortune = null;
    this.Map = null
}
BonusData.prototype.HasMultipliers = function() {
    return this.MultipliersStatus != null
}
;
BonusData.prototype.HasMultipleLevels = function() {
    return this.ItemsMarkers != null
}
;
BonusData.prototype.ConstrainedLevel = function() {
    return Math.min(this.numberOfLevels, this.GameOver ? this.Level + 1 : this.Level)
}
;
BonusData.prototype.GetCurrentLevelIndex = function() {
    var rv = this.Level;
    if (rv >= this.numberOfLevels)
        rv = this.numberOfLevels - 1;
    return rv
}
;
goog.require("UHT.XTLink");
goog.require("UHT.ServerOptions");
goog.require("UHT.ResourceHelpers");
goog.require("UHT.VideoSlotsConnection");
goog.require("UHT.BonusPickConnection");
goog.require("UHT.FreeSpinsResponse");
goog.require("UHT.Paytable");
VideoSlotsConnectionXTLayer.prototype = Object.create(XTLink.prototype);
VideoSlotsConnectionXTLayer.prototype.constructor = VideoSlotsConnectionXTLayer;
function VideoSlotsConnectionXTLayer() {
    XTLink.call(this);
    this.vsc = null;
    this.bonusConnection = null;
    this.gameSymbol = null;
    this.fsr = null;
    this.bonusData = null;
    this.needToSendSettingsToServer = false;
    this.isInCoolDown = false;
    this.timeInCooldown = 0;
    this.internalGlobalSoundIsOn = false;
    this.handlerGameInitReceived = false;
    this.settingsReceived = false;
    this.resourcesLoaded = false;
    this.mustTriggerDelayedGameLoadingFinished = false;
    this.delayedGameLoadingFinishedFrameCount = 0
}
VideoSlotsConnectionXTLayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_OnShowResult, this.OnShowResult, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_OnFreeSpinsClosed, this.OnFreeSpinClosed, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestInit, this.OnRequestInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestSpin, this.OnRequestSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_GamblePicked, this.OnGambleV2Pick, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestGambleOpen, this.OnRequestGambleOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_RequestGambleClose, this.OnRequestGambleClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_BonusPickItem, this.OnBonusPick, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_BonusGameFinished, this.OnBonusGameFinished, this);
    XT.RegisterCallbackEvent(BGVars.Evt_ToServer_BonusPickedItem, this.OnBonusPick, this);
    XT.RegisterCallbackEvent(BGVars.Evt_ToServer_BonusPickedCustomItem, this.OnBonusCustomPick, this);
    XT.RegisterCallbackEvent(BGVars.Evt_ToServer_SendBonusRespin, this.OnSendBonusRespin, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_UpdateSettingsOnServer, this.OnUpdateSettingsOnServer, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_OpenCashier, this.OnRequestToOpenCashier, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_CloseGame, this.OnRequestToCloseGame, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_ReloadGame, this.OnRequestToReloadGame, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_ItemPickedFSBGPick, this.OnItemPickedFSBGPick, this);
    XT.RegisterCallbackBool(Vars.BatterySaver, this.OnBatterySaverStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_ToServer_SendGetMysteryScatter, this.SendGetMysteryScatter, this)
}
;
VideoSlotsConnectionXTLayer.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.ReceivedWinLines, null);
    XT.SetObject(Vars.PaytablePayoutData, null);
    XT.SetBool(Vars.FastPlay, false);
    XT.SetObject(Vars.SoundState, new SoundState);
    XT.SetBool(Vars.ShouldDisplayIntro, true);
    XT.SetInt(Vars.MobileTapToStopMessageShowCount, 0);
    XT.SetInt(Vars.DesktopTurboSpinMessageShowCount, 0);
    XT.SetBool(Vars.FromServer_IsJackpotWin, false);
    XT.SetObject(Vars.BonusData, null);
    XT.SetInt(Vars.Lines, 0);
    XT.SetObject(Vars.ExpandingSymbolsData, null);
    XT.SetObject(Vars.FromServer_JackpotsInformation, null);
    XT.SetObject(Vars.ReelStopPositions, null);
    XT.SetBool(Vars.IgnoreServerBalanceRequest, false);
    XT.SetBool(Vars.CanAnimateValues, false);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, false);
    XT.SetDouble(Vars.SpinCycleWinReceived, 0);
    XT.SetDouble(Vars.WinReceived, 0);
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, null);
    XT.SetObject(Vars.TruncatedFreeSpinsResponse, null);
    XT.SetObject(Vars.MarkedSymbolPositions, []);
    XT.SetObject(Vars.SpinOneReelData, null);
    XT.SetInt(Vars.ReelToBeSpun, -1);
    XT.SetBool(Vars.HasGameHistory, false);
    XT.SetBool(Vars.HasAdvancedAutoplay, false);
    XT.SetBool(Vars.BatterySaver, false);
    XT.SetBool(Vars.HasCoins, false);
    XT.SetDouble(Vars.AlternativeWager, -1);
    XT.SetBool(Vars.Jurisdiction_Clock, false);
    XT.SetBool(Vars.Jurisdiction_DisableAutoplay, false);
    XT.SetBool(Vars.Jurisdiction_GameTitle, false);
    XT.SetBool(Vars.Jurisdiction_SplitBalance, false);
    XT.SetBool(Vars.Jurisdiction_PromotionURL, false);
    XT.SetBool(Vars.Autoplay_SkipScreens, true);
    XT.SetBool(Vars.ShowInGameTutorial, true);
    XT.SetBool(Vars.KeepSpinning, false);
    XT.SetBool(Vars.Jurisdiction_SpinLimit, false);
    XT.SetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit, false);
    XT.SetBool(Vars.Jurisdiction_ResultMinimumTime, false);
    XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, false);
    XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo, false);
    XT.SetBool(Vars.Jurisdiction_FinishCountersBeforeSpin, false);
    XT.SetBool(Vars.Jurisdiction_LineByLineFreespin, false);
    XT.SetBool(Vars.Jurisdiction_LineByLineGlobal, false);
    XT.SetBool(Vars.Jurisdiction_ClientRevision, false);
    XT.SetBool(Vars.Jurisdiction_GameSymbol, false);
    XT.SetFloat(Vars.Jurisdiction_SpinLimit_Value, 3);
    XT.SetFloat(Vars.Jurisdiction_ResultMinimumTime_Value, 3);
    XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value, 3);
    XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeTurbo_Value, 3);
    XT.SetObject(Vars.CustomGameStoredData, {});
    XT.SetInt(Vars.ReelSetIndexPrevious, -1);
    XT.SetInt(Vars.ReelSetIndexCurrent, -1);
    XT.SetBool(Vars.BonusTriggersFSBG, false);
    XT.SetBool(Vars.BonusTriggeredFSBGIsMystery, false);
    XT.SetBool(Vars.OpenFSBGForMysteryScatter, false);
    XT.SetFloat(Vars.SoundVolume, 1);
    XT.SetBool(Vars.IsNoMoneySpin, false);
    XT.SetObject(Vars.InitialScreen, null);
    XT.SetObject(Vars.InitialRandomAward, null);
    XT.SetDouble(Vars.BalanceReceived, 0);
    XT.SetDouble(Vars.BonusBalanceReceived, 0);
    XT.SetBool(Vars.InstantAutoplay, false)
}
;
VideoSlotsConnectionXTLayer.prototype.AddServerCallbacks = function() {
    EventManager.AddHandler(GameEvents.evtSoundState + this.gameSymbol, this.OnSoundState, this);
    EventManager.AddHandler(GameEvents.evtGameStatus + this.gameSymbol, this.OnGameStatus, this);
    EventManager.AddHandler(BalanceEvents.evtBalanceUpdated, this.OnServerBalanceUpdated, this);
    EventManager.AddHandler(GameEvents.evtSettingsUpdated + this.gameSymbol, this.OnSettingsUpdated, this);
    EventManager.AddHandler(GameEvents.evtSettingsNotSaved, this.OnSettingsNotSaved, this);
    EventManager.AddHandler(ResourceEvents.evtResourcesCompleted + this.gameSymbol, this.OnResourcesCompleted, this)
}
;
VideoSlotsConnectionXTLayer.prototype.OnConnectionReady = function(gameSymbol) {
    console.log("OnConnectionReady", gameSymbol);
    this.gameSymbol = gameSymbol;
    this.vsc = this.gameObject.AddComponent("VideoSlotsConnection");
    this.vsc.xtLayer = this;
    this.bonusConnection = this.gameObject.AddComponent("BonusPickConnection");
    this.bonusConnection.xtLayer = this;
    this.AddServerCallbacks();
    this.vsc.AddServerCallbacks();
    this.bonusConnection.SetupHandlers();
    this.SetInitialSoundState(ServerOptions.isExternal);
    EventManager.Trigger(GameEvents.evtInitRequest + gameSymbol, null);
    EventManager.Trigger(ResourceEvents.evtRequestResources, gameSymbol)
}
;
VideoSlotsConnectionXTLayer.prototype.OnServerBalanceUpdated = function(data) {
    this.SetBalance(data.Balance, false);
    this.SetBonusBalance(data.BonusBalance)
}
;
VideoSlotsConnectionXTLayer.prototype.OnBatterySaverStateChanged = function(val) {
    UHTEngine.SetBatterySaverState(val)
}
;
VideoSlotsConnectionXTLayer.prototype.OnSettingsUpdated = function(settings) {
    this.UpdateSettings(true, settings);
    this.settingsReceived = true;
    if (this.CanTriggerInitReady())
        this.TriggerInitReady()
}
;
VideoSlotsConnectionXTLayer.prototype.OnSettingsNotSaved = function(param) {}
;
VideoSlotsConnectionXTLayer.prototype.OnUpdateSettingsOnServer = function() {
    this.timeInCooldown = 0;
    this.needToSendSettingsToServer = true;
    if (XT.GetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer)) {
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, false);
        this.isInCoolDown = false
    }
}
;
VideoSlotsConnectionXTLayer.prototype.OnResourcesCompleted = function(pack) {
    LoaderProgress.Localize_Current = 1;
    for (var i = 0; i < pack.assetBundles.length; ++i) {
        var go = UHTEngine.LoadAssetBundle(pack.assetBundles[i].mainAsset, ServerOptions.gameUrl + "packages/");
        var mm = go.GetComponent(ModificationsManager);
        var cp = go.GetComponent(CurrencyPatch);
        if (mm != null)
            mm.Init();
        if (cp != null) {
            cp.currencyName = ServerOptions.currency;
            cp.languageName = ServerOptions.language;
            cp.localeName = UHT_GAME_CONFIG_SRC["locale"] != undefined ? UHT_GAME_CONFIG_SRC["locale"] : ServerOptions.language;
            LocaleManager.Init(cp)
        }
    }
    pack.assetBundles = [];
    if (XT.GetObject(Vars.PaytablePayoutData) != null)
        XT.TriggerEvent(Vars.Evt_Internal_PaytablePayoutUpdate);
    this.resourcesLoaded = true;
    if (this.CanTriggerInitReady())
        this.TriggerInitReady()
}
;
VideoSlotsConnectionXTLayer.prototype.UpdateSettings = function(settingsReceivedFromServer, settings) {
    console.log("UpdateSettings", settingsReceivedFromServer, settings);
    var mustUpdateSettings = false;
    if (!settingsReceivedFromServer)
        settings.Settings = {};
    var valueStr;
    if (settingsReceivedFromServer && settings.Settings["SoundState"] != undefined) {
        valueStr = settings.Settings["SoundState"];
        var arr = valueStr.split("_");
        var gameSoundIsOn = UHT_DEVICE_TYPE.MOBILE ? false : _bool.Parse(arr[0]);
        this.SetSoundState(gameSoundIsOn, _bool.Parse(arr[1]), _bool.Parse(arr[2]), _bool.Parse(arr[3]), _bool.Parse(arr[4]))
    } else {
        var s = XT.GetObject(Vars.SoundState);
        settings.Settings["SoundState"] = [s.gameSoundIsOn.toString(), s.musicIsOn.toString(), s.soundFXIsOn.toString(), s.oldMusicIsOn.toString(), s.oldSoundFXIsOn.toString()].join("_");
        mustUpdateSettings = true;
        this.SetSoundState(s.gameSoundIsOn, s.musicIsOn, s.soundFXIsOn, s.oldMusicIsOn, s.oldSoundFXIsOn)
    }
    if (settingsReceivedFromServer && settings.Settings["FastPlay"] != undefined) {
        valueStr = settings.Settings["FastPlay"];
        XT.SetBool(Vars.FastPlay, _bool.Parse(valueStr))
    } else {
        var fastPlay = XT.GetBool(Vars.FastPlay);
        settings.Settings["FastPlay"] = String(fastPlay);
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["Intro"] != undefined) {
        valueStr = settings.Settings["Intro"];
        XT.SetBool(Vars.ShouldDisplayIntro, _bool.Parse(valueStr))
    } else {
        var intro = XT.GetBool(Vars.ShouldDisplayIntro);
        settings.Settings["Intro"] = String(intro);
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["StopMsg"] != undefined) {
        valueStr = settings.Settings["StopMsg"];
        XT.SetInt(Vars.MobileTapToStopMessageShowCount, _number.otoi(valueStr))
    } else {
        var count = XT.GetInt(Vars.MobileTapToStopMessageShowCount);
        valueStr = count.toString();
        settings.Settings["StopMsg"] = valueStr;
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["TurboSpinMsg"] != undefined) {
        valueStr = settings.Settings["TurboSpinMsg"];
        XT.SetInt(Vars.DesktopTurboSpinMessageShowCount, _number.otoi(valueStr))
    } else {
        var count = XT.GetInt(Vars.DesktopTurboSpinMessageShowCount);
        valueStr = count.toString();
        settings.Settings["TurboSpinMsg"] = valueStr;
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["BetInfo"] != undefined) {
        valueStr = settings.Settings["BetInfo"];
        var arr2 = valueStr.split("_");
        CoinManager.SetPreviousBetIndices(_number.otoi(arr2[0]), _number.otoi(arr2[1]))
    } else {
        var level = XT.GetInt(Vars.NextBetIndex);
        var index = XT.GetInt(Vars.CoinValueIndex);
        valueStr = (level.toString() + "_" + index.toString()).toString();
        settings.Settings["BetInfo"] = valueStr;
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["Rated"] != undefined) {
        var rated = _bool.Parse(settings.Settings["Rated"]);
        XT.SetBool(Vars.GameIsRated, rated);
        XT.SetBool(Vars.RatingSkipped, !rated)
    } else {
        var rated = XT.GetBool(Vars.GameIsRated);
        var ratingSkipped = XT.GetBool(Vars.RatingSkipped);
        if (rated || ratingSkipped) {
            settings.Settings["Rated"] = String(rated);
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["BrowserWarningShown"] != undefined) {
        var browserWarningShown = _bool.Parse(settings.Settings["BrowserWarningShown"]);
        XT.SetBool(Vars.BrowserWarningShown, browserWarningShown)
    } else {
        var browserWarningShown = XT.GetBool(Vars.BrowserWarningShown);
        if (browserWarningShown) {
            settings.Settings["BrowserWarningShown"] = String(browserWarningShown);
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["BatterySaver"] != undefined)
        XT.SetBool(Vars.BatterySaver, _bool.Parse(settings.Settings["BatterySaver"]));
    else {
        settings.Settings["BatterySaver"] = XT.GetBool(Vars.BatterySaver).toString();
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["ShowIGT"] != undefined)
        XT.SetBool(Vars.ShowInGameTutorial, _bool.Parse(settings.Settings["ShowIGT"]));
    else {
        var show = XT.GetBool(Vars.ShowInGameTutorial);
        if (!show) {
            settings.Settings["ShowIGT"] = String(show);
            mustUpdateSettings = true
        }
    }
    if (settingsReceivedFromServer && settings.Settings["ShowCCH"] != undefined)
        XT.SetBool(InterfaceVars.ShowCoinsAndCashHint, _bool.Parse(settings.Settings["ShowCCH"]));
    else {
        settings.Settings["ShowCCH"] = String(XT.GetBool(InterfaceVars.ShowCoinsAndCashHint));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["ShowFPH"] != undefined)
        XT.SetBool(InterfaceVars.ShowFastPlayHint, _bool.Parse(settings.Settings["ShowFPH"]));
    else {
        settings.Settings["ShowFPH"] = String(XT.GetBool(InterfaceVars.ShowFastPlayHint));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["CustomGameStoredData"] != undefined) {
        var customGameStoredData = settings.BuildDictionaryFromString(settings.Settings["CustomGameStoredData"], "~", ":");
        XT.SetObject(Vars.CustomGameStoredData, customGameStoredData);
        XT.TriggerEvent(Vars.Evt_Internal_CustomGameStoredDataReceived)
    } else {
        var data = XT.GetObject(Vars.CustomGameStoredData);
        settings.Settings["CustomGameStoredData"] = settings.DictionaryToString(data, "~", ":");
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer) {
        var coins = false;
        if (ServerOptions.amountType != "CURRENCY")
            if (settings.Settings["Coins"] != undefined)
                coins = _bool.Parse(settings.Settings["Coins"]);
        XT.SetBool(Vars.HasCoins, coins)
    } else {
        settings.Settings["Coins"] = String(XT.GetBool(Vars.HasCoins));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["Volume"] != undefined)
        XT.SetFloat(Vars.SoundVolume, _number.otod(settings.Settings["Volume"]));
    else {
        settings.Settings["Volume"] = String(XT.GetFloat(Vars.SoundVolume));
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["InitialScreen"] != undefined) {
        var s1 = [];
        var s2 = settings.Settings["InitialScreen"].split("_");
        for (var i = 0; i < s2.length; ++i)
            s1.push(_array.ConvertAll(s2[i].split(","), _number.otoi));
        XT.SetObject(Vars.InitialScreen, s1)
    } else if (this.handlerGameInitReceived) {
        var s1 = XT.GetObject(Vars.InitialScreen);
        if (s1 == null) {
            s1 = XT.GetObject(Vars.FirstScreenSymbols);
            XT.SetObject(Vars.InitialScreen, s1)
        }
        var s2 = [];
        for (var i = 0; i < s1.length; ++i)
            s2.push(s1[i].join(","));
        settings.Settings["InitialScreen"] = s2.join("_");
        mustUpdateSettings = true
    }
    if (settingsReceivedFromServer && settings.Settings["InitialRandomAward"] != undefined) {
        var rar = new RandomAwardsResponse;
        var s2 = settings.Settings["InitialRandomAward"].split("_");
        var tmp = parseInt(s2[0], 10);
        if (isFinite(tmp) && !isNaN(tmp))
            rar.awardIndex = tmp;
        tmp = parseInt(s2[1], 10);
        if (isFinite(tmp) && !isNaN(tmp))
            rar.awardPositionInReel = tmp;
        XT.SetObject(Vars.InitialRandomAward, rar)
    } else if (this.handlerGameInitReceived) {
        var rar = XT.GetObject(Vars.InitialRandomAward);
        if (rar == null) {
            rar = XT.GetObject(Vars.RandomAwardsResponse);
            XT.SetObject(Vars.InitialRandomAward, rar)
        }
        if (rar != null) {
            var s2 = [];
            s2.push(rar.awardIndex.toString());
            s2.push(rar.awardPositionInReel.toString());
            settings.Settings["InitialRandomAward"] = s2.join("_");
            mustUpdateSettings = true
        }
    }
    if (mustUpdateSettings)
        EventManager.Trigger(GameEvents.evtUpdateSettingsRequest + this.gameSymbol, settings)
}
;
VideoSlotsConnectionXTLayer.prototype.OnGameStatus = function(isActive) {}
;
VideoSlotsConnectionXTLayer.prototype.OnSoundState = function(soundState) {
    this.internalGlobalSoundIsOn = soundState.state == CasinoSoundState.SoundOn;
    var s = XT.GetObject(Vars.SoundState);
    s.globalSoundIsOn = this.internalGlobalSoundIsOn;
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged)
}
;
VideoSlotsConnectionXTLayer.prototype.UpdateReelSetIndexes = function(reelSetIndexCurrent) {
    XT.SetInt(Vars.ReelSetIndexPrevious, XT.GetInt(Vars.ReelSetIndexCurrent));
    XT.SetInt(Vars.ReelSetIndexCurrent, reelSetIndexCurrent)
}
;
VideoSlotsConnectionXTLayer.prototype.InitReelSymbols = function(reelSymbols) {
    XT.SetObject(Vars.ReelSymbols, reelSymbols)
}
;
VideoSlotsConnectionXTLayer.prototype.InitNextReelSymbols = function(nextReelSymbols) {
    XT.SetObject(Vars.NextReelSymbols, nextReelSymbols)
}
;
VideoSlotsConnectionXTLayer.prototype.SetReelSets = function(reelSets) {
    XT.SetObject(Vars.ReelSets, reelSets)
}
;
VideoSlotsConnectionXTLayer.prototype.SetStackedSymbolIndex = function(stackedSymbolIndex) {
    XT.SetInt(Vars.StackedSymbolIndex, stackedSymbolIndex)
}
;
VideoSlotsConnectionXTLayer.prototype.InitReelsPositions = function(reelPositions) {
    XT.SetObject(Vars.ReelInitialPositions, reelPositions)
}
;
VideoSlotsConnectionXTLayer.prototype.SetReelStopPositions = function(stopPositions) {
    XT.SetObject(Vars.ReelStopPositions, stopPositions)
}
;
VideoSlotsConnectionXTLayer.prototype.JurisdictionSetup = function() {
    XT.SetBool(Vars.HasGameHistory, ServerOptions.gameHistory != null);
    if (ServerOptions.jurisdiction == "UK") {
        XT.SetBool(Vars.HasAdvancedAutoplay, true);
        XT.SetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit, true);
        XT.SetBool(Vars.Jurisdiction_GameTitle, true);
        XT.SetBool(Vars.Jurisdiction_SplitBalance, true);
        XT.SetBool(Vars.Jurisdiction_PromotionURL, true)
    }
    if (ServerOptions.jurisdiction == "ES") {
        XT.SetBool(Vars.HasAdvancedAutoplay, true);
        XT.SetBool(Vars.Jurisdiction_Clock, true);
        XT.SetBool(Vars.Jurisdiction_GameTitle, true)
    }
    if (ServerOptions.jurisdiction == "DK") {
        XT.SetBool(Vars.Jurisdiction_Clock, true);
        XT.SetBool(Vars.Jurisdiction_Clock_Server, true);
        XT.SetBool(Vars.Jurisdiction_GameTitle, true)
    }
    if (ServerOptions.jurisdiction == "PT") {
        XT.SetBool(Vars.Jurisdiction_Clock, true);
        XT.SetBool(Vars.Jurisdiction_GameTitle, true)
    }
    if (!_string.IsNullOrEmpty(ServerOptions.jurisdictionRequirements)) {
        var jr = ServerOptions.jurisdictionRequirements.split(",");
        for (var i = 0; i < jr.length; ++i)
            if (jr[i] == "AAP")
                XT.SetBool(Vars.HasAdvancedAutoplay, true);
            else if (jr[i].indexOf("SS") == 0) {
                var sval = jr[i].substr(2);
                var val = _number.otoi(sval) / 10;
                XT.SetBool(Vars.Jurisdiction_SpinLimit, true);
                XT.SetFloat(Vars.Jurisdiction_SpinLimit_Value, val)
            } else if (jr[i].indexOf("SR") == 0) {
                var sval = jr[i].substr(2);
                var val = _number.otoi(sval) / 10;
                XT.SetBool(Vars.Jurisdiction_ResultMinimumTime, true);
                XT.SetFloat(Vars.Jurisdiction_ResultMinimumTime_Value, val)
            } else if (jr[i].indexOf("ST") == 0) {
                var sval = jr[i].substr(2);
                var val = _number.otoi(sval) / 10;
                XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo, true);
                XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeTurbo_Value, val)
            } else if (jr[i].indexOf("SB") == 0) {
                var sval = jr[i].substr(2);
                var val = _number.otoi(sval) / 10;
                XT.SetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins, true);
                XT.SetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value, val)
            } else if (jr[i] == "CLK")
                XT.SetBool(Vars.Jurisdiction_Clock, true);
            else if (jr[i] == "CLS")
                XT.SetBool(Vars.Jurisdiction_Clock_Server, true);
            else if (jr[i] == "GT")
                XT.SetBool(Vars.Jurisdiction_GameTitle, true);
            else if (jr[i] == "NOAP")
                XT.SetBool(Vars.Jurisdiction_DisableAutoplay, true);
            else if (jr[i] == "MALL")
                XT.SetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit, true);
            else if (jr[i] == "LBLFS")
                XT.SetBool(Vars.Jurisdiction_LineByLineFreespin, true);
            else if (jr[i] == "LBLG")
                XT.SetBool(Vars.Jurisdiction_LineByLineGlobal, true);
            else if (jr[i] == "BALS")
                XT.SetBool(Vars.Jurisdiction_SplitBalance, true);
            else if (jr[i] == "PURL")
                XT.SetBool(Vars.Jurisdiction_PromotionURL, true);
            else if (jr[i] == "CREV")
                XT.SetBool(Vars.Jurisdiction_ClientRevision, true);
            else if (jr[i] == "GSYM")
                XT.SetBool(Vars.Jurisdiction_GameSymbol, true);
            else if (jr[i] == "FCBS")
                XT.SetBool(Vars.Jurisdiction_FinishCountersBeforeSpin, true)
    }
}
;
VideoSlotsConnectionXTLayer.prototype.InitReceived = function() {
    this.handlerGameInitReceived = true;
    if (this.CanTriggerInitReady())
        this.TriggerInitReady()
}
;
var GLOBAL_TIME_RESPONSE_RECEIVED = -1;
VideoSlotsConnectionXTLayer.prototype.SpinResultReceived = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_SpinResultReceived);
    GLOBAL_TIME_RESPONSE_RECEIVED = globalTracking.GetTimerValue("uht_spin", "time_response_received", "SpinTracker");
    globalTracking.StopTimerAndSend("uht_spin", "time_response_received", "SpinTracker")
}
;
VideoSlotsConnectionXTLayer.prototype.InitFirstScreenSymbols = function(reelSymbols) {
    XT.SetObject(Vars.FirstScreenSymbols, reelSymbols)
}
;
VideoSlotsConnectionXTLayer.prototype.SetNASymbolId = function(_naSymbolId) {
    XT.SetInt(Vars.NASymbolId, _naSymbolId)
}
;
VideoSlotsConnectionXTLayer.prototype.SetWildRandomLineMpConfig = function(cfgs) {
    XT.SetObject(Vars.WildRandomLineMpConfig, cfgs)
}
;
VideoSlotsConnectionXTLayer.prototype.SetWRLMResponse = function(response) {
    XT.SetObject(Vars.WRLMResponse, response)
}
;
VideoSlotsConnectionXTLayer.prototype.SetWRLMCurrentSets = function(css) {
    XT.SetObject(Vars.WRLMCurrentSets, css)
}
;
VideoSlotsConnectionXTLayer.prototype.SetRandomAwardsConfig = function(config) {
    XT.SetObject(Vars.RandomAwardsConfig, config)
}
;
VideoSlotsConnectionXTLayer.prototype.SetRandomAwardResponse = function(rar) {
    XT.SetObject(Vars.RandomAwardsResponse, rar)
}
;
VideoSlotsConnectionXTLayer.prototype.SetBetLevelSettings = function(bl) {
    XT.SetObject(Vars.BetLevelSettings, bl)
}
;
VideoSlotsConnectionXTLayer.prototype.SetFSPurchaseConfig = function(fspc) {
    XT.SetObject(Vars.FreeSpinsPurchaseConfig, fspc)
}
;
VideoSlotsConnectionXTLayer.prototype.SetFSPurchaseData = function(fspd) {
    XT.SetObject(Vars.FreeSpinsPurchaseData, fspd)
}
;
VideoSlotsConnectionXTLayer.prototype.SetRandomSymbolMultipliers = function(rsm) {
    XT.SetObject(Vars.RandomSymbolMultipliers, rsm)
}
;
VideoSlotsConnectionXTLayer.prototype.SetPossibleRandomSymbolMultipliers = function(prm) {
    XT.SetObject(Vars.PossibleRandomSymbolMultipliers, prm)
}
;
VideoSlotsConnectionXTLayer.prototype.SetFreeSpinsChainData = function(fcsd) {
    XT.SetObject(Vars.FreeSpinsChainData, fcsd)
}
;
VideoSlotsConnectionXTLayer.prototype.SetOpeningSymbolsData = function(osd) {
    XT.SetObject(Vars.OpeningSymbolsData, osd)
}
;
VideoSlotsConnectionXTLayer.prototype.SetRandomMysterySymbolId = function(rms) {
    XT.SetInt(Vars.RandomMysterySymbolId, rms)
}
;
VideoSlotsConnectionXTLayer.prototype.SetInitialMysterySymbolId = function(rmi) {
    XT.SetInt(Vars.InitialMysterySymbolId, rmi)
}
;
VideoSlotsConnectionXTLayer.prototype.SetInitialBGItemValues = function(bgItemValues) {
    XT.SetObject(Vars.InitBGItemValues, bgItemValues)
}
;
VideoSlotsConnectionXTLayer.prototype.SetInitialBGItemMasks = function(bgItemMasks) {
    XT.SetObject(Vars.InitBGItemMasks, bgItemMasks)
}
;
VideoSlotsConnectionXTLayer.prototype.SetSpinOneReelValues = function(Values) {
    XT.SetObject(Vars.SpinOneReelData, Values)
}
;
VideoSlotsConnectionXTLayer.prototype.SetPatternedMysterySymbols = function(pms) {
    XT.SetObject(Vars.PatternedMysterySymbols, pms)
}
;
VideoSlotsConnectionXTLayer.prototype.SetTumblingData = function(value) {
    XT.SetObject(Vars.TumblingData, value)
}
;
VideoSlotsConnectionXTLayer.prototype.SetRandomWildsData = function(randomWildsData, upSymbols) {
    XT.SetObject(Vars.RandomWildsData, randomWildsData);
    XT.SetObject(Vars.UpSymbols_RandomWilds, upSymbols);
    XT.TriggerEvent(Vars.Evt_Internal_RandomWildsDataSet)
}
;
VideoSlotsConnectionXTLayer.prototype.SetExpandingSymbolsData = function(expSymbolsData) {
    XT.SetObject(Vars.ExpandingSymbolsData, expSymbolsData);
    XT.TriggerEvent(Vars.Evt_Internal_ExpandingSymbolsDataSet)
}
;
VideoSlotsConnectionXTLayer.prototype.SetResultScreenSymbols = function(reelSymbols) {
    XT.SetObject(Vars.ResultScreenSymbols, reelSymbols)
}
;
VideoSlotsConnectionXTLayer.prototype.SetInitialResultScreenSymbols = function(reelSymbols) {
    XT.SetObject(Vars.InitialResultScreenSymbols, reelSymbols)
}
;
VideoSlotsConnectionXTLayer.prototype.SetSymbolsAbove = function(sa) {
    XT.SetObject(Vars.SymbolsAboveReels, sa)
}
;
VideoSlotsConnectionXTLayer.prototype.SetSymbolsBelow = function(sb) {
    XT.SetObject(Vars.SymbolsBelowReels, sb)
}
;
VideoSlotsConnectionXTLayer.prototype.SetNextReelsSymbolsList = function(n_rsl) {
    XT.SetObject(Vars.NextReelsSymbolsList, n_rsl)
}
;
VideoSlotsConnectionXTLayer.prototype.SetWinValue = function(value) {
    if (value >= 0)
        XT.SetDouble(Vars.WinReceived, value)
}
;
VideoSlotsConnectionXTLayer.prototype.SetExtraAwardWin = function(val) {
    XT.SetDouble(Vars.ExtraAwardWin, val)
}
;
VideoSlotsConnectionXTLayer.prototype.SetRespinCycleWin = function(val) {
    XT.SetDouble(Vars.RespinCycleWin, val)
}
;
VideoSlotsConnectionXTLayer.prototype.SetSpinCycleWinValue = function(value) {
    if (value >= 0)
        XT.SetDouble(Vars.SpinCycleWinReceived, value)
}
;
VideoSlotsConnectionXTLayer.prototype.SetLinesWinValue = function(value) {
    XT.SetDouble(Vars.TotalLinesWinReceived, value)
}
;
VideoSlotsConnectionXTLayer.prototype.SetHasCoins = function(allowCoins) {
    var hasCoins = XT.GetBool(Vars.HasCoins);
    XT.SetBool(Vars.HasCoins, !hasCoins);
    XT.SetBool(Vars.HasCoins, hasCoins);
    XT.SetBool(Vars.FromServer_AllowCoins, allowCoins)
}
;
VideoSlotsConnectionXTLayer.prototype.SetBets = function(betsFromServer, previousBet, defaultBet) {
    CoinManager.ComputeCoinValuesAndCurrentBet(betsFromServer, previousBet, defaultBet)
}
;
VideoSlotsConnectionXTLayer.prototype.SetBetLines = function(lines) {
    XT.SetInt(Vars.BetToTotalBetMultiplier, lines);
    XT.SetInt(Vars.Lines, XT.GetBool(Vars.GameHasWaysInsteadOfLines) ? XT.GetInt(Vars.TotalNumberOfLines) : lines)
}
;
VideoSlotsConnectionXTLayer.prototype.SetWinLines = function(winLines) {
    if (XT.GetBool(Vars.GameHasWaysInsteadOfLines))
        for (var i = 0; i < winLines.length; i++)
            winLines[i].LineNumber = i;
    XT.SetObject(Vars.ReceivedWinLines, winLines)
}
;
VideoSlotsConnectionXTLayer.prototype.SetBalance = function(value, fromSpinResult) {
    XT.SetDouble(Vars.BalanceReceived, value);
    if (fromSpinResult)
        XT.TriggerEvent(Vars.Evt_FromServer_BalanceUpdatedFromResult);
    else if (!XT.GetBool(Vars.IgnoreServerBalanceRequest)) {
        XT.TriggerEvent(Vars.Evt_FromServer_BalanceUpdated);
        UHTInterfaceBOSS.PostMessage("post_updateBalance")
    }
}
;
VideoSlotsConnectionXTLayer.prototype.SetBonusBalance = function(value) {
    XT.SetDouble(Vars.BonusBalanceReceived, value)
}
;
VideoSlotsConnectionXTLayer.prototype.SetCanGambleSpinWin = function(val) {
    XT.SetBool(Vars.FromServer_CanGambleSpinWin, val)
}
;
VideoSlotsConnectionXTLayer.prototype.SetGambleResponse = function(vsGambleResp) {
    XT.SetObject(Vars.FromServer_GambleResult, vsGambleResp)
}
;
VideoSlotsConnectionXTLayer.prototype.SetGambleHistory = function(vsGambleHistory) {
    XT.SetObject(Vars.FromServer_GambleHistory, vsGambleHistory)
}
;
VideoSlotsConnectionXTLayer.prototype.SetInitialSoundState = function(isOn) {
    this.internalGlobalSoundIsOn = isOn
}
;
VideoSlotsConnectionXTLayer.prototype.SetSoundState = function(_gameSoundIsOn, _musicIsOn, _soundFXIsOn, _oldMusicIsOn, _oldSoundFXIsOn) {
    var s = new SoundState;
    s.gameSoundIsOn = _gameSoundIsOn;
    if (UHT_DEVICE_TYPE.MOBILE) {
        s.musicIsOn = s.gameSoundIsOn;
        s.soundFXIsOn = s.gameSoundIsOn;
        s.oldMusicIsOn = !s.gameSoundIsOn;
        s.oldSoundFXIsOn = !s.gameSoundIsOn
    } else {
        s.musicIsOn = _musicIsOn;
        s.soundFXIsOn = _soundFXIsOn;
        s.oldMusicIsOn = _oldMusicIsOn;
        s.oldSoundFXIsOn = _oldSoundFXIsOn
    }
    s.globalSoundIsOn = this.internalGlobalSoundIsOn;
    XT.SetObject(Vars.SoundState, s);
    XT.SetBool(Vars.MusicIsOn, s.musicIsOn);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged)
}
;
VideoSlotsConnectionXTLayer.prototype.SetFreeSpinResponseReceived = function(_freeSpinResponse) {
    if (this.fsr == null)
        this.fsr = new FreeSpinsResponse;
    this.fsr.SetFreeSpinsResponse(_freeSpinResponse);
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, this.fsr)
}
;
VideoSlotsConnectionXTLayer.prototype.SetTruncatedFSResponseReceived = function(_fsr) {
    var t_fsr = new FreeSpinsResponse;
    t_fsr.SetFreeSpinsResponse(_fsr);
    XT.SetObject(Vars.TruncatedFreeSpinsResponse, t_fsr)
}
;
VideoSlotsConnectionXTLayer.prototype.SetMysteryScatterSymbolId = function(mssid) {
    XT.SetInt(Vars.MysteryScatterSymbolId, mssid)
}
;
VideoSlotsConnectionXTLayer.prototype.SetStartFSBG = function(isMysteryScatter) {
    if (isMysteryScatter)
        this.SendGetMysteryScatter();
    XT.SetBool(Vars.FromServer_MustOpenFSBG, true)
}
;
VideoSlotsConnectionXTLayer.prototype.SendGetMysteryScatter = function() {
    this.vsc.SendGetMysteryScatter()
}
;
VideoSlotsConnectionXTLayer.prototype.SendFSBGInitDone = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_InitFSBGPick)
}
;
VideoSlotsConnectionXTLayer.prototype.SendFSBGResponseReceived = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_ResponseFSBGPick)
}
;
VideoSlotsConnectionXTLayer.prototype.OnShowResult = function() {
    this.vsc.OnShowResult()
}
;
VideoSlotsConnectionXTLayer.prototype.OnFreeSpinClosed = function() {
    this.vsc.OnFreeSpinsClosed();
    this.fsr = new FreeSpinsResponse;
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, this.fsr)
}
;
VideoSlotsConnectionXTLayer.prototype.OnRequestInit = function() {
    console.log("OnRequestInit", ServerOptions);
    EventManager.AddHandler(GameEvents.evtConnectionReady, this.OnConnectionReady, this)
}
;
VideoSlotsConnectionXTLayer.prototype.OnRequestSpin = function() {
    this.vsc.SpinPressed(XT.GetInt(Vars.Lines), CoinManager.GetNextBet());
    XT.SetBool(Vars.CanAnimateValues, true)
}
;
VideoSlotsConnectionXTLayer.prototype.OnRequestGambleOpen = function() {
    this.vsc.SendGambleOpen()
}
;
VideoSlotsConnectionXTLayer.prototype.OnRequestGambleClose = function() {
    XT.SetObject(Vars.FromServer_GambleHistory, null);
    this.vsc.SendGambleBack()
}
;
VideoSlotsConnectionXTLayer.prototype.OnGamblePick = function() {
    var choice;
    XT.SetBool(Vars.CanAnimateValues, true);
    switch (XT.GetInt(Vars.Gamble_Choice)) {
    case 0:
        choice = VsGamblingRequest.GamblingChoices.Red;
        break;
    case 1:
        choice = VsGamblingRequest.GamblingChoices.Black;
        break;
    case 2:
        choice = VsGamblingRequest.GamblingChoices.Clubs;
        break;
    case 3:
        choice = VsGamblingRequest.GamblingChoices.Spades;
        break;
    case 4:
        choice = VsGamblingRequest.GamblingChoices.Diamond;
        break;
    case 5:
        choice = VsGamblingRequest.GamblingChoices.Heart;
        break;
    case 6:
        choice = VsGamblingRequest.GamblingChoices.Dices;
        break;
    default:
        choice = VsGamblingRequest.GamblingChoices.None;
        break
    }
    this.vsc.SendGambleChoice(choice)
}
;
VideoSlotsConnectionXTLayer.prototype.OnBonusPick = function() {
    var i = XT.GetInt(Vars.BonusPickItemIndex);
    this.bonusConnection.SendItemPick(i);
    XT.SetBool(Vars.CanAnimateValues, true)
}
;
VideoSlotsConnectionXTLayer.prototype.OnSendBonusRespin = function() {
    this.bonusConnection.SendBonusRespin();
    XT.SetBool(Vars.CanAnimateValues, true)
}
;
VideoSlotsConnectionXTLayer.prototype.OnBonusCustomPick = function() {
    var i = XT.GetInt(Vars.BonusPickItemIndex);
    this.bonusConnection.SendCustomItemPick(i, -1);
    XT.SetBool(Vars.CanAnimateValues, true)
}
;
VideoSlotsConnectionXTLayer.prototype.OnBonusGameFinished = function() {
    this.bonusConnection.OnBonusGameFinished();
    if (XT.GetBool(Vars.BonusTriggersFSBG))
        this.SetStartFSBG(XT.GetBool(Vars.BonusTriggeredFSBGIsMystery))
}
;
VideoSlotsConnectionXTLayer.prototype.SendBonusInitDone = function() {
    this.UpdateBonusVars();
    XT.TriggerEvent(Vars.Evt_FromServer_BonusInitDone)
}
;
VideoSlotsConnectionXTLayer.prototype.SendBonusResponse = function() {
    this.UpdateBonusVars();
    XT.TriggerEvent(Vars.Evt_FromServer_BonusResponseReceived)
}
;
VideoSlotsConnectionXTLayer.prototype.UpdateBonusVars = function() {
    if (this.bonusData == null)
        this.bonusData = new BonusData;
    this.bonusData.GameID = this.bonusConnection.lastResponse.id;
    this.bonusData.WheelOfFortune = this.bonusConnection.lastResponse.wheelOfFortune;
    this.bonusData.Coef = this.bonusConnection.Coef();
    this.bonusData.GameOver = this.bonusConnection.GameOver();
    this.bonusData.Level = this.bonusConnection.Level();
    this.bonusData.Life = this.bonusConnection.Life();
    this.bonusData.RealWin = this.bonusConnection.RealWin();
    this.bonusData.WinPoints = this.bonusConnection.WinPoints();
    this.bonusData.PossibleWins = this.bonusConnection.PossibleWins();
    this.bonusData.PremultipliedWin = this.bonusConnection.lastResponse.PremultipliedWin;
    this.bonusData.MultipliedSymbolPositions = this.bonusConnection.MultipliedSymbolPositions();
    this.bonusData.RespinsTotalMultiplier = this.bonusConnection.lastResponse.RespinsTotalMultiplier;
    this.bonusData.ExtraRespinsWon = this.bonusConnection.lastResponse.ExtraRespinsWon;
    if ((this.bonusConnection.lastResponse.currentBonusRespin == 0 || this.bonusData.MultipliedSymbolPositions != null) && this.bonusConnection.lastResponse.respinSymbols == null) {
        this.bonusData.ItemsMarkers = this.bonusConnection.ItemsMarkers();
        this.bonusData.ItemsStatus = this.bonusConnection.ItemsStatus();
        this.bonusData.ItemsWins = this.bonusConnection.ItemsWins();
        this.bonusData.WinsMask = this.bonusConnection.WinsMask()
    }
    this.bonusData.LifeWins = this.bonusConnection.LifeWins();
    this.bonusData.currentBonusRespin = this.bonusConnection.CurrentBonusRespin();
    this.bonusData.maxBonusRespins = this.bonusConnection.MaxBonusRespins();
    this.bonusData.respinSymbols = this.bonusConnection.RespinSymbols();
    if (this.bonusConnection.lastResponse.MultipliersTable.Markers != null) {
        this.bonusData.MultipliersMarkers = this.bonusConnection.MultipliersMarkers();
        this.bonusData.MultipliersStatus = this.bonusConnection.MultipliersStatus();
        this.bonusData.MultipliersWins = this.bonusConnection.MultipliersWins()
    }
    this.bonusData.MultiplierStep = this.bonusConnection.MultiplierStep();
    this.bonusData.numberOfLevels = this.bonusConnection.lastResponse.numberOfLevels;
    if (this.bonusConnection.lastResponse.BonusTable.BGItemValues != null)
        this.bonusData.BGItemValues = this.bonusConnection.lastResponse.BonusTable.BGItemValues;
    if (this.bonusConnection.lastResponse.BonusTable.BGItemMasks != null)
        this.bonusData.BGItemMasks = this.bonusConnection.lastResponse.BonusTable.BGItemMasks;
    if (this.bonusConnection.lastResponse.map != null)
        this.bonusData.Map = this.bonusConnection.lastResponse.map;
    XT.SetObject(Vars.BonusData, this.bonusData);
    XT.SetBool(BGVars.BonusDataReceived, true)
}
;
VideoSlotsConnectionXTLayer.prototype.SetMustOpenBonus = function(mustOpen, mustOpenAnother) {
    XT.SetBool(Vars.MustOpenBonus, mustOpen);
    XT.SetBool(Vars.MustOpenAnotherBonus, mustOpenAnother)
}
;
VideoSlotsConnectionXTLayer.prototype.MustOpenFSOptions = function(fsOptions) {
    XT.SetObject(Vars.FreeSpinOptions, fsOptions);
    XT.SetBool(Vars.FromServer_MustOpenFSBG, true)
}
;
VideoSlotsConnectionXTLayer.prototype.FreeSpinOptionsResponseReceived = function(response) {
    if (this.fsr == null)
        this.fsr = new FreeSpinsResponse;
    this.fsr.SetFreeSpinsResponse(response.GetVsFreeSpin());
    XT.SetObject(Vars.ReceivedFreeSpinsResponse, this.fsr);
    XT.SetInt(Vars.StackedSymbolIndex, response.StackedSymbolIndex);
    XT.SetObject(Vars.FreeSpinOptions, response.FreeSpinsOptions);
    var reelSets = XT.GetObject(Vars.ReelSets);
    if (reelSets != null && response.ReelSetIndex >= 0)
        this.InitNextReelSymbols(reelSets[response.ReelSetIndex]);
    XT.TriggerEvent(Vars.Evt_FromServer_ResponseFSBGPick)
}
;
VideoSlotsConnectionXTLayer.prototype.OnItemPickedFSBGPick = function() {
    XT.SetBool(Vars.CanAnimateValues, true);
    var pickedIndex = XT.GetInt(Vars.PickedItemIndexLocal_FSBGPick);
    if (this.vsc.HasFreeSpinOptions())
        this.vsc.FSOption_SendPick(pickedIndex);
    else
        this.vsc.FSBG_SendPick(pickedIndex)
}
;
VideoSlotsConnectionXTLayer.prototype.SetJackpotState = function(data) {
    var jackpotToEnable = -1;
    if (data != null && data.JackpotID > 0)
        jackpotToEnable = 0;
    else
        ;XT.SetInt(Vars.CurrentlyDisplayedJackpot, jackpotToEnable)
}
;
VideoSlotsConnectionXTLayer.prototype.SetJackpotWon = function(jackpotId, jackpotOrder, amount) {
    XT.SetDouble(Vars.FromServer_JackpotAmountWon, amount);
    XT.SetInt(Vars.FromServer_JackpotWonID, jackpotId);
    XT.SetInt(Vars.FromServer_JackpotWonOrder, jackpotOrder);
    XT.SetBool(Vars.FromServer_IsJackpotWin, true);
    XT.SetBool(Vars.MustShowJackpotWon, true)
}
;
VideoSlotsConnectionXTLayer.prototype.SetJackpotsInfo = function(jpInfo) {
    var oldJP = XT.GetObject(Vars.FromServer_JackpotsInformation);
    if (oldJP != null)
        XT.SetObject(Vars.FromServer_LastValidJackpotsInformation, oldJP);
    else
        XT.SetObject(Vars.FromServer_LastValidJackpotsInformation, jpInfo);
    XT.SetObject(Vars.FromServer_JackpotsInformation, jpInfo)
}
;
VideoSlotsConnectionXTLayer.prototype.SetJackpotVisualization = function(jpv) {
    XT.SetObject(Vars.JackpotVisualization, jpv)
}
;
VideoSlotsConnectionXTLayer.prototype.SetGoldSymbol = function(gs) {
    XT.SetObject(Vars.GoldSymbol, gs)
}
;
VideoSlotsConnectionXTLayer.prototype.SetSymbolReplacementData = function(sr) {
    XT.SetObject(Vars.SymbolReplacementData, sr)
}
;
VideoSlotsConnectionXTLayer.prototype.SetPaytableInfo = function(paytableInfo) {
    XT.SetObject(Vars.PaytablePayoutData, paytableInfo);
    XT.TriggerEvent(Vars.Evt_Internal_PaytablePayoutUpdate)
}
;
VideoSlotsConnectionXTLayer.prototype.SetRespinData = function(_respinData) {
    if (_respinData != null && _respinData.TotalRespins != null)
        _respinData.IsDone = true;
    XT.SetObject(Vars.RespinData, _respinData)
}
;
VideoSlotsConnectionXTLayer.prototype.SetProgressiveFeatureConfig = function(_progressiveConfig) {
    XT.SetObject(Vars.ProgressiveFeatureConfig, _progressiveConfig)
}
;
VideoSlotsConnectionXTLayer.prototype.SetProgressiveFeatureData = function(_progressiveData) {
    XT.SetObject(Vars.ProgressiveFeatureData, _progressiveData)
}
;
VideoSlotsConnectionXTLayer.prototype.SetMoneySymbolConfig = function(_moneySymbolConfig) {
    XT.SetObject(Vars.MoneySymbolConfig, _moneySymbolConfig)
}
;
VideoSlotsConnectionXTLayer.prototype.SetMoneySymbolData = function(_moneySymbolData) {
    XT.SetObject(Vars.MoneySymbolData, _moneySymbolData)
}
;
VideoSlotsConnectionXTLayer.prototype.SetStickySymbolsData = function(_stickySymbolsData) {
    XT.SetObject(Vars.StickySymbolsData, _stickySymbolsData)
}
;
VideoSlotsConnectionXTLayer.prototype.SetMergingSymbolsData = function(_mergingSymbolsData) {
    XT.SetObject(Vars.MergingSymbolsData, _mergingSymbolsData)
}
;
VideoSlotsConnectionXTLayer.prototype.SetNudgedSymbolsData = function(_nudgedSymbolsData) {
    XT.SetObject(Vars.NudgedSymbols, _nudgedSymbolsData)
}
;
VideoSlotsConnectionXTLayer.prototype.Update = function() {
    if (this.isInCoolDown) {
        this.timeInCooldown += Time.deltaTime;
        if (this.timeInCooldown > 3)
            this.isInCoolDown = false
    }
    if (!this.isInCoolDown && this.needToSendSettingsToServer) {
        var settings = new GameSettings;
        this.UpdateSettings(false, settings);
        this.needToSendSettingsToServer = false;
        this.isInCoolDown = true;
        this.timeInCooldown = 0
    }
    if (this.mustTriggerDelayedGameLoadingFinished)
        if (Time.frameCount - this.delayedGameLoadingFinishedFrameCount > 5) {
            EventManager.Trigger(ApplicationEvents.evtGameLoadingFinished, this.gameSymbol);
            Globals.InputBlocked = false;
            this.mustTriggerDelayedGameLoadingFinished = false
        }
}
;
VideoSlotsConnectionXTLayer.prototype.OnRequestToOpenCashier = function() {
    EventManager.Trigger(AdapterEvents.evtOpenCashier, null)
}
;
VideoSlotsConnectionXTLayer.prototype.OnRequestToCloseGame = function() {
    UHTInterfaceBOSS.PostMessage("gameQuit");
    EventManager.Trigger(AdapterEvents.evtCloseGame, null)
}
;
VideoSlotsConnectionXTLayer.prototype.OnRequestToReloadGame = function() {
    EventManager.Trigger(AdapterEvents.evtReload, null)
}
;
VideoSlotsConnectionXTLayer.prototype.SetGambleSettings = function(canGambleSpin, canGambleFreeSpin, canGambleBonus, gambleColorMultiplier, gambleSuitMultiplier) {
    XT.SetBool(Vars.CanGamble_Spin, canGambleSpin);
    XT.SetBool(Vars.CanGamble_FreeSpin, canGambleFreeSpin);
    XT.SetBool(Vars.CanGamble_Bonus, canGambleBonus);
    XT.SetDouble(Vars.Gamble_ColorMultiplier, gambleColorMultiplier);
    XT.SetDouble(Vars.Gamble_SuitMultiplier, gambleSuitMultiplier)
}
;
VideoSlotsConnectionXTLayer.prototype.SetReturnToPlayer = function(rtp) {
    XT.SetDouble(Vars.ReturnToPlayer, rtp)
}
;
VideoSlotsConnectionXTLayer.prototype.SetReturnToPlayerMin = function(rtp) {
    XT.SetDouble(Vars.ReturnToPlayerMin, rtp)
}
;
VideoSlotsConnectionXTLayer.prototype.SkipResultDisplayOnInit = function() {
    XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true)
}
;
VideoSlotsConnectionXTLayer.prototype.CanTriggerInitReady = function() {
    return this.handlerGameInitReceived && this.settingsReceived && (this.resourcesLoaded || !ServerOptions.isOnline)
}
;
VideoSlotsConnectionXTLayer.prototype.TriggerInitReady = function() {
    XT.TriggerEvent(Vars.Evt_FromServer_InitReceived);
    this.mustTriggerDelayedGameLoadingFinished = true;
    this.delayedGameLoadingFinishedFrameCount = Time.frameCount
}
;
VideoSlotsConnectionXTLayer.prototype.UpdateBonusRoundsInfo = function(res) {
    XT.SetObject(Vars.BonusRoundsEvents, res.FreeRoundEvents);
    XT.SetObject(Vars.BonusRoundsData, res.FreeRound);
    XT.TriggerEvent(Vars.Evt_Internal_BonusRoundsInfoUpdated)
}
;
VideoSlotsConnectionXTLayer.prototype.UpdateBonusFSResponseValues = function(res) {
    var _vsFreeSpin = res.GetVsFreeSpin();
    if (_vsFreeSpin != null)
        this.SetFreeSpinResponseReceived(res.GetVsFreeSpin());
    this.SetWinValue(res.Win);
    this.vsc.UpdateBonusFSResponseValues(res)
}
;
VideoSlotsConnectionXTLayer.prototype.SetWildRandomMultipliers = function(wildRandomMultipliers) {
    XT.SetObject(Vars.WildRandomMultipliers, wildRandomMultipliers);
    XT.TriggerEvent(Vars.Evt_Internal_WildRandomMultipliersReceived)
}
;
VideoSlotsConnectionXTLayer.prototype.OnGambleV2Pick = function() {
    XT.SetBool(Vars.CanAnimateValues, true);
    this.vsc.SendGambleV2Choice(XT.GetInt(Vars.Gamble_Choice))
}
;
VideoSlotsConnectionXTLayer.prototype.SetGambleV2Response = function(gambleData) {
    XT.SetObject(Vars.GambleV2Data, gambleData);
    XT.TriggerEvent(Vars.Evt_FromServer_GambleV2Response)
}
;
VideoSlotsConnectionXTLayer.prototype.SetMustOpenGambleV2 = function(mustOpen) {
    XT.SetBool(Vars.MustOpenGambleV2, mustOpen)
}
;
VideoSlotsConnectionXTLayer.prototype.SetServerTime = function(time) {
    XT.SetDouble(Vars.Jurisdiction_ServerTime, time)
}
;
function RandomAwardsResponse() {
    this.awardIndex = -1;
    this.awardPositionInReel = -1;
    this.currentReelIndex = -1;
    this.nextReelIndex = -1
}
RandomAwardsResponse.prototype.Clone = function() {
    var clone = new RandomAwardsResponse;
    clone.awardIndex = this.awardIndex;
    clone.awardPositionInReel = this.awardPositionInReel;
    clone.currentReelIndex = this.currentReelIndex;
    clone.nextReelIndex = this.nextReelIndex;
    return clone
}
;
goog.require("UHT.Engine");
ServerInterface.prototype = Object.create(Component.prototype);
ServerInterface.prototype.constructor = ServerInterface;
function ServerInterface() {
    Component.call(this);
    this.userName = "";
    this.userPass = "";
    this.domain = "";
    this.isExternal = false;
    this.xtLayer = null;
    this.configFile = null;
    this.counter = 0
}
ServerInterface.prototype.Awake = function() {
    if (UHT_LOCAL)
        ServerOptions.logLevel = LogLevel.Debug;
    this.ParseConfigFile()
}
;
ServerInterface.prototype.Start = function() {}
;
ServerInterface.prototype.Update = function() {
    if (this.counter < 4)
        this.counter++;
    if (this.counter == 2) {
        if (!UHT_LOCAL)
            ServerOptions.serverUrl = location.protocol + "//" + ServerInterface.GetDomain();
        else
            ServerOptions.serverUrl = "https://" + this.domain;
        if (UHT_LOCAL)
            if (_string.IsNullOrEmpty(this.userName) || _string.IsNullOrEmpty(this.userPass)) {
                console.error("The username and/or password are empty!");
                return
            }
        if (UHT_LOCAL && UHT_ONLINE)
            ServerHelpers.CookiesRequest(new EventHandler(this,this.OnCookieResponse));
        else
            EventManager.Trigger(ApplicationEvents.evtRequestInitApplication, null)
    }
}
;
ServerInterface.prototype.OnCookieResponse = function(param, statusCode) {
    console.info("Received response for sessionid request");
    ServerHelpers.LoginRequest(this.userName, this.userPass, new EventHandler(this,this.OnLoginResponse))
}
;
ServerInterface.prototype.OnLoginResponse = function(loginStr, statusCode) {
    if (loginStr.indexOf("log=1") != -1) {
        console.info("Login - Succes");
        EventManager.Trigger(ApplicationEvents.evtRequestInitApplication, null)
    } else
        console.error("Login - Fail")
}
;
ServerInterface.prototype.ParseConfigFile = function() {
    var lines = this.configFile.text.split("\n");
    if (this.configFile.text.indexOf("external") != -1)
        this.isExternal = true;
    if (lines.length < 6 || this.isExternal && lines.length < 8)
        console.error("There are missing parameters from the config file!");
    else {
        this.userName = lines[0];
        this.userPass = lines[1];
        this.domain = lines[2];
        ServerOptions.styleName = lines[3];
        ServerOptions.gameSymbol = lines[4];
        ServerOptions.language = lines[5];
        if (this.isExternal) {
            ServerOptions.gameServiceUri = lines[6];
            ServerOptions.tokenUrl = lines[7];
            ServerOptions.serverDomain = this.domain
        }
        if (this.configFile.text.indexOf("online") != -1)
            ServerOptions.isOnline = true;
        ServerInterface.domain = this.domain
    }
    ServerOptions.isOnline = UHT_ONLINE
}
;
ServerInterface.domain = "";
ServerInterface.GetDomain = function() {
    return UHT_LOCAL ? ServerInterface.domain : location.host
}
;
goog.provide("UHT.Special_Symbol");
goog.require("UHT.Engine");
goog.require("UHT.CAT_Event");
Special_Symbol.prototype = Object.create(Component.prototype);
Special_Symbol.prototype.constructor = Special_Symbol;
function Special_Symbol() {
    Component.call(this);
    this.symbolId = 0;
    this.willHighlightOffAfterExciteWin = true;
    this.eventNormal = null;
    this.eventSpinStart = null;
    this.eventSpinLoop = null;
    this.eventSpinStop = null;
    this.eventHighlightOff = null;
    this.eventHighlightOn = null;
    this.eventExcited = null;
    this.eventWinExcited = null;
    this.eventWinning = null;
    this.eventSpinLoopExcited = null;
    this.eventFSHighlightOff = null;
    this.eventStart = null;
    this.eventStop = null;
    this.currentStateForInspector = Special_Symbol.State.Invalid;
    this.internalState = Special_Symbol.State.Invalid;
    this.lastQueuedState = Special_Symbol.State.Invalid;
    this.commands = [];
    this.stopEventSent = false;
    this.canProcessNextCommand = true
}
Special_Symbol.State = {
    Invalid: 0,
    Normal: 1,
    HighlightOn: 2,
    HighlightOff: 3,
    SpinStart: 4,
    SpinLoop: 5,
    SpinStop: 6,
    Excited: 7,
    WinExcited: 8,
    SpinLoopExcited: 9,
    Winning: 10,
    FSHighlightOff: 11
};
Special_Symbol.prototype.ChangeToState = function(newState) {
    this.commands.push(newState);
    this.lastQueuedState = newState;
    this.ProcessCommands()
}
;
Special_Symbol.prototype.Start = function() {
    this.eventNormal.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWinExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWinning.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventNormal.RegisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.RegisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWinExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWinning.RegisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.RegisterCallback(this.Callback_EventEnded, this)
}
;
Special_Symbol.prototype.ProcessCommands = function() {
    if (this.commands.length > 0)
        if (this.canProcessNextCommand) {
            var newState = this.commands[0];
            this.commands.splice(0, 1);
            this.canProcessNextCommand = false;
            switch (newState) {
            case Special_Symbol.State.Normal:
                this.eventNormal.Start();
                break;
            case Special_Symbol.State.HighlightOn:
                this.eventHighlightOn.Start();
                break;
            case Special_Symbol.State.HighlightOff:
                this.eventHighlightOff.Start();
                break;
            case Special_Symbol.State.SpinStart:
                this.eventSpinStart.Start();
                break;
            case Special_Symbol.State.SpinLoop:
                this.eventSpinLoop.Start();
                break;
            case Special_Symbol.State.SpinStop:
                this.eventSpinStop.Start();
                break;
            case Special_Symbol.State.Excited:
                this.eventExcited.Start();
                break;
            case Special_Symbol.State.WinExcited:
                this.eventWinExcited.Start();
                break;
            case Special_Symbol.State.Winning:
                this.eventWinning.Start();
                break;
            case Special_Symbol.State.SpinLoopExcited:
                this.eventSpinLoopExcited.Start();
                break;
            case Special_Symbol.State.FSHighlightOff:
                this.eventFSHighlightOff.Start();
                break;
            case Special_Symbol.State.Invalid:
            default:
                this.canProcessNextCommand = true;
                break
            }
            this.internalState = newState;
            this.currentStateForInspector = this.internalState
        } else if (this.stopEventSent == false)
            this.StopAllRunningEvents()
}
;
Special_Symbol.prototype.Update = function() {
    this.ProcessCommands()
}
;
Special_Symbol.prototype.Callback_EventEnded = function(_type, data) {
    if (_type == CAT_Event.CallbackType.EndOfEvent)
        this.canProcessNextCommand = true
}
;
Special_Symbol.prototype.StopAllRunningEvents = function() {
    if (this.eventNormal.IsRunning())
        this.eventNormal.Stop();
    if (this.eventHighlightOn.IsRunning())
        this.eventHighlightOn.Stop();
    if (this.eventHighlightOff.IsRunning())
        this.eventHighlightOff.Stop();
    if (this.eventSpinStart.IsRunning())
        this.eventSpinStart.Stop();
    if (this.eventSpinLoop.IsRunning())
        this.eventSpinLoop.Stop();
    if (this.eventSpinStop.IsRunning())
        this.eventSpinStop.Stop();
    if (this.eventExcited.IsRunning())
        this.eventExcited.Stop();
    if (this.eventWinExcited.IsRunning())
        this.eventWinExcited.Stop();
    if (this.eventWinning.IsRunning())
        this.eventWinning.Stop();
    if (this.eventSpinLoopExcited.IsRunning())
        this.eventSpinLoopExcited.Stop();
    if (this.eventFSHighlightOff.IsRunning())
        this.eventFSHighlightOff.Stop()
}
;
Special_Symbol.prototype.SpinStart = function() {
    this.ChangeToState(Special_Symbol.State.SpinStart)
}
;
Special_Symbol.prototype.SpinLoop = function() {
    this.ChangeToState(Special_Symbol.State.SpinLoop)
}
;
Special_Symbol.prototype.SpinStop = function() {
    this.ChangeToState(Special_Symbol.State.SpinStop)
}
;
Special_Symbol.prototype.SetHighlightOn = function() {
    this.ChangeToState(Special_Symbol.State.HighlightOn)
}
;
Special_Symbol.prototype.SetHighlightOff = function() {
    if (this.internalState != Special_Symbol.State.WinExcited && this.internalState != Special_Symbol.State.Winning || this.willHighlightOffAfterExciteWin)
        if (XT.GetBool(Vars.Logic_IsFreeSpin))
            this.ChangeToState(Special_Symbol.State.FSHighlightOff);
        else
            this.ChangeToState(Special_Symbol.State.HighlightOff)
}
;
Special_Symbol.prototype.SetNormal = function() {
    this.ChangeToState(Special_Symbol.State.Normal)
}
;
Special_Symbol.prototype.SetExcited = function() {
    this.ChangeToState(Special_Symbol.State.Excited)
}
;
Special_Symbol.prototype.SetWinExcited = function() {
    this.ChangeToState(Special_Symbol.State.WinExcited)
}
;
Special_Symbol.prototype.SpinLoopExcited = function() {
    this.ChangeToState(Special_Symbol.State.SpinLoopExcited)
}
;
Special_Symbol.prototype.SetWinning = function() {
    this.ChangeToState(Special_Symbol.State.Winning)
}
;
Special_Symbol.prototype.EventStart = function() {
    this.eventStart.Start()
}
;
Special_Symbol.prototype.EventStop = function() {
    this.eventStop.Start()
}
;
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
goog.require("UHT.Special_Symbol");
Special_SymbolsManager.prototype = Object.create(XTLink.prototype);
Special_SymbolsManager.prototype.constructor = Special_SymbolsManager;
function Special_SymbolsManager() {
    XTLink.call(this);
    this.pool = null;
    this.symbols = [];
    this.symbolIdToIndexMap = [];
    this.pooledSymbols = [];
    this.disablePoolNextFrame = false;
    this.defaultBufferAmount = 10;
    this.currentInitSymbol = -1
}
Special_SymbolsManager.initializing = 0;
Special_SymbolsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SymbolManager, this.OnSymbolManagerInit, this)
}
;
Special_SymbolsManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSymbolManagerInit, this)
}
;
Special_SymbolsManager.prototype.OnSymbolManagerInit = function() {
    SymbolsManager_CheckAndSendTrackingInit();
    Special_SymbolsManager.initializing++;
    this.currentInitSymbol = 0;
    this.BuildSymbolIdToIndexMap();
    this.pooledSymbols = [];
    this.pool.SetActive(true);
    if (LoaderProgress.SymbolsManagers_Total == -1)
        LoaderProgress.SymbolsManagers_Total = this.symbols.length;
    else
        LoaderProgress.SymbolsManagers_Total += this.symbols.length
}
;
Special_SymbolsManager.prototype.Update = function() {
    if (this.currentInitSymbol >= 0)
        if (this.currentInitSymbol < this.symbols.length) {
            var id = this.symbols[this.currentInitSymbol].symbolId;
            this.pooledSymbols[id] = [];
            for (var n = 0; n < this.defaultBufferAmount; n++) {
                var newObj = instantiate(this.symbols[this.currentInitSymbol].gameObject);
                newObj.SetActive(true);
                this.PoolSymbol(id, newObj.GetComponent(Special_Symbol))
            }
            this.currentInitSymbol++;
            LoaderProgress.SymbolsManagers_Current++
        } else if (this.currentInitSymbol == this.symbols.length) {
            this.disablePoolNextFrame = false;
            Special_SymbolsManager.initializing--;
            SymbolsManager_CheckAndSendTrackingEnd();
            this.currentInitSymbol++
        }
}
;
Special_SymbolsManager.prototype.BuildSymbolIdToIndexMap = function() {
    var highestSymbolId = -1;
    for (var i = 0; i < this.symbols.length; i++)
        if (this.symbols[i].symbolId > highestSymbolId)
            highestSymbolId = this.symbols[i].symbolId;
    this.symbolIdToIndexMap = new Array(highestSymbolId + 1);
    for (var j = 0; j < this.symbols.length; j++)
        this.symbolIdToIndexMap[this.symbols[j].symbolId] = j
}
;
Special_SymbolsManager.prototype.GetFromPool = function(id, parent) {
    if (this.pooledSymbols[id].length == 0) {
        console.log("Symbol pool capacity is too small! ID = " + id);
        this.pooledSymbols[id].push(instantiate(this.symbols[this.symbolIdToIndexMap[id]].gameObject).GetComponent(Special_Symbol));
        this.pooledSymbols[id][this.pooledSymbols[id].length - 1].gameObject.SetActive(true)
    }
    var pooledObject = this.pooledSymbols[id][0];
    this.pooledSymbols[id].splice(0, 1);
    pooledObject.gameObject.transform.SetParent(parent.transform, false);
    pooledObject.gameObject.transform.localPosition(UHTMath.Vector3.zero);
    pooledObject.gameObject.transform.localRotation(UHTMath.Quaternion.euler(UHTMath.Vector3.zero));
    pooledObject.gameObject.transform.localScale(UHTMath.Vector3.one);
    return pooledObject
}
;
Special_SymbolsManager.prototype.PoolSymbol = function(id, obj) {
    obj.gameObject.transform.SetParent(this.pool.transform, false);
    this.pooledSymbols[id].push(obj)
}
;
Special_SymbolsManager.prototype.GetSymbol = function(symbolId, parent) {
    return this.GetFromPool(symbolId, parent)
}
;
Special_SymbolsManager.prototype.RecycleSymbol = function(symbol) {
    this.PoolSymbol(symbol.symbolId, symbol)
}
;
Special_SymbolsManager.prototype.LateUpdate = function() {
    if (this.pool.activeSelf && this.currentInitSymbol > this.symbols.length) {
        if (!this.disablePoolNextFrame) {
            this.disablePoolNextFrame = true;
            return
        }
        this.pool.SetActive(false)
    }
}
;
goog.require("UHT.UHTStage");
StageInit.prototype = Object.create(UHTStage.prototype);
StageInit.prototype.constructor = StageInit;
function StageInit() {
    UHTStage.call(this);
    this.initShow = null;
    this.introShow = null;
    this.introHide = null;
    this.XTRoot = null;
    this.manualRespin = false;
    this.totalNumberOfLines = -1;
    this.hasWaysInsteadOfLines = false;
    this.paysBothWays = false;
    this.hasCustomGamble = false;
    this.hasIntro = false;
    this.triggerBonusBeforeResult = false;
    this.scatterIsWild = false;
    this.freeSpinsStartNeedsConfirmation = false;
    this.bonusWinIsSeparated = false;
    this.opaqueInterface = true;
    this.hasReelAwareSymbolContent = false;
    this.truncateFSResponseDuringRespin = false;
    this.updateFSResponseOnBonusPick = true;
    this.numberOfBetLevels = 10;
    this.minimumJackpotBigWinDuration = 99999;
    this.defaultGameWindowOverride = null;
    this.initReceived = false;
    this.introClosed = false;
    this.canGoToNextStage = false
}
StageInit.prototype.GetStageName = function() {
    return UHTStageName.Init
}
;
StageInit.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.GameHasIntro, this.hasIntro);
    XT.SetBool(Vars.GameHasCustomGamble, this.hasCustomGamble);
    XT.SetBool(Vars.ScatterSymbolIsWild, this.scatterIsWild);
    XT.SetBool(Vars.TruncateFSResponseDuringRespin, this.truncateFSResponseDuringRespin);
    XT.SetBool(Vars.UpdateFSResponseOnBonusPick, this.updateFSResponseOnBonusPick);
    XT.SetInt(Vars.TotalNumberOfLines, this.totalNumberOfLines);
    XT.SetBool(Vars.GameHasWaysInsteadOfLines, this.hasWaysInsteadOfLines);
    XT.SetInt(Vars.NumberOfBetLevels, this.numberOfBetLevels);
    XT.SetBool(Vars.TriggerBonusBeforeResult, this.triggerBonusBeforeResult);
    XT.SetBool(Vars.BonusWinIsSeparated, this.bonusWinIsSeparated);
    XT.SetBool(Vars.OpaqueInterface, this.opaqueInterface);
    XT.SetBool(Vars.HasReelAwareSymbolContent, this.hasReelAwareSymbolContent);
    XT.SetBool(Vars.HiddenMathematics, false);
    XT.SetBool(BGVars.BonusDataReceived, false);
    XT.SetBool(Vars.LinesPaysBothWays, this.paysBothWays);
    XT.SetObject(Vars.FreeSpinOptions, null);
    XT.SetBool(Vars.CanSpin, false);
    XT.SetBool(Vars.AllowFastStop, true);
    XT.SetBool(Vars.IsDifferentSpinType, false);
    XT.SetObject(Vars.DefaultGameWindowOverrideData, this.defaultGameWindowOverride);
    XT.SetBool(Vars.BrowserWarningShown, false);
    XT.SetBool(Vars.FSStartNeedsConfirmation, this.freeSpinsStartNeedsConfirmation);
    XT.SetBool(Vars.SpinNeedsConfirmation, false);
    XT.SetBool(Vars.SpinBlockingFeatureIsRunning, false);
    XT.SetFloat(Vars.MinimumJackpotBigWinDuration, this.minimumJackpotBigWinDuration);
    XT.SetBool(Vars.ManualRespin, this.manualRespin)
}
;
StageInit.prototype.UHTInit = function() {
    XT.RegisterAndInit(this.XTRoot)
}
;
StageInit.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        XT.TriggerEvent(Vars.Evt_Internal_Init_SymbolManager);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_InitReceived, this.OnInitReceived, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_IntroClosePressed, this.IntroClosed, this);
        XT.TriggerEvent(Vars.Evt_ToServer_RequestInit)
    }
    if (this.initReceived && globalResourcesNeededList.length == 0 && !(VS_SymbolsManager.initializing + Special_SymbolsManager.initializing > 0)) {
        UHTEngine.HideLoader();
        if (XT.GetBool(Vars.MustOpenBonus)) {
            this.PatchNudgeData();
            CoinManager.SetStrictBetMode(false)
        }
        CoinManager.SetStrictBetMode(true);
        CoinManager.InitLastBets();
        XT.TriggerEvent(Vars.Evt_Internal_Init_SoundManager);
        XT.TriggerEvent(Vars.Evt_Internal_Init_ReelsManager);
        XT.TriggerEvent(Vars.Evt_Internal_GameInit);
        XT.TriggerEvent(Vars.Evt_Internal_GUIInit);
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        if (fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected) {
            XT.SetInt(Vars.MaxFreeSpinsDisplayed, fsr.MaxSpins);
            XT.SetInt(Vars.CurrentFreeSpinDisplayed, fsr.CurrentSpin);
            XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins - fsr.CurrentSpin);
            XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, fsr.TotalMultiplier | 0)
        }
        XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
        UHTEngine.SignalCanStartPrefetchingUnusedAtlasses();
        if (!XT.GetBool(Vars.GameHasIntro) || XT.GetBool(Vars.GameHasIntro) && !XT.GetBool(Vars.ShouldDisplayIntro)) {
            if (this.ProcessStageToGo()) {
                this.initShow.RegisterCallback(this.OnIntroClosedOrSkipped, this);
                this.initShow.Start();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        } else
            this.introShow.Start();
        this.canGoToNextStage = true;
        this.initReceived = false
    }
    if (this.canGoToNextStage) {
        if (!Globals.InputBlocked && (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return)))
            this.introClosed = true;
        if (this.introClosed)
            if (this.ProcessStageToGo()) {
                this.introHide.RegisterCallback(this.OnIntroClosedOrSkipped, this);
                this.introHide.Start();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
    }
    return UHTAction.NoAction()
}
;
StageInit.prototype.UHTFinish = function() {
    XT.UnregisterCallbackEvent(this.OnInitReceived, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.IntroClosed, this)
}
;
StageInit.prototype.XTRegisterCallbacks = function() {}
;
StageInit.prototype.OnBalanceUpdated = function() {
    XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
    XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
}
;
StageInit.prototype.OnInitReceived = function() {
    this.initReceived = true
}
;
StageInit.prototype.IntroClosed = function() {
    this.introClosed = true
}
;
StageInit.prototype.ProcessStageToGo = function() {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    XT.SetBool(Vars.Logic_IsFreeSpin, fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected);
    var isBonus = XT.GetBool(Vars.MustOpenBonus);
    if (isBonus) {
        if (XT.GetBool(Vars.TriggerBonusBeforeResult) && fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected) {
            if (fsr.BonusGameData != null && fsr.BonusGameData.GameOver || fsr.IsFreeSpinsStart && fsr.MysteryScatter != null)
                XT.SetBool(Vars.Internal_FSBGJustClosed, true);
            if (fsr.PickedOptionIndex >= 0) {
                XT.SetBool(Vars.MustResumeFreeSpinOptions, true);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
                return true
            }
        }
        if (!XT.GetBool(BGVars.BonusDataReceived))
            return false;
        else
            XT.SetBool(BGVars.BonusDataReceived, false);
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
        return true
    }
    if (XT.GetBool(Vars.FromServer_MustOpenFSBG) || XT.GetObject(Vars.FreeSpinOptions) != null) {
        XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
        return true
    }
    XT.TriggerEvent(Vars.Evt_Internal_StartVSLogicSounds);
    if (XT.GetBool(Vars.MustOpenGambleV2)) {
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Gamble);
        return true
    }
    if (fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected) {
        if (fsr.BonusGameData != null && fsr.BonusGameData.GameOver || fsr.IsFreeSpinsStart && fsr.MysteryScatter != null)
            XT.SetBool(Vars.Internal_FSBGJustClosed, true);
        if (fsr.PickedOptionIndex >= 0) {
            XT.SetBool(Vars.MustResumeFreeSpinOptions, true);
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
            return true
        }
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.ResultFreeSpin);
        return true
    } else {
        XT.SetObject(Vars.FromStageName, this.GetStageName());
        XT.SetObject(Vars.ToStageName, UHTStageName.Result);
        return true
    }
}
;
StageInit.prototype.OnBrowserWarningShown = function() {
    XT.SetBool(Vars.BrowserWarningShown, true);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
}
;
StageInit.prototype.OnIntroClosedOrSkipped = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent)
        XT.TriggerEvent(Vars.Evt_CodeToData_IntroClosedOrSkipped)
}
;
StageInit.prototype.PatchNudgeData = function() {
    var nudgeData = XT.GetObject(Vars.NudgedSymbols);
    if (nudgeData != null) {
        var initialScreenSymbols = XT.GetObject(Vars.InitialResultScreenSymbols);
        for (var i = 0; i < nudgeData.length; i++) {
            initialScreenSymbols[nudgeData[i].reelID] = nudgeData[i].nudgedSymbolsIDs;
            initialScreenSymbols[nudgeData[i].reelID].reverse()
        }
        XT.SetObject(Vars.ReceivedWinLines, []);
        XT.SetObject(Vars.InitialResultScreenSymbols, initialScreenSymbols);
        XT.SetObject(Vars.NudgedSymbols, null)
    }
}
;
goog.require("UHT.XTLink");
var globalMustStopAutoplay = false;
function AdvancedAutoplaySettings() {
    this.stopOnAnyWin = false;
    this.stopIfFeature = false;
    this.stopIfSingleWinExceeds = false;
    this.singleWinValue = 0;
    this.stopIfCashIncreases = false;
    this.cashIncreasesValue = 0;
    this.stopIfCashDecreases = false;
    this.cashDecreasesValue = 0;
    this.initialBalance = 0
}
function AutoplayManager() {}
AutoplayManager.wasReset = false;
AutoplayManager.fastPlay = false;
AutoplayManager.autoplayContinuousSpin = false;
AutoplayManager.TestAdvancedStopConditions = function() {
    if (globalMustStopAutoplay) {
        XT.SetInt(Vars.AutoplaySpinsLeft, -1);
        globalMustStopAutoplay = false;
        return
    }
    if (XT.GetBool(Vars.HasAdvancedAutoplay) == false || XT.GetInt(Vars.AutoplaySpinsLeft) < 0)
        return;
    var mustStop = false;
    var s = XT.GetObject(Vars.AdvancedAutoplaySettings);
    if (!mustStop && s.stopOnAnyWin)
        if (XT.GetDouble(Vars.SpinCycleWinReceived) > 0)
            mustStop = true;
    if (!mustStop && s.stopIfFeature) {
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        if (fsr.IsFreeSpin || XT.GetBool(Vars.FromServer_MustOpenFSBG) || XT.GetBool(Vars.MustOpenBonus))
            mustStop = true
    }
    if (!mustStop && s.stopIfSingleWinExceeds)
        if (XT.GetDouble(Vars.SpinCycleWinReceived) > s.singleWinValue)
            mustStop = true;
    if (!mustStop && s.stopIfCashIncreases)
        if (XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived) > s.initialBalance + s.cashIncreasesValue)
            mustStop = true;
    if (!mustStop && s.stopIfCashDecreases)
        if (XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived) - CoinManager.GetNextTotalBet() < s.initialBalance - s.cashDecreasesValue)
            mustStop = true;
    if (mustStop)
        XT.SetInt(Vars.AutoplaySpinsLeft, -1)
}
;
AutoplayManager.ResetSettings = function() {
    if (AutoplayManager.wasReset)
        return;
    AutoplayManager.wasReset = true;
    AutoplayManager.fastPlay = XT.GetBool(Vars.FastPlay);
    AutoplayManager.autoplayContinuousSpin = XT.GetBool(Vars.AutoplayContinuousSpin);
    XT.SetBool(Vars.FastPlay, false);
    XT.SetBool(Vars.AutoplayContinuousSpin, false)
}
;
AutoplayManager.RestoreSettings = function() {
    if (!AutoplayManager.wasReset)
        return;
    AutoplayManager.wasReset = false;
    XT.SetBool(Vars.FastPlay, AutoplayManager.fastPlay);
    XT.SetBool(Vars.AutoplayContinuousSpin, AutoplayManager.autoplayContinuousSpin)
}
;
goog.require("UHT.Engine");
var BonusRoundsController = {
    HandleNextEvent: function(onlyTreatErrors, betChangeAllowed, showWindowAllowed) {
        var ret = new BonusRoundRetData;
        var data = XT.GetObject(Vars.BonusRoundsData);
        ret.isBonusRounds = data != null;
        if (ret.isBonusRounds && !onlyTreatErrors) {
            XT.SetInt(Vars.BonusRoundsLeftDisplayed, data.RoundsLeft);
            XT.SetDouble(Vars.BonusRoundsWinDisplayed, data.TotalWin)
        }
        var evts = XT.GetObject(Vars.BonusRoundsEvents);
        if (evts != null && evts.length > 0) {
            var curEvt = evts[0];
            if (curEvt.Type == VsFreeRoundEvent.EventType.Start && !onlyTreatErrors) {
                if (showWindowAllowed) {
                    XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsStarted);
                    ret.messageIsOpened = true
                }
                if (betChangeAllowed) {
                    evts.splice(0, 1);
                    CoinManager.SetDesiredBet(curEvt.Bet);
                    BonusRoundsController.SetLines(curEvt.Lines);
                    XT.TriggerEvent(Vars.Evt_Internal_CoinValueChanged);
                    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup)
                }
            } else if (curEvt.Type == VsFreeRoundEvent.EventType.Finish && !onlyTreatErrors) {
                if (showWindowAllowed) {
                    XT.SetInt(Vars.BonusRoundsLeftDisplayed, 0);
                    XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsFinished);
                    ret.messageIsOpened = true
                }
                if (betChangeAllowed) {
                    evts.splice(0, 1);
                    ret.isBonusRounds = false;
                    CoinManager.SetDesiredBet(curEvt.Bet);
                    BonusRoundsController.SetLines(curEvt.Lines);
                    if (evts.length == 0)
                        XT.SetObject(Vars.BonusRoundsData, null);
                    XT.TriggerEvent(Vars.Evt_Internal_CoinValueChanged);
                    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup)
                }
            } else if (curEvt.Type == VsFreeRoundEvent.EventType.Error) {
                if (showWindowAllowed) {
                    XT.SetInt(Vars.BonusRoundsLeftDisplayed, 0);
                    XT.TriggerEvent(Vars.Evt_CodeToData_BonusRoundsError);
                    ret.messageIsOpened = true
                }
                if (betChangeAllowed) {
                    evts.splice(0, 1);
                    ret.isBonusRounds = false;
                    CoinManager.SetDesiredBet(curEvt.Bet);
                    BonusRoundsController.SetLines(curEvt.Lines)
                }
            }
        }
        return ret
    },
    SetLines: function(lines) {
        XT.SetInt(Vars.BetToTotalBetMultiplier, lines);
        XT.SetInt(Vars.Lines, XT.GetBool(Vars.GameHasWaysInsteadOfLines) ? XT.GetInt(Vars.TotalNumberOfLines) : lines)
    }
};
function BonusRoundRetData() {
    this.isBonusRounds = false;
    this.messageIsOpened = false
}
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
StageResult.prototype = Object.create(UHTStage.prototype);
StageResult.prototype.constructor = StageResult;
function StageResult() {
    UHTStage.call(this);
    this.cat = null;
    this.startEvent = null;
    this.mustSpin = false;
    this.mustShowGamble = false;
    this.prepareToOpenBonus = false;
    this.mustOpenBonus = false;
    this.isJackpotWinOnScreen = false;
    this.isBonusRounds = false;
    this.bonusRoundsMessageWindowIsOpened = false;
    this.isRespin = false;
    this.canAutoSpinAfterResultMinimumTime = false;
    this.spinBlockersCounter = 0
}
StageResult.prototype.GetStageName = function() {
    return UHTStageName.Result
}
;
StageResult.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BlockSpin, this.OnBlockSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_UnblockSpin, this.OnUnblockSpin, this)
}
;
StageResult.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, -1);
    XT.SetInt(Vars.AutoplaySpinsRequested, 0);
    XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, 0);
    XT.SetBool(Vars.WaitInResultForBigWin, false);
    XT.SetInt(Vars.VAWBWCounters, 0);
    XT.SetBool(Vars.LastWinIsCounting, false);
    XT.SetBool(Vars.BalanceIsCounting, false);
    XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, false);
    XT.SetBool(Vars.ForceDisableGambleSpinWin, false)
}
;
StageResult.prototype.UHTInit = function() {}
;
StageResult.AllowSkipMoneyCheckOnContinuousSpin = false;
StageResult.SkipMoneyCheckOnSpin = false;
StageResult.prototype.UHTUpdate = function(isFirstFrame) {
    window["RC_CheckShowWindow"]();
    if (isFirstFrame) {
        window["RC1API"]["ReinstateRC"]();
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Spin, this.OnPressedSpin, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Stop, this.OnPressedStop, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnResultDisplayerLoopDone, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Gamble, this.OnPressedGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_GambleOpen, this.OnMustOpenGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StartAutoplay, this.OnStartAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StopAutoplay, this.OnStopAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_CollectJackpotPressed, this.OnJackpotCollected, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed, this.OnBonusRoundsContinuePressed, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_BonusRoundsInfoUpdated, this.OnBonusRoundsInfoUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWin, this.OnRequestToUpdateDisplayedWin, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_ConfirmSpinStart, this.OnConfirmStartSpin, this);
        XT.SetDouble(Vars.WinDisplayed, 0);
        XT.SetDouble(Vars.TotalLinesWinDisplayed, 0);
        XT.SetDouble(Vars.TotalScattersWinDisplayed, 0);
        XT.SetInt(Vars.Lines, XT.GetInt(Vars.TotalNumberOfLines));
        AutoplayManager.TestAdvancedStopConditions();
        var brret = BonusRoundsController.HandleNextEvent(false, false, true);
        this.isBonusRounds = brret.isBonusRounds;
        this.bonusRoundsMessageWindowIsOpened = brret.messageIsOpened;
        var respinData = XT.GetObject(Vars.RespinData);
        this.isRespin = respinData != null && !respinData.IsDone;
        if (this.bonusRoundsMessageWindowIsOpened == false)
            CoinManager.SetStrictBetMode(this.isBonusRounds);
        this.prepareToOpenBonus = XT.GetBool(Vars.MustOpenBonus);
        if (XT.GetInt(Vars.AutoplaySpinsLeft) > 0 || this.IsAutoRespin())
            XT.SetBool(Vars.ForceDisableGambleSpinWin, true);
        this.UpdateGambleButtonState();
        var autoplaySpinsLeft = XT.GetInt(Vars.AutoplaySpinsLeft);
        var displayResultMinimal = false;
        var normalResult = true;
        if (autoplaySpinsLeft >= 0 && !this.IsAutoRespin()) {
            autoplaySpinsLeft--;
            if (XT.GetBool(Vars.InstantAutoplay) && autoplaySpinsLeft == -1)
                autoplaySpinsLeft = 0;
            if (autoplaySpinsLeft == -1)
                displayResultMinimal = false;
            else {
                if (this.isBonusRounds)
                    VSGameStateManager.ChangeTo(VSGameState.ResultBonusRoundsAutoplay);
                else
                    VSGameStateManager.ChangeTo(VSGameState.ResultAutoplay);
                displayResultMinimal = true;
                normalResult = false
            }
            if (!this.prepareToOpenBonus)
                XT.SetInt(Vars.AutoplaySpinsLeft, autoplaySpinsLeft)
        }
        if (normalResult)
            if (this.prepareToOpenBonus)
                VSGameStateManager.ChangeTo(VSGameState.ResultPrepareForBonus);
            else if (this.isBonusRounds)
                VSGameStateManager.ChangeTo(VSGameState.ResultBonusRounds);
            else
                VSGameStateManager.ChangeTo(VSGameState.Result);
        displayResultMinimal = displayResultMinimal || this.IsAutoRespin() || this.prepareToOpenBonus;
        XT.SetBool(Vars.ResultDisplayerMinimalMode, displayResultMinimal);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_Prepare);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        if (this.cat != null)
            this.cat.StartEvent(this.startEvent.id);
        this.canAutoSpinAfterResultMinimumTime = false
    } else {
        if (this.mustOpenBonus && !XT.GetBool(Vars.LastWinIsCounting)) {
            XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            if (XT.GetBool(Vars.WaitInResultForBigWin) == false)
                if (XT.GetBool(BGVars.BonusDataReceived)) {
                    this.mustOpenBonus = false;
                    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                    XT.SetBool(BGVars.BonusDataReceived, false);
                    XT.SetObject(Vars.FromStageName, this.GetStageName());
                    XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
                    window["RC1API"]["PauseRC"]();
                    return UHTAction.ChangeStage(UHTStageName.Transition)
                } else
                    return UHTAction.NoAction()
        }
        if (!Globals.InputBlocked) {
            if (XT.GetBool(Vars.ContinuousSpin) && StageResult.AllowSkipMoneyCheckOnContinuousSpin)
                StageResult.SkipMoneyCheckOnSpin = true;
            if (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return) || XT.GetBool(Vars.ContinuousSpin))
                if (this.CanSpin())
                    this.mustSpin = true;
            StageResult.SkipMoneyCheckOnSpin = false
        }
        if (this.mustSpin) {
            this.mustSpin = false;
            if (XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.SpinBlockingFeatureIsRunning))
                XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            else if (!this.IsJackpotWin()) {
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, XT.GetInt(Vars.AutoplaySpinsLeft));
                XT.SetBool(Vars.ForceDisableGambleSpinWin, true);
                this.UpdateGambleButtonState();
                XT.SetBool(Vars.ForceDisableGambleSpinWin, false);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Spin);
                window["RC1API"]["PauseRC"]();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        }
        if (this.mustShowGamble) {
            this.mustShowGamble = false;
            if (XT.GetBool(Vars.WaitInResultForBigWin))
                XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            else if (!this.IsJackpotWin()) {
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true);
                XT.SetDouble(Vars.Gamble_CurrentBalance, XT.GetDouble(Vars.WinReceived));
                XT.SetBool(Vars.ForceDisableGambleSpinWin, true);
                this.UpdateGambleButtonState();
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Gamble);
                window["RC1API"]["PauseRC"]();
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        }
        if (this.canAutoSpinAfterResultMinimumTime && XT.GetBool(Vars.CanSpin))
            this.OnResultDisplayerLoopDone()
    }
    return UHTAction.NoAction()
}
;
StageResult.prototype.UHTFinish = function() {
    XT.UnregisterCallbackEvent(this.OnPressedSpin, this);
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.OnResultDisplayerLoopDone, this);
    XT.UnregisterCallbackEvent(this.OnPressedGamble, this);
    XT.UnregisterCallbackEvent(this.OnMustOpenGamble, this);
    XT.UnregisterCallbackEvent(this.OnStartAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnStopAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnJackpotCollected, this);
    XT.UnregisterCallbackEvent(this.OnBonusRoundsContinuePressed, this);
    XT.UnregisterCallbackEvent(this.OnBonusRoundsInfoUpdated, this);
    XT.UnregisterCallbackEvent(this.OnCoinValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this);
    XT.UnregisterCallbackEvent(this.OnConfirmStartSpin, this)
}
;
StageResult.prototype.OnPressedStop = function() {
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
}
;
StageResult.prototype.UpdateGambleButtonState = function() {
    if (XT.GetBool(Vars.FromServer_CanGambleSpinWin) && !XT.GetBool(Vars.ForceDisableGambleSpinWin))
        XT.TriggerEvent(Vars.Evt_Internal_EnableGambleButton);
    else
        XT.TriggerEvent(Vars.Evt_Internal_DisableGambleButton)
}
;
StageResult.prototype.OnPressedSpin = function() {
    if (this.CanSpin())
        this.mustSpin = true
}
;
StageResult.prototype.OnPressedGamble = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_RequestGambleOpen)
}
;
StageResult.prototype.OnMustOpenGamble = function() {
    this.mustShowGamble = true
}
;
StageResult.prototype.OnBalanceUpdated = function() {
    if (XT.GetBool(Vars.BalanceDisplayedIsAnimating) == false) {
        XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
        XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
    }
}
;
StageResult.prototype.CanSpin = function() {
    if (this.spinBlockersCounter > 0)
        return false;
    if (!XT.GetBool(Vars.WaitInResultForBigWin)) {
        if (XT.GetBool(Vars.Jurisdiction_FinishCountersBeforeSpin))
            if ((XT.GetBool(Vars.LastWinIsCounting) || XT.GetBool(Vars.BalanceIsCounting)) && XT.GetInt(Vars.AutoplaySpinsLeft) < 0) {
                XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
                return false
            }
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
    }
    if (window["SystemMessageManager"]["IsMessageOpen"]())
        return false;
    if (XT.GetBool(Vars.CanSpin) == false)
        return false;
    if (this.bonusRoundsMessageWindowIsOpened)
        return false;
    if (this.prepareToOpenBonus)
        return false;
    if (this.isBonusRounds)
        return true;
    if (this.isRespin)
        if (this.IsAutoRespin())
            return false;
        else
            return true;
    if (!StageResult.SkipMoneyCheckOnSpin && window["UHT_STILLCHECKMONEYONSPIN"] != undefined)
        if (CoinManager.GetNextTotalBet() > XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived) && !XT.GetBool(Vars.Logic_IsFreeSpin)) {
            XT.TriggerEvent(Vars.Evt_CodeToData_NotEnoughMoneyForSpin);
            XT.SetDouble(Vars.AlternativeWager, -1);
            UHTInterfaceBOSS.PostMessage("balanceTooLow");
            return false
        }
    XT.SetDouble(Vars.AlternativeWager, -1);
    if (XT.GetBool(Vars.SpinNeedsConfirmation)) {
        XT.TriggerEvent(Vars.Evt_CodeToData_ShowSpinConfirmationWindow);
        return false
    }
    return true
}
;
var BT_AUTOPLAY_FirstSent = false;
StageResult.prototype.OnStartAutoplay = function() {
    if (this.CanSpin() == false)
        return;
    if (!BT_AUTOPLAY_FirstSent) {
        var timer = globalTracking.GetTimerValue("uht_behaviour", "Session_timer", "BehaviourTracker");
        globalTracking.SendEvent("uht_behaviour", "AUTOPLAY_started_once", timer, "BehaviourTracker");
        BT_AUTOPLAY_FirstSent = true
    }
    globalTracking.SendEvent("uht_behaviour", "AUTOPLAY_start_" + XT.GetInt(Vars.AutoplaySpinsRequested), 1, "BehaviourTracker");
    XT.SetInt(Vars.AutoplaySpinsLeft, XT.GetInt(Vars.AutoplaySpinsRequested) - 1);
    XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, XT.GetInt(Vars.AutoplaySpinsLeft));
    this.mustSpin = true
}
;
StageResult.prototype.OnStopAutoplay = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, -1);
    XT.SetBool(Vars.ForceDisableGambleSpinWin, false);
    this.UpdateGambleButtonState();
    if (this.isBonusRounds)
        VSGameStateManager.ChangeTo(VSGameState.ResultBonusRounds);
    else
        VSGameStateManager.ChangeTo(VSGameState.Result)
}
;
StageResult.prototype.IsJackpotWin = function() {
    if (XT.GetBool(Vars.FromServer_IsJackpotWin) && !this.isJackpotWinOnScreen)
        if (!(XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting)))
            this.isJackpotWinOnScreen = true;
    return XT.GetBool(Vars.FromServer_IsJackpotWin)
}
;
StageResult.prototype.OnJackpotCollected = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting))
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.SetBool(Vars.FromServer_IsJackpotWin, false);
    this.isJackpotWinOnScreen = false
}
;
StageResult.prototype.OnResultDisplayerLoopDone = function() {
    if (this.IsJackpotWin()) {
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        return
    }
    if (this.prepareToOpenBonus) {
        this.mustOpenBonus = true;
        return
    }
    if (this.IsAutoRespin())
        if (XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting))
            XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        else {
            this.mustSpin = true;
            return
        }
    var autoplaySpinsLeft = XT.GetInt(Vars.AutoplaySpinsLeft);
    if (autoplaySpinsLeft >= 0)
        if (XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting))
            XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        else if (this.CanSpin())
            this.mustSpin = true;
        else {
            this.canAutoSpinAfterResultMinimumTime = XT.GetBool(Vars.CanSpinAfterResultMinimumTime);
            if (!this.canAutoSpinAfterResultMinimumTime) {
                XT.SetInt(Vars.AutoplaySpinsLeft, -1);
                if (this.isBonusRounds)
                    VSGameStateManager.ChangeTo(VSGameState.ResultBonusRounds);
                else
                    VSGameStateManager.ChangeTo(VSGameState.Result)
            }
        }
    else {
        if (!XT.GetBool(Vars.WaitInResultForBigWin) && !XT.GetBool(Vars.LastWinIsCounting))
            XT.TriggerEvent(Vars.Evt_Internal_StartIdleSpinCounter);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop)
    }
}
;
StageResult.prototype.OnBonusRoundsContinuePressed = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_CloseOtherOpenedBonusRoundsWindows);
    XT.SetBool(Vars.CanSpin, true);
    this.OnBonusRoundsInfoUpdated()
}
;
StageResult.prototype.OnBonusRoundsInfoUpdated = function() {
    var brret = BonusRoundsController.HandleNextEvent(false, true, false);
    CoinManager.SetStrictBetMode(brret.isBonusRounds);
    brret = BonusRoundsController.HandleNextEvent(false, false, true);
    this.isBonusRounds = brret.isBonusRounds;
    this.bonusRoundsMessageWindowIsOpened = brret.messageIsOpened;
    var autoplaySpinsLeft = XT.GetInt(Vars.AutoplaySpinsLeft);
    if (autoplaySpinsLeft >= 0)
        VSGameStateManager.ChangeTo(this.isBonusRounds ? VSGameState.ResultBonusRoundsAutoplay : VSGameState.ResultAutoplay);
    else
        VSGameStateManager.ChangeTo(this.isBonusRounds ? VSGameState.ResultBonusRounds : VSGameState.Result);
    if (this.bonusRoundsMessageWindowIsOpened == false)
        CoinManager.SetStrictBetMode(this.isBonusRounds)
}
;
StageResult.prototype.OnCoinValueChanged = function() {
    if (XT.GetBool(Vars.CanSpin) == false)
        return;
    if (this.bonusRoundsMessageWindowIsOpened)
        return;
    if (this.prepareToOpenBonus)
        return;
    if (this.isBonusRounds)
        return;
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup)
}
;
StageResult.prototype.OnRequestToUpdateDisplayedWin = function() {
    XT.SetDouble(Vars.WinDisplayed, XT.GetDouble(Vars.WinReceived));
    XT.SetDouble(Vars.TotalLinesWinDisplayed, XT.GetDouble(Vars.TotalLinesWinReceived));
    XT.SetDouble(Vars.TotalScattersWinDisplayed, XT.GetDouble(Vars.WinReceived) - XT.GetDouble(Vars.TotalLinesWinReceived));
    XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
    XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived));
    if (XT.GetBool(Vars.BonusWinIsSeparated))
        if (this.prepareToOpenBonus)
            XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.WinReceived));
        else {
            if (XT.GetObject(Vars.BonusData) != null)
                XT.SetBool(Vars.CanAnimateValues, false);
            XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived))
        }
    else if (ResultDisplayer.isJackpotWin) {
        var canAnimate = XT.GetBool(Vars.CanAnimateValues);
        var cycleWin = XT.GetDouble(Vars.SpinCycleWinReceived);
        var jackpotWin = XT.GetDouble(Vars.FromServer_JackpotAmountWon);
        XT.SetBool(Vars.CanAnimateValues, false);
        XT.SetDouble(Vars.SpinCycleWinDisplayed, jackpotWin);
        XT.SetBool(Vars.CanAnimateValues, canAnimate);
        XT.SetDouble(Vars.SpinCycleWinDisplayed, jackpotWin + cycleWin)
    } else
        XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
    XT.TriggerEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this)
}
;
StageResult.prototype.OnConfirmStartSpin = function() {
    XT.SetBool(Vars.SpinNeedsConfirmation, false);
    this.OnPressedSpin()
}
;
StageResult.prototype.OnBlockSpin = function() {
    this.spinBlockersCounter++
}
;
StageResult.prototype.OnUnblockSpin = function() {
    this.spinBlockersCounter--
}
;
StageResult.prototype.IsAutoRespin = function() {
    return this.isRespin && !XT.GetBool(Vars.ManualRespin)
}
;
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
StageResultFreeSpin.prototype = Object.create(UHTStage.prototype);
StageResultFreeSpin.prototype.constructor = StageResultFreeSpin;
function StageResultFreeSpin() {
    UHTStage.call(this);
    this.transition = null;
    this.transitionFast = null;
    this.additionalFreeSpins = null;
    this.minimalResultDisplayAtFreeSpinsPrepare = false;
    this.bypassNoWinFSWindow = true;
    this.mustSpin = false;
    this.changeToResult = false;
    this.changeToFSBG = false;
    this.freeSpinsEnded = false;
    this.fsr = null;
    this.prepareToOpenBonus = false;
    this.mustOpenBonus = false;
    this.mustOpenGamble = false;
    this.isJackpotWinOnScreen = false;
    this.isRespin = false;
    this.totalWinReceivedSoFarInFS = 0;
    this.firstTimeInFSResult = true;
    this.fsStartConfirmed = true;
    this.shouldEnterFS = false;
    this.mustStartFSSounds = false;
    this.transitionWasStarted = false;
    this.varsToUpdateWhenWinIsUpdated = {}
}
StageResultFreeSpin.prototype.GetStageName = function() {
    return UHTStageName.ResultFreeSpin
}
;
StageResultFreeSpin.prototype.XTRegisterCallbacks = function() {}
;
StageResultFreeSpin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsWinDisplayed, 0);
    XT.SetInt(Vars.AdditionalFreeSpinsWon, 0);
    XT.SetDouble(Vars.FreeSpinsWinMultipliedDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsTotalWinDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsTotalWinMultipliedDisplayed, 0);
    XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
    XT.SetBool(Vars.Internal_FSBGJustClosed, false)
}
;
StageResultFreeSpin.prototype.UHTInit = function() {}
;
StageResultFreeSpin.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        CoinManager.SetStrictBetMode(true);
        XT.SetInt(Vars.AdditionalFreeSpinsWon, 0);
        XT.SetBool(Vars.Logic_IsFreeSpin, true);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Stop, this.OnPressedStop, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_FreeSpinsWindowWinCollectPressed, this.OnWinResultCollectPressed, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_FreeSpinsWindowLoseCollectPressed, this.OnLoseResultCollectPressed, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnResultDisplayerLoopDone, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_ConfirmFSStart, this.OnConfirmFSStart, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Gamble_FreeSpinsResult, this.OnPressedGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_GambleOpen, this.OnMustOpenGamble, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_CollectJackpotPressed, this.OnJackpotCollected, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWin, this.OnRequestToUpdateDisplayedWin, this);
        AutoplayManager.TestAdvancedStopConditions();
        this.fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        this.prepareToOpenBonus = XT.GetBool(Vars.MustOpenBonus);
        var respinData = XT.GetObject(Vars.RespinData);
        this.isRespin = respinData != null && !respinData.IsDone;
        this.UpdateGambleButtonState();
        XT.SetDouble(Vars.FreeSpinsWinDisplayed, this.fsr.CurrentWin);
        this.varsToUpdateWhenWinIsUpdated[Vars.FreeSpinsWinMultipliedDisplayed] = this.fsr.CurrentWinMultiplied;
        XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, this.fsr.TotalMultiplier);
        if (this.fsr.IsFreeSpin && !this.fsr.IsLastFreeSpin) {
            XT.SetInt(Vars.AdditionalFreeSpinsWon, this.fsr.AdditionalSpins);
            XT.SetInt(Vars.MaxFreeSpinsDisplayed, this.fsr.MaxSpins)
        } else
            XT.SetInt(Vars.FreeSpinsLeftDisplayed, 0);
        if (this.fsr.IsFreeSpinsStart || XT.GetObject(Vars.FreeSpinOptions) != null && XT.GetBool(Vars.FromServer_MustOpenFSBG) || XT.GetBool(Vars.OpenFSBGForMysteryScatter)) {
            UHTInterfaceBOSS.PostMessage("freeSpinStarted");
            this.fsStartConfirmed = false;
            if (XT.GetBool(Vars.Internal_FSBGJustClosed)) {
                XT.SetBool(Vars.Internal_FSBGJustClosed, false);
                this.ReallyEnterFreeSpins()
            } else if (XT.GetBool(Vars.BonusTriggersFSBG))
                VSGameStateManager.ChangeTo(VSGameState.FSBG);
            else if (XT.GetObject(Vars.FreeSpinsChainData) == null) {
                XT.SetDouble(Vars.WinDisplayed, 0);
                this.varsToUpdateWhenWinIsUpdated[Vars.WinDisplayed] = XT.GetDouble(Vars.WinReceived);
                XT.SetDouble(Vars.TotalLinesWinDisplayed, 0);
                this.varsToUpdateWhenWinIsUpdated[Vars.TotalLinesWinDisplayed] = XT.GetDouble(Vars.TotalLinesWinReceived);
                VSGameStateManager.ChangeTo(VSGameState.ResultFreeSpinsPrepare)
            }
            this.varsToUpdateWhenWinIsUpdated[Vars.BalanceDisplayed] = XT.GetDouble(Vars.BalanceReceived);
            this.varsToUpdateWhenWinIsUpdated[Vars.BonusBalance] = XT.GetDouble(Vars.BonusBalanceReceived);
            XT.SetBool(Vars.ResultDisplayerMinimalMode, this.minimalResultDisplayAtFreeSpinsPrepare)
        } else if (this.fsr.IsFreeSpin) {
            XT.SetDouble(Vars.FreeSpinsLastWinDisplayed, 0);
            if (this.fsr.IsLastFreeSpin)
                if (this.firstTimeInFSResult) {
                    XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true);
                    XT.SetDouble(Vars.FreeSpinsWinMultipliedDisplayed, this.fsr.CurrentWinMultiplied);
                    XT.SetDouble(Vars.SpinCycleWinDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived))
                } else
                    this.varsToUpdateWhenWinIsUpdated[Vars.FreeSpinsLastWinDisplayed] = (this.fsr.CurrentWin - this.totalWinReceivedSoFarInFS) * this.fsr.TotalMultiplier;
            else {
                this.varsToUpdateWhenWinIsUpdated[Vars.FreeSpinsLastWinDisplayed] = XT.GetDouble(Vars.WinReceived) * this.fsr.TotalMultiplier;
                this.totalWinReceivedSoFarInFS = this.fsr.CurrentWin
            }
            XT.SetBool(Vars.ResultDisplayerMinimalMode, true);
            VSGameStateManager.ChangeTo(VSGameState.ResultFreeSpins);
            if (!this.transitionWasStarted) {
                AutoplayManager.ResetSettings();
                this.transitionWasStarted = true;
                if (this.transitionFast != null)
                    this.transitionFast.Start()
            }
        }
        this.varsToUpdateWhenWinIsUpdated[Vars.SpinCycleWinDisplayed] = XT.GetDouble(Vars.SpinCycleWinReceived);
        var scatterwin = (XT.GetDouble(Vars.WinReceived) - XT.GetDouble(Vars.TotalLinesWinReceived)) * this.fsr.TotalMultiplier;
        XT.SetDouble(Vars.MysteryScatterWinDisplayed, 0);
        this.varsToUpdateWhenWinIsUpdated[Vars.MysteryScatterWinDisplayed] = scatterwin;
        XT.SetDouble(Vars.TotalScattersWinDisplayed, 0);
        this.varsToUpdateWhenWinIsUpdated[Vars.TotalScattersWinDisplayed] = scatterwin;
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_Prepare);
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop)
    } else {
        XT.SetBool(Vars.Internal_FSBGJustClosed, false);
        if (this.mustOpenBonus && !XT.GetBool(Vars.LastWinIsCounting))
            if (XT.GetBool(BGVars.BonusDataReceived)) {
                this.mustOpenBonus = false;
                XT.SetBool(BGVars.BonusDataReceived, false);
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
                if (fsr != null) {
                    XT.SetInt(Vars.CurrentFreeSpinDisplayed, fsr.CurrentSpin);
                    XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins - fsr.CurrentSpin)
                }
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            } else
                return UHTAction.NoAction();
        this.mustOpenGamble = XT.GetObject(Vars.GambleV2Data) != null && XT.GetBool(Vars.CanSpin) && !XT.GetBool(Vars.LastWinIsCounting);
        if (this.mustOpenGamble) {
            this.mustOpenGamble = false;
            XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
            XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true);
            XT.SetDouble(Vars.Gamble_CurrentBalance, XT.GetDouble(Vars.FreeSpinsWinMultipliedDisplayed));
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.Gamble);
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
        if (this.changeToResult) {
            this.changeToResult = false;
            AutoplayManager.RestoreSettings();
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.Result);
            UHTInterfaceBOSS.PostMessage("freeSpinEnded");
            UHTInterfaceBOSS.PostMessage("gameRoundEnded");
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
        if (this.shouldEnterFS && XT.GetBool(Vars.WaitInResultForBigWin) == false && XT.GetBool(Vars.LastWinIsCounting) == false)
            if (!XT.GetBool(Vars.SpinBlockingFeatureIsRunning)) {
                this.shouldEnterFS = false;
                this.ReallyEnterFreeSpins()
            }
        if (this.freeSpinsEnded && XT.GetBool(Vars.WaitInResultForBigWin) == false && XT.GetBool(Vars.LastWinIsCounting) == false) {
            this.freeSpinsEnded = false;
            if (XT.GetBool(Vars.OpenFSBGForMysteryScatter) && XT.GetBool(Vars.FromServer_MustOpenFSBG)) {
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
            XT.SetBool(Vars.SkipNextBigWin, true);
            var totalFreeSpins = this.fsr.TotalSpins;
            var fscd = XT.GetObject(Vars.FreeSpinsChainData);
            if (fscd != null && fscd.HasPreviousChainInformation()) {
                totalFreeSpins = 0;
                for (var i = 0; i < fscd.FSCSpinsTotal.length; i++)
                    totalFreeSpins += fscd.FSCSpinsTotal[i]
            }
            XT.SetInt(Vars.TotalFreeSpinsChainDisplayed, totalFreeSpins);
            XT.SetInt(Vars.TotalFreeSpinsDisplayed, this.fsr.TotalSpins);
            XT.SetDouble(Vars.FreeSpinsTotalWinDisplayed, this.fsr.TotalWin);
            XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, this.fsr.TotalMultiplier);
            XT.SetDouble(Vars.FreeSpinsTotalWinMultipliedDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
            if (XT.GetDouble(Vars.SpinCycleWinReceived) > 0) {
                XT.SetDouble(Vars.FSResultWindowTotalWinMultipliedDisplayed, 0);
                XT.SetDouble(Vars.FSResultWindowTotalWinMultipliedDisplayed, XT.GetDouble(Vars.SpinCycleWinReceived));
                XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsShowWindowWin)
            } else if (!this.bypassNoWinFSWindow)
                XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsShowWindowLose);
            else
                this.OnLoseResultCollectPressed();
            if (XT.GetBool(Vars.CanGamble_FreeSpin) == false)
                XT.TriggerEvent(Vars.Evt_ToServer_OnFreeSpinsClosed)
        }
        if (this.mustSpin && XT.GetBool(Vars.WaitInResultForBigWin) == false && XT.GetBool(Vars.LastWinIsCounting) == false || this.changeToFSBG) {
            if (XT.GetBool(Vars.FSStartNeedsConfirmation))
                if (!this.fsStartConfirmed)
                    return UHTAction.NoAction();
            if (this.mustStartFSSounds) {
                XT.TriggerEvent(Vars.Evt_Internal_SwitchToFSSounds);
                this.mustStartFSSounds = false
            }
            if (XT.GetBool(Vars.FromServer_MustOpenFSBG)) {
                this.changeToFSBG = false;
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetBool(Vars.FromServer_MustOpenFSBG, false);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.FSBG);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
            if (!XT.GetBool(Vars.WaitInResultForBigWin)) {
                this.mustSpin = false;
                XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.Spin);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
        }
    }
    return UHTAction.NoAction()
}
;
StageResultFreeSpin.prototype.UHTFinish = function() {
    this.firstTimeInFSResult = false;
    this.varsToUpdateWhenWinIsUpdated = {};
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.OnWinResultCollectPressed, this);
    XT.UnregisterCallbackEvent(this.OnLoseResultCollectPressed, this);
    XT.UnregisterCallbackEvent(this.OnResultDisplayerLoopDone, this);
    XT.UnregisterCallbackEvent(this.OnConfirmFSStart, this);
    XT.UnregisterCallbackEvent(this.OnPressedGamble, this);
    XT.UnregisterCallbackEvent(this.OnMustOpenGamble, this);
    XT.UnregisterCallbackEvent(this.OnJackpotCollected, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this)
}
;
StageResultFreeSpin.prototype.OnPressedStop = function() {
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
}
;
StageResultFreeSpin.prototype.ReadyForSpin = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent) {
        if (!XT.GetBool(Vars.FromServer_MustOpenFSBG))
            VSGameStateManager.ChangeTo(VSGameState.ResultFreeSpins);
        this.transition.cat.UnregisterCallback(this.transition.id, this.ReadyForSpin, this);
        this.additionalFreeSpins.cat.UnregisterCallback(this.additionalFreeSpins.id, this.ReadyForSpin, this)
    }
    this.mustSpin = true
}
;
StageResultFreeSpin.prototype.OnBalanceUpdated = function() {
    if (XT.GetBool(Vars.BalanceDisplayedIsAnimating) == false) {
        XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
        XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
    }
}
;
StageResultFreeSpin.prototype.OnPressedGamble = function() {
    this.freeSpinsEnded = false;
    this.fsr.IsFreeSpinsGambled = true;
    XT.SetBool(Vars.Logic_IsFreeSpin, false);
    XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsEnded);
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting))
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.TriggerEvent(Vars.Evt_ToServer_RequestGambleOpen)
}
;
StageResultFreeSpin.prototype.OnMustOpenGamble = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsCloseWindowWin);
    this.mustOpenGamble = true
}
;
StageResultFreeSpin.prototype.UpdateGambleButtonState = function() {
    if (XT.GetBool(Vars.FromServer_CanGambleSpinWin) && !XT.GetBool(Vars.ForceDisableGambleSpinWin))
        XT.TriggerEvent(Vars.Evt_Internal_EnableGambleButton);
    else
        XT.TriggerEvent(Vars.Evt_Internal_DisableGambleButton)
}
;
StageResultFreeSpin.prototype.IsJackpotWin = function() {
    if (XT.GetBool(Vars.FromServer_IsJackpotWin) && !this.isJackpotWinOnScreen)
        if (!(XT.GetBool(Vars.WaitInResultForBigWin) || XT.GetBool(Vars.LastWinIsCounting)))
            this.isJackpotWinOnScreen = true;
    return XT.GetBool(Vars.FromServer_IsJackpotWin)
}
;
StageResultFreeSpin.prototype.OnJackpotCollected = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting))
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.SetBool(Vars.FromServer_IsJackpotWin, false);
    this.isJackpotWinOnScreen = false
}
;
StageResultFreeSpin.prototype.OnResultDisplayerLoopDone = function() {
    if (this.IsJackpotWin() || XT.GetBool(Vars.LastWinIsCounting)) {
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop);
        return
    }
    if (this.prepareToOpenBonus) {
        this.mustOpenBonus = true;
        return
    }
    if (this.fsr.IsLastFreeSpin) {
        if (this.IsAutoRespin()) {
            this.mustSpin = true;
            return
        }
        if (this.IsFSChainedSession())
            return;
        this.freeSpinsEnded = true;
        this.transitionWasStarted = false;
        XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup);
        XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true)
    } else if (this.fsr.IsFreeSpinsStart)
        this.shouldEnterFS = true;
    else if (XT.GetInt(Vars.AdditionalFreeSpinsWon) > 0) {
        this.additionalFreeSpins.cat.RegisterCallback(this.additionalFreeSpins.id, this.ReadyForSpin, this);
        this.additionalFreeSpins.Start()
    } else
        this.mustSpin = true
}
;
StageResultFreeSpin.prototype.OnWinResultCollectPressed = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting))
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsCloseWindowWin);
    XT.TriggerEvent("PS_AnnounceResultShown");
    this.OnFreeSpinsClosed()
}
;
StageResultFreeSpin.prototype.OnLoseResultCollectPressed = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_FreeSpinsCloseWindowLose);
    this.OnFreeSpinsClosed()
}
;
StageResultFreeSpin.prototype.IsFSChainedSession = function() {
    var fscd = XT.GetObject(Vars.FreeSpinsChainData);
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fscd != null && fsr.MaxSpins > 0) {
        XT.SetInt(Vars.FreeSpinsTotalMultiplierDisplayed, fsr.TotalMultiplier);
        XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins);
        this.mustStartFSSounds = true;
        XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsStarted);
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        this.transitionWasStarted = true;
        this.transition.cat.RegisterCallback(this.transition.id, this.ReadyForSpin, this);
        this.transition.Start();
        return true
    }
    return false
}
;
StageResultFreeSpin.prototype.OnFreeSpinsClosed = function() {
    if (XT.GetBool(Vars.FromServer_MustOpenFSBG))
        this.changeToFSBG = true;
    else
        this.changeToResult = true;
    this.freeSpinsEnded = false;
    XT.SetInt(Vars.MysteryScatterSymbolId, -1);
    XT.SetBool(Vars.Logic_IsFreeSpin, false);
    if (XT.GetBool(Vars.CanGamble_FreeSpin))
        XT.TriggerEvent(Vars.Evt_ToServer_OnFreeSpinsClosed);
    XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsEnded)
}
;
StageResultFreeSpin.prototype.ReallyEnterFreeSpins = function() {
    this.mustStartFSSounds = true;
    XT.TriggerEvent(Vars.Evt_Internal_FreeSpinsStarted);
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    this.fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    XT.SetInt(Vars.CurrentFreeSpinDisplayed, 0);
    XT.SetDouble(Vars.FreeSpinsLastWinDisplayed, 0);
    this.totalWinReceivedSoFarInFS = 0;
    XT.SetInt(Vars.FreeSpinsLeftDisplayed, this.fsr.MaxSpins);
    AutoplayManager.ResetSettings();
    this.transitionWasStarted = true;
    this.transition.cat.RegisterCallback(this.transition.id, this.ReadyForSpin, this);
    this.transition.Start()
}
;
StageResultFreeSpin.prototype.OnConfirmFSStart = function() {
    this.fsStartConfirmed = true
}
;
StageResultFreeSpin.prototype.OnRequestToUpdateDisplayedWin = function() {
    for (var i in this.varsToUpdateWhenWinIsUpdated)
        XT.SetDouble(i, this.varsToUpdateWhenWinIsUpdated[i]);
    XT.TriggerEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWin, this)
}
;
StageResultFreeSpin.prototype.IsAutoRespin = function() {
    return this.isRespin && !XT.GetBool(Vars.ManualRespin)
}
;
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
StageSpin.prototype = Object.create(UHTStage.prototype);
StageSpin.prototype.constructor = StageSpin;
function StageSpin() {
    UHTStage.call(this);
    this.cat = null;
    this.startEvent = null;
    this.spinEnded = false;
    this.isBonusRounds = false;
    this.rq = null;
    this.isRQEnded = false;
    this.shouldResetSpinCycleWinDisplayed = false
}
StageSpin.prototype.GetStageName = function() {
    return UHTStageName.Spin
}
;
StageSpin.prototype.XTRegisterCallbacks = function() {}
;
StageSpin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetDouble(Vars.CurrentWinMultiplier, 1);
    XT.SetObject(Vars.SpinRoutineQueue, this.rq);
    XT.SetBool(Vars.SpinResultIsBigWin, false);
    XT.SetFloat(Vars.SpinDuration, 0)
}
;
StageSpin.prototype.UHTInit = function() {}
;
StageSpin.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        XT.SetFloat(Vars.SpinDuration, 0);
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        var respinData = XT.GetObject(Vars.RespinData);
        this.shouldResetSpinCycleWinDisplayed = (respinData == null || respinData.IsDone) && (!fsr.IsFreeSpin || fsr.IsLastFreeSpin);
        if (this.rq != null) {
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeSpinStart);
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnRQEnded,null,this));
            this.rq.StartRoutines()
        } else
            this.OnRQEnded(null);
        UHTEngine.RegisterUserInteraction()
    } else
        XT.SetFloat(Vars.SpinDuration, XT.GetFloat(Vars.SpinDuration) + Time.deltaTime);
    if (this.isRQEnded) {
        this.isRQEnded = false;
        if (!XT.GetBool(Vars.Logic_IsFreeSpin))
            if (XT.GetBool(Vars.ContinuousSpin))
                globalTracking.SendEvent("uht_spin", "started_turbo_spin_fastplay", XT.GetBool(Vars.FastPlay) ? 1 : 0, "SpinTracker");
            else
                globalTracking.SendEvent("uht_spin", "started_normal_spin_fastplay", XT.GetBool(Vars.FastPlay) ? 1 : 0, "SpinTracker");
        globalTracking.StartTimer("uht_spin", "time_response_received", "SpinTracker");
        globalTracking.StartTimer("uht_spin", "time_total", "SpinTracker");
        var respinData = XT.GetObject(Vars.RespinData);
        if (!XT.GetBool(Vars.Logic_IsFreeSpin) && (respinData == null || respinData.IsDone))
            UHTInterfaceBOSS.PostMessage("gameRoundStarted");
        UHTInterfaceBOSS.PostMessage("spinStarted");
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_Stop, this.OnPressedStop, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StartAutoplay, this.OnStartAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StopAutoplay, this.OnStopAutoplay, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_SpinEnded, this.OnSpinEnded, this);
        XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdatedFromResult, this.OnBalanceUpdated, this);
        XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BonusRoundsOnContinuePressed, this.OnBonusRoundsContinuePressed, this);
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        XT.TriggerEvent(Vars.Evt_ToServer_RequestSpin);
        XT.TriggerEvent(Vars.Evt_Internal_StopIdleSpinCounter);
        XT.TriggerEvent(Vars.Evt_Internal_SpinStarted);
        XT.SetBool(Vars.CanSpin, false);
        XT.SetBool(Vars.SkipNextBigWin, false);
        XT.SetInt(Vars.BigWinLevel, 0);
        XT.SetBool(Vars.SpinResultIsBigWin, false);
        XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, false);
        var brret = BonusRoundsController.HandleNextEvent(true, true, true);
        this.isBonusRounds = brret.isBonusRounds;
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        XT.SetDouble(Vars.CurrentWinMultiplier, 1);
        if (fsr.IsFreeSpin && !fsr.IsFreeSpinsCollected && !fsr.IsFreeSpinsGambled) {
            XT.SetDouble(Vars.CurrentWinMultiplier, fsr.TotalMultiplier);
            VSGameStateManager.ChangeTo(VSGameState.SpinFreeSpins)
        } else if (XT.GetInt(Vars.AutoplaySpinsLeft) >= 0)
            if (this.isBonusRounds)
                VSGameStateManager.ChangeTo(VSGameState.SpinBonusRoundsAutoplay);
            else
                VSGameStateManager.ChangeTo(VSGameState.SpinAutoplay);
        else if (this.isBonusRounds)
            VSGameStateManager.ChangeTo(VSGameState.SpinBonusRounds);
        else
            VSGameStateManager.ChangeTo(VSGameState.Spin);
        if (this.cat != null)
            this.cat.StartEvent(this.startEvent.id)
    } else {
        var brret = BonusRoundsController.HandleNextEvent(true, true, true);
        this.isBonusRounds = brret.isBonusRounds;
        if (!Globals.InputBlocked)
            if ((Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return) || XT.GetBool(Vars.ContinuousSpin)) && XT.GetBool(Vars.AllowFastStop))
                XT.TriggerEvent(Vars.Evt_Internal_ReelManager_StopSpin);
        if (this.spinEnded) {
            this.spinEnded = false;
            if (!XT.GetBool(Vars.Logic_IsFreeSpin)) {
                var timer = GLOBAL_TIME_RESPONSE_RECEIVED;
                if (timer > 0)
                    if (XT.GetInt(Vars.AutoplaySpinsLeft) >= 0)
                        globalTracking.SendEvent("uht_spin", "finished_autospin", timer, "SpinTracker");
                    else
                        globalTracking.SendEvent("uht_spin", "finished_manualspin", timer, "SpinTracker")
            }
            globalTracking.StopTimerAndSend("uht_spin", "time_total", "SpinTracker");
            UHTInterfaceBOSS.PostMessage("spinEnded");
            var fsr2 = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
            var respinData = XT.GetObject(Vars.RespinData);
            if (this.shouldResetSpinCycleWinDisplayed)
                XT.SetDouble(Vars.SpinCycleWinDisplayed, 0);
            var isEndOfSpinCycle = (respinData == null || respinData.IsDone) && (!fsr2.IsFreeSpin || fsr2.IsLastFreeSpin);
            if (isEndOfSpinCycle)
                if (!XT.GetBool(Vars.MustOpenBonus) && !XT.GetBool(Vars.FromServer_MustOpenFSBG) && XT.GetObject(Vars.GambleV2Data) == null)
                    UHTInterfaceBOSS.PostMessage("gameRoundEnded");
            XT.TriggerEvent(Vars.Evt_Internal_SpinEnded);
            if (XT.GetBool(Vars.TriggerBonusBeforeResult) && XT.GetBool(Vars.MustOpenBonus))
                if (XT.GetBool(BGVars.BonusDataReceived)) {
                    XT.SetBool(BGVars.BonusDataReceived, false);
                    XT.SetObject(Vars.FromStageName, this.GetStageName());
                    XT.SetObject(Vars.ToStageName, UHTStageName.Bonus);
                    return UHTAction.ChangeStage(UHTStageName.Transition)
                } else
                    return UHTAction.NoAction();
            if ((fsr2.IsFreeSpin || XT.GetBool(Vars.FromServer_MustOpenFSBG)) && (respinData == null || respinData.IsDone && fsr2.IsFreeSpinsStart || !fsr2.IsFreeSpinsStart)) {
                XT.SetObject(Vars.FromStageName, this.GetStageName());
                XT.SetObject(Vars.ToStageName, UHTStageName.ResultFreeSpin);
                return UHTAction.ChangeStage(UHTStageName.Transition)
            }
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.Result);
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
    }
    return UHTAction.NoAction()
}
;
StageSpin.prototype.UHTFinish = function() {
    XT.UnregisterCallbackEvent(this.OnSpinEnded, this);
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this);
    XT.UnregisterCallbackEvent(this.OnPressedStop, this);
    XT.UnregisterCallbackEvent(this.OnStartAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnStopAutoplay, this);
    XT.UnregisterCallbackEvent(this.OnBonusRoundsContinuePressed, this)
}
;
StageSpin.prototype.OnPressedStop = function() {
    if (XT.GetBool(Vars.AllowFastStop))
        XT.TriggerEvent(Vars.Evt_Internal_ReelManager_StopSpin)
}
;
StageSpin.prototype.OnSpinEnded = function() {
    this.spinEnded = true
}
;
StageSpin.prototype.OnBalanceUpdated = function() {
    XT.SetDouble(Vars.BalanceDisplayed, XT.GetDouble(Vars.BalanceReceived));
    XT.SetDouble(Vars.BonusBalance, XT.GetDouble(Vars.BonusBalanceReceived))
}
;
StageSpin.prototype.OnStopAutoplay = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, -1);
    if (this.isBonusRounds)
        VSGameStateManager.ChangeTo(VSGameState.SpinBonusRounds);
    else
        VSGameStateManager.ChangeTo(VSGameState.Spin)
}
;
StageSpin.prototype.OnBonusRoundsContinuePressed = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_ReloadGame)
}
;
StageSpin.prototype.OnStartAutoplay = function() {
    XT.SetInt(Vars.AutoplaySpinsLeft, XT.GetInt(Vars.AutoplaySpinsRequested));
    XT.SetInt(Vars.AutoplaySpinsLeftDisplayed, XT.GetInt(Vars.AutoplaySpinsLeft))
}
;
StageSpin.prototype.OnRQEnded = function(unused) {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr != null) {
        XT.SetInt(Vars.CurrentFreeSpinDisplayed, fsr.CurrentSpin);
        XT.SetInt(Vars.FreeSpinsLeftDisplayed, fsr.MaxSpins - fsr.CurrentSpin)
    }
    this.isRQEnded = true
}
;
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
StageGamble.prototype = Object.create(UHTStage.prototype);
StageGamble.prototype.constructor = StageGamble;
function StageGamble() {
    UHTStage.call(this);
    this.cat = null;
    this.startEvent = null;
    this.endEvent = null;
    this.lastGambleResponse = null;
    this.canPick = false;
    this.atLeastOnePick = false;
    this.mustHideGamble = false
}
StageGamble.prototype.GetStageName = function() {
    return UHTStageName.Gamble
}
;
StageGamble.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.Gamble_CurrentProgressObject, new GambleProgressObject)
}
;
StageGamble.prototype.UHTInit = function() {}
;
StageGamble.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        CoinManager.SetStrictBetMode(true);
        this.Init();
        var isCustom = XT.GetBool(Vars.GameHasCustomGamble);
        if (!isCustom)
            VSGameStateManager.ChangeTo(VSGameState.Gamble);
        else
            VSGameStateManager.ChangeTo(VSGameState.GambleCustom);
        if (this.cat != null)
            this.cat.StartEvent(this.startEvent.id)
    } else if (this.mustHideGamble) {
        this.mustHideGamble = false;
        XT.TriggerEvent(Vars.Evt_Internal_Gamble_ClearProgress);
        XT.SetDouble(Vars.WinReceived, XT.GetDouble(Vars.Gamble_CurrentBalance));
        XT.SetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion, true);
        if (this.cat != null)
            this.cat.StartEvent(this.endEvent.id);
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        if (fsr.IsFreeSpin && !fsr.IsFreeSpinsGambled) {
            XT.SetObject(Vars.FromStageName, this.GetStageName());
            XT.SetObject(Vars.ToStageName, UHTStageName.ResultFreeSpin);
            return UHTAction.ChangeStage(UHTStageName.Transition)
        }
        return UHTAction.ChangeStage(UHTStageName.Result)
    }
    return UHTAction.NoAction()
}
;
StageGamble.prototype.UHTFinish = function() {
    XT.UnregisterCallbackObject(this.OnResultReceived, this);
    XT.UnregisterCallbackEvent(this.OnPressedGambleCollect, this);
    XT.UnregisterCallbackEvent(this.OnMustCloseGamble, this);
    XT.UnregisterCallbackEvent(this.OnPick, this)
}
;
StageGamble.prototype.Init = function() {
    XT.RegisterCallbackObject(Vars.FromServer_GambleResult, this.OnResultReceived, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_GambleCollect, this.OnPressedGambleCollect, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_GambleClose, this.OnMustCloseGamble, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_GamblePick, this.OnPick, this);
    if (XT.GetObject(Vars.FromServer_GambleHistory) != null) {
        var history = XT.GetObject(Vars.FromServer_GambleHistory);
        XT.SetDouble(Vars.Gamble_CurrentBalance, history.WinAmount);
        XT.TriggerEvent(Vars.Evt_Internal_Gamble_DisplayHistory)
    }
    XT.SetDouble(Vars.Gamble_FinalBalanceDisplayed, 0);
    this.canPick = true;
    this.atLeastOnePick = false
}
;
StageGamble.prototype.OnPick = function() {
    if (this.canPick) {
        this.canPick = false;
        this.atLeastOnePick = true;
        XT.SetBool(Vars.SkipNextBigWin, false);
        XT.TriggerEvent(Vars.Evt_ToServer_GamblePicked)
    }
}
;
StageGamble.prototype.OnResultReceived = function(param) {
    this.lastGambleResponse = param;
    XT.SetDouble(Vars.Gamble_CurrentBalance, this.lastGambleResponse.GetBalance());
    XT.SetInt(Vars.Gamble_PickResult_ItemID, this.lastGambleResponse.GetCard());
    XT.TriggerEvent(Vars.Evt_Internal_Gamble_PickResult_Handled);
    switch (this.lastGambleResponse.GetState()) {
    case GamblingState.Win:
        XT.TriggerEvent(Vars.Evt_CodeToData_Gamble_PickResult_Win);
        break;
    case GamblingState.Lose:
        XT.TriggerEvent(Vars.Evt_CodeToData_Gamble_PickResult_Lose);
        break;
    case GamblingState.WinLimit:
        XT.TriggerEvent(Vars.Evt_CodeToData_Gamble_PickResult_WinLimit);
        break
    }
    this.canPick = true
}
;
StageGamble.prototype.OnMustCloseGamble = function() {
    this.mustHideGamble = true
}
;
StageGamble.prototype.OnPressedGambleCollect = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    if (XT.GetBool(Vars.LastWinIsCounting))
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    var bd = XT.GetObject(Vars.BonusData);
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (!this.atLeastOnePick) {
        if (bd != null && bd.isBonusGambled)
            XT.TriggerEvent(Vars.Evt_ToServer_BonusGameFinished);
        if (fsr != null && fsr.IsFreeSpinsGambled)
            XT.TriggerEvent(Vars.Evt_ToServer_OnFreeSpinsClosed)
    }
    if (bd != null)
        bd.isBonusGambled = false;
    XT.TriggerEvent(Vars.Evt_ToServer_RequestGambleClose);
    XT.TriggerEvent(Vars.Evt_Internal_GambleCloseCurrentResultWindow)
}
;
goog.require("UHT.Engine");
goog.require("UHT.UHTStage");
function TransitionHelperClass() {
    this.transitionCAT = null;
    this.fromStageName = UHTStageName.No_Stage;
    this.toStageName = UHTStageName.No_Stage
}
StageTransition.prototype = Object.create(UHTStage.prototype);
StageTransition.prototype.constructor = StageTransition;
function StageTransition() {
    UHTStage.call(this);
    this.transitions = [];
    this.toStageName = UHTStageName.No_Stage;
    this.fromStageName = UHTStageName.No_Stage;
    this.transitionCAT = null;
    this.transitionDone = false
}
StageTransition.prototype.GetStageName = function() {
    return UHTStageName.Transition
}
;
StageTransition.prototype.XTRegisterCallbacks = function() {}
;
StageTransition.prototype.XTInitVariablesAndEvents = function() {}
;
StageTransition.prototype.UHTInit = function() {}
;
StageTransition.prototype.UHTUpdate = function(isFirstFrame) {
    if (isFirstFrame) {
        this.fromStageName = XT.GetObject(Vars.FromStageName);
        this.toStageName = XT.GetObject(Vars.ToStageName);
        this.transitionCAT = this.GetCAT(this.fromStageName, this.toStageName);
        if (this.transitionCAT != null) {
            this.transitionCAT.RegisterCallback(0, this.TransitionToStageDone, this);
            this.transitionCAT.StartEvent(0)
        } else
            return UHTAction.ChangeStage(this.toStageName)
    } else if (this.transitionDone) {
        this.transitionDone = false;
        return UHTAction.ChangeStage(this.toStageName)
    }
    return UHTAction.NoAction()
}
;
StageTransition.prototype.UHTFinish = function() {
    if (this.transitionCAT != null)
        this.transitionCAT.StartEvent(1)
}
;
StageTransition.prototype.TransitionToStageDone = function(type, data) {
    if (type == CAT_Event.CallbackType.EndOfEvent)
        this.transitionDone = true
}
;
StageTransition.prototype.GetCAT = function(_fromStage, _toStage) {
    for (var index = 0; index < this.transitions.length; index++)
        if (this.transitions[index].fromStageName == _fromStage && this.transitions[index].toStageName == _toStage)
            return this.transitions[index].transitionCAT;
    return null
}
;
goog.provide("UHT.PaytableSymbolPayout_Ways");
goog.require("UHT.XTLink");
PaytableSymbolPayout_Ways.prototype = Object.create(XTLink.prototype);
PaytableSymbolPayout_Ways.prototype.constructor = PaytableSymbolPayout_Ways;
function PaytableSymbolPayout_Ways() {
    XTLink.call(this);
    this.symbolIndex = 0;
    this.isDisplayingCoins = false;
    this.isMultipliedByTotalBet = false;
    this.showOnlyValue = false;
    this.customPayoutData = null;
    this.formatOptions = null
}
PaytableSymbolPayout_Ways.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
}
;
PaytableSymbolPayout_Ways.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGameInit, this);
    XT.UnregisterCallbackEvent(this.UpdateSymbolPayoutInformation, this);
    XT.UnregisterCallbackBool(this.OnHasCoinsChanged, this)
}
;
PaytableSymbolPayout_Ways.prototype.OnGameInit = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_BetChanged, this.UpdateSymbolPayoutInformation, this);
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this);
    this.UpdateSymbolPayoutInformation()
}
;
PaytableSymbolPayout_Ways.prototype.OnHasCoinsChanged = function(param) {
    this.UpdateSymbolPayoutInformation()
}
;
PaytableSymbolPayout_Ways.prototype.UpdateSymbolPayoutInformation = function() {
    var payoutData = XT.GetObject(Vars.PaytablePayoutData);
    if (payoutData == null)
        return;
    this.gameObject.GetComponent(UILabel).text = this.GetProcessedText(this.customPayoutData.length == 0 ? payoutData[this.symbolIndex] : this.customPayoutData)
}
;
PaytableSymbolPayout_Ways.prototype.GetProcessedText = function(symbolPayoutData) {
    var symbolPayoutText = "";
    var multiplier = this.isMultipliedByTotalBet ? CoinManager.GetNextTotalBet() : CoinManager.GetNextBet();
    for (var payoutLineIndex = symbolPayoutData.length - 1; payoutLineIndex >= 0; payoutLineIndex--)
        if (symbolPayoutData[payoutLineIndex] > 0) {
            var realValueStr = "";
            if (this.isDisplayingCoins && XT.GetBool(Vars.HasCoins))
                realValueStr = CoinManager.ConvertMoneyToCoins(symbolPayoutData[payoutLineIndex] * multiplier).toString();
            else
                realValueStr = LocaleManager.FormatValue(symbolPayoutData[payoutLineIndex] * multiplier, this.formatOptions);
            symbolPayoutText += (this.showOnlyValue ? "" : (symbolPayoutText == "" ? "" : "\n") + (payoutLineIndex + 1) + " - ") + realValueStr
        }
    return symbolPayoutText
}
;
goog.require("UHT.Engine");
ReelFX.prototype = Object.create(XTLink.prototype);
ReelFX.prototype.constructor = ReelFX;
function ReelFX() {
    XTLink.call(this);
    this.reelIndex = 0;
    this.reelExcited = null;
    this.reelStop = null;
    this.reelStopWin = null;
    this.fastPlayReelExcited = null;
    this.fastPlayReelStop = null;
    this.fastPlayReelStopWin = null;
    this.reelStoppedFast = null;
    this.reelsExcited = null;
    this.numberOfReels = 0
}
ReelFX.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ExcitedReel, this.ReelExcited, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStopStarted, this.ReelStopped, this);
    XT.RegisterCallbackObject(Vars.ReelInitialPositions, this.OnReelPositions, this);
    XT.RegisterCallbackObject(Vars.ResultScreenSymbols, this.OnResultScreenSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnReelStoppedFast, this)
}
;
ReelFX.prototype.XTInitVariablesAndEvents = function() {}
;
ReelFX.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.ReelExcited, this);
    XT.UnregisterCallbackEvent(this.ReelStopped, this);
    XT.UnregisterCallbackObject(this.OnReelPositions, this);
    XT.UnregisterCallbackObject(this.OnResultScreenSymbols, this);
    XT.UnregisterCallbackEvent(this.OnReelStoppedFast, this)
}
;
ReelFX.prototype.OnResultScreenSymbols = function(resultScreenSymbols) {
    this.reelsExcited = [];
    for (var reIndex = 0; reIndex < this.numberOfReels; reIndex++)
        this.reelsExcited.push(false)
}
;
ReelFX.prototype.OnReelPositions = function(reelPos) {
    this.numberOfReels = reelPos.length;
    this.reelsExcited = []
}
;
ReelFX.prototype.ReelExcited = function() {
    var excitedReelIndex = XT.GetInt(Vars.LastExcitedReelIndex);
    this.reelsExcited[excitedReelIndex] = true;
    if (excitedReelIndex == this.reelIndex)
        if (XT.GetBool(Vars.FastPlay) && this.fastPlayReelExcited.cat != null)
            this.fastPlayReelExcited.Start();
        else
            this.reelExcited.Start()
}
;
ReelFX.prototype.ReelStopped = function() {
    var reelsStopped = XT.GetObject(Vars.LastStoppedReelIndices);
    var reelsStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    for (var rsIndex = 0; rsIndex < reelsStopped.length; rsIndex++)
        if (_array.indexOf(this.reelIndex, reelsStopOrder) <= _array.indexOf(reelsStopped[rsIndex], reelsStopOrder)) {
            this.reelExcited.Stop();
            if (this.fastPlayReelExcited.cat != null)
                this.fastPlayReelExcited.Stop();
            if (this.reelIndex == reelsStopped[rsIndex]) {
                var fastPlay = XT.GetBool(Vars.FastPlay);
                var reelwin = XT.GetObject(Vars.ReelsWinInfo)[this.reelIndex];
                var win = this.reelsExcited[this.reelIndex] && reelwin;
                if (win && this.reelStopWin.cat != null)
                    if (fastPlay && this.fastPlayReelStopWin.cat != null)
                        this.fastPlayReelStopWin.Start();
                    else
                        this.reelStopWin.Start();
                else if (fastPlay && this.fastPlayReelExcited.cat != null)
                    this.fastPlayReelStop.Start();
                else
                    this.reelStop.Start()
            }
        }
}
;
ReelFX.prototype.OnReelStoppedFast = function() {
    if (this.reelsExcited[this.reelIndex] && this.reelStoppedFast != null)
        this.reelStoppedFast.Start()
}
;
goog.provide("UHT.VS_Symbol");
goog.require("UHT.Engine");
goog.require("UHT.CAT_Event");
VS_Symbol.prototype = Object.create(Component.prototype);
VS_Symbol.prototype.constructor = VS_Symbol;
function VS_Symbol() {
    Component.call(this);
    this.symbolId = 0;
    this.willHighlightOffAfterExciteWin = true;
    this.eventNormal = null;
    this.eventSpinStart = null;
    this.eventSpinLoop = null;
    this.eventSpinStop = null;
    this.eventHighlightOff = null;
    this.eventHighlightOn = null;
    this.eventExcited = null;
    this.eventWinExcited = null;
    this.eventWinning = null;
    this.eventSpinLoopExcited = null;
    this.eventSpinLoopExcitedImportant = null;
    this.eventFSHighlightOff = null;
    this.eventStart = null;
    this.eventStop = null;
    this.currentStateForInspector = VS_Symbol.State.Invalid;
    this.internalState = VS_Symbol.State.Invalid;
    this.lastQueuedState = VS_Symbol.State.Invalid;
    this.commands = [];
    this.stopEventSent = false;
    this.canProcessNextCommand = true
}
VS_Symbol.State = {
    Invalid: 0,
    Normal: 1,
    HighlightOn: 2,
    HighlightOff: 3,
    SpinStart: 4,
    SpinLoop: 5,
    SpinStop: 6,
    Excited: 7,
    WinExcited: 8,
    SpinLoopExcited: 9,
    Winning: 10,
    FSHighlightOff: 11,
    SpinLoopExcitedImportant: 12
};
VS_Symbol.prototype.ChangeToState = function(newState) {
    this.commands.push(newState);
    this.lastQueuedState = newState;
    this.ProcessCommands()
}
;
VS_Symbol.prototype.Start = function() {
    this.eventNormal.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWinExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcitedImportant.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWinning.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventNormal.RegisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOn.RegisterCallback(this.Callback_EventEnded, this);
    this.eventHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStart.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinStop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWinExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSpinLoopExcitedImportant.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWinning.RegisterCallback(this.Callback_EventEnded, this);
    this.eventFSHighlightOff.RegisterCallback(this.Callback_EventEnded, this)
}
;
VS_Symbol.prototype.ProcessCommands = function() {
    if (this.commands.length > 0)
        if (this.canProcessNextCommand) {
            var newState = this.commands[0];
            this.commands.splice(0, 1);
            this.canProcessNextCommand = false;
            switch (newState) {
            case VS_Symbol.State.Normal:
                this.eventNormal.Start();
                break;
            case VS_Symbol.State.HighlightOn:
                this.eventHighlightOn.Start();
                break;
            case VS_Symbol.State.HighlightOff:
                this.eventHighlightOff.Start();
                break;
            case VS_Symbol.State.SpinStart:
                this.eventSpinStart.Start();
                break;
            case VS_Symbol.State.SpinLoop:
                this.eventSpinLoop.Start();
                break;
            case VS_Symbol.State.SpinStop:
                this.eventSpinStop.Start();
                break;
            case VS_Symbol.State.Excited:
                this.eventExcited.Start();
                break;
            case VS_Symbol.State.WinExcited:
                this.eventWinExcited.Start();
                break;
            case VS_Symbol.State.Winning:
                this.eventWinning.Start();
                break;
            case VS_Symbol.State.SpinLoopExcited:
                this.eventSpinLoopExcited.Start();
                break;
            case VS_Symbol.State.SpinLoopExcitedImportant:
                this.eventSpinLoopExcitedImportant.Start();
                break;
            case VS_Symbol.State.FSHighlightOff:
                this.eventFSHighlightOff.Start();
                break;
            case VS_Symbol.State.Invalid:
            default:
                this.canProcessNextCommand = true;
                break
            }
            this.internalState = newState;
            this.currentStateForInspector = this.internalState
        } else if (this.stopEventSent == false)
            this.StopAllRunningEvents()
}
;
VS_Symbol.prototype.Update = function() {
    this.ProcessCommands()
}
;
VS_Symbol.prototype.Callback_EventEnded = function(_type, data) {
    if (_type == CAT_Event.CallbackType.EndOfEvent)
        this.canProcessNextCommand = true
}
;
VS_Symbol.prototype.StopAllRunningEvents = function() {
    if (this.eventNormal.IsRunning())
        this.eventNormal.Stop();
    if (this.eventHighlightOn.IsRunning())
        this.eventHighlightOn.Stop();
    if (this.eventHighlightOff.IsRunning())
        this.eventHighlightOff.Stop();
    if (this.eventSpinStart.IsRunning())
        this.eventSpinStart.Stop();
    if (this.eventSpinLoop.IsRunning())
        this.eventSpinLoop.Stop();
    if (this.eventSpinStop.IsRunning())
        this.eventSpinStop.Stop();
    if (this.eventExcited.IsRunning())
        this.eventExcited.Stop();
    if (this.eventWinExcited.IsRunning())
        this.eventWinExcited.Stop();
    if (this.eventWinning.IsRunning())
        this.eventWinning.Stop();
    if (this.eventSpinLoopExcited.IsRunning())
        this.eventSpinLoopExcited.Stop();
    if (this.eventSpinLoopExcitedImportant.IsRunning())
        this.eventSpinLoopExcitedImportant.Stop();
    if (this.eventFSHighlightOff.IsRunning())
        this.eventFSHighlightOff.Stop()
}
;
VS_Symbol.prototype.SpinStart = function() {
    this.ChangeToState(VS_Symbol.State.SpinStart)
}
;
VS_Symbol.prototype.SpinLoop = function() {
    this.ChangeToState(VS_Symbol.State.SpinLoop)
}
;
VS_Symbol.prototype.SpinStop = function() {
    this.ChangeToState(VS_Symbol.State.SpinStop)
}
;
VS_Symbol.prototype.SetHighlightOn = function() {
    this.ChangeToState(VS_Symbol.State.HighlightOn)
}
;
VS_Symbol.prototype.SetHighlightOff = function() {
    if (this.internalState != VS_Symbol.State.WinExcited && this.internalState != VS_Symbol.State.Winning || this.willHighlightOffAfterExciteWin)
        if (XT.GetBool(Vars.Logic_IsFreeSpin))
            this.ChangeToState(VS_Symbol.State.FSHighlightOff);
        else
            this.ChangeToState(VS_Symbol.State.HighlightOff)
}
;
VS_Symbol.prototype.SetNormal = function() {
    this.ChangeToState(VS_Symbol.State.Normal)
}
;
VS_Symbol.prototype.SetExcited = function() {
    this.ChangeToState(VS_Symbol.State.Excited)
}
;
VS_Symbol.prototype.SetWinExcited = function() {
    this.ChangeToState(VS_Symbol.State.WinExcited)
}
;
VS_Symbol.prototype.SpinLoopExcited = function() {
    this.ChangeToState(VS_Symbol.State.SpinLoopExcited)
}
;
VS_Symbol.prototype.SpinLoopExcitedImportant = function() {
    this.ChangeToState(VS_Symbol.State.SpinLoopExcitedImportant)
}
;
VS_Symbol.prototype.SetWinning = function() {
    this.ChangeToState(VS_Symbol.State.Winning)
}
;
VS_Symbol.prototype.EventStart = function() {
    this.eventStart.Start()
}
;
VS_Symbol.prototype.EventStop = function() {
    this.eventStop.Start()
}
;
VS_Symbol.prototype.Reset = function() {
    this.commands = [];
    this.StopAllRunningEvents();
    this.canProcessNextCommand = true
}
;
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
goog.require("UHT.VS_Symbol");
VS_SymbolsManager.prototype = Object.create(XTLink.prototype);
VS_SymbolsManager.prototype.constructor = VS_SymbolsManager;
function VS_SymbolsManager() {
    XTLink.call(this);
    this.SpecialLoopsManager = null;
    this.hasOnlyLoops = false;
    this.pool = null;
    this.symbols = [];
    this.symbolIdToIndexMap = [];
    this.pooledSymbols = [];
    this.disablePoolNextFrame = false;
    this.defaultBufferAmount = 10;
    this.currentInitSymbol = -1
}
VS_SymbolsManager.initializing = 0;
VS_SymbolsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SymbolManager, this.OnSymbolManagerInit, this)
}
;
VS_SymbolsManager.prototype.XTInitVariablesAndEvents = function() {
    if (!this.hasOnlyLoops)
        XT.SetObject(Vars.SymbolsManagerObject, this)
}
;
VS_SymbolsManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSymbolManagerInit, this)
}
;
function SymbolsManager_CheckAndSendTrackingInit() {
    if (VS_SymbolsManager.initializing + Special_SymbolsManager.initializing == 0)
        globalTracking.StartTimer("uht_loading", "_X_symbolsManager_duration", "LoadingTracker")
}
function SymbolsManager_CheckAndSendTrackingEnd() {
    if (VS_SymbolsManager.initializing + Special_SymbolsManager.initializing == 0)
        globalTracking.StopTimerAndSend("uht_loading", "_X_symbolsManager_duration", "LoadingTracker")
}
VS_SymbolsManager.prototype.OnSymbolManagerInit = function() {
    SymbolsManager_CheckAndSendTrackingInit();
    VS_SymbolsManager.initializing++;
    this.currentInitSymbol = 0;
    this.BuildSymbolIdToIndexMap();
    this.pooledSymbols = [];
    this.pool.SetActive(true);
    if (LoaderProgress.SymbolsManagers_Total == -1)
        LoaderProgress.SymbolsManagers_Total = this.symbols.length;
    else
        LoaderProgress.SymbolsManagers_Total += this.symbols.length
}
;
VS_SymbolsManager.prototype.Update = function() {
    if (this.currentInitSymbol >= 0) {
        if (this.currentInitSymbol < this.symbols.length) {
            var id = this.symbols[this.currentInitSymbol].symbolId;
            this.pooledSymbols[id] = [];
            for (var n = 0; n < this.defaultBufferAmount; n++) {
                var newObj = instantiate(this.symbols[this.currentInitSymbol].gameObject);
                newObj.SetActive(true);
                this.PoolSymbol(id, newObj.GetComponent(VS_Symbol))
            }
            this.currentInitSymbol++;
            LoaderProgress.SymbolsManagers_Current++
        }
        if (this.currentInitSymbol == this.symbols.length) {
            this.disablePoolNextFrame = false;
            VS_SymbolsManager.initializing--;
            SymbolsManager_CheckAndSendTrackingEnd();
            this.currentInitSymbol++
        }
    }
}
;
VS_SymbolsManager.prototype.BuildSymbolIdToIndexMap = function() {
    var highestSymbolId = -1;
    for (var i = 0; i < this.symbols.length; i++)
        if (this.symbols[i].symbolId > highestSymbolId)
            highestSymbolId = this.symbols[i].symbolId;
    this.symbolIdToIndexMap = new Array(highestSymbolId + 1);
    for (var j = 0; j < this.symbols.length; j++)
        this.symbolIdToIndexMap[this.symbols[j].symbolId] = j
}
;
VS_SymbolsManager.prototype.GetFromPool = function(id, parent) {
    if (this.pooledSymbols[id].length == 0) {
        console.log("Symbol pool capacity is too small! ID = " + id);
        this.pooledSymbols[id].push(instantiate(this.symbols[this.symbolIdToIndexMap[id]].gameObject).GetComponent(VS_Symbol));
        this.pooledSymbols[id][this.pooledSymbols[id].length - 1].gameObject.SetActive(true)
    }
    var pooledObject = this.pooledSymbols[id][0];
    this.pooledSymbols[id].splice(0, 1);
    pooledObject.gameObject.transform.SetParent(parent.transform, false);
    pooledObject.gameObject.transform.localPosition(UHTMath.Vector3.zero);
    pooledObject.gameObject.transform.localRotation(UHTMath.Quaternion.euler(UHTMath.Vector3.zero));
    pooledObject.gameObject.transform.localScale(UHTMath.Vector3.one);
    return pooledObject
}
;
VS_SymbolsManager.prototype.PoolSymbol = function(id, obj) {
    obj.Reset();
    obj.gameObject.transform.SetParent(this.pool.transform, false);
    this.pooledSymbols[id].push(obj)
}
;
VS_SymbolsManager.prototype.GetSymbol = function(symbolId, parent, forLoop) {
    if (forLoop == true && this.SpecialLoopsManager != null)
        return this.SpecialLoopsManager.GetSymbol(symbolId, parent);
    return this.GetFromPool(symbolId, parent)
}
;
VS_SymbolsManager.prototype.RecycleSymbol = function(symbol, forLoop) {
    if (forLoop == true && this.SpecialLoopsManager != null)
        this.SpecialLoopsManager.RecycleSymbol(symbol);
    else
        this.PoolSymbol(symbol.symbolId, symbol)
}
;
VS_SymbolsManager.prototype.LateUpdate = function() {
    if (this.pool.activeSelf && this.currentInitSymbol > this.symbols.length) {
        if (!this.disablePoolNextFrame) {
            this.disablePoolNextFrame = true;
            return
        }
        this.pool.SetActive(false)
    }
}
;
goog.require("UHT.Engine");
goog.require("UHT.VS_Symbol");
goog.provide("UHT.VS_ReelSymbolHolder");
VS_ReelSymbolHolder.prototype = Object.create(XTLink.prototype);
VS_ReelSymbolHolder.prototype.constructor = VS_ReelSymbolHolder;
function VS_ReelSymbolHolder() {
    XTLink.call(this);
    this.startAnimation = null;
    this.startAnimationFastPlay = null;
    this.loopAnimation = null;
    this.stopAnimation = null;
    this.positionInReel = 0;
    this.orderedSymbolIdx = 0;
    this.parentReel = null;
    this.currentSymbol = null;
    this.eventStartDelay = 0;
    this.eventStartDelayFastPlay = 0;
    this.eventStopDelay = 0;
    this.canFireStartEvent = false;
    this.canFireStopEvent = false;
    this.animationState = null;
    this.animationTime = 0;
    this.animationIsUpdated = false;
    this.symbolIsLooper = false;
    this.speed = 1;
    this.linkedLooper = null;
    this.linkedLooperShouldBeDiscarded = false;
    this.linkedLooperOffsetY = 0;
    this.lastSymbolId = -1;
    this.rememberToChangeSymbolState = false;
    this.state = VS_ReelSymbolHolder.State.IDLE
}
VS_ReelSymbolHolder.State = {
    IDLE: 0,
    START: 1,
    LOOP: 2,
    STOP: 3
};
VS_ReelSymbolHolder.prototype.SetPositionInReel = function(pos) {
    this.positionInReel = pos
}
;
VS_ReelSymbolHolder.prototype.SetOrderedSymbolIdx = function(idx) {
    this.orderedSymbolIdx = idx
}
;
VS_ReelSymbolHolder.prototype.GetOrderedSymbolIdx = function() {
    return this.orderedSymbolIdx
}
;
VS_ReelSymbolHolder.prototype.SetParentReel = function(reel) {
    this.parentReel = reel
}
;
VS_ReelSymbolHolder.prototype.DiscardSymbol = function() {
    if (this.currentSymbol != null)
        this.parentReel.reelsManager.symbolsManager.RecycleSymbol(this.currentSymbol, this.symbolIsLooper);
    this.currentSymbol = null
}
;
VS_ReelSymbolHolder.prototype.ReplaceSymbol = function(idx, forLoop) {
    this.symbolIsLooper = forLoop == true;
    this.DiscardSymbol();
    this.currentSymbol = this.parentReel.reelsManager.symbolsManager.GetSymbol(idx, this.gameObject, this.symbolIsLooper);
    this.lastSymbolId = this.currentSymbol.symbolId
}
;
VS_ReelSymbolHolder.prototype.UpdateLinkedLooperPosition = function() {
    if (this.linkedLooper != null && XT.GetBool(Vars.CanUpdateLinkedLoopersPosition))
        this.linkedLooper.transform.localPosition(UHTMath.Vector3.sub(this.transform.localPosition(), new UHTMath.Vector3(0,this.linkedLooperOffsetY,0)))
}
;
VS_ReelSymbolHolder.prototype.SampleAnimation = function() {
    this.animationState.enabled = true;
    this.animationState.weight = 1;
    this.animationState.time = this.animationTime;
    this.gameObject.animation.Sample();
    this.animationState.enabled = false
}
;
VS_ReelSymbolHolder.prototype.UpdateVisual = function() {
    if (!this.animationIsUpdated)
        this.animationTime += Time.deltaTime * this.speed;
    else
        this.animationIsUpdated = false;
    if (this.rememberToChangeSymbolState && this.animationTime > 0) {
        this.rememberToChangeSymbolState = false;
        this.ChangeSymbolState()
    }
    switch (this.state) {
    case VS_ReelSymbolHolder.State.START:
        if (this.canFireStartEvent)
            if (this.animationTime >= (this.parentReel.reelsManager.isFastStart ? this.eventStartDelayFastPlay : this.eventStartDelay)) {
                this.canFireStartEvent = false;
                this.currentSymbol.EventStart()
            }
        if (this.animationTime > this.animationState.length) {
            this.state = VS_ReelSymbolHolder.State.IDLE;
            this.DiscardSymbol();
            this.parentReel.SymbolLeftTheReel(this.positionInReel, this.animationTime - this.animationState.length);
            if (this.linkedLooperShouldBeDiscarded) {
                this.linkedLooper.DiscardSymbol();
                this.linkedLooperShouldBeDiscarded = false
            }
            this.linkedLooper = null
        } else
            this.SampleAnimation();
        break;
    case VS_ReelSymbolHolder.State.LOOP:
        if (this.animationTime > this.animationState.length) {
            this.state = VS_ReelSymbolHolder.State.IDLE;
            this.DiscardSymbol();
            this.parentReel.SymbolLeftTheReel(this.positionInReel, this.animationTime - this.animationState.length)
        } else
            this.SampleAnimation();
        break;
    case VS_ReelSymbolHolder.State.STOP:
        if (this.canFireStopEvent)
            if (this.animationTime >= this.eventStopDelay) {
                this.canFireStopEvent = false;
                this.currentSymbol.EventStop()
            }
        if (this.animationTime > this.animationState.length) {
            this.animationTime = this.animationState.length;
            this.state = VS_ReelSymbolHolder.State.IDLE;
            this.parentReel.StopFinished(this.positionInReel)
        }
        this.SampleAnimation();
        break;
    default:
        break
    }
}
;
VS_ReelSymbolHolder.prototype.AfterUpdateVisual = function() {
    this.animationIsUpdated = false;
    this.UpdateLinkedLooperPosition()
}
;
VS_ReelSymbolHolder.prototype.StartAnimation = function(clip, startTime) {
    this.gameObject.animation.clip = clip;
    this.animationState = this.gameObject.animation.GetAnimationState(clip.name);
    this.animationTime = startTime;
    this.SampleAnimation();
    this.animationIsUpdated = true;
    this.parentReel.UpdateSortedSymbolHolders()
}
;
VS_ReelSymbolHolder.prototype.PlayStart = function() {
    this.rememberToChangeSymbolState = false;
    this.canFireStartEvent = true;
    this.state = VS_ReelSymbolHolder.State.START;
    this.StartAnimation(this.GetStartAnimation(), 0);
    this.currentSymbol.SpinStart();
    if (this.linkedLooper != null)
        this.linkedLooper.currentSymbol.SpinStart()
}
;
VS_ReelSymbolHolder.prototype.PlayLoop = function(startTime) {
    this.rememberToChangeSymbolState = false;
    this.state = VS_ReelSymbolHolder.State.LOOP;
    this.StartAnimation(this.loopAnimation, startTime);
    if (this.parentReel.reelsManager.showTopBottomSymbols && startTime < 0)
        this.rememberToChangeSymbolState = true;
    else
        this.ChangeSymbolState()
}
;
VS_ReelSymbolHolder.prototype.ChangeSymbolState = function() {
    if (this.currentSymbol == null)
        return;
    if (this.parentReel.isExcited)
        if (this.parentReel.ExcitedImportantSymbols[this.currentSymbol.symbolId])
            this.currentSymbol.SpinLoopExcitedImportant();
        else
            this.currentSymbol.SpinLoopExcited();
    else
        this.currentSymbol.SpinLoop()
}
;
VS_ReelSymbolHolder.prototype.PlayStop = function(startTime) {
    this.rememberToChangeSymbolState = false;
    this.canFireStopEvent = true;
    this.state = VS_ReelSymbolHolder.State.STOP;
    this.StartAnimation(this.stopAnimation, startTime);
    this.currentSymbol.SpinStop();
    if (this.linkedLooper != null)
        this.linkedLooper.currentSymbol.SpinStop()
}
;
VS_ReelSymbolHolder.prototype.GetStartAnimation = function() {
    return this.parentReel.reelsManager.isFastStart ? this.startAnimationFastPlay : this.startAnimation
}
;
goog.require("UHT.Engine");
goog.require("UHT.VS_ReelSymbolHolder");
goog.provide("UHT.VS_Reel");
VS_Reel.prototype = Object.create(Component.prototype);
VS_Reel.prototype.constructor = VS_Reel;
function VS_Reel() {
    Component.call(this);
    this.reelsManager = null;
    this.symbolHolders = [];
    this.symbolLoopHolders = [];
    this.sortedSymbolHolders = [];
    this.stopOffset = 1;
    this.spinInPlace = false;
    this.loopDelayAfterStart = 0;
    this.loopDelayAfterFastStart = 0;
    this.reelIndex = 0;
    this.isExcited = false;
    this.ExcitedImportantSymbols = null;
    this.randomStop = false;
    this.randomStopDelay = .25;
    this.looperIdx = -1;
    this.mustStop = false;
    this.stopIdx = 0;
    this.symbolList = [];
    this.stopPosition = 0;
    this.rememberedStopPosition = 0;
    this.currentPosition = 0;
    this.holdersSpinning = 0;
    this.internalCounterInPlace = 0;
    this.randomizedStopIdx = [];
    this.willRandomStopIdx = 0;
    this.randomStopTimer = 0;
    this.cs_stopCounter = 0;
    this.mustSortHolders = false;
    this.speedCurveTimer = 0;
    this.speedCurve = null;
    this.reelScreenSymbols = []
}
VS_Reel.prototype.InitReel = function() {
    for (var i = 0; i < this.symbolHolders.length; i++) {
        this.symbolHolders[i].SetParentReel(this);
        this.symbolHolders[i].SetPositionInReel(i);
        this.sortedSymbolHolders.push(this.symbolHolders[i])
    }
    this.symbolHolders[0].linkedLooperOffsetY = this.symbolHolders[1].transform.localPosition().y - this.symbolHolders[0].transform.localPosition().y;
    this.symbolHolders[this.symbolHolders.length - 1].linkedLooperOffsetY = this.symbolHolders[this.symbolHolders.length - 2].transform.localPosition().y - this.symbolHolders[this.symbolHolders.length - 1].transform.localPosition().y;
    for (var j = 0; j < this.symbolLoopHolders.length; j++) {
        this.symbolLoopHolders[j].SetParentReel(this);
        this.symbolLoopHolders[j].SetPositionInReel(j);
        this.sortedSymbolHolders.push(this.symbolLoopHolders[j])
    }
    this.UpdateSortedSymbolHolders();
    this.randomizedStopIdx = new Array(this.symbolHolders.length)
}
;
VS_Reel.prototype.SetScreenSymbols = function(ssList) {
    for (var i = 0; i < this.symbolHolders.length; i++) {
        this.symbolHolders[this.symbolHolders.length - 1 - i].ReplaceSymbol(ssList[this.reelIndex][i]);
        this.symbolHolders[i].SetOrderedSymbolIdx(i * this.reelsManager.reels.length + this.reelIndex)
    }
    var pos = this.currentPosition;
    for (var j = 0; j < this.symbolHolders.length; j++)
        this.currentPosition--;
    this.currentPosition += ssList[this.reelIndex].length;
    this.currentPosition %= ssList[this.reelIndex].length;
    var topSymbol;
    var bottomSymbol;
    if (XT.GetBool(Vars.HiddenMathematics)) {
        var symbolsAbove = XT.GetObject(Vars.SymbolsAboveReels);
        topSymbol = symbolsAbove[this.reelIndex];
        var symbolsBelow = XT.GetObject(Vars.SymbolsBelowReels);
        bottomSymbol = symbolsBelow[this.reelIndex]
    } else {
        topSymbol = ssList[this.reelIndex][pos % ssList[this.reelIndex].length];
        bottomSymbol = ssList[this.reelIndex][this.currentPosition % ssList[this.reelIndex].length]
    }
    this.AddBottomLinkedLooperSymbol(bottomSymbol);
    this.AddTopLinkedLooperSymbol(topSymbol);
    this.UpdateSortedSymbolHolders()
}
;
VS_Reel.prototype.GetNextSymbol = function() {
    if (this.mustStop)
        if (this.reelsManager.stopOnScreenSymbols || this.reelsManager.forceStopOnScreenSymbols) {
            this.stopPosition--;
            this.stopPosition += this.symbolList.length;
            this.stopPosition %= this.symbolList.length;
            return this.GetReelScreenSymbols(XT.GetObject(Vars.ResultScreenSymbols))[this.cs_stopCounter++]
        } else if (this.reelsManager.stopOnInitialScreenSymbols) {
            this.stopPosition--;
            this.stopPosition += this.symbolList.length;
            this.stopPosition %= this.symbolList.length;
            return this.GetReelScreenSymbols(XT.GetObject(Vars.InitialResultScreenSymbols))[this.cs_stopCounter++]
        } else {
            var pos = this.stopPosition;
            this.stopPosition--;
            this.stopPosition += this.symbolList.length;
            this.stopPosition %= this.symbolList.length;
            return this.symbolList[pos % this.symbolList.length]
        }
    else {
        var pos2 = this.currentPosition;
        this.currentPosition--;
        this.currentPosition += this.symbolList.length;
        this.currentPosition %= this.symbolList.length;
        return this.symbolList[pos2 % this.symbolList.length]
    }
}
;
VS_Reel.prototype.GetNextSymbolInPlace = function(positionInReel) {
    if (this.mustStop) {
        var pos = this.stopPosition - (this.symbolHolders.length - 1 - positionInReel);
        pos += this.symbolList.length;
        pos %= this.symbolList.length;
        return this.symbolList[pos]
    } else {
        this.internalCounterInPlace++;
        if (this.internalCounterInPlace == this.symbolHolders.length) {
            this.internalCounterInPlace = 0;
            this.currentPosition -= this.symbolHolders.length;
            this.currentPosition += this.symbolList.length;
            this.currentPosition %= this.symbolList.length
        }
        var pos2 = this.currentPosition - positionInReel;
        pos2 += this.symbolList.length;
        pos2 %= this.symbolList.length;
        return this.symbolList[pos2]
    }
}
;
VS_Reel.prototype.RandomizeStops = function() {
    var allpos = [];
    for (var i = 0; i < this.randomizedStopIdx.length; i++)
        allpos.push(i);
    for (var j = 0; j < this.randomizedStopIdx.length; j++) {
        var idx = Random.Range(0, allpos.length);
        this.randomizedStopIdx[j] = allpos[idx];
        for (var k = 0; k < allpos.length; k++)
            if (allpos[k] == allpos[idx])
                allpos.splice(k, 1)
    }
}
;
VS_Reel.prototype.SetPosition = function(pos) {
    this.currentPosition = Random.Range(0, this.symbolList.length) % this.symbolList.length
}
;
VS_Reel.prototype.SetStopPosition = function(pos) {
    this.stopPosition = (pos + this.stopOffset) % this.symbolList.length;
    this.rememberedStopPosition = this.stopPosition
}
;
VS_Reel.prototype.SetSymbolList = function(list) {
    this.symbolList = [];
    for (var i = 0; i < list.length; i++)
        this.symbolList.push(list[i])
}
;
VS_Reel.prototype.Start = function() {}
;
VS_Reel.prototype.SetSpeedCurve = function(curve) {
    this.speedCurveTimer = 0;
    this.speedCurve = curve
}
;
VS_Reel.prototype.Update = function() {
    var speed = 1;
    if (this.speedCurve != null) {
        speed = this.speedCurve.Evaluate(this.speedCurveTimer);
        this.speedCurveTimer += Time.deltaTime
    }
    var i;
    for (i = this.symbolHolders.length - 1; i >= 0; i--) {
        this.symbolHolders[i].speed = speed;
        this.symbolHolders[i].UpdateVisual()
    }
    var loopersLeft = this.symbolLoopHolders.length;
    var currentLooper = (this.looperIdx + 1) % this.symbolLoopHolders.length;
    while (loopersLeft > 0) {
        this.symbolLoopHolders[currentLooper].speed = speed;
        this.symbolLoopHolders[currentLooper].UpdateVisual();
        currentLooper = (currentLooper + 1) % this.symbolLoopHolders.length;
        loopersLeft--
    }
    for (var i3 = 0; i3 < this.symbolHolders.length; i3++)
        this.symbolHolders[i3].AfterUpdateVisual();
    for (var i4 = 0; i4 < this.symbolLoopHolders.length; i4++)
        this.symbolLoopHolders[i4].AfterUpdateVisual();
    this.randomStopTimer += Time.deltaTime
}
;
VS_Reel.prototype.GetFreeLooper = function() {
    this.looperIdx++;
    this.looperIdx %= this.symbolLoopHolders.length;
    return this.looperIdx
}
;
VS_Reel.prototype.NewLoop = function(positionInReel, extraTime) {
    var rsh;
    if (this.spinInPlace) {
        rsh = this.symbolLoopHolders[positionInReel];
        rsh.ReplaceSymbol(this.GetNextSymbolInPlace(positionInReel), true)
    } else if (positionInReel == -1 && this.symbolHolders[0].linkedLooper != null)
        rsh = this.symbolHolders[0].linkedLooper;
    else {
        rsh = this.symbolLoopHolders[this.GetFreeLooper()];
        rsh.ReplaceSymbol(this.GetNextSymbol(), true)
    }
    rsh.PlayLoop(extraTime)
}
;
VS_Reel.prototype.StartSpin = function() {
    this.mustStop = false;
    this.holdersSpinning = this.symbolHolders.length;
    for (var i1 = 0; i1 < this.symbolHolders.length; i1++)
        this.symbolHolders[i1].PlayStart();
    if (!this.spinInPlace)
        this.SymbolLeftTheReel(-1, -this.GetLoopDelayAfterStart());
    this.internalCounterInPlace = 0;
    this.RandomizeStops();
    this.willRandomStopIdx = 0;
    this.randomStopTimer = this.randomStopDelay
}
;
VS_Reel.prototype.AddLinkedLooper = function(holderIdx, symbolIdx, mustDiscardOnLeavingReel) {
    if (!this.reelsManager.showTopBottomSymbols)
        return;
    var looper = this.GetFreeLooper();
    this.symbolLoopHolders[looper].ReplaceSymbol(symbolIdx);
    this.symbolLoopHolders[looper].currentSymbol.SpinStop();
    this.symbolHolders[holderIdx].linkedLooper = this.symbolLoopHolders[looper];
    this.symbolHolders[holderIdx].UpdateLinkedLooperPosition();
    this.symbolHolders[holderIdx].linkedLooperShouldBeDiscarded = mustDiscardOnLeavingReel
}
;
VS_Reel.prototype.AddTopLinkedLooperSymbol = function(symbolIdx) {
    this.AddLinkedLooper(0, symbolIdx, false)
}
;
VS_Reel.prototype.AddBottomLinkedLooperSymbol = function(symbolIdx) {
    this.AddLinkedLooper(this.symbolHolders.length - 1, symbolIdx, true)
}
;
VS_Reel.prototype.AddTopLinkedLooper = function() {
    var topSymbol;
    if (XT.GetBool(Vars.HiddenMathematics)) {
        var symbolsAbove = XT.GetObject(Vars.SymbolsAboveReels);
        topSymbol = symbolsAbove[this.reelIndex]
    } else
        topSymbol = this.symbolList[this.currentPosition % this.symbolList.length];
    this.AddTopLinkedLooperSymbol(topSymbol)
}
;
VS_Reel.prototype.AddBottomLinkedLooper = function() {
    var bottomSymbol;
    if (XT.GetBool(Vars.HiddenMathematics)) {
        var symbolsBelow = XT.GetObject(Vars.SymbolsBelowReels);
        bottomSymbol = symbolsBelow[this.reelIndex]
    } else
        bottomSymbol = this.symbolList[(this.currentPosition + this.symbolHolders.length) % this.symbolList.length];
    this.AddBottomLinkedLooperSymbol(bottomSymbol)
}
;
VS_Reel.prototype.GetLooperTimersAndCleanUp = function(template) {
    var list = [];
    var loopAnimationTime = this.symbolLoopHolders[0].loopAnimation.length;
    var lowestStartSymbolId = -1;
    var i;
    for (i = 0; i < this.symbolHolders.length; i++) {
        if (this.symbolHolders[i].state == VS_ReelSymbolHolder.State.START) {
            var capped = this.symbolHolders[i].animationTime;
            if (capped < this.GetLoopDelayAfterStart())
                capped = this.GetLoopDelayAfterStart();
            var loopOffset = loopAnimationTime - (this.symbolHolders[i].GetStartAnimation().length - capped);
            if (loopOffset < 0)
                loopOffset = 0;
            list.push(loopOffset);
            lowestStartSymbolId = this.symbolHolders[i].currentSymbol.symbolId;
            this.symbolHolders[i].DiscardSymbol();
            this.symbolHolders[i].state = VS_ReelSymbolHolder.State.IDLE
        }
        if (this.symbolHolders[i].state == VS_ReelSymbolHolder.State.STOP) {
            list.push(this.symbolHolders[i].animationTime);
            this.symbolHolders[i].DiscardSymbol();
            this.symbolHolders[i].state = VS_ReelSymbolHolder.State.IDLE
        }
        if (this.symbolHolders[i].linkedLooper)
            if (this.symbolHolders[i].linkedLooperShouldBeDiscarded)
                this.symbolHolders[i].linkedLooper.DiscardSymbol();
        this.symbolHolders[i].linkedLooper = null
    }
    var mostAdvancedLooperSymbolId = -1;
    var maxLoopTime = -1;
    for (i = 0; i < this.symbolLoopHolders.length; i++)
        if (this.symbolLoopHolders[i].state == VS_ReelSymbolHolder.State.LOOP) {
            var aTime = this.symbolLoopHolders[i].animationTime;
            if (aTime < 0)
                aTime = 0;
            list.push(aTime);
            if (aTime > maxLoopTime) {
                mostAdvancedLooperSymbolId = this.symbolLoopHolders[i].currentSymbol.symbolId;
                maxLoopTime = aTime
            }
        }
    for (i = 0; i < this.symbolLoopHolders.length; i++) {
        this.symbolLoopHolders[i].DiscardSymbol();
        this.symbolLoopHolders[i].state = VS_ReelSymbolHolder.State.IDLE
    }
    if (template != null)
        list = template;
    else {
        list.sort(function(a, b) {
            return a - b
        });
        this.reelsManager.fastStopTimeUntilFinish = this.symbolHolders[0].stopAnimation.length - list[0]
    }
    if (list.length > this.symbolHolders.length && !this.reelsManager.showTopBottomSymbols) {
        var extraLooperNeeded = true;
        if (lowestStartSymbolId != -1)
            this.symbolLoopHolders[0].ReplaceSymbol(lowestStartSymbolId);
        else if (mostAdvancedLooperSymbolId != -1)
            this.symbolLoopHolders[0].ReplaceSymbol(mostAdvancedLooperSymbolId);
        else
            extraLooperNeeded = false;
        if (extraLooperNeeded)
            this.symbolLoopHolders[0].PlayLoop(list[this.symbolHolders.length])
    }
    this.AddBottomLinkedLooper();
    this.AddTopLinkedLooper();
    return list
}
;
VS_Reel.prototype.StopSpin = function(fastStop, template) {
    this.cs_stopCounter = 0;
    this.stopPosition = this.rememberedStopPosition;
    this.mustStop = true;
    this.stopIdx = this.symbolHolders.length - 1;
    if (this.reelsManager.instantStop && fastStop && this.holdersSpinning == this.symbolHolders.length) {
        var timers = this.GetLooperTimersAndCleanUp(template);
        var holderIdx = this.stopIdx;
        while (holderIdx >= 0) {
            this.symbolHolders[holderIdx].ReplaceSymbol(this.GetNextSymbol());
            this.symbolHolders[holderIdx].PlayStop(timers[holderIdx]);
            holderIdx--
        }
        this.stopIdx = -1;
        return timers
    }
    return null
}
;
VS_Reel.prototype.SymbolLeftTheReel = function(positionInReel, extraTime) {
    if (this.mustStop)
        if (this.spinInPlace)
            if (!this.randomStop) {
                this.symbolHolders[positionInReel].ReplaceSymbol(this.GetNextSymbolInPlace(positionInReel));
                this.symbolHolders[positionInReel].PlayStop(extraTime)
            } else if (this.randomStop && this.randomStopTimer >= this.randomStopDelay && positionInReel == this.randomizedStopIdx[this.willRandomStopIdx]) {
                this.symbolHolders[positionInReel].ReplaceSymbol(this.GetNextSymbolInPlace(positionInReel));
                this.symbolHolders[positionInReel].PlayStop(extraTime);
                this.willRandomStopIdx++;
                this.randomStopTimer = 0
            } else
                this.NewLoop(positionInReel, extraTime);
        else if (this.stopIdx >= 0) {
            this.symbolHolders[this.stopIdx].ReplaceSymbol(this.GetNextSymbol());
            this.symbolHolders[this.stopIdx].PlayStop(extraTime);
            this.stopIdx--
        } else {
            var topSymbol;
            var bottomSymbol;
            if (XT.GetBool(Vars.HiddenMathematics)) {
                var symbolsAbove = XT.GetObject(Vars.SymbolsAboveReels);
                topSymbol = symbolsAbove[this.reelIndex];
                var symbolsBelow = XT.GetObject(Vars.SymbolsBelowReels);
                bottomSymbol = symbolsBelow[this.reelIndex]
            } else {
                topSymbol = this.symbolList[this.currentPosition % this.symbolList.length];
                bottomSymbol = this.symbolLoopHolders[positionInReel].lastSymbolId
            }
            this.AddBottomLinkedLooperSymbol(bottomSymbol);
            this.AddTopLinkedLooperSymbol(topSymbol)
        }
    else
        this.NewLoop(positionInReel, extraTime)
}
;
VS_Reel.prototype.StopFinished = function(positionInReel) {
    this.holdersSpinning--;
    if (this.holdersSpinning == 0) {
        this.reelsManager.StopFinished(this.reelIndex);
        this.currentPosition = this.stopPosition;
        this.speedCurve = null
    }
}
;
VS_Reel.prototype.GetLoopDelayAfterStart = function() {
    return this.reelsManager.isFastStart ? this.loopDelayAfterFastStart : this.loopDelayAfterStart
}
;
VS_Reel.prototype.UpdateSortedSymbolHolders = function() {
    if (this.sortedSymbolHolders != null && this.mustSortHolders)
        this.sortedSymbolHolders.sort(function(symbolHolder1, symbolHolder2) {
            return symbolHolder2.transform._dangerous_get_localPosition().y - symbolHolder1.transform._dangerous_get_localPosition().y
        })
}
;
VS_Reel.prototype.SetSymbolsToNormal = function() {
    for (var i = 0; i < this.symbolHolders.length; i++)
        if (this.symbolHolders[i].currentSymbol != null)
            this.symbolHolders[i].currentSymbol.SetNormal()
}
;
VS_Reel.prototype.GetReelScreenSymbols = function(reelsSymbols) {
    if (XT.GetBool(Vars.HiddenMathematics) && this.symbolHolders.length > reelsSymbols[this.reelIndex].length) {
        if (this.cs_stopCounter == 0) {
            this.reelScreenSymbols.splice(0);
            this.reelScreenSymbols.push(XT.GetObject(Vars.SymbolsAboveReels)[this.reelIndex]);
            for (var i = 0; i < reelsSymbols[this.reelIndex].length; ++i)
                this.reelScreenSymbols.push(reelsSymbols[this.reelIndex][i]);
            this.reelScreenSymbols.push(XT.GetObject(Vars.SymbolsBelowReels)[this.reelIndex])
        }
        return this.reelScreenSymbols
    }
    return reelsSymbols[this.reelIndex]
}
;
goog.require("UHT.XTLink");
goog.require("UHT.VS_Reel");
VS_ReelsManager.prototype = Object.create(XTLink.prototype);
VS_ReelsManager.prototype.constructor = VS_ReelsManager;
function SpinAnimationsSpeedCurves() {
    this.startNormal = null;
    this.startFS = null;
    this.stopNormal = null;
    this.stopFS = null;
    this.stopCustom = null;
    this.stopExcitedNormal = null;
    this.stopExcitedFS = null;
    this.excitedNormal = null;
    this.excitedFS = null;
    this.excitedCustom = null
}
function VS_ReelsManager() {
    XTLink.call(this);
    this.symbolsManager = null;
    this.reels = [];
    this.reelsStartOrder = null;
    this.reelsStopOrder = null;
    this.reelDelayStart = .1;
    this.reelDelayStop = .15;
    this.extraReelDelayStop = null;
    this.extraReelDelayStart = null;
    this.autoStopDelay = 1.5;
    this.stopOnScreenSymbols = true;
    this.stopOnInitialScreenSymbols = false;
    this.forceStopOnScreenSymbols = false;
    this.instantStop = false;
    this.startFasterInFastPlay = false;
    this.isFastStart = false;
    this.useCustomSpinCurves = null;
    this.autoStopTimer = 0;
    this.reelsSpinning = 0;
    this.startTimer = 0;
    this.reelToStart = 0;
    this.stopTimer = 0;
    this.reelToStop = 0;
    this.fastStop = false;
    this.rememberToStop = false;
    this.resultReceived = false;
    this.isStoppingFast = false;
    this.mustStopStoppingReels = false;
    this.reelIdxList = [];
    this.exciter = null;
    this.nextReels = [];
    this.fastStopTimers = null;
    this.fastStopTimeUntilFinish = 0;
    this.showTopBottomSymbols = false;
    this.justVisualSymbols = 0;
    this.blankSymbolId = 0;
    this.continuousSpinTimer = 0;
    this.logicIsFS = false;
    this.state = VS_ReelsManager.State.IDLE;
    this.spinCurves = null
}
VS_ReelsManager.prototype.scriptUpdatePriority = 3;
VS_ReelsManager.State = {
    IDLE: 0,
    STARTING: 1,
    SPINNING: 2,
    STOPPING: 3
};
VS_ReelsManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.ReelSymbols, this.OnReelSymbols, this);
    XT.RegisterCallbackObject(Vars.NextReelSymbols, this.OnNextReelSymbols, this);
    XT.RegisterCallbackObject(Vars.ReelInitialPositions, this.OnReelPositions, this);
    XT.RegisterCallbackObject(Vars.ExcitedImportantSymbols, this.OnExcitedImportantSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_ReelsManager, this.OnReelsManagerInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnStartSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnStopSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.OnSpinResultReceived, this);
    XT.RegisterCallbackBool(Vars.AllowFastStop, this.SetAllowFastStop, this)
}
;
VS_ReelsManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.ReelsManagerObject, this);
    XT.SetObject(Vars.ReelsStartOrder, this.reelsStartOrder);
    XT.SetObject(Vars.ReelsStartOrderDefault, this.reelsStartOrder);
    XT.SetObject(Vars.ReelsStopOrder, this.reelsStopOrder);
    XT.SetObject(Vars.ReelsStopOrderDefault, this.reelsStopOrder);
    XT.SetObject(Vars.ExtraReelDelayStop, this.extraReelDelayStop);
    XT.SetObject(Vars.ExtraReelDelayStopDefault, this.extraReelDelayStop);
    XT.SetObject(Vars.ExtraReelDelayStart, this.extraReelDelayStart);
    XT.SetObject(Vars.ExtraReelDelayStartDefault, this.extraReelDelayStart);
    XT.SetBool(Vars.ContinuousSpin, false);
    XT.SetBool(Vars.ForceContinuousSpin, false);
    XT.SetBool(Vars.AutoplayContinuousSpin, false);
    XT.SetBool(Vars.CanUpdateLinkedLoopersPosition, true);
    if (this.useCustomSpinCurves == null || this.useCustomSpinCurves.length == 0)
        this.useCustomSpinCurves = _array.create(this.reels.length, false);
    var reelsCanBeExcited = _array.create(this.reels.length, true);
    XT.SetObject(Vars.ReelsCanBeExcited, reelsCanBeExcited);
    this.PrepareVariables()
}
;
VS_ReelsManager.prototype.PrepareVariables = function() {
    var i = 0;
    if (this.reelsStartOrder.length < this.reels.length) {
        this.reelsStartOrder = _array.create(this.reels.length, 0);
        for (i = 0; i < this.reelsStartOrder.length; i++)
            this.reelsStartOrder[i] = i;
        XT.SetObject(Vars.ReelsStartOrder, this.reelsStartOrder);
        XT.SetObject(Vars.ReelsStartOrderDefault, this.reelsStartOrder)
    }
    if (this.reelsStopOrder.length < this.reels.length) {
        this.reelsStopOrder = _array.create(this.reels.length, 0);
        for (i = 0; i < this.reelsStopOrder.length; i++)
            this.reelsStopOrder[i] = i;
        XT.SetObject(Vars.ReelsStopOrder, this.reelsStopOrder);
        XT.SetObject(Vars.ReelsStopOrderDefault, this.reelsStopOrder)
    }
    if (this.extraReelDelayStop.length < this.reels.length) {
        this.extraReelDelayStop = _array.create(this.reels.length, 0);
        for (i = 0; i < this.extraReelDelayStop.length; i++)
            this.extraReelDelayStop[i] = 0;
        XT.SetObject(Vars.ExtraReelDelayStop, this.extraReelDelayStop);
        XT.SetObject(Vars.ExtraReelDelayStopDefault, this.extraReelDelayStop)
    }
    if (this.extraReelDelayStart.length < this.reels.length) {
        this.extraReelDelayStart = _array.create(this.reels.length, 0);
        for (i = 0; i < this.extraReelDelayStart.length; i++)
            this.extraReelDelayStart[i] = 0;
        XT.SetObject(Vars.ExtraReelDelayStart, this.extraReelDelayStart);
        XT.SetObject(Vars.ExtraReelDelayStartDefault, this.extraReelDelayStart)
    }
}
;
VS_ReelsManager.prototype.OnReelsManagerInit = function() {
    if (XT.GetBool(Vars.HiddenMathematics))
        if (!this.stopOnScreenSymbols)
            this.stopOnInitialScreenSymbols = true;
    for (var i = 0; i < this.reels.length; i++) {
        this.reels[i].InitReel();
        this.reels[i].reelsManager = this;
        this.reels[i].reelIndex = i
    }
    this.InitFirstScreenSymbols();
    this.BuildOrderedHoldersList();
    this.SetAllSymbolsToNormal()
}
;
VS_ReelsManager.prototype.OnReelSymbols = function(rsList) {
    for (var i = 0; i < this.reels.length; i++)
        this.reels[i].SetSymbolList(rsList[i]);
    this.exciter = XT.GetObject(Vars.SpinExciterObject)
}
;
VS_ReelsManager.prototype.OnNextReelSymbols = function(rsList) {
    this.nextReels = [];
    for (var i = 0; i < rsList.length; i++)
        this.nextReels.push(rsList[i])
}
;
VS_ReelsManager.prototype.OnReelPositions = function(rpList) {
    for (var i = 0; i < this.reels.length; i++)
        this.reels[i].SetPosition(rpList[i])
}
;
VS_ReelsManager.prototype.OnExcitedImportantSymbols = function(excitedImportantSymbols) {
    for (var i = 0; i < this.reels.length; i++)
        this.reels[i].ExcitedImportantSymbols = excitedImportantSymbols[i]
}
;
VS_ReelsManager.prototype.OnSpinResultReceived = function() {
    this.forceStopOnScreenSymbols = XT.GetBool(Vars.IsNoMoneySpin);
    var rspList = XT.GetObject(Vars.ReelStopPositions);
    if (rspList != null) {
        this.resultReceived = true;
        for (var i = 0; i < this.reels.length; i++)
            this.reels[i].SetStopPosition(rspList[i])
    }
}
;
VS_ReelsManager.prototype.InitFirstScreenSymbols = function() {
    var fssList = XT.GetObject(Vars.FirstScreenSymbols);
    if (this.justVisualSymbols == 1)
        for (var fssIndex = 0; fssIndex < fssList.length; fssIndex++) {
            var visualSymbolId = fssList[fssIndex][0] != this.blankSymbolId ? this.blankSymbolId : this.blankSymbolId - 1;
            fssList[fssIndex].unshift(visualSymbolId);
            fssList[fssIndex].push(visualSymbolId)
        }
    for (var ir = 0; ir < this.reels.length; ir++)
        this.reels[ir].SetScreenSymbols(fssList);
    this.BuildOrderedSymbolList()
}
;
VS_ReelsManager.prototype.SetAllSymbolsToNormal = function() {
    for (var rIndex = 0; rIndex < this.reels.length; rIndex++)
        this.reels[rIndex].SetSymbolsToNormal()
}
;
VS_ReelsManager.prototype.OnStartSpin = function() {
    this.resultReceived = false;
    if (XT.GetBool(Vars.IsDifferentSpinType)) {
        XT.TriggerEvent(Vars.StartDifferentSpin);
        return
    }
    if (this.startFasterInFastPlay)
        this.isFastStart = this.IsFastPlayOn();
    this.PrepareStart()
}
;
VS_ReelsManager.prototype.OnStopSpin = function() {
    this.isStoppingFast = true;
    this.fastStop = true;
    this.rememberToStop = true;
    this.mustStopStoppingReels = true
}
;
VS_ReelsManager.prototype.SetAllowFastStop = function(allow) {
    if (!allow)
        this.fastStop = false
}
;
VS_ReelsManager.prototype.PrepareStart = function() {
    this.startTimer = this.reelDelayStart;
    if (this.IsFastPlayOn() || XT.GetBool(Vars.ContinuousSpin))
        this.startTimer = this.reelDelayStart * this.reels.length;
    var currentStartOrder = XT.GetObject(Vars.ReelsStartOrder);
    if (XT.GetInt(Vars.ReelToBeSpun) == -1) {
        this.reelsSpinning = this.reels.length;
        this.reelToStart = currentStartOrder[0]
    } else {
        this.reelToStart = XT.GetInt(Vars.ReelToBeSpun);
        this.reelsSpinning = 1
    }
    this.autoStopTimer = 0;
    if (this.IsFastPlayOn())
        this.autoStopTimer = this.autoStopDelay;
    this.state = VS_ReelsManager.State.STARTING;
    if (this.nextReels.length > 0)
        XT.SetObject(Vars.ReelSymbols, this.nextReels);
    if (XT.GetBool(Vars.HiddenMathematics))
        for (var i = 0; i < this.reels.length; i++)
            this.reels[i].SetPosition(0);
    this.nextReels = [];
    this.isStoppingFast = false;
    this.rememberToStop = false;
    this.mustStopStoppingReels = false;
    this.fastStop = false;
    this.fastStopTimers = null;
    this.logicIsFS = XT.GetBool(Vars.Logic_IsFreeSpin)
}
;
VS_ReelsManager.prototype.PrepareStop = function() {
    this.stopTimer = this.reelDelayStop;
    if (this.IsFastPlayOn() || this.fastStop)
        this.stopTimer = this.reelDelayStop * this.reels.length;
    var currentStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    if (XT.GetInt(Vars.ReelToBeSpun) == -1)
        this.reelToStop = currentStopOrder[0];
    else
        this.reelToStop = XT.GetInt(Vars.ReelToBeSpun);
    this.state = VS_ReelsManager.State.STOPPING
}
;
VS_ReelsManager.prototype.Start = function() {}
;
VS_ReelsManager.prototype.Init = function() {}
;
VS_ReelsManager.prototype.CheckAndSetContinuousSpin = function() {
    if (XT.GetBool(Vars.ForceContinuousSpin))
        if (!Input.GetMouseButton(0))
            if (XT.GetInt(Vars.AutoplaySpinsLeft) < 0)
                XT.SetBool(Vars.ForceContinuousSpin, false);
    if (!Globals.InputBlocked && (Input.GetKey(KeyCode.Space) || Input.GetKey(KeyCode.Return) || XT.GetBool(Vars.ForceContinuousSpin) || XT.GetBool(Vars.AutoplayContinuousSpin) && XT.GetInt(Vars.AutoplaySpinsLeft) >= 0)) {
        this.continuousSpinTimer += Time.deltaTime;
        if (this.continuousSpinTimer > .8 || XT.GetBool(Vars.ForceContinuousSpin) || XT.GetBool(Vars.AutoplayContinuousSpin) && XT.GetInt(Vars.AutoplaySpinsLeft) >= 0)
            XT.SetBool(Vars.ContinuousSpin, true)
    } else {
        XT.SetBool(Vars.ContinuousSpin, false);
        this.continuousSpinTimer = 0
    }
}
;
VS_ReelsManager.prototype.Update = function() {
    this.CheckAndSetContinuousSpin();
    if (this.state == VS_ReelsManager.State.SPINNING) {
        this.autoStopTimer += Time.deltaTime;
        if (this.autoStopTimer > this.autoStopDelay && this.resultReceived && !XT.GetBool(Vars.KeepSpinning)) {
            this.PrepareStop();
            this.autoStopTimer = 0
        }
    }
    if (this.state == VS_ReelsManager.State.SPINNING && this.resultReceived && !XT.GetBool(Vars.KeepSpinning))
        if (this.rememberToStop)
            this.PrepareStop();
    if (this.state == VS_ReelsManager.State.STARTING) {
        this.startTimer += Time.deltaTime;
        this.reelIdxList = [];
        var currentExtraDelayStart = XT.GetObject(Vars.ExtraReelDelayStart);
        var reelToStartIndex = this.GetIndexOfReelToStart(this.reelToStart);
        while (this.startTimer > this.reelDelayStart + currentExtraDelayStart[reelToStartIndex]) {
            this.startTimer -= this.reelDelayStart + currentExtraDelayStart[reelToStartIndex];
            if (this.logicIsFS)
                this.reels[this.reelToStart].SetSpeedCurve(this.spinCurves.startFS);
            else
                this.reels[this.reelToStart].SetSpeedCurve(this.spinCurves.startNormal);
            if (this.ShouldSpinReel()) {
                this.reels[this.reelToStart].StartSpin();
                this.reelIdxList.push(this.reelToStart)
            }
            var currentStartOrder = XT.GetObject(Vars.ReelsStartOrder);
            if (XT.GetInt(Vars.ReelToBeSpun) == -1 && reelToStartIndex < currentStartOrder.length - 1) {
                this.reelToStart = currentStartOrder[reelToStartIndex + 1];
                reelToStartIndex = this.GetIndexOfReelToStart(this.reelToStart)
            } else {
                this.state = VS_ReelsManager.State.SPINNING;
                break
            }
        }
        if (this.reelIdxList.length > 0) {
            XT.SetObject(Vars.LastStartedReelIndices, this.reelIdxList);
            XT.TriggerEvent(Vars.Evt_Internal_ReelStarted)
        }
    }
    if (this.state == VS_ReelsManager.State.STOPPING && this.resultReceived) {
        this.stopTimer += Time.deltaTime;
        this.reelIdxList = [];
        var currentExtraDelayStop = XT.GetObject(Vars.ExtraReelDelayStop);
        var currentStopOrder = XT.GetObject(Vars.ReelsStopOrder);
        var reelToStopIndex = this.GetIndexOfReelToStop(this.reelToStop);
        if (this.instantStop && this.mustStopStoppingReels) {
            for (var i = 0; i < reelToStopIndex; i++) {
                var idx = currentStopOrder[i];
                this.fastStopTimers = this.reels[idx].StopSpin(this.fastStop, this.fastStopTimers)
            }
            this.mustStopStoppingReels = false
        }
        while (this.stopTimer > this.reelDelayStop + currentExtraDelayStop[reelToStopIndex] || this.fastStop) {
            this.stopTimer -= this.reelDelayStop + currentExtraDelayStop[reelToStopIndex];
            if (this.reels[this.reelToStop].isExcited && !this.fastStop) {
                this.stopTimer -= this.exciter.extraStopDelayForNextReelOnExcite;
                if (this.logicIsFS)
                    this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopExcitedFS);
                else
                    this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopExcitedNormal)
            } else if (this.useCustomSpinCurves[this.reelToStop])
                this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopCustom);
            else if (this.logicIsFS)
                this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopFS);
            else
                this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.stopNormal);
            this.fastStopTimers = this.reels[this.reelToStop].StopSpin(this.fastStop, this.fastStopTimers);
            this.reelIdxList.push(this.reelToStop);
            if (XT.GetInt(Vars.ReelToBeSpun) == -1 && reelToStopIndex < currentStopOrder.length - 1) {
                this.reelToStop = currentStopOrder[reelToStopIndex + 1];
                reelToStopIndex = this.GetIndexOfReelToStop(this.reelToStop)
            } else {
                this.state = VS_ReelsManager.State.IDLE;
                break
            }
            if (this.exciter != null && this.exciter.Excite(this.reelToStop)) {
                XT.SetInt(Vars.LastExcitedReelIndex, this.reelToStop);
                XT.TriggerEvent(Vars.Evt_Internal_ExcitedReel);
                this.stopTimer = -this.exciter.extraExciteTime;
                this.reels[this.reelToStop].isExcited = true;
                if (this.logicIsFS)
                    this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.excitedFS);
                else
                    this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.excitedNormal)
            } else if (this.useCustomSpinCurves[this.reelToStop])
                this.reels[this.reelToStop].SetSpeedCurve(this.spinCurves.excitedCustom)
        }
        if (this.reelIdxList.length > 0) {
            XT.SetObject(Vars.LastStoppedReelIndices, this.reelIdxList);
            XT.TriggerEvent(Vars.Evt_Internal_ReelStopStarted);
            for (var rsIndex = 0; rsIndex < this.reelIdxList.length; rsIndex++)
                this.reels[this.reelIdxList[rsIndex]].isExcited = false
        }
    }
}
;
VS_ReelsManager.prototype.StopFinished = function(reelIdx) {
    if (this.exciter != null)
        this.exciter.ReelStopped(reelIdx, this.isStoppingFast);
    this.reelsSpinning--;
    if (this.reelsSpinning == 0) {
        this.resultReceived = false;
        this.BuildOrderedSymbolList();
        XT.TriggerEvent(Vars.Evt_Internal_ReelManager_SpinEnded)
    }
    XT.SetInt(Vars.LastStopEndedReelIndex, reelIdx);
    XT.TriggerEvent(Vars.Evt_Internal_ReelStopEnded)
}
;
VS_ReelsManager.prototype.BuildOrderedHoldersList = function() {
    var symbolIndex = 0;
    var numberOfReels = this.reels.length;
    var symbolsOnReels = this.reels[0].symbolHolders.length;
    var orderedHoldersList = [];
    for (var i = this.justVisualSymbols; i < symbolsOnReels; i++)
        for (var reelIndex = 0; reelIndex < numberOfReels; reelIndex++) {
            symbolIndex++;
            orderedHoldersList.push(this.reels[reelIndex].symbolHolders[i])
        }
    XT.SetObject(Vars.OrderedSymbolHoldersList, orderedHoldersList)
}
;
VS_ReelsManager.prototype.BuildOrderedSymbolList = function() {
    var symbolIndex = 0;
    var numberOfReels = this.reels.length;
    var symbolsOnReels = this.reels[0].symbolHolders.length;
    var orderedSymbolList = [];
    for (var i = 0; i < symbolsOnReels; i++)
        for (var reelIndex = 0; reelIndex < numberOfReels; reelIndex++) {
            symbolIndex++;
            orderedSymbolList.push(this.reels[reelIndex].symbolHolders[i].currentSymbol)
        }
    XT.SetObject(Vars.OrderedSymbolList, orderedSymbolList)
}
;
VS_ReelsManager.prototype.IsFastPlayOn = function() {
    return XT.GetBool(Vars.FastPlay)
}
;
VS_ReelsManager.prototype.GetIndexOfReelToStop = function(_reelToStop) {
    var currentStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    var reelToStopIndex = -1;
    for (var j = 0; j < currentStopOrder.length; j++)
        if (_reelToStop == currentStopOrder[j])
            reelToStopIndex = j;
    return reelToStopIndex
}
;
VS_ReelsManager.prototype.GetIndexOfReelToStart = function(_reelToStart) {
    var currentStartOrder = XT.GetObject(Vars.ReelsStartOrder);
    var reelToStartIndex = -1;
    for (var j = 0; j < currentStartOrder.length; j++)
        if (_reelToStart == currentStartOrder[j])
            reelToStartIndex = j;
    return reelToStartIndex
}
;
VS_ReelsManager.prototype.ShouldSpinReel = function() {
    if (XT.GetInt(Vars.ReelToBeSpun) != -1)
        if (this.reelToStart == XT.GetInt(Vars.ReelToBeSpun))
            return true;
        else
            return false;
    return true
}
;
goog.provide("UHT.LineInfo");
function LineInfo() {
    this.isRightToLeft = false;
    this.symbolIndices = null
}
goog.provide("UHT.VS_LinesDefinitions");
goog.require("UHT.XTLink");
goog.require("UHT.LineInfo");
VS_LinesDefinitions.prototype = Object.create(XTLink.prototype);
VS_LinesDefinitions.prototype.constructor = VS_LinesDefinitions;
function VS_LinesDefinitions() {
    XTLink.call(this);
    this.reels = 5;
    this.symbols = 3;
    this.symbolSquares = null;
    this.lines = null
}
VS_LinesDefinitions.prototype.XTRegisterCallbacks = function() {}
;
VS_LinesDefinitions.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.LinesDefinitionsObject, this)
}
;
goog.require("UHT.XTLink");
goog.require("UHT.VS_LinesDefinitions");
goog.require("UHT.System.Misc.Utils");
function SubstitutingIDs() {
    this.realID = 0;
    this.substituteIDs = []
}
var SpecialSymbolPayType = {
    Everywhere: 0,
    OnActivePayline: 1,
    OnActivePaylineLeftToRight: 2
};
var ScatterSymbolPayType = {
    Nowhere: 0,
    Everywhere: 1,
    OnActivePayline: 2,
    OnActivePaylineLeftToRight: 3,
    OnAdjacentReelsBothWays: 4
};
var ScreenSymbolsToUse = {
    initialScreenSymbols: 0,
    finalScreenSymbols: 1,
    customScreenSymbols: 2
};
function WinLineInfo() {
    this.Id = 0;
    this.Positions = null;
    this.dominatingSymbol = 0;
    this.containsWild = false
}
VS_SpinExciter.prototype = Object.create(XTLink.prototype);
VS_SpinExciter.prototype.constructor = VS_SpinExciter;
function VS_SpinExciter() {
    XTLink.call(this);
    this.symbolList = [];
    this.allReelsSymbolList = [];
    this.PossibleWinCombo = null;
    this.AccumulatedPossibleWin = null;
    this.PossibleWinComboSymbols = null;
    this.StillPossibleWinComboPerSymbol = null;
    this.PossibleWinComboBonus = null;
    this.PossibleWinComboScatter = null;
    this.ActualWinCombo = null;
    this.ActualWinComboBonus = null;
    this.ActualWinComboScatter = null;
    this.StillPossibleWinComboBonus = null;
    this.StillPossibleWinComboScatter = null;
    this.StillPossibleWinComboWild = null;
    this.ShouldAnimateBonus = null;
    this.ShouldAnimateScatter = null;
    this.ExcitedImportantSymbols = null;
    this.symbolPaying = null;
    this.exciteOn = ScreenSymbolsToUse.finalScreenSymbols;
    this.symbolExciting = null;
    this.canHighlightOff = null;
    this.extraScatters = null;
    this.extraWilds = null;
    this.symbolIDSubstitutes = [];
    this.BonusPays = SpecialSymbolPayType.Everywhere;
    this.BonusMinCombo = 3;
    this.exciteForBonusSymbols = true;
    this.forceBonusOnReels = [];
    this.WildSubstitutesScatter = false;
    this.ScatterExcites = false;
    this.ScatterMustBeStacked = false;
    this.ScatterIsStacked = false;
    this.ScatterPays = SpecialSymbolPayType.Everywhere;
    this.ScatterMinCombo = 3;
    this.ScatterMinComboFreeSpins = -1;
    this.exciteForScatterSymbols = true;
    this.MysteryScatterMinCombo = 3;
    this.ScatterPaysMoney = ScatterSymbolPayType.Nowhere;
    this.ScatterPaysMoneyMinCombo = 3;
    this.extraExciteTime = 1.5;
    this.extraStopDelayForNextReelOnExcite = 0;
    this.betLines = null;
    this.betLinesServer = [];
    this.linesDef = null;
    this.reelsManager = null;
    this.firstExcitedReel = 2;
    this.hasLoopExciteImportant = false;
    this.payoutThreshold = 3;
    this.payoutData = null
}
VS_SpinExciter.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.FirstScreenSymbols, this.OnFirstScreenSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytablePayoutUpdate, this.UpdateSymbolPayoutInformation, this);
    XT.RegisterCallbackObject(Vars.ReelSymbols, this.OnReelSymbols, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.ComputeBetLinesFromServer, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BonusResponseReceived, this.ComputeBetLinesFromServer, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_InitReceived, this.ComputeBetLinesFromServer, this);
    switch (this.exciteOn) {
    case ScreenSymbolsToUse.initialScreenSymbols:
        XT.RegisterCallbackObject(Vars.InitialResultScreenSymbols, this.OnScreenSymbols, this);
        break;
    case ScreenSymbolsToUse.finalScreenSymbols:
        XT.RegisterCallbackObject(Vars.ResultScreenSymbols, this.OnScreenSymbols, this);
        break;
    case ScreenSymbolsToUse.customScreenSymbols:
        XT.RegisterCallbackObject(Vars.CustomResultScreenSymbols, this.OnScreenSymbols, this);
        break
    }
}
;
VS_SpinExciter.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.SpinExciterObject, this);
    XT.SetObject(Vars.ExtraScatters, this.extraScatters);
    XT.SetObject(Vars.AdditionalBonusScatters, null)
}
;
VS_SpinExciter.prototype.OnReelSymbols = function(rs) {
    this.allReelsSymbolList = [];
    for (var i = 0; i < rs.length; i++)
        this.allReelsSymbolList.push(rs[i])
}
;
VS_SpinExciter.prototype.SymbolsPresentAnywhereOnReel = function(symbol, reel) {
    var ret = 0;
    for (var i = 0; i < this.allReelsSymbolList[reel].length; i++)
        if (this.IsSameID(symbol, this.allReelsSymbolList[reel][i]))
            ret++;
    if (ret == 0 && this.forceBonusOnReels.length > reel && this.forceBonusOnReels[reel])
        ret++;
    return ret
}
;
VS_SpinExciter.prototype.IsSameID = function(realID, substituteID) {
    if (realID == substituteID)
        return true;
    if (this.symbolIDSubstitutes != null)
        for (var i = 0; i < this.symbolIDSubstitutes.length; i++)
            if (this.symbolIDSubstitutes[i].realID == realID && this.symbolIDSubstitutes[i].substituteIDs.indexOf(substituteID) != -1)
                return true;
    return false
}
;
VS_SpinExciter.prototype.OnFirstScreenSymbols = function(_initialSymbols) {
    var initialSymbols = _initialSymbols;
    this.symbolList = [];
    for (var i = 0; i < initialSymbols.length; i++)
        this.symbolList.push([]);
    var reelsCount = this.symbolList.length;
    this.PossibleWinCombo = _array.create(reelsCount, false);
    this.AccumulatedPossibleWin = _array.create(reelsCount, false);
    this.PossibleWinComboSymbols = _array.create(reelsCount, false);
    this.PossibleWinComboBonus = _array.create(reelsCount, false);
    this.PossibleWinComboScatter = _array.create(reelsCount, false);
    this.ActualWinCombo = _array.create(reelsCount, false);
    this.ActualWinComboBonus = _array.create(reelsCount, false);
    this.ActualWinComboScatter = _array.create(reelsCount, false);
    this.StillPossibleWinComboBonus = _array.create(reelsCount, false);
    this.StillPossibleWinComboScatter = _array.create(reelsCount, false);
    this.StillPossibleWinComboWild = _array.create(reelsCount, false);
    this.ShouldAnimateBonus = _array.create(reelsCount * initialSymbols[0].length, false);
    this.ShouldAnimateScatter = _array.create(reelsCount * initialSymbols[0].length, false);
    var symbols = XT.GetObject(Vars.SymbolsManagerObject).symbols;
    var maxSymbolId = -1;
    for (var i = 0; i < symbols.length; ++i)
        if (symbols[i].symbolId > maxSymbolId)
            maxSymbolId = symbols[i].symbolId;
    var symbolsCount = maxSymbolId + 1;
    this.ExcitedImportantSymbols = [];
    for (var i = 0; i < reelsCount; i++)
        this.ExcitedImportantSymbols.push(_array.create(symbolsCount, false));
    XT.SetObject(Vars.ExcitedImportantSymbols, this.ExcitedImportantSymbols);
    this.linesDef = XT.GetObject(Vars.LinesDefinitionsObject);
    this.reelsManager = XT.GetObject(Vars.ReelsManagerObject);
    this.StillPossibleWinComboPerSymbol = [];
    for (var i = 0; i < reelsCount; ++i)
        this.StillPossibleWinComboPerSymbol[i] = new Array(symbolsCount)
}
;
VS_SpinExciter.prototype.OnScreenSymbols = function(_resultSymbols) {
    var resultSymbols = _resultSymbols;
    for (var i = 0; i < resultSymbols.length; i++) {
        this.symbolList[i] = [];
        for (var j = 0; j < resultSymbols[i].length; j++)
            this.symbolList[i].push(resultSymbols[i][resultSymbols[i].length - 1 - j])
    }
    this.ResetPossibleWins();
    this.ComputePossibleWins();
    XT.TriggerEvent(Vars.Evt_Internal_ExciterComputeEnded)
}
;
VS_SpinExciter.prototype.UpdateSymbolPayoutInformation = function() {
    var pD = XT.GetObject(Vars.PaytablePayoutData);
    if (pD != null)
        this.payoutData = pD
}
;
VS_SpinExciter.prototype.ResetPossibleWins = function() {
    for (var i = 0; i < this.PossibleWinCombo.length; i++) {
        this.PossibleWinCombo[i] = false;
        this.AccumulatedPossibleWin[i] = 0;
        this.PossibleWinComboSymbols[i] = false;
        this.PossibleWinComboBonus[i] = false;
        this.PossibleWinComboScatter[i] = false;
        this.ActualWinCombo[i] = false;
        this.ActualWinComboBonus[i] = false;
        this.ActualWinComboScatter[i] = false;
        this.StillPossibleWinComboBonus[i] = false;
        this.StillPossibleWinComboScatter[i] = false;
        this.StillPossibleWinComboWild[i] = false
    }
    for (var i = 0; i < this.StillPossibleWinComboPerSymbol.length; ++i)
        for (var j = 0; j < this.StillPossibleWinComboPerSymbol[i].length; j++)
            this.StillPossibleWinComboPerSymbol[i][j] = false;
    for (var i = 0; i < this.ShouldAnimateBonus.length; i++)
        this.ShouldAnimateBonus[i] = false;
    for (var i = 0; i < this.ShouldAnimateScatter.length; i++)
        this.ShouldAnimateScatter[i] = false;
    for (var i = 0; i < this.ExcitedImportantSymbols.length; i++)
        for (var j = 0; j < this.ExcitedImportantSymbols[i].length; j++)
            this.ExcitedImportantSymbols[i][j] = false
}
;
VS_SpinExciter.prototype.SymbolAppearencesOnReel = function(symbolId, reelidx) {
    var ret = 0;
    for (var i = 0; i < this.symbolList[reelidx].length; i++)
        if (this.symbolList[reelidx][i] == symbolId)
            ret++;
    var additionalBonusScatters = XT.GetObject(Vars.AdditionalBonusScatters);
    if (additionalBonusScatters != null)
        for (var i = 0; i < additionalBonusScatters[reelidx].length; i++)
            if (additionalBonusScatters[reelidx][i] == symbolId)
                ret++;
    return ret
}
;
VS_SpinExciter.prototype.GetSymbolFromReel = function(pos, reel, isForLines) {
    var symbol = this.symbolList[reel][pos];
    if (isForLines == false) {
        var additionalBonusScatters = XT.GetObject(Vars.AdditionalBonusScatters);
        if (additionalBonusScatters != null && additionalBonusScatters[reel][pos] >= 0)
            symbol = additionalBonusScatters[reel][pos]
    }
    return symbol
}
;
VS_SpinExciter.prototype.ComputePossibleWins = function() {
    var lines = XT.GetInt(Vars.Lines);
    var reels = this.symbolList.length;
    this.betLines = _array.create(lines, null);
    for (var i = 0; i < lines; i++) {
        this.betLines[i] = new WinLineInfo;
        this.betLines[i].Id = i + 1;
        this.betLines[i].Positions = _array.create(reels, 0);
        this.betLines[i].containsWild = false;
        for (var j = 0; j < reels; j++)
            this.betLines[i].Positions[j] = this.linesDef.lines[i].symbolIndices[j]
    }
    if (this.BonusPays == SpecialSymbolPayType.Everywhere) {
        var bonuses = 0;
        for (var i = 0; i < reels; i++) {
            var moreBonusesPossible = false;
            var possibleBonuses = 0;
            var bonusIsOnReel = false;
            for (var j = i; j < reels; j++)
                if (this.SymbolsPresentAnywhereOnReel(0, j) > 0) {
                    moreBonusesPossible = true;
                    if (j != i)
                        possibleBonuses++;
                    else
                        bonusIsOnReel = true
                }
            if (i > 1 && bonuses >= this.BonusMinCombo - 1 && moreBonusesPossible && bonusIsOnReel) {
                this.PossibleWinCombo[i] = true;
                this.PossibleWinComboBonus[i] = true
            }
            bonuses += this.SymbolAppearencesOnReel(0, i);
            if (bonuses >= this.BonusMinCombo) {
                this.ActualWinCombo[i] = true;
                this.ActualWinComboBonus[i] = true
            }
            if (bonuses + possibleBonuses >= this.BonusMinCombo)
                this.StillPossibleWinComboBonus[i] = true
        }
        if (bonuses >= this.BonusMinCombo)
            for (var i = 0; i < this.ShouldAnimateBonus.length; i++)
                this.ShouldAnimateBonus[i] = true
    }
    if (this.BonusPays == SpecialSymbolPayType.OnActivePayline || this.BonusPays == SpecialSymbolPayType.OnActivePaylineLeftToRight)
        for (var idx = 0; idx < this.betLines.length; ++idx) {
            var wli = this.betLines[idx];
            var bonuses = 0;
            for (var i = 0; i < wli.Positions.length; i++) {
                var moreBonusesPossible = false;
                var possibleBonuses = 0;
                var bonusIsOnReel = false;
                for (var j = i; j < wli.Positions.length; j++)
                    if (this.SymbolsPresentAnywhereOnReel(0, j) > 0) {
                        moreBonusesPossible = true;
                        if (j != i)
                            possibleBonuses++;
                        else
                            bonusIsOnReel = true
                    }
                var pos = wli.Positions[i];
                var reelIdx = pos % reels;
                var reelPosIdx = Math.floor(pos / reels);
                var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx, false);
                if (i > 1 && bonuses >= this.BonusMinCombo - 1 && moreBonusesPossible && bonusIsOnReel) {
                    this.PossibleWinCombo[i] = true;
                    this.PossibleWinComboBonus[i] = true
                }
                if (symbol == 0)
                    bonuses++;
                else if (this.BonusPays == SpecialSymbolPayType.OnActivePaylineLeftToRight)
                    break;
                if (bonuses >= this.BonusMinCombo) {
                    this.ActualWinCombo[i] = true;
                    this.ActualWinComboBonus[i] = true;
                    for (var j = 0; j <= i; j++)
                        this.ShouldAnimateBonus[wli.Positions[j]] = true
                }
                if (bonuses + possibleBonuses >= this.BonusMinCombo)
                    this.StillPossibleWinComboBonus[i] = true
            }
        }
    if (this.ScatterPays == SpecialSymbolPayType.Everywhere) {
        var scatters = 0;
        for (var i = 0; i < reels; i++) {
            var moreScattersPossible = false;
            var possibleScatters = 0;
            var scatterIsOnReel = false;
            for (var j = i; j < reels; j++)
                if (this.SymbolsPresentAnywhereOnReel(1, j) > 0) {
                    moreScattersPossible = true;
                    if (j != i)
                        if (this.ScatterIsStacked)
                            possibleScatters += this.symbolList[i].length;
                        else
                            possibleScatters++;
                    else
                        scatterIsOnReel = true
                }
            if (i > 1 && scatters >= this.ScatterMinCombo - 1 && moreScattersPossible && scatterIsOnReel) {
                this.PossibleWinCombo[i] = true;
                this.PossibleWinComboScatter[i] = true
            }
            if (this.ScatterMustBeStacked)
                scatters += this.SymbolAppearencesOnReel(1, i) == this.reelsManager.reels[i].symbolHolders.length ? 1 : 0;
            else {
                scatters += this.SymbolAppearencesOnReel(1, i);
                if (this.extraScatters != null && this.extraScatters.length > 0)
                    for (var esIndex = 0; esIndex < this.extraScatters.length; esIndex++)
                        scatters += this.SymbolAppearencesOnReel(this.extraScatters[esIndex], i)
            }
            if (scatters >= this.ScatterMinCombo) {
                this.ActualWinCombo[i] = true;
                this.ActualWinComboScatter[i] = true
            }
            if (this.ScatterMustBeStacked) {
                if (scatters + possibleScatters >= this.GetScatterMinCombo() && this.SymbolAppearencesOnReel(1, i) == this.reelsManager.reels[i].symbolHolders.length)
                    this.StillPossibleWinComboScatter[i] = true
            } else if (scatters + possibleScatters >= this.GetScatterMinCombo())
                this.StillPossibleWinComboScatter[i] = true
        }
        if (scatters >= this.GetScatterMinCombo())
            for (var i = 0; i < this.ShouldAnimateScatter.length; i++)
                this.ShouldAnimateScatter[i] = true
    }
    if (this.ScatterPays == SpecialSymbolPayType.OnActivePayline || this.ScatterPays == SpecialSymbolPayType.OnActivePaylineLeftToRight)
        for (var idx = 0; idx < this.betLines.length; ++idx) {
            var wli = this.betLines[idx];
            var scatters = 0;
            for (var i = 0; i < wli.Positions.length; i++) {
                var moreScattersPossible = false;
                var possibleScatters = 0;
                var scatterIsOnReel = false;
                for (var j = i; j < wli.Positions.length; j++)
                    if (this.SymbolsPresentAnywhereOnReel(1, j) > 0) {
                        moreScattersPossible = true;
                        if (j != i)
                            possibleScatters++;
                        else
                            scatterIsOnReel = true
                    }
                var pos = wli.Positions[i];
                var reelIdx = pos % reels;
                var reelPosIdx = Math.floor(pos / reels);
                var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx, false);
                if (i > 1 && scatters >= this.ScatterMinCombo - 1 && moreScattersPossible && scatterIsOnReel) {
                    this.PossibleWinCombo[i] = true;
                    this.PossibleWinComboScatter[i] = true
                }
                if (symbol == 1 || symbol == 2 && this.WildSubstitutesScatter)
                    scatters++;
                else if (this.ScatterPays == SpecialSymbolPayType.OnActivePaylineLeftToRight)
                    break;
                if (scatters >= this.GetScatterMinCombo()) {
                    this.ActualWinCombo[i] = true;
                    this.ActualWinComboScatter[i] = true;
                    for (var j = 0; j <= i; j++)
                        this.ShouldAnimateScatter[wli.Positions[j]] = true
                }
                if (scatters + possibleScatters >= this.GetScatterMinCombo())
                    this.StillPossibleWinComboScatter[i] = true
            }
        }
    for (var idx = 0; idx < this.betLines.length; ++idx) {
        var wli = this.betLines[idx];
        var scatterIsWild = XT.GetBool(Vars.ScatterSymbolIsWild);
        var winningsymbol = 2;
        var actualwinningsymbol = -1;
        var leadingWilds = 0;
        for (var i = 0; i < wli.Positions.length; i++) {
            var pos = wli.Positions[i];
            var reelIdx = pos % reels;
            var reelPosIdx = Math.floor(pos / reels);
            var symbol = this.GetSymbolFromReel(reelPosIdx, reelIdx);
            if (actualwinningsymbol == -1)
                actualwinningsymbol = symbol;
            if (scatterIsWild)
                if (!this.SymbolIsWild(symbol) && symbol != 1)
                    if (symbol != winningsymbol && !this.SymbolIsWild(winningsymbol) && winningsymbol != 1 || symbol < 2) {
                        var newLength = i;
                        var newPos = _array.create(newLength, 0);
                        for (var j = 0; j < newLength; j++)
                            newPos[j] = wli.Positions[j];
                        wli.Positions = newPos
                    } else {
                        winningsymbol = symbol;
                        actualwinningsymbol = symbol
                    }
                else
                    this.StillPossibleWinComboWild[i] = true;
            else if (!this.SymbolIsWild(symbol))
                if (symbol != winningsymbol && !this.SymbolIsWild(winningsymbol) || symbol < 2) {
                    var newLength = i;
                    if (leadingWilds > 0)
                        if (this.payoutData[2][leadingWilds - 1] > this.payoutData[winningsymbol][newLength - 1]) {
                            newLength = leadingWilds;
                            winningsymbol = 2
                        }
                    var newPos = _array.create(newLength, 0);
                    for (var j = 0; j < newLength; j++)
                        newPos[j] = wli.Positions[j];
                    wli.Positions = newPos
                } else {
                    winningsymbol = symbol;
                    actualwinningsymbol = symbol
                }
            else {
                this.StillPossibleWinComboWild[i] = true;
                if (leadingWilds == i)
                    leadingWilds++
            }
            if (!wli.containsWild)
                wli.containsWild = this.SymbolIsWild(symbol)
        }
        wli.dominatingSymbol = winningsymbol;
        if (actualwinningsymbol != -1) {
            var linelength = wli.Positions.length;
            for (var i = 0; i < linelength; i++)
                this.StillPossibleWinComboPerSymbol[i][actualwinningsymbol] = true
        }
        if (winningsymbol > (scatterIsWild ? 0 : 1))
            if (this.symbolExciting[winningsymbol] || this.payoutThreshold > .001) {
                var linelength = wli.Positions.length;
                for (var i = 0; i < linelength; i++)
                    this.ActualWinCombo[i] = true;
                if (linelength > reels - 1)
                    linelength = reels - 1;
                for (var i = 0; i <= linelength; i++)
                    if (this.payoutData != null)
                        this.AccumulatedPossibleWin[i] += this.payoutData[winningsymbol][i] * XT.GetDouble(Vars.CurrentWinMultiplier);
                for (var i = 0; i <= linelength; i++) {
                    this.PossibleWinCombo[i] = true;
                    this.PossibleWinComboSymbols[i] = true;
                    if (this.hasLoopExciteImportant)
                        this.ExcitedImportantSymbols[i][winningsymbol] = true
                }
            }
    }
    this.SetWinComboSounds()
}
;
VS_SpinExciter.prototype.SetWinComboSounds = function() {
    XT.SetObject(Vars.PossibleWinComboSymbols, this.PossibleWinComboSymbols);
    XT.SetObject(Vars.StillPossibleWinComboPerSymbol, this.StillPossibleWinComboPerSymbol);
    XT.SetObject(Vars.StillPossibleWinComboBonus, this.StillPossibleWinComboBonus);
    XT.SetObject(Vars.StillPossibleWinComboScatter, this.StillPossibleWinComboScatter);
    XT.SetObject(Vars.StillPossibleWinComboWild, this.StillPossibleWinComboWild);
    XT.SetObject(Vars.ReelsWinInfo, this.ActualWinCombo)
}
;
VS_SpinExciter.prototype.Excite = function(reelToStop) {
    if (this.extraExciteTime < 0 || !XT.GetObject(Vars.ReelsCanBeExcited)[reelToStop])
        return false;
    if (reelToStop >= this.firstExcitedReel) {
        if (this.PossibleWinComboScatter[reelToStop] && this.exciteForScatterSymbols || this.PossibleWinComboBonus[reelToStop] && this.exciteForBonusSymbols)
            return true;
        var enoughMoney = false;
        if (this.payoutData == null)
            enoughMoney = true;
        else {
            var lines = XT.GetInt(Vars.Lines);
            if (this.AccumulatedPossibleWin[reelToStop] >= this.payoutThreshold * lines)
                enoughMoney = true
        }
        if (this.PossibleWinCombo[reelToStop] && enoughMoney)
            return true
    }
    return false
}
;
VS_SpinExciter.prototype.CanHighlightOff = function(symbolId) {
    return this.canHighlightOff[symbolId]
}
;
VS_SpinExciter.prototype.UpdateSymbol = function(rsh, reelIdx, allowScatterExcite) {
    var symbolId = rsh.currentSymbol.symbolId;
    var scatterIsWild = XT.GetBool(Vars.ScatterSymbolIsWild);
    if (!this.CanHighlightOff(symbolId) && !(scatterIsWild && symbolId == 1))
        return;
    if (symbolId == 1 && this.ScatterExcites && allowScatterExcite) {
        var foundWinningScatter = false;
        var foundExcitedScatter = reelIdx < this.reelsManager.reels.length - 1 && this.PossibleWinComboScatter[reelIdx + 1];
        for (var i = 0; i <= reelIdx; i++)
            if (this.ActualWinComboScatter[i])
                foundWinningScatter = true;
        if (foundWinningScatter && foundExcitedScatter)
            rsh.currentSymbol.SetWinExcited();
        else if (foundWinningScatter)
            rsh.currentSymbol.SetWinning();
        else if (foundExcitedScatter)
            rsh.currentSymbol.SetExcited();
        else if (!this.CanHighlightOff(symbolId))
            rsh.currentSymbol.SetNormal();
        else
            rsh.currentSymbol.SetHighlightOff();
        return
    }
    var orderedIdx = rsh.GetOrderedSymbolIdx();
    var maxLineLength = -1;
    for (var idx = 0; idx < this.betLines.length; ++idx) {
        var wli = this.betLines[idx];
        for (var k = 0; k < wli.Positions.length; k++)
            if (k <= reelIdx)
                if (wli.Positions[k] == orderedIdx)
                    if (maxLineLength < wli.Positions.length)
                        maxLineLength = wli.Positions.length
    }
    var foundExcited = false;
    var foundWinning = false;
    if (maxLineLength >= this.firstExcitedReel)
        if (maxLineLength > reelIdx)
            foundExcited = true;
    if (maxLineLength >= this.symbolPaying[symbolId])
        if (reelIdx + 1 >= this.symbolPaying[symbolId])
            foundWinning = true;
    if (foundWinning && foundExcited)
        rsh.currentSymbol.SetWinExcited();
    else if (foundWinning)
        rsh.currentSymbol.SetWinning();
    else if (foundExcited)
        rsh.currentSymbol.SetExcited();
    else if (!this.CanHighlightOff(symbolId) && (scatterIsWild && symbolId == 1))
        rsh.currentSymbol.SetNormal();
    else
        rsh.currentSymbol.SetHighlightOff()
}
;
VS_SpinExciter.prototype.ReelStopped = function(reelIdx, isStoppingFast) {
    if (isStoppingFast)
        return;
    if (reelIdx < this.firstExcitedReel - 1)
        return;
    var atLeastOneExcitedReel = false;
    var nextReelIdx = Math.min(reelIdx + 1, this.reelsManager.reels.length - 1);
    for (var i = 0; i <= nextReelIdx; i++)
        if (this.Excite(i) && this.PossibleWinComboSymbols[i])
            atLeastOneExcitedReel = true;
    if (atLeastOneExcitedReel)
        for (var i = 0; i <= reelIdx; i++) {
            var reel = this.reelsManager.reels[i];
            for (var j = 0; j < reel.symbolHolders.length; j++)
                this.UpdateSymbol(reel.symbolHolders[j], reelIdx, false)
        }
    if (this.ScatterExcites)
        for (var i = 0; i <= reelIdx; i++) {
            var reel = this.reelsManager.reels[i];
            for (var j = 0; j < reel.symbolHolders.length; j++)
                if (reel.symbolHolders[j].currentSymbol.symbolId == 1)
                    this.UpdateSymbol(reel.symbolHolders[j], reelIdx, true)
        }
}
;
VS_SpinExciter.prototype.GetScattersThatNeedToBeAnimated = function() {
    return this.ShouldAnimateScatter
}
;
VS_SpinExciter.prototype.GetBonusesThatNeedToBeAnimated = function() {
    return this.ShouldAnimateBonus
}
;
VS_SpinExciter.prototype.GetScatterMinCombo = function() {
    if (XT.GetBool(Vars.Logic_IsFreeSpin) && this.ScatterMinComboFreeSpins > 0)
        return this.ScatterMinComboFreeSpins;
    return this.ScatterMinCombo
}
;
VS_SpinExciter.prototype.SymbolIsWild = function(id) {
    return id == 2 || this.extraWilds.indexOf(id) > -1
}
;
VS_SpinExciter.prototype.ComputeBetLinesFromServer = function() {
    this.betLinesServer.splice(0);
    var linesFromServer = XT.GetObject(Vars.ReceivedWinLines);
    if (linesFromServer == null)
        return;
    var reels = this.symbolList.length;
    var wild = 2;
    for (var i = 0; i < linesFromServer.length; i++) {
        var wli = new WinLineInfo;
        wli.Id = linesFromServer[i].LineNumber;
        wli.Positions = linesFromServer[i].WinPositions;
        wli.containsWild = false;
        var symbols = [];
        for (var j = 0; j < wli.Positions.length; ++j) {
            var symbol = this.GetSymbolFromReel(_number.otoi(wli.Positions[j] / reels), _number.otoi(wli.Positions[j] % reels));
            if (symbols.indexOf(symbol) < 0)
                symbols.push(symbol);
            if (this.SymbolIsWild(symbol)) {
                wild = symbol;
                wli.containsWild = true
            }
        }
        if (wli.containsWild)
            wli.dominatingSymbol = wild;
        for (var j = 0; j < symbols.length; ++j)
            if (!this.SymbolIsWild(symbols[j]))
                wli.dominatingSymbol = symbols[j];
        this.betLinesServer.push(wli)
    }
}
;
VS_SpinExciter.prototype.BetLinesFromServer = function(id) {
    for (var i = 0; i < this.betLinesServer.length; ++i)
        if (id == this.betLinesServer[i].Id)
            return this.betLinesServer[i];
    return null
}
;
goog.require("UHT.Engine");
function SkewDescriptor() {
    this.position = null;
    this.rotation = null;
    this.scale = null;
    this.childPosition = null;
    this.childRotation = null;
    this.childScale = null
}
function FloatRange() {
    this.from = 0;
    this.to = 0
}
function SkewDescriptorReel() {
    this.xRange = null;
    this.skewRange = null;
    this.values = null;
    this.defaults = null;
    this.descriptors = []
}
SkewDescriptorReel.SDRange = function(_from, _to) {
    this.from = _from;
    this.to = _to;
    this.delta = new SkewDescriptor;
    this.delta.position = new UHTMath.Vector3(this.to.position.x - this.from.position.x,this.to.position.y - this.from.position.y,0);
    this.delta.rotation = new UHTMath.Vector3(0,0,this.to.rotation.z - this.from.rotation.z);
    this.delta.scale = new UHTMath.Vector3(this.to.scale.x - this.from.scale.x,this.to.scale.y - this.from.scale.y,0);
    this.delta.childPosition = new UHTMath.Vector3(this.to.childPosition.x - this.from.childPosition.x,this.to.childPosition.y - this.from.childPosition.y,0);
    this.delta.childRotation = new UHTMath.Vector3(0,0,this.to.childRotation.z - this.from.childRotation.z);
    this.delta.childScale = new UHTMath.Vector3(this.to.childScale.x - this.from.childScale.x,this.to.childScale.y - this.from.childScale.y,0)
}
;
SkewDescriptorReel.SDRange.prototype.GetSkewDescriptor = function(pos, posAbs, defaults, skewRange) {
    var desc = new SkewDescriptor;
    desc.rotation = defaults.rotation;
    desc.scale = defaults.scale;
    desc.childPosition = defaults.childPosition;
    desc.childRotation = defaults.childRotation;
    desc.childScale = defaults.childScale;
    var dY = (posAbs.y - this.from.position.y) / this.delta.position.y;
    var sign = pos.x * pos.y > 0 ? 1 : -1;
    if (posAbs.x >= skewRange.from && posAbs.x < skewRange.to) {
        desc.rotation = new UHTMath.Vector3(0,0,(this.from.rotation.z + this.delta.rotation.z * dY) * sign);
        desc.childRotation = new UHTMath.Vector3(0,0,(this.from.childRotation.z + this.delta.childRotation.z * dY) * sign);
        desc.childPosition = new UHTMath.Vector3((this.from.childPosition.x + this.delta.childPosition.x * dY) * (pos.x > 0 ? 1 : -1),(this.from.childPosition.y + this.delta.childPosition.y * dY) * (pos.y > 0 ? 1 : -1),0)
    } else
        desc.childPosition = new UHTMath.Vector3(defaults.childPosition.x,(this.from.childPosition.y + this.delta.childPosition.y * dY) * (pos.y > 0 ? 1 : -1),0);
    if (posAbs.y > 0) {
        desc.scale = new UHTMath.Vector3(this.from.scale.x + this.delta.scale.x * dY,this.from.scale.y + this.delta.scale.y * dY,1);
        desc.childScale = new UHTMath.Vector3(this.from.childScale.x + this.delta.childScale.x * dY,this.from.childScale.y + this.delta.childScale.y * dY,1)
    }
    return desc
}
;
SkewDescriptorReel.prototype.Init = function() {
    for (var i = 0; i < this.values.length - 1; ++i)
        this.descriptors.push(new SkewDescriptorReel.SDRange(this.values[i],this.values[i + 1]))
}
;
SkewDescriptorReel.prototype.GetSkewDescriptor = function(pos, posAbs) {
    for (var i = 0; i < this.descriptors.length; ++i)
        if (posAbs.y >= this.descriptors[i].from.position.y && posAbs.y < this.descriptors[i].to.position.y)
            return this.descriptors[i].GetSkewDescriptor(pos, posAbs, this.defaults, this.skewRange);
    return null
}
;
ReelDeformerSettings.prototype = Object.create(Component.prototype);
ReelDeformerSettings.prototype.constructor = ReelDeformerSettings;
function ReelDeformerSettings() {
    Component.call(this);
    this.reelsRoot = null;
    this.descriptors = null
}
ReelDeformerSettings.prototype.Start = function() {
    for (var i = 0; i < this.descriptors.length; ++i)
        this.descriptors[i].Init()
}
;
ReelDeformerSettings.prototype.GetSkewDescriptor = function(position) {
    var pos = this.reelsRoot.inverseTransformPoint(position);
    var posAbs = new UHTMath.Vector3(Math.abs(pos.x),Math.abs(pos.y),0);
    for (var i = 0; i < this.descriptors.length; ++i)
        if (posAbs.x >= this.descriptors[i].xRange.from && posAbs.x < this.descriptors[i].xRange.to)
            return this.descriptors[i].GetSkewDescriptor(pos, posAbs);
    return null
}
;
goog.require("UHT.Engine");
ReelDeformer.prototype = Object.create(Component.prototype);
ReelDeformer.prototype.constructor = ReelDeformer;
function ReelDeformer() {
    Component.call(this);
    this.settings = null;
    this.children = null
}
ReelDeformer.prototype.LateUpdate = function() {
    var shouldRecompute = false;
    this.gameObject.transform._internal_get_position();
    if (this.gameObject.transform.IsDirtyUserFlag(Transform._DirtyFlagPerspective)) {
        shouldRecompute = true;
        this.gameObject.transform.ClearDirtyUserFlag(Transform._DirtyFlagPerspective)
    }
    if (!shouldRecompute)
        return;
    var desc = this.settings.GetSkewDescriptor(this.gameObject.transform.position());
    if (desc == null)
        return;
    this.gameObject.transform.localRotation(UHTMath.Quaternion.euler(desc.rotation));
    this.gameObject.transform.localScale(desc.scale);
    for (var i = 0; i < this.children.length; ++i) {
        this.children[i].localPosition(desc.childPosition);
        this.children[i].localRotation(UHTMath.Quaternion.euler(desc.childRotation))
    }
    for (var j = 0; j < this.children.length; ++j)
        this.children[j].localScale(desc.childScale)
}
;
goog.require("UHT.XTLink");
WinLineVisual.prototype = Object.create(XTLink.prototype);
WinLineVisual.prototype.constructor = WinLineVisual;
function WinLineVisual() {
    XTLink.call(this);
    this.id = 0;
    this.thickness = 0;
    this.color = null;
    this.guides = [];
    this.useObjectAsEnd = false;
    this.lineEndings = [];
    this.showOnlyLineEnd = false;
    this.linesDefinitions = null;
    this.pixiZOrderedContainer = new PIXI.Container
}
WinLineVisual.prototype.OnWillRenderObject = function() {
    var scale = this.gameObject.transform.scale();
    this.pixiZOrderedContainer.x = this.gameObject.transform.position().x;
    this.pixiZOrderedContainer.y = -this.gameObject.transform.position().y;
    this.pixiZOrderedContainer.scale.x = scale.x;
    this.pixiZOrderedContainer.scale.y = scale.y
}
;
WinLineVisual.prototype.Awake = function() {
    if (this.showOnlyLineEnd)
        return;
    var grLeft = new PIXI.Graphics;
    grLeft.lineStyle(0);
    grLeft.beginFill(this.color.rgbAsHex, this.color.a);
    if (!this.useObjectAsEnd)
        grLeft.drawRect(this.guides[0].x - this.thickness, -this.guides[0].y - this.thickness, this.thickness * 2, this.thickness * 2);
    grLeft.endFill();
    var grLeftShadow = new PIXI.Graphics;
    grLeftShadow.lineStyle(0);
    grLeftShadow.beginFill(0, this.color.a);
    if (!this.useObjectAsEnd)
        grLeftShadow.drawRect(this.guides[0].x - this.thickness, -this.guides[0].y - this.thickness / 2, this.thickness * 2, this.thickness * 2);
    grLeftShadow.endFill();
    var grRight = new PIXI.Graphics;
    grRight.lineStyle(0);
    grRight.beginFill(this.color.rgbAsHex, this.color.a);
    if (!this.useObjectAsEnd)
        grRight.drawRect(this.guides[this.guides.length - 1].x - this.thickness, -this.guides[this.guides.length - 1].y - this.thickness, this.thickness * 2, this.thickness * 2);
    grRight.endFill();
    var grRightShadow = new PIXI.Graphics;
    grRightShadow.lineStyle(0);
    grRightShadow.beginFill(0, this.color.a);
    if (!this.useObjectAsEnd)
        grRightShadow.drawRect(this.guides[this.guides.length - 1].x - this.thickness, -this.guides[this.guides.length - 1].y - this.thickness / 2, this.thickness * 2, this.thickness * 2);
    grRightShadow.endFill();
    var grLine = new PIXI.Graphics;
    grLine.lineStyle(this.thickness, this.color.rgbAsHex, this.color.a);
    grLine.moveTo(this.guides[0].x, -this.guides[0].y);
    for (var i = 1; i < this.guides.length; i++)
        grLine.lineTo(this.guides[i].x, -this.guides[i].y);
    var grShadow = new PIXI.Graphics;
    grShadow.lineStyle(this.thickness, 0, this.color.a);
    grShadow.moveTo(this.guides[0].x, -this.guides[0].y + this.thickness / 2);
    for (var i = 1; i < this.guides.length; i++)
        grShadow.lineTo(this.guides[i].x, -this.guides[i].y + this.thickness / 2);
    this.pixiZOrderedContainer.addChild(grShadow);
    this.pixiZOrderedContainer.addChild(grLeftShadow);
    this.pixiZOrderedContainer.addChild(grRightShadow);
    this.pixiZOrderedContainer.addChild(grLine);
    this.pixiZOrderedContainer.addChild(grLeft);
    this.pixiZOrderedContainer.addChild(grRight)
}
;
WinLineVisual.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ShowWinLine, this.OnWinLineShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_HideWinLine, this.OnWinLineHide, this);
    XT.RegisterCallbackObject(Vars.LinesDefinitionsObject, this.LinesDefinitionsObject, this)
}
;
WinLineVisual.prototype.XTInitVariablesAndEvents = function() {}
;
WinLineVisual.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnWinLineShow, this);
    XT.UnregisterCallbackEvent(this.OnWinLineHide, this);
    XT.UnregisterCallbackObject(this.LinesDefinitionsObject, this)
}
;
WinLineVisual.prototype.Update = function() {}
;
WinLineVisual.prototype.OnWinLineShow = function() {
    if (this.id == XT.GetInt(Vars.CurrentDisplayedWinLineId)) {
        this.gameObject.SetActive(true);
        if (XT.GetBool(Vars.ShowSymbolSquaresOnLineVisual)) {
            var curWinLines = XT.GetObject(Vars.ReceivedWinLines);
            for (var i = 0; i < curWinLines.length; i++)
                if (curWinLines[i].LineNumber == this.id)
                    for (var j = 0; j < curWinLines[i].WinPositions.length; j++)
                        this.linesDefinitions.symbolSquares[curWinLines[i].WinPositions[j]].SetActive(true)
        }
    }
}
;
WinLineVisual.prototype.OnWinLineHide = function() {
    if (this.id == XT.GetInt(Vars.CurrentDisplayedWinLineId)) {
        this.gameObject.SetActive(false);
        if (XT.GetBool(Vars.ShowSymbolSquaresOnLineVisual)) {
            var curWinLines = XT.GetObject(Vars.ReceivedWinLines);
            for (var i = 0; i < curWinLines.length; i++)
                if (curWinLines[i].LineNumber == this.id)
                    for (var j = 0; j < curWinLines[i].WinPositions.length; j++)
                        this.linesDefinitions.symbolSquares[curWinLines[i].WinPositions[j]].SetActive(false)
        }
    }
}
;
WinLineVisual.prototype.LinesDefinitionsObject = function(ldObj) {
    this.linesDefinitions = ldObj
}
;
WinLineVisual.prototype.OnEnable = function() {
    if (this.useObjectAsEnd) {
        this.lineEndings[0].SetActive(true);
        this.lineEndings[1].SetActive(true)
    }
}
;
WinLineVisual.prototype.OnDisable = function() {
    if (this.useObjectAsEnd) {
        this.lineEndings[0].SetActive(false);
        this.lineEndings[1].SetActive(false)
    }
}
;
function ValueDisplayerVariable() {
    this.variable = null;
    this.suffix = ""
}
ValueDisplayerVariable.prototype.GetAnimatedVarName = function() {
    return this.variable.name + "_" + this.suffix + "_@nimated"
}
;
goog.require("UHT.XTLink");
goog.require("UHT.LocaleManager");
ValueDisplayer.prototype = Object.create(XTLink.prototype);
ValueDisplayer.prototype.constructor = ValueDisplayer;
function ValueDisplayer() {
    XTLink.call(this);
    this.vdVariable = null;
    this.animated = false;
    this.label = null;
    this.multiplier = 1;
    this.isDisplayingCoins = false;
    this.isDisplayingDecimals = false;
    this.formatOptions = null;
    this.forceHasCoins = false;
    this.allowDOG = true;
    this.catEventAnimation = null;
    this.callEventWhenValueChanged = false;
    this.callEventWhenFormatChanged = false;
    this.callEventWhenValueChangedAllowed = true;
    this.actualVarName = "";
    this.manualValue = 0;
    this.isLastOneToChangeTheLabel = false
}
ValueDisplayer.globalValueDisplayerDict = {};
ValueDisplayer.MarkAsLastModifierForLabel = function(label, obj) {
    if (obj.isLastOneToChangeTheLabel == false) {
        var key = ValueDisplayer.GetPathForLabel(label);
        if (ValueDisplayer.globalValueDisplayerDict[key] != undefined) {
            var list = ValueDisplayer.globalValueDisplayerDict[key];
            for (var i = 0; i < list.length; i++)
                list[i].isLastOneToChangeTheLabel = false
        }
        obj.isLastOneToChangeTheLabel = true
    }
}
;
ValueDisplayer.RegisterAsModifierForLabel = function(label, obj) {
    var key = ValueDisplayer.GetPathForLabel(label);
    var list = null;
    if (ValueDisplayer.globalValueDisplayerDict.hasOwnProperty(key) == false) {
        list = [];
        ValueDisplayer.globalValueDisplayerDict[key] = list
    } else
        list = ValueDisplayer.globalValueDisplayerDict[key];
    list.push(obj)
}
;
ValueDisplayer.GetPathForLabel = function(label) {
    var target = label.gameObject.transform;
    var path = label.gameObject.name;
    while (target.parent != null) {
        path = target.parent.gameObject.name + "_" + path;
        target = target.parent
    }
    return path
}
;
ValueDisplayer.prototype.XTRegisterCallbacks = function() {
    this.actualVarName = this.animated ? this.vdVariable.GetAnimatedVarName() : this.vdVariable.variable.name;
    if (!this.IsManualValue())
        XT.RegisterCallbackDouble(this.actualVarName, this.OnTargetValueChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_LocaleChanged, this.OnLocaleChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged, this);
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this);
    ValueDisplayer.RegisterAsModifierForLabel(this.label, this)
}
;
ValueDisplayer.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnTargetValueChanged, this)
}
;
ValueDisplayer.prototype.OnTargetValueChanged = function(newVal) {
    if (this.label.DOGchars == null && LocaleManager.isInit)
        this.label.DOGchars = this.GetDOGchars();
    newVal *= this.multiplier;
    ValueDisplayer.MarkAsLastModifierForLabel(this.label, this);
    var oldText = this.label.text;
    if (this.isDisplayingCoins && this.GetHasCoins())
        this.label.text = CoinManager.ConvertMoneyToCoins(newVal);
    else if (this.isDisplayingDecimals)
        this.label.text = LocaleManager.FormatValue(newVal, this.formatOptions);
    else
        this.label.text = (newVal | 0).toString();
    this.StartAnimEventIfNeeded(this.callEventWhenValueChanged && this.callEventWhenValueChangedAllowed, oldText.toString())
}
;
ValueDisplayer.prototype.OnLocaleChanged = function() {
    this.label.DOGchars = this.GetDOGchars();
    if (this.isDisplayingCoins && this.GetHasCoins())
        return;
    if (!this.isLastOneToChangeTheLabel)
        return;
    LocaleManager.ApplyFontToLabel(this.formatOptions.fontId, this.label);
    this.OnTargetValueChanged(this.GetTargetValue())
}
;
ValueDisplayer.prototype.OnCoinValueChanged = function() {
    if (!this.isDisplayingCoins || !this.GetHasCoins())
        return;
    if (!this.isLastOneToChangeTheLabel)
        return;
    this.OnTargetValueChanged(this.GetTargetValue())
}
;
ValueDisplayer.prototype.OnHasCoinsChanged = function(unused) {
    if (!this.isLastOneToChangeTheLabel)
        return;
    this.OnTargetValueChanged(this.GetTargetValue())
}
;
ValueDisplayer.prototype.StartAnimEventIfNeeded = function(canStart, oldText) {
    if (canStart && this.label.gameObject.activeInHierarchy && !this.catEventAnimation.IsRunning() && this.label.text != oldText)
        this.catEventAnimation.Start()
}
;
ValueDisplayer.prototype.GetHasCoins = function() {
    if (this.forceHasCoins)
        return true;
    return XT.GetBool(Vars.HasCoins)
}
;
ValueDisplayer.prototype.IsManualValue = function() {
    return _string.IsNullOrEmpty(this.actualVarName) || this.actualVarName == "*None*"
}
;
ValueDisplayer.prototype.GetTargetValue = function() {
    return this.IsManualValue() ? this.manualValue : XT.GetDouble(this.actualVarName)
}
;
ValueDisplayer.prototype.GetInternalValue = function() {
    return this.GetTargetValue()
}
;
ValueDisplayer.prototype.SetValueManually = function(newVal) {
    this.manualValue = newVal;
    this.OnTargetValueChanged(newVal)
}
;
ValueDisplayer.prototype.Awake = function() {
    XTLink.prototype.Awake.call(this);
    if (!this.allowDOG)
        return;
    this.label.isDOG = true;
    this.label.DOGmonospaceDigits = this.animated;
    if (LocaleManager.isInit)
        this.label.DOGchars = this.GetDOGchars()
}
;
ValueDisplayer.prototype.GetDOGchars = function() {
    var ret = " ,.0123456789";
    if (this.isDisplayingDecimals)
        if (this.formatOptions.hasJackpotCurrency)
            ret += LocaleManager.jackpotCurrencyInfo.CurrencySymbol;
        else
            ret += LocaleManager.currencyInfo.CurrencySymbol;
    return ret
}
;
goog.require("UHT.XTLink");
PerLineWinDisplayer.prototype = Object.create(XTLink.prototype);
PerLineWinDisplayer.prototype.constructor = PerLineWinDisplayer;
function PerLineWinDisplayer() {
    XTLink.call(this);
    this.StartCAT = null;
    this.StopCAT = null
}
PerLineWinDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateCurrentDisplayedWinLineIndex, this.OnUpdateWinLineIndex, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartDisplayWinLine, this.OnStartDisplayWinLine, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopDisplayWinLine, this.OnStopDisplayWinLine, this)
}
;
PerLineWinDisplayer.prototype.OnUpdateWinLineIndex = function() {
    var index = XT.GetInt(Vars.CurrentDisplayedWinLineIndex);
    var curWinLines = XT.GetObject(Vars.ReceivedWinLines);
    XT.SetDouble(Vars.CurrentDisplayedWinLineWin, curWinLines[index].WinAmount * XT.GetDouble(Vars.CurrentWinMultiplier));
    var curOrderedHoldersList = XT.GetObject(Vars.OrderedSymbolHoldersList);
    var winPositions = curWinLines[index].WinPositions;
    this.gameObject.transform.position(curOrderedHoldersList[winPositions[winPositions.length - 1]].gameObject.transform.position())
}
;
PerLineWinDisplayer.prototype.OnStartDisplayWinLine = function() {
    this.StartCAT.cat.StartEvent(this.StartCAT.id)
}
;
PerLineWinDisplayer.prototype.OnStopDisplayWinLine = function() {
    if (!this.StopCAT.cat.IsEventRunning(this.StopCAT.id))
        this.StopCAT.cat.StartEvent(this.StopCAT.id)
}
;
goog.require("UHT.VS_Symbol");
VS_SymbolScatterWild.prototype = Object.create(VS_Symbol.prototype);
VS_SymbolScatterWild.prototype.constructor = VS_SymbolScatterWild;
function VS_SymbolScatterWild() {
    VS_Symbol.call(this);
    this.eventWildNormal = null;
    this.eventWildSpinStart = null;
    this.eventWildSpinLoop = null;
    this.eventWildSpinStop = null;
    this.eventWildHighlightOff = null;
    this.eventWildFSHighlightOff = null;
    this.eventWildHighlightOn = null;
    this.eventWildExcited = null;
    this.eventWildWinExcited = null;
    this.eventWildWinning = null;
    this.eventSetAsScatter = null;
    this.eventSetAsWild = null;
    this.eventWildSpinLoopExcited = null;
    this.isScatter = true
}
VS_SymbolScatterWild.prototype.Start = function() {
    VS_Symbol.prototype.Start.call(this);
    this.eventWildNormal.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStart.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStop.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildFSHighlightOff.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildHighlightOn.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinning.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsScatter.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsWild.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoopExcited.UnregisterCallback(this.Callback_EventEnded, this);
    this.eventWildNormal.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStart.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinStop.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildFSHighlightOff.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildHighlightOn.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinExcited.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildWinning.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsScatter.RegisterCallback(this.Callback_EventEnded, this);
    this.eventSetAsWild.RegisterCallback(this.Callback_EventEnded, this);
    this.eventWildSpinLoopExcited.RegisterCallback(this.Callback_EventEnded, this)
}
;
VS_SymbolScatterWild.prototype.ProcessCommands = function() {
    if (this.commands.length > 0)
        if (this.canProcessNextCommand) {
            var newState = this.commands[0];
            this.commands.splice(0, 1);
            this.canProcessNextCommand = false;
            switch (newState) {
            case VS_Symbol.State.Normal:
                if (this.isScatter)
                    this.eventNormal.Start();
                else
                    this.eventWildNormal.Start();
                break;
            case VS_Symbol.State.HighlightOn:
                if (this.isScatter)
                    this.eventHighlightOn.Start();
                else
                    this.eventWildHighlightOn.Start();
                break;
            case VS_Symbol.State.HighlightOff:
                if (this.isScatter)
                    this.eventHighlightOff.Start();
                else
                    this.eventWildHighlightOff.Start();
                break;
            case VS_Symbol.State.SpinStart:
                if (this.isScatter)
                    this.eventSpinStart.Start();
                else
                    this.eventWildSpinStart.Start();
                break;
            case VS_Symbol.State.SpinLoop:
                if (this.isScatter)
                    this.eventSpinLoop.Start();
                else
                    this.eventWildSpinLoop.Start();
                break;
            case VS_Symbol.State.SpinStop:
                if (this.isScatter)
                    this.eventSpinStop.Start();
                else
                    this.eventWildSpinStop.Start();
                break;
            case VS_Symbol.State.Excited:
                if (this.isScatter)
                    this.eventExcited.Start();
                else
                    this.eventWildExcited.Start();
                break;
            case VS_Symbol.State.WinExcited:
                if (this.isScatter)
                    this.eventWinExcited.Start();
                else
                    this.eventWildWinExcited.Start();
                break;
            case VS_Symbol.State.Winning:
                if (this.isScatter)
                    this.eventWinning.Start();
                else
                    this.eventWildWinning.Start();
                break;
            case VS_Symbol.State.SpinLoopExcited:
                if (this.isScatter)
                    this.eventSpinLoopExcited.Start();
                else
                    this.eventWildSpinLoopExcited.Start();
                break;
            case VS_Symbol.State.FSHighlightOff:
                if (this.isScatter)
                    this.eventFSHighlightOff.Start();
                else
                    this.eventWildFSHighlightOff.Start();
                break;
            case VS_Symbol.State.Invalid:
            default:
                this.canProcessNextCommand = true;
                break
            }
            this.internalState = newState;
            this.currentStateForInspector = this.internalState
        } else if (this.stopEventSent == false)
            this.StopAllRunningEvents()
}
;
VS_SymbolScatterWild.prototype.StopAllRunningEvents = function() {
    VS_Symbol.prototype.StopAllRunningEvents.call(this);
    if (this.eventWildNormal.IsRunning())
        this.eventWildNormal.Stop();
    if (this.eventWildSpinStart.IsRunning())
        this.eventWildSpinStart.Stop();
    if (this.eventWildSpinLoop.IsRunning())
        this.eventWildSpinLoop.Stop();
    if (this.eventWildSpinStop.IsRunning())
        this.eventWildSpinStop.Stop();
    if (this.eventWildHighlightOff.IsRunning())
        this.eventWildHighlightOff.Stop();
    if (this.eventWildHighlightOn.IsRunning())
        this.eventWildHighlightOn.Stop();
    if (this.eventWildExcited.IsRunning())
        this.eventWildExcited.Stop();
    if (this.eventWildWinExcited.IsRunning())
        this.eventWildWinExcited.Stop();
    if (this.eventWildWinning.IsRunning())
        this.eventWildWinning.Stop();
    if (this.eventSetAsScatter.IsRunning())
        this.eventSetAsScatter.Stop();
    if (this.eventSetAsWild.IsRunning())
        this.eventSetAsWild.Stop();
    if (this.eventWildSpinLoopExcited.IsRunning())
        this.eventWildSpinLoopExcited.Stop();
    if (this.eventWildFSHighlightOff.IsRunning())
        this.eventWildFSHighlightOff.Stop()
}
;
VS_SymbolScatterWild.prototype.SetAsWild = function() {
    this.eventSetAsWild.Start();
    this.isScatter = false
}
;
VS_SymbolScatterWild.prototype.SetAsScatter = function() {
    this.eventSetAsScatter.Start();
    this.isScatter = true
}
;
goog.require("UHT.XTLink");
ResultDisplayer.prototype = Object.create(XTLink.prototype);
ResultDisplayer.prototype.constructor = ResultDisplayer;
function ResultDisplayer() {
    XTLink.call(this);
    ResultDisplayer.PlaySpinEndedBigWinSound = {
        whenEnteringResult: 0,
        whenExpandingIsDone: 1,
        whenLinesWillShow: 2
    };
    this.rq = null;
    this.showAllLinesVisual = true;
    this.showEachLineVisual = true;
    this.showSymbolSquaresOnLineVisual = false;
    this.expandSymbolsOneByOne = true;
    this.singleLineShowDuration = .5;
    this.allLinesShowDuration = 1;
    this.scatterDuration = .5;
    this.bonusDuration = .5;
    this.transitionDuration = .1;
    this.noWinDisplayDuration = .5;
    this.scatterWildChangeDuration = .2;
    this.mysteryScatterDuration = .5;
    this.applyDelayOnSymbols = false;
    this.delayIsAppliedPerReel = false;
    this.singleLineSymbolDelay = .2;
    this.allLinesSymbolDelay = .15;
    this.singleLineLastSymbolDelay = 1;
    this.allLinesLastSymbolDelay = 1;
    this.numberOfReels = 5;
    this.expandingSymbolDuration = 1;
    this.bigWinWaitsAllLinesLoops = 0;
    this.playSpinEndedBWCondition = 0;
    this.eachLine_WldOverridesDominatingSymbolWinSound = false;
    this.allLines_WildOverridesDominatingSymbolWinSound = false;
    this.allLines_PlaySymbolWinSoundOnlyOnce = false;
    this.showFSWonBeforeResult = false;
    this.showFSWonBeforeResultDuration = 2;
    this.showBonusWonBeforeResult = false;
    this.showBonusWonBeforeResultDuration = 2;
    this.treatMoneySymbolsAsBonusSymbols = true;
    this.treatMarkedPositionsAsBonusSymbols = false;
    this.symbolWinSoundPlayedOnce = false;
    this.mustStart = false;
    this.isMinimalMode = false;
    this.isStarted = false;
    this.mustAnimateScatters = false;
    this.scatterPositions = null;
    this.mustAnimateScattersWin = false;
    this.scatterWinPositions = null;
    this.mustAnimateBonuses = false;
    this.bonusPositions = null;
    this.mustSetScattersAsWilds = false;
    this.scatterAsWildPositions = null;
    this.mysteryScatterID = -1;
    this.mustAnimateMysteryScatters = false;
    this.mysteryScatterPositions = null;
    this.curWinLines = null;
    this.calculator = null;
    this.mustExpandSymbols = false;
    this.expandingSymbolsData = null;
    this.upSymbols = null;
    this.curOrderedHoldersList = null;
    this.resultTime = 3
}
ResultDisplayer.isJackpotWin = false;
ResultDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_Prepare, this.OnPrepare, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoLoop, this.OnDoLoop, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_DoCleanup, this.OnDoCleanup, this)
}
;
ResultDisplayer.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.RQManagerObject, this.rq);
    XT.SetBool(Vars.CanSpinAfterResultMinimumTime, false);
    XT.SetBool(Vars.ShowSymbolSquaresOnLineVisual, this.showSymbolSquaresOnLineVisual)
}
;
ResultDisplayer.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnPrepare, this);
    XT.UnregisterCallbackEvent(this.OnDoLoop, this);
    XT.UnregisterCallbackEvent(this.OnDoCleanup, this)
}
;
ResultDisplayer.prototype.Update = function() {
    if (this.mustStart) {
        this.mustStart = false;
        this.rq.StopRoutines();
        if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenEnteringResult && XT.GetBool(Vars.SpinResultIsBigWin))
            this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
        XT.TriggerEvent(Vars.Evt_Internal_InjectRQIOnResultDisplayerLoopStarts);
        if (XT.GetBool(Vars.FromServer_IsJackpotWin) && XT.GetBool(Vars.MustShowJackpotWon)) {
            ResultDisplayer.isJackpotWin = true;
            XT.SetBool(Vars.MustShowJackpotWon, false);
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIForMysteryJackpotWin)
        }
        if (XT.GetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion)) {
            this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_UpdateDisplayedWin));
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SignalTheUserCanSpin,true,this));
            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.noWinDisplayDuration))
        } else {
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIAfterBonusAnimate);
            if (this.mustAnimateScatters && this.showFSWonBeforeResult) {
                if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.mustSetScattersAsWilds) {
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetScatterWildAsScatter,this.scatterPositions,this));
                    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterWildChangeDuration))
                }
                if (this.mustAnimateScattersWin)
                    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowScattersWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,this.scatterPositions,this));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowFSWonBeforeResult));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.showFSWonBeforeResultDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this));
                if (this.mustAnimateScattersWin)
                    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin))
            }
            if (this.mustAnimateBonuses && this.showBonusWonBeforeResult) {
                this.mustAnimateBonuses = false;
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,this.bonusPositions,this));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowBonusWonBeforeResult));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.showBonusWonBeforeResultDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this))
            }
            if (this.mustExpandSymbols) {
                for (var xdIndex = 0; xdIndex < this.expandingSymbolsData.length; xdIndex++) {
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowExpandingSymbol,this.expandingSymbolsData[xdIndex].ExpandingSymbolId,this));
                    if (this.expandSymbolsOneByOne)
                        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.expandingSymbolDuration))
                }
                if (!this.expandSymbolsOneByOne && XT.GetBool(Vars.ExpandableDelayNeededAtTheEnd))
                    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.expandingSymbolDuration));
                this.mustExpandSymbols = false
            }
            if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenExpandingIsDone && XT.GetBool(Vars.SpinResultIsBigWin))
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
            if (!XT.GetBool(Vars.SpinResultIsBigWin) || this.bigWinWaitsAllLinesLoops == 0) {
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_UpdateDisplayedWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SignalTheUserCanSpin,true,this));
                XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeLinesShow);
                if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenLinesWillShow && XT.GetBool(Vars.SpinResultIsBigWin))
                    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
                if (this.curWinLines.length > 0)
                    this.QueueDisplayAllLines();
                this.QueueDisplayJackpot();
                this.QueueDisplayPayingSymbols()
            }
            if (this.bigWinWaitsAllLinesLoops > 0 && XT.GetBool(Vars.SpinResultIsBigWin)) {
                XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeLinesShow);
                if (this.playSpinEndedBWCondition == ResultDisplayer.PlaySpinEndedBigWinSound.whenLinesWillShow && XT.GetBool(Vars.SpinResultIsBigWin))
                    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_PlaySpinEndedBWSound));
                for (var i = 0; i < this.bigWinWaitsAllLinesLoops; i++)
                    if (this.curWinLines.length > 0)
                        this.QueueDisplayAllLines();
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_UpdateDisplayedWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SignalTheUserCanSpin,true,this))
            }
            var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
            var forceLBL = false;
            if (XT.GetBool(Vars.Jurisdiction_LineByLineFreespin))
                if (fsr.IsFreeSpin && !fsr.IsFreeSpinsStart)
                    forceLBL = true;
            if (XT.GetBool(Vars.Jurisdiction_LineByLineGlobal))
                forceLBL = true;
            if (!this.isMinimalMode || forceLBL) {
                this.rq.AddRoutineQueueItem(new RQIMarker(RQIMarker.MarkerType.StartLineByLine));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration));
                if (this.curWinLines.length > 1)
                    this.QueueDisplayLinesOneByOne();
                this.rq.AddRoutineQueueItem(new RQIMarker(RQIMarker.MarkerType.EndLineByLine));
                for (var i = 0; i < this.curWinLines.length; i++) {
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine,this.curWinLines[i].LineNumber,this));
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLineWin,i,this))
                }
            }
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIAfterLinesShow);
            if (this.mustAnimateScattersWin) {
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowScattersWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,this.scatterWinPositions,this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,1,this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin))
            }
            if (this.mustAnimateScatters && !this.showFSWonBeforeResult) {
                if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.mustSetScattersAsWilds) {
                    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetScatterWildAsScatter,this.scatterPositions,this));
                    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterWildChangeDuration))
                }
                if (this.mustAnimateScattersWin)
                    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowScattersWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,this.scatterPositions,this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,1,this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this));
                if (this.mustAnimateScattersWin)
                    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin))
            }
            if (XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin && this.mustAnimateMysteryScatters) {
                this.mustAnimateMysteryScatters = false;
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetMysteryScatters,this.mysteryScatterPositions,this));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowMysteryScatterWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,this.mysteryScatterPositions,this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.mysteryScatterDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideMysteryScatterWin));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this))
            }
            if (this.mustAnimateBonuses && !this.showBonusWonBeforeResult) {
                this.mustAnimateBonuses = false;
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,this.bonusPositions,this));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,0,this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.bonusDuration));
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this))
            }
            if (XT.GetBool(Vars.TruncateFSResponseDuringRespin)) {
                var truncated_fsr = XT.GetObject(Vars.TruncatedFreeSpinsResponse);
                var normal_fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
                if (truncated_fsr.IsFreeSpin && !normal_fsr.IsFreeSpin)
                    this.mustAnimateScatters = false
            }
            if (this.HasWorkToDo() == false)
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.noWinDisplayDuration));
            XT.TriggerEvent(Vars.Evt_Internal_InjectRQIBeforeEndOfDisplayLoop)
        }
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnDisplayLoopEnded,null,this));
        this.rq.StartRoutines()
    }
    this.resultTime += Time.deltaTime;
    if (XT.GetBool(Vars.CanSpinAfterResultMinimumTime)) {
        XT.SetBool(Vars.CanSpinAfterResultMinimumTime, false);
        this.SignalTheUserCanSpin(true)
    }
}
;
ResultDisplayer.prototype.OnPrepare = function() {
    this.curWinLines = XT.GetObject(Vars.ReceivedWinLines);
    this.isMinimalMode = XT.GetBool(Vars.ResultDisplayerMinimalMode);
    this.curOrderedHoldersList = XT.GetObject(Vars.OrderedSymbolHoldersList);
    this.calculator = XT.GetObject(Vars.SpinExciterObject);
    this.upSymbols = XT.GetObject(Vars.UpSymbols_RandomWilds);
    this.ComputeScatters();
    this.ComputeBonuses();
    if (XT.GetBool(Vars.ScatterSymbolIsWild))
        this.ComputeScattersSetAsWilds();
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin && !fsr.IsFreeSpinsStart && XT.GetDouble(Vars.MysteryScatterWinDisplayed) > 0)
        this.ComputeMysteryScatters();
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (this.HasWorkToDo() && !XT.GetBool(Vars.Evt_Internal_ResultDisplayer_SkipNextLoopOccasion))
            this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff();
        else
            this.curOrderedHoldersList[i].currentSymbol.SetNormal();
    this.expandingSymbolsData = XT.GetObject(Vars.ExpandingSymbolsData);
    this.mustExpandSymbols = this.expandingSymbolsData != null;
    console.log("ResultDisplayer - started (winlines: " + this.curWinLines.length + ", this.mustAnimateScatters = " + String(this.mustAnimateScatters) + ", this.mustAnimateBonuses = " + String(this.mustAnimateBonuses) + ")");
    this.isStarted = true;
    if (XT.GetObject(Vars.FromStageName) != UHTStageName.Init)
        this.resultTime = 0
}
;
ResultDisplayer.prototype.OnDoLoop = function() {
    if (this.isStarted)
        this.mustStart = true
}
;
ResultDisplayer.prototype.OnDoCleanup = function() {
    if (this.isStarted) {
        this.isStarted = false;
        this.mustStart = false;
        this.rq.StopRoutines();
        for (var i = 0; i < this.curWinLines.length; i++) {
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine,this.curWinLines[i].LineNumber,this));
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLineWin,i,this))
        }
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideScattersWin));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnResetAllSymbolsVisual,null,this));
        this.rq.StartRoutines()
    }
    this.symbolWinSoundPlayedOnce = false;
    ResultDisplayer.isJackpotWin = false
}
;
ResultDisplayer.prototype.QueueDisplayAllLines = function() {
    if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.mustSetScattersAsWilds) {
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnSetScatterWildAsWild,this.scatterAsWildPositions,this));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.scatterWildChangeDuration))
    }
    if (XT.GetDouble(Vars.TotalLinesWinReceived) > 0)
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowAllLinesWin));
    if (this.showAllLinesVisual)
        for (var i = 0; i < this.curWinLines.length; i++) {
            var id = this.curWinLines[i].LineNumber;
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowLine,id,this))
        }
    var mustPlaySymbolsWinSound = true;
    if (!(this.symbolWinSoundPlayedOnce && this.allLines_PlaySymbolWinSoundOnlyOnce))
        for (var i = 0; i < this.curWinLines.length; i++)
            if (this.allLines_WildOverridesDominatingSymbolWinSound && this.calculator.BetLinesFromServer(this.curWinLines[i].LineNumber).containsWild) {
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,2,this));
                this.symbolWinSoundPlayedOnce = true;
                mustPlaySymbolsWinSound = false;
                break
            }
    if (mustPlaySymbolsWinSound)
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,-1,this));
    if (this.applyDelayOnSymbols)
        this.QueueAllLinesDelayed(null);
    else {
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowAllSymbolAnimation,null,this));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_Internal_InjectRQIWhileShowingAllLines));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesShowDuration))
    }
    if (this.showAllLinesVisual)
        for (var i = 0; i < this.curWinLines.length; i++) {
            var id = this.curWinLines[i].LineNumber;
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine,id,this))
        }
    this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this));
    if (XT.GetDouble(Vars.TotalLinesWinReceived) > 0)
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
}
;
ResultDisplayer.prototype.QueueDisplayLinesOneByOne = function() {
    for (var i = 0; i < this.curWinLines.length; i++) {
        var id = this.curWinLines[i].LineNumber;
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowLineWin,i,this));
        if (this.showEachLineVisual)
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowLine,id,this));
        if (this.eachLine_WldOverridesDominatingSymbolWinSound && this.calculator.BetLinesFromServer(id).containsWild)
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,2,this));
        else
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SymbolWinPlaySound,this.calculator.BetLinesFromServer(id).dominatingSymbol,this));
        if (this.applyDelayOnSymbols)
            this.QueueSingleLineDelayed(id);
        else {
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnShowSymbolAnimation,id,this));
            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration))
        }
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLine,id,this));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,id,this));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideLineWin,i,this));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
}
;
ResultDisplayer.prototype.QueueSingleLineDelayed = function(lineId) {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    for (var i = 0; i < this.curWinLines.length; i++)
        if (this.curWinLines[i].LineNumber == lineId) {
            var winPositions = this.curWinLines[i].WinPositions;
            for (var j = 0; j < winPositions.length; ++j)
                isWinning[winPositions[j]] = true
        }
    for (var i = 0; i < this.numberOfReels; i++) {
        var j = i;
        while (j < this.curOrderedHoldersList.length) {
            if (isWinning[j]) {
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HighlightSymbol,j,this));
                this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineSymbolDelay))
            } else
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.UnHighlightSymbol,j,this));
            j = j + this.numberOfReels
        }
    }
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineLastSymbolDelay - this.singleLineSymbolDelay))
}
;
ResultDisplayer.prototype.QueueAllLinesDelayed = function(unused) {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    for (var i = 0; i < this.curWinLines.length; i++) {
        var winPositions = this.curWinLines[i].WinPositions;
        for (var j = 0; j < winPositions.length; j++)
            isWinning[winPositions[j]] = true
    }
    for (var i = 0; i < this.numberOfReels; i++) {
        var j = i;
        while (j < this.curOrderedHoldersList.length) {
            if (isWinning[j]) {
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HighlightSymbol,j,this));
                if (!this.delayIsAppliedPerReel)
                    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesSymbolDelay))
            } else
                this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.UnHighlightSymbol,j,this));
            j = j + this.numberOfReels
        }
        if (this.delayIsAppliedPerReel)
            this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesSymbolDelay))
    }
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.allLinesLastSymbolDelay - this.allLinesSymbolDelay))
}
;
ResultDisplayer.prototype.HighlightSymbol = function(id) {
    this.curOrderedHoldersList[id].currentSymbol.SetHighlightOn()
}
;
ResultDisplayer.prototype.UnHighlightSymbol = function(id) {
    this.curOrderedHoldersList[id].currentSymbol.SetHighlightOff()
}
;
ResultDisplayer.prototype.OnDisplayLoopEnded = function(unused) {
    XT.TriggerEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone)
}
;
ResultDisplayer.prototype.OnShowExpandingSymbol = function(param) {
    XT.SetInt(Vars.CurrentAnimatingExpandingSymbolID, _number.otoi(param));
    XT.TriggerEvent(Vars.Evt_Internal_ShowExpandingSymbol)
}
;
ResultDisplayer.prototype.OnShowLineWin = function(param) {
    XT.SetInt(Vars.CurrentDisplayedWinLineIndex, param);
    XT.TriggerEvent(Vars.Evt_Internal_UpdateCurrentDisplayedWinLineIndex);
    if (XT.GetDouble(Vars.CurrentDisplayedWinLineWin) > 0)
        XT.TriggerEvent(Vars.Evt_Internal_StartDisplayWinLine)
}
;
ResultDisplayer.prototype.OnHideLineWin = function(param) {
    if (XT.GetDouble(Vars.CurrentDisplayedWinLineWin) > 0)
        XT.TriggerEvent(Vars.Evt_Internal_StopDisplayWinLine)
}
;
ResultDisplayer.prototype.OnShowLine = function(param) {
    XT.SetInt(Vars.CurrentDisplayedWinLineId, param);
    XT.TriggerEvent(Vars.Evt_Internal_ShowWinLine)
}
;
ResultDisplayer.prototype.OnHideLine = function(param) {
    XT.SetInt(Vars.CurrentDisplayedWinLineId, param);
    XT.TriggerEvent(Vars.Evt_Internal_HideWinLine)
}
;
ResultDisplayer.prototype.OnShowAllSymbolAnimation = function(unused) {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    for (var i = 0; i < this.curWinLines.length; i++) {
        var winPositions = this.curWinLines[i].WinPositions;
        for (var j = 0; j < winPositions.length; j++)
            isWinning[winPositions[j]] = true
    }
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (isWinning[i])
            this.curOrderedHoldersList[i].currentSymbol.SetHighlightOn();
        else
            this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff()
}
;
ResultDisplayer.prototype.OnHideAllSymbolAnimation = function(unused) {
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff()
}
;
ResultDisplayer.prototype.OnResetAllSymbolsVisual = function(unused) {
    for (var i = 0; i < this.curOrderedHoldersList.length; i++) {
        if (XT.GetBool(Vars.ScatterSymbolIsWild) && this.curOrderedHoldersList[i].currentSymbol.symbolId == 1)
            this.curOrderedHoldersList[i].currentSymbol.SetAsScatter();
        this.curOrderedHoldersList[i].currentSymbol.SetNormal()
    }
}
;
ResultDisplayer.prototype.OnShowSymbolAnimation = function(lineId) {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    for (var i = 0; i < this.curWinLines.length; i++)
        if (this.curWinLines[i].LineNumber == lineId) {
            var winPositions = this.curWinLines[i].WinPositions;
            for (var j = 0; j < winPositions.length; ++j)
                isWinning[winPositions[j]] = true
        }
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (isWinning[i])
            this.curOrderedHoldersList[i].currentSymbol.SetHighlightOn();
        else
            this.curOrderedHoldersList[i].currentSymbol.SetHighlightOff()
}
;
ResultDisplayer.prototype.OnAnimateListOfSymbols = function(list) {
    for (var i = 0; i < list.length; i++)
        this.curOrderedHoldersList[list[i]].currentSymbol.SetHighlightOn()
}
;
ResultDisplayer.prototype.SymbolWinPlaySound = function(param) {
    var winSymbolID = param;
    XT.SetInt(Vars.ResultSymbolWinID, winSymbolID);
    XT.TriggerEvent(Vars.Evt_Internal_ResultSymbolWinPlaySound)
}
;
ResultDisplayer.prototype.FindSymbolsWithID = function(id) {
    var ret = [];
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (this.curOrderedHoldersList[i].currentSymbol.symbolId == id)
            ret.push(i);
    return ret
}
;
ResultDisplayer.prototype.FindInitialSymbolsWithID = function(id) {
    var ret = [];
    var initialResultSymbols = XT.GetObject(Vars.InitialResultScreenSymbols);
    for (var i = 0; i < initialResultSymbols.length; i++)
        for (var j = 0; j < initialResultSymbols[i].length; j++)
            if (id == initialResultSymbols[i][j])
                ret.push(i + (initialResultSymbols[i].length - 1 - j) * initialResultSymbols.length);
    return ret
}
;
ResultDisplayer.prototype.ComputeScatters = function() {
    var list = this.upSymbols != null ? this.FindInitialSymbolsWithID(1) : this.FindSymbolsWithID(1);
    var scatters = this.calculator.GetScattersThatNeedToBeAnimated();
    this.scatterPositions = [];
    for (var i = 0; i < list.length; i++)
        if (scatters[list[i]])
            this.scatterPositions.push(list[i]);
    this.mustAnimateScatters = this.scatterPositions.length > 0;
    if (this.mustAnimateScatters)
        this.isMinimalMode = true;
    this.scatterWinPositions = null;
    this.mustAnimateScattersWin = false;
    switch (this.calculator.ScatterPaysMoney) {
    case ScatterSymbolPayType.Everywhere:
        this.scatterWinPositions = this.upSymbols != null ? this.FindInitialSymbolsWithID(1) : this.FindSymbolsWithID(1);
        var scatterWin = XT.GetDouble(Vars.WinReceived) - XT.GetDouble(Vars.TotalLinesWinReceived);
        this.mustAnimateScattersWin = this.scatterWinPositions.length >= this.calculator.ScatterPaysMoneyMinCombo && scatterWin > 0;
        break;
    case ScatterSymbolPayType.OnActivePayline:
        console.warn("scatter pays on active payline...");
        break;
    case ScatterSymbolPayType.OnActivePaylineLeftToRight:
        console.warn("scatter pays on active payline from left to right...");
        break;
    case ScatterSymbolPayType.OnAdjacentReelsBothWays:
        this.scatterWinPositions = this.FindSymbolsWithID(1);
        var positions = [];
        var iR = 0;
        var j = 0;
        for (iR = 0; iR < this.numberOfReels; iR++)
            if (this.calculator.SymbolAppearencesOnReel(1, iR) == 0)
                break;
        if (iR >= this.calculator.ScatterPaysMoneyMinCombo) {
            for (j = 0; j < this.scatterWinPositions.length; j++)
                if (this.curOrderedHoldersList[this.scatterWinPositions[j]].parentReel.reelIndex < iR)
                    positions.push(this.scatterWinPositions[j]);
            this.mustAnimateScattersWin = true
        }
        for (iR = 0; iR < this.numberOfReels; iR++)
            if (this.calculator.SymbolAppearencesOnReel(1, this.numberOfReels - iR - 1) == 0)
                break;
        if (iR >= this.calculator.ScatterPaysMoneyMinCombo) {
            for (j = 0; j < this.scatterWinPositions.length; j++)
                if (this.curOrderedHoldersList[this.scatterWinPositions[j]].parentReel.reelIndex > this.numberOfReels - iR - 1)
                    positions.push(this.scatterWinPositions[j]);
            this.mustAnimateScattersWin = true
        }
        this.scatterWinPositions = positions;
        break;
    default:
        break
    }
    var payingSymbolsScatterIdx = XT.GetInt(PayingSymbolVars.PayingSymbolsScatterIndex);
    if (payingSymbolsScatterIdx > -1) {
        this.mustAnimateScattersWin = true;
        this.scatterWinPositions = XT.GetObject(PayingSymbolVars.PayingSymbols)[payingSymbolsScatterIdx].positions
    }
}
;
ResultDisplayer.prototype.ComputeBonuses = function() {
    var list = this.FindSymbolsWithID(0);
    var bonuses = this.calculator.GetBonusesThatNeedToBeAnimated();
    this.bonusPositions = [];
    for (var i = 0; i < list.length; i++)
        if (bonuses[list[i]])
            this.bonusPositions.push(list[i]);
    if (this.bonusPositions.length == 0) {
        var msData = XT.GetObject(Vars.MoneySymbolData);
        var j;
        if (this.treatMoneySymbolsAsBonusSymbols && msData != null && msData.currentValues != null)
            for (j = 0; j < msData.currentValues.length; j++) {
                if (msData.currentValues[j] > 0)
                    this.bonusPositions.push(j)
            }
        else {
            var markedPositions = XT.GetObject(Vars.MarkedSymbolPositions);
            if (this.treatMarkedPositionsAsBonusSymbols && markedPositions != null)
                for (j = 0; j < markedPositions.length; j++)
                    this.bonusPositions.push(markedPositions[j])
        }
    }
    var bonusFlag = XT.GetBool(Vars.MustOpenBonus);
    this.mustAnimateBonuses = this.bonusPositions.length > 0 && bonusFlag
}
;
ResultDisplayer.prototype.ComputeScattersSetAsWilds = function() {
    var isWinning = _array.create(this.curOrderedHoldersList.length, false);
    this.scatterAsWildPositions = [];
    for (var i = 0; i < this.curWinLines.length; i++) {
        var winPositions = this.curWinLines[i].WinPositions;
        for (var j = 0; j < winPositions.length; ++j)
            isWinning[winPositions[j]] = true
    }
    for (var i = 0; i < this.curOrderedHoldersList.length; i++)
        if (isWinning[i] && this.curOrderedHoldersList[i].currentSymbol.symbolId == 1)
            this.scatterAsWildPositions.push(i);
    this.mustSetScattersAsWilds = this.scatterAsWildPositions.length > 0
}
;
ResultDisplayer.prototype.OnSetScatterWildAsScatter = function(list) {
    for (var i = 0; i < list.length; i++)
        this.curOrderedHoldersList[list[i]].currentSymbol.SetAsScatter()
}
;
ResultDisplayer.prototype.OnSetScatterWildAsWild = function(list) {
    for (var i = 0; i < list.length; i++)
        this.curOrderedHoldersList[list[i]].currentSymbol.SetAsWild()
}
;
ResultDisplayer.prototype.HasWorkToDo = function() {
    return this.curWinLines.length > 0 || (this.mustAnimateScatters || XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin && this.mustAnimateMysteryScatters) || this.mustAnimateBonuses || this.mustAnimateScattersWin
}
;
ResultDisplayer.prototype.SignalTheUserCanSpin = function(param) {
    var canSpin = param;
    if (canSpin) {
        var applyResultMinimumTime = XT.GetBool(Vars.Jurisdiction_ResultMinimumTime) || XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins);
        if (XT.GetBool(Vars.ContinuousSpin) && XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo))
            applyResultMinimumTime = true;
        if (applyResultMinimumTime && !XT.GetObject(Vars.ReceivedFreeSpinsResponse).IsFreeSpin) {
            var resultMinimumTime = 0;
            if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTime))
                resultMinimumTime = XT.GetFloat(Vars.Jurisdiction_ResultMinimumTime_Value);
            if (XT.GetBool(Vars.ContinuousSpin) && XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeTurbo))
                resultMinimumTime = XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeTurbo_Value);
            if (XT.GetBool(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins))
                resultMinimumTime = Math.max(resultMinimumTime, XT.GetFloat(Vars.Jurisdiction_ResultMinimumTimeBetweenSpins_Value) - XT.GetFloat(Vars.SpinDuration));
            if (this.resultTime < resultMinimumTime) {
                canSpin = false;
                XT.SetBool(Vars.CanSpinAfterResultMinimumTime, true)
            }
        }
    }
    if (XT.GetObject(Vars.NudgedSymbols) != null)
        canSpin = false;
    XT.SetBool(Vars.CanSpin, canSpin)
}
;
ResultDisplayer.prototype.OnSetMysteryScatters = function(list) {
    for (var i = 0; i < list.length; ++i)
        this.curOrderedHoldersList[list[i]].ReplaceSymbol(this.mysteryScatterID);
    if (XT.GetBool(Vars.ScatterSymbolIsWild))
        this.ComputeScattersSetAsWilds()
}
;
ResultDisplayer.prototype.ComputeMysteryScatters = function() {
    this.mysteryScatterPositions = [];
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.MysteryScatter != null) {
        this.mysteryScatterID = fsr.MysteryScatter;
        var mysteryScatters = this.FindSymbolsWithID(this.mysteryScatterID);
        if (mysteryScatters.length >= this.calculator.MysteryScatterMinCombo) {
            var reels = XT.GetObject(Vars.ReelsManagerObject).reels;
            for (var i = 0; i < mysteryScatters.length; ++i) {
                var reelIdx = mysteryScatters[i] % reels.length;
                for (var j = 0; j < reels[reelIdx].symbolHolders.length; ++j)
                    this.mysteryScatterPositions.push(reelIdx + j * reels.length)
            }
        }
    }
    this.mustAnimateMysteryScatters = this.mysteryScatterPositions.length > 0
}
;
ResultDisplayer.prototype.QueueDisplayJackpot = function() {
    if (!ResultDisplayer.isJackpotWin)
        return;
    var allLinesWinShown = this.curWinLines.length > 0 && XT.GetDouble(Vars.TotalLinesWinReceived) > 0;
    if (!allLinesWinShown) {
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowJackpotWin));
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
    this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideJackpotWin));
    this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
}
;
ResultDisplayer.prototype.QueueDisplayPayingSymbols = function() {
    var payingSymbols = XT.GetObject(PayingSymbolVars.PayingSymbols);
    if (payingSymbols.length == 0 || XT.GetBool(PayingSymbolVars.PayingSymbolIsScatter))
        return;
    var allLinesWinShown = this.curWinLines.length > 0 && XT.GetDouble(Vars.TotalLinesWinReceived) > 0;
    if (!allLinesWinShown && !ResultDisplayer.isJackpotWin) {
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_ShowAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(Vars.Evt_CodeToData_HideAllLinesWin));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
    var scatterIdx = XT.GetInt(PayingSymbolVars.PayingSymbolsScatterIndex);
    for (var i = 0; i < payingSymbols.length; ++i) {
        if (i == scatterIdx)
            continue;
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.SetCurrentDisplayedPayingSymbolIndex,i,this));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(PayingSymbolVars.Evt_Internal_ShowPayingSymbol));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnAnimateListOfSymbols,payingSymbols[i].positions,this));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.singleLineShowDuration));
        this.rq.AddRoutineQueueItem(new RQITriggerEvent(PayingSymbolVars.Evt_Internal_HidePayingSymbol));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.OnHideAllSymbolAnimation,null,this));
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(this.transitionDuration))
    }
}
;
ResultDisplayer.prototype.SetCurrentDisplayedPayingSymbolIndex = function(param) {
    XT.SetInt(PayingSymbolVars.CurrentDisplayedPayingSymbolIndex, param)
}
;
goog.require("UHT.XTLink");
VS_MusicDuckByOneShot.prototype = Object.create(XTLink.prototype);
VS_MusicDuckByOneShot.prototype.constructor = VS_MusicDuckByOneShot;
function VS_MusicDuckByOneShot() {
    XTLink.call(this);
    this.oneShotDuckers = null;
    this.winCounter = null;
    this.soundManager = null;
    this.musicLogic = null
}
VS_MusicDuckByOneShot.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerObject, this);
    XT.RegisterCallbackObject(Vars.MusicLogicObject, this.OnMusicLogicObject, this);
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinCountingChanged, this)
}
;
VS_MusicDuckByOneShot.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.MusicDuckByOneShotObject, this);
    this.oneShotDuckers.push(this.winCounter)
}
;
VS_MusicDuckByOneShot.prototype.OnLastWinCountingChanged = function(counting) {
    if (counting)
        this.OneShotStartsPlaying(null, true);
    else
        this.OneShotStartsPlaying(null, false)
}
;
VS_MusicDuckByOneShot.prototype.OnSoundManagerObject = function(sMgr) {
    this.soundManager = sMgr
}
;
VS_MusicDuckByOneShot.prototype.OnMusicLogicObject = function(mLogic) {
    this.musicLogic = mLogic
}
;
VS_MusicDuckByOneShot.prototype.OneShotStartsPlaying = function(sound, duck) {
    if (this.soundManager == null)
        return;
    var isWinCounterDucking = sound == null;
    for (var i = isWinCounterDucking ? this.oneShotDuckers.length - 1 : 0; i < this.oneShotDuckers.length - (isWinCounterDucking ? 0 : 1); i++)
        if (isWinCounterDucking || this.oneShotDuckers[i].oneShotsClips.indexOf(sound) != -1) {
            var j;
            var useFading;
            for (j = 0; j < this.oneShotDuckers[i].musicClipsToDuck.length; j++) {
                var mClip = null;
                if (this.musicLogic != null)
                    mClip = this.musicLogic.GetMusicClipByAudioClip(this.oneShotDuckers[i].musicClipsToDuck[j]);
                if (mClip == null)
                    mClip = this.soundManager.GetMusicClipByAudioClip(this.oneShotDuckers[i].musicClipsToDuck[j]);
                if (mClip == null) {
                    this.oneShotDuckers[i].musicClipsToDuck.splice(j--, 1);
                    continue
                }
                useFading = this.oneShotDuckers[i].duckInDuration > 0 || this.oneShotDuckers[i].duckOutDuration > 0;
                if (useFading) {
                    mClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeInDuration = this.oneShotDuckers[i].duckInDuration;
                    mClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeOutDuration = this.oneShotDuckers[i].duckOutDuration
                }
                if (duck) {
                    if (isWinCounterDucking || sound.length > this.oneShotDuckers[i].autoUnduckOffset)
                        this.soundManager.DuckMusicClip(mClip, this.oneShotDuckers[i].duckingStep, isWinCounterDucking ? -1 : sound.length - this.oneShotDuckers[i].autoUnduckOffset, useFading)
                } else
                    this.soundManager.UnduckMusicClip(mClip, this.oneShotDuckers[i].duckingStep, useFading)
            }
            for (j = 0; j < this.oneShotDuckers[i].loopingClipsToDuck.length; j++) {
                var lClip = null;
                if (this.musicLogic != null)
                    lClip = this.musicLogic.GetLoopingClipByAudioClip(this.oneShotDuckers[i].loopingClipsToDuck[j]);
                if (lClip == null)
                    lClip = this.soundManager.GetLoopingClipByAudioClip(this.oneShotDuckers[i].loopingClipsToDuck[j]);
                if (lClip == null) {
                    this.oneShotDuckers[i].loopingClipsToDuck.splice(j--, 1);
                    continue
                }
                useFading = this.oneShotDuckers[i].duckInDuration > 0 || this.oneShotDuckers[i].duckOutDuration > 0;
                if (useFading) {
                    lClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeInDuration = this.oneShotDuckers[i].duckInDuration;
                    lClip.duckingSteps[this.oneShotDuckers[i].duckingStep].fadeOutDuration = this.oneShotDuckers[i].duckOutDuration
                }
                if (duck) {
                    if (isWinCounterDucking || sound.length > this.oneShotDuckers[i].autoUnduckOffset)
                        this.soundManager.DuckLoopingClip(lClip, this.oneShotDuckers[i].duckingStep, isWinCounterDucking ? -1 : sound.length - this.oneShotDuckers[i].autoUnduckOffset, useFading)
                } else
                    this.soundManager.UnduckLoopingClip(lClip, this.oneShotDuckers[i].duckingStep, useFading)
            }
        }
}
;
function SoundAndMusicList() {
    this.oneShotsClips = null;
    this.musicClipsToDuck = null;
    this.loopingClipsToDuck = null;
    this.duckingStep = 0;
    this.autoUnduckOffset = 0;
    this.duckInDuration = -1;
    this.duckOutDuration = -1
}
goog.provide("UHT.SoundManager");
goog.require("UHT.System.Misc.Utils");
goog.require("UHT.XTLink");
goog.require("UHT.AudioSource");
goog.require("UHT.AudioClip");
SoundManager.prototype = Object.create(XTLink.prototype);
SoundManager.prototype.constructor = SoundManager;
var MusicEmitterState = {
    Free: 0,
    InUse: 1
};
function SoundManager() {
    XTLink.call(this);
    this.playOneShotSource = null;
    this.fadeDuration = .5;
    this.musicSoundSource = [];
    this.loopingSources = [];
    this.AllowDuckingInTurboSpin = false;
    this.musicClips = [];
    this.loopingClips = [];
    this.duckByOneShot = null;
    this.volumeFX = 1;
    this.volumeMusic = 1;
    this.internalVolumeMusic = 1;
    this.internalVolumeFX = 1;
    this.initDone = false;
    this.nextFreeMusicHandler = 0;
    this.nextFreeLoopingHandler = 0
}
SoundManager.InvalidSoundHandle = -1;
SoundManager.forcedMute = false;
SoundManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SoundManager, this.OnSoundManagerInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_SoundBtn, this.OnSoundPressed, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_SoundFXBtn, this.OnSoundFXPressed, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_MusicBtn, this.OnMusicPressed, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SoundStateChanged, this.OnSoundStateChanged, this);
    XT.RegisterCallbackObject(Vars.MusicDuckByOneShotObject, this.OnMusicDuckByOneShotObject, this)
}
;
SoundManager.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.SoundManagerObject, this)
}
;
SoundManager.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSoundManagerInit, this);
    XT.UnregisterCallbackEvent(this.OnSoundStateChanged, this);
    XT.UnregisterCallbackEvent(this.OnSoundPressed, this);
    XT.UnregisterCallbackEvent(this.OnSoundFXPressed, this);
    XT.UnregisterCallbackEvent(this.OnMusicPressed, this);
    XT.UnregisterCallbackObject(this.OnMusicDuckByOneShotObject, this)
}
;
SoundManager.prototype.OnMusicDuckByOneShotObject = function(OSDucker) {
    this.duckByOneShot = OSDucker
}
;
SoundManager.prototype.OnMusicPressed = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    sndState.oldMusicIsOn = sndState.musicIsOn;
    sndState.musicIsOn = !sndState.musicIsOn;
    sndState.gameSoundIsOn = sndState.musicIsOn || sndState.soundFXIsOn;
    XT.SetBool(Vars.MusicIsOn, sndState.musicIsOn);
    XT.SetObject(Vars.SoundState, sndState);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
}
;
SoundManager.prototype.OnSoundFXPressed = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    sndState.oldSoundFXIsOn = sndState.soundFXIsOn;
    sndState.soundFXIsOn = !sndState.soundFXIsOn;
    sndState.gameSoundIsOn = sndState.musicIsOn || sndState.soundFXIsOn;
    XT.SetObject(Vars.SoundState, sndState);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
}
;
SoundManager.prototype.OnSoundPressed = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    if (SoundManager.forcedMute)
        if (!sndState.gameSoundIsOn)
            return;
    sndState.gameSoundIsOn = !sndState.gameSoundIsOn;
    if (sndState.gameSoundIsOn) {
        sndState.musicIsOn = sndState.oldMusicIsOn;
        sndState.soundFXIsOn = sndState.oldSoundFXIsOn
    } else {
        sndState.oldMusicIsOn = sndState.musicIsOn;
        sndState.oldSoundFXIsOn = sndState.soundFXIsOn;
        if (!sndState.musicIsOn && !sndState.soundFXIsOn)
            sndState.oldMusicIsOn = sndState.oldSoundFXIsOn = true;
        sndState.musicIsOn = false;
        sndState.soundFXIsOn = false
    }
    XT.SetBool(Vars.MusicIsOn, sndState.musicIsOn);
    XT.SetObject(Vars.SoundState, sndState);
    XT.TriggerEvent(Vars.Evt_Internal_SoundStateChanged);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
}
;
SoundManager.prototype.PlaySimple = function(sound) {
    this.playOneShotSource.PlayOneShot(sound, UHTAudioListener.volume * this.volumeFX * this.internalVolumeFX);
    if (this.duckByOneShot != null)
        if (sound != null)
            this.duckByOneShot.OneShotStartsPlaying(sound, true)
}
;
SoundManager.prototype.PlayMusic = function(music) {
    if (music == null)
        return -1;
    var mClip = this.GetMusicClipByAudioClip(music);
    this.PlayMusicClip(mClip, true);
    return mClip.handler
}
;
SoundManager.prototype.GetMusicClipByAudioClip = function(clip) {
    if (clip == null)
        return null;
    var mClip = null;
    for (var i = 0; i < this.musicClips.length; i++)
        if (this.musicClips[i].clip == clip) {
            mClip = this.musicClips[i];
            break
        }
    if (mClip == null) {
        mClip = new MusicClip;
        mClip.maxVolume = 1;
        mClip.volumeFadeInDuration = this.fadeDuration;
        mClip.volumeFadeOutDuration = this.fadeDuration;
        mClip.clip = clip
    }
    return mClip
}
;
SoundManager.prototype.RestartMusic = function() {
    for (var handler = 0; handler < this.musicClips.length; handler++)
        if (this.musicClips[handler].isPlaying && this.musicSoundSource[handler].clip != null)
            this.musicSoundSource[handler].Play()
}
;
SoundManager.prototype.StopMusic = function(args) {
    for (var i = 0; i < this.musicClips.length; i++)
        if (this.musicClips[i].handler == args.handle)
            this.StopMusicClip(this.musicClips[i], true);
    args.handle = SoundManager.InvalidSoundHandle
}
;
SoundManager.prototype.PlayLooping = function(sound) {
    if (sound == null)
        return -1;
    var lClip = this.GetLoopingClipByAudioClip(sound);
    this.PlayLoopingClip(lClip, false);
    return lClip.handler
}
;
SoundManager.prototype.GetLoopingClipByAudioClip = function(sound) {
    if (sound == null)
        return null;
    var lClip = null;
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].clip == sound) {
            lClip = this.loopingClips[i];
            break
        }
    if (lClip == null) {
        lClip = new MusicClip;
        lClip.maxVolume = 1;
        lClip.volumeFadeInDuration = this.fadeDuration;
        lClip.volumeFadeOutDuration = this.fadeDuration;
        lClip.clip = sound
    }
    return lClip
}
;
SoundManager.prototype.StopLoopingSound = function(args) {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].handler == args.handle)
            this.StopLoopingClip(this.loopingClips[i], false);
    args.handle = SoundManager.InvalidSoundHandle
}
;
SoundManager.prototype.MuteMusic = function() {
    this.internalVolumeMusic = 0;
    XT.TriggerEvent(Vars.Evt_Internal_MuteMusic)
}
;
SoundManager.prototype.UnmuteMusic = function() {
    this.internalVolumeMusic = 1;
    XT.TriggerEvent(Vars.Evt_Internal_UnmuteMusic)
}
;
SoundManager.prototype.MuteSoundFX = function() {
    this.internalVolumeFX = 0;
    this.UpdateSoundEmittersVolume()
}
;
SoundManager.prototype.UnmuteSoundFX = function() {
    this.internalVolumeFX = 1;
    this.UpdateSoundEmittersVolume()
}
;
SoundManager.prototype.MuteLoopingSound = function(handle) {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].handler == handle)
            this.MuteLoopingClip(this.loopingClips[i], false)
}
;
SoundManager.prototype.UnmuteLoopingSound = function(handle) {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingClips[i].handler == handle)
            this.UnmuteLoopingClip(this.loopingClips[i], false)
}
;
SoundManager.prototype.OnSoundManagerInit = function() {
    this.initDone = true;
    this.OnSoundStateChanged()
}
;
SoundManager.prototype.OnSoundStateChanged = function() {
    if (!this.initDone)
        return;
    var sndState = XT.GetObject(Vars.SoundState);
    this.volumeFX = 1;
    this.volumeMusic = 1;
    if (!sndState.globalSoundIsOn || !sndState.gameSoundIsOn)
        this.volumeFX = this.volumeMusic = 0;
    if (!sndState.soundFXIsOn)
        this.volumeFX = 0;
    if (!sndState.musicIsOn)
        this.volumeMusic = 0;
    this.UpdateSoundEmittersVolume()
}
;
SoundManager.prototype.UpdateSoundEmittersVolume = function() {
    this.playOneShotSource.volume = this.volumeFX * this.internalVolumeFX
}
;
SoundManager.prototype.PrepareNewMusicClip = function(mClip) {
    var handler = -1;
    if (this.nextFreeMusicHandler < this.musicSoundSource.length)
        handler = this.nextFreeMusicHandler;
    else
        handler = this.GetNewMusicSource();
    this.nextFreeMusicHandler++;
    this.musicSoundSource[handler].clip = mClip.clip;
    this.musicSoundSource[handler].loop = true;
    mClip.handler = handler;
    this.musicClips.push(mClip)
}
;
SoundManager.prototype.PrepareNewLoopingClip = function(lClip) {
    var handler = -1;
    if (this.nextFreeLoopingHandler < this.loopingSources.length)
        handler = this.nextFreeLoopingHandler;
    else
        handler = this.GetNewLoopingSource();
    this.nextFreeLoopingHandler++;
    this.loopingSources[handler].clip = lClip.clip;
    this.loopingSources[handler].loop = true;
    lClip.handler = handler;
    this.loopingClips.push(lClip)
}
;
SoundManager.prototype.GetNewMusicSource = function() {
    var newMusicSource = instantiate(this.musicSoundSource[0].gameObject);
    newMusicSource.name = "MusicSoundSource" + this.musicSoundSource.length;
    newMusicSource.audio = newMusicSource.GetComponent(AudioSource);
    newMusicSource.audio.playOnAwake = false;
    newMusicSource.transform.SetParent(this.transform, true);
    this.musicSoundSource.push(newMusicSource.audio);
    return this.musicSoundSource.length - 1
}
;
SoundManager.prototype.GetNewLoopingSource = function() {
    var newLoopingSource = instantiate(this.loopingSources[0].gameObject);
    newLoopingSource.name = "LoopingSource" + this.loopingSources.length;
    newLoopingSource.audio = newLoopingSource.GetComponent(AudioSource);
    newLoopingSource.audio.playOnAwake = false;
    newLoopingSource.transform.SetParent(this.transform, true);
    this.loopingSources.push(newLoopingSource.audio);
    return this.loopingSources.length - 1
}
;
SoundManager.prototype.PlayMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewMusicClip(musicClip);
    if (musicClip.isPlaying)
        return;
    musicClip.isPlaying = true;
    this.musicSoundSource[musicClip.handler].volume = 0;
    if (!musicClip.isMuted)
        if (useFading && musicClip.volumeFadeInDuration > 0) {
            musicClip.volumeLevel = 0;
            musicClip.volumeState = MusicVolumeState.fadingIn
        } else {
            musicClip.volumeLevel = 1;
            musicClip.volumeState = MusicVolumeState.idle;
            if (XT.GetBool(Vars.MusicIsOn))
                this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
        }
    if (musicClip.clip != null)
        this.musicSoundSource[musicClip.handler].Play()
}
;
SoundManager.prototype.StopMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewMusicClip(musicClip);
    musicClip.isPlaying = false;
    if (useFading && musicClip.volumeFadeOutDuration > 0)
        musicClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.musicSoundSource[musicClip.handler].volume = 0;
        this.musicSoundSource[musicClip.handler].Stop();
        musicClip.volumeLevel = 0;
        musicClip.volumeState = MusicVolumeState.idle
    }
}
;
SoundManager.prototype.MuteMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewMusicClip(musicClip);
    musicClip.isMuted = true;
    if (useFading && musicClip.volumeFadeOutDuration > 0)
        musicClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.musicSoundSource[musicClip.handler].volume = 0;
        musicClip.volumeState = MusicVolumeState.idle;
        musicClip.volumeLevel = 0
    }
}
;
SoundManager.prototype.UnmuteMusicClip = function(musicClip, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewMusicClip(musicClip);
    musicClip.isMuted = false;
    if (useFading && musicClip.volumeFadeInDuration > 0)
        musicClip.volumeState = MusicVolumeState.fadingIn;
    else {
        musicClip.volumeLevel = 1;
        musicClip.volumeState = MusicVolumeState.idle;
        if (XT.GetBool(Vars.MusicIsOn))
            this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
    }
}
;
SoundManager.prototype.DuckMusicClip = function(musicClip, duckingStepIndex, delayToAutoUnduck, useFading) {
    if (!this.AllowDuckingInTurboSpin)
        if (XT.GetBool(Vars.ContinuousSpin))
            return;
    if (musicClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewMusicClip(musicClip);
    if (delayToAutoUnduck > 0) {
        if (!musicClip.duckingSteps[duckingStepIndex].autoUnduck) {
            musicClip.duckingSteps[duckingStepIndex].autoUnduck = true;
            musicClip.duckingSteps[duckingStepIndex].duckCount++
        }
        if (delayToAutoUnduck > musicClip.duckingSteps[duckingStepIndex].autoUnduckTimer) {
            musicClip.duckingSteps[duckingStepIndex].autoUnduckShouldFade = useFading && musicClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0;
            musicClip.duckingSteps[duckingStepIndex].autoUnduckTimer = delayToAutoUnduck
        }
    } else
        musicClip.duckingSteps[duckingStepIndex].duckCount++;
    musicClip.UpdateDuckingStepPriority();
    if (useFading && musicClip.duckingSteps[duckingStepIndex].fadeInDuration > 0) {
        musicClip.duckingFadeInDuration = musicClip.duckingSteps[duckingStepIndex].fadeInDuration;
        musicClip.duckingState = MusicVolumeState.fadingIn
    } else {
        musicClip.duckingVolume = musicClip.duckingSteps[musicClip.priorityDuckingStepIndex].targetVolume;
        musicClip.duckingState = MusicVolumeState.idle;
        if (XT.GetBool(Vars.MusicIsOn))
            this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
    }
}
;
SoundManager.prototype.UnduckMusicClip = function(musicClip, duckingStepIndex, useFading) {
    if (musicClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewMusicClip(musicClip);
    if (musicClip.duckingSteps[duckingStepIndex].duckCount > 0) {
        if (musicClip.duckingSteps[duckingStepIndex].duckCount == 1 && musicClip.duckingSteps[duckingStepIndex].autoUnduck)
            return;
        musicClip.duckingSteps[duckingStepIndex].duckCount--;
        if (musicClip.duckingSteps[duckingStepIndex].duckCount > 0)
            return
    }
    musicClip.UpdateDuckingStepPriority();
    if (useFading && musicClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0)
        if (musicClip.priorityDuckingStepIndex == -1) {
            musicClip.duckingFadeOutDuration = musicClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            musicClip.duckingState = MusicVolumeState.fadingOut
        } else {
            musicClip.duckingFadeInDuration = musicClip.duckingSteps[duckingStepIndex].fadeInDuration;
            musicClip.duckingFadeOutDuration = musicClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            musicClip.duckingState = MusicVolumeState.fadingIn
        }
    else {
        if (musicClip.priorityDuckingStepIndex == -1)
            musicClip.duckingVolume = 1;
        else
            musicClip.duckingVolume = musicClip.duckingSteps[musicClip.priorityDuckingStepIndex].targetVolume;
        musicClip.duckingState = MusicVolumeState.idle;
        if (XT.GetBool(Vars.MusicIsOn))
            this.musicSoundSource[musicClip.handler].volume = musicClip.GetVolume() * this.internalVolumeMusic
    }
}
;
SoundManager.prototype.PlayLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewLoopingClip(loopingClip);
    if (loopingClip.isPlaying)
        return;
    loopingClip.isPlaying = true;
    this.loopingSources[loopingClip.handler].volume = 0;
    if (!loopingClip.isMuted)
        if (useFading && loopingClip.volumeFadeInDuration > 0) {
            loopingClip.volumeLevel = 0;
            loopingClip.volumeState = MusicVolumeState.fadingIn
        } else {
            loopingClip.volumeLevel = 1;
            loopingClip.volumeState = MusicVolumeState.idle;
            var sndState = XT.GetObject(Vars.SoundState);
            if (sndState.soundFXIsOn)
                this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() * this.internalVolumeFX
        }
    if (loopingClip.clip != null)
        this.loopingSources[loopingClip.handler].Play()
}
;
SoundManager.prototype.StopLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewLoopingClip(loopingClip);
    loopingClip.isPlaying = false;
    if (useFading && loopingClip.volumeFadeOutDuration > 0)
        loopingClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.loopingSources[loopingClip.handler].volume = 0;
        this.loopingSources[loopingClip.handler].Stop();
        loopingClip.volumeLevel = 0;
        loopingClip.volumeState = MusicVolumeState.idle
    }
}
;
SoundManager.prototype.MuteLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewLoopingClip(loopingClip);
    loopingClip.isMuted = true;
    if (useFading && loopingClip.volumeFadeOutDuration > 0)
        loopingClip.volumeState = MusicVolumeState.fadingOut;
    else {
        this.loopingSources[loopingClip.handler].volume = 0;
        loopingClip.volumeState = MusicVolumeState.idle;
        loopingClip.volumeLevel = 0
    }
}
;
SoundManager.prototype.UnmuteLoopingClip = function(loopingClip, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewLoopingClip(loopingClip);
    loopingClip.isMuted = false;
    if (useFading && loopingClip.volumeFadeInDuration > 0)
        loopingClip.volumeState = MusicVolumeState.fadingIn;
    else {
        loopingClip.volumeLevel = 1;
        loopingClip.volumeState = MusicVolumeState.idle;
        var sndState = XT.GetObject(Vars.SoundState);
        if (sndState.soundFXIsOn)
            this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() * this.internalVolumeFX
    }
}
;
SoundManager.prototype.DuckLoopingClip = function(loopingClip, duckingStepIndex, delayToAutoUnduck, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewLoopingClip(loopingClip);
    if (delayToAutoUnduck > 0) {
        if (!loopingClip.duckingSteps[duckingStepIndex].autoUnduck) {
            loopingClip.duckingSteps[duckingStepIndex].autoUnduck = true;
            loopingClip.duckingSteps[duckingStepIndex].duckCount++
        }
        if (delayToAutoUnduck > loopingClip.duckingSteps[duckingStepIndex].autoUnduckTimer) {
            loopingClip.duckingSteps[duckingStepIndex].autoUnduckShouldFade = useFading && loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0;
            loopingClip.duckingSteps[duckingStepIndex].autoUnduckTimer = delayToAutoUnduck
        }
    } else
        loopingClip.duckingSteps[duckingStepIndex].duckCount++;
    loopingClip.UpdateDuckingStepPriority();
    if (useFading && loopingClip.duckingSteps[duckingStepIndex].fadeInDuration > 0) {
        loopingClip.duckingFadeInDuration = loopingClip.duckingSteps[duckingStepIndex].fadeInDuration;
        loopingClip.duckingState = MusicVolumeState.fadingIn
    } else {
        loopingClip.duckingVolume = loopingClip.duckingSteps[loopingClip.priorityDuckingStepIndex].targetVolume;
        loopingClip.duckingState = MusicVolumeState.idle;
        var sndState = XT.GetObject(Vars.SoundState);
        if (sndState.soundFXIsOn)
            this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() * this.internalVolumeFX
    }
}
;
SoundManager.prototype.UnduckLoopingClip = function(loopingClip, duckingStepIndex, useFading) {
    if (loopingClip.handler == SoundManager.InvalidSoundHandle)
        this.PrepareNewLoopingClip(loopingClip);
    if (loopingClip.duckingSteps[duckingStepIndex].duckCount > 0) {
        if (loopingClip.duckingSteps[duckingStepIndex].duckCount == 1 && loopingClip.duckingSteps[duckingStepIndex].autoUnduck)
            return;
        loopingClip.duckingSteps[duckingStepIndex].duckCount--;
        if (loopingClip.duckingSteps[duckingStepIndex].duckCount > 0)
            return
    }
    loopingClip.UpdateDuckingStepPriority();
    if (useFading && loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration > 0)
        if (loopingClip.priorityDuckingStepIndex == -1) {
            loopingClip.duckingFadeOutDuration = loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            loopingClip.duckingState = MusicVolumeState.fadingOut
        } else {
            loopingClip.duckingFadeInDuration = loopingClip.duckingSteps[duckingStepIndex].fadeInDuration;
            loopingClip.duckingFadeOutDuration = loopingClip.duckingSteps[duckingStepIndex].fadeOutDuration;
            loopingClip.duckingState = MusicVolumeState.fadingIn
        }
    else {
        if (loopingClip.priorityDuckingStepIndex == -1)
            loopingClip.duckingVolume = 1;
        else
            loopingClip.duckingVolume = loopingClip.duckingSteps[loopingClip.priorityDuckingStepIndex].targetVolume;
        loopingClip.duckingState = MusicVolumeState.idle;
        var sndState = XT.GetObject(Vars.SoundState);
        if (sndState.soundFXIsOn)
            this.loopingSources[loopingClip.handler].volume = loopingClip.GetVolume() * this.internalVolumeFX
    }
}
;
SoundManager.prototype.UpdateMusicVolume = function() {
    for (var i = 0; i < this.musicClips.length; i++)
        if (this.musicSoundSource[this.musicClips[i].handler].volume != this.musicClips[i].GetVolume() * this.volumeMusic * this.internalVolumeMusic)
            this.musicSoundSource[this.musicClips[i].handler].volume = this.musicClips[i].GetVolume() * this.volumeMusic * this.internalVolumeMusic
}
;
SoundManager.prototype.UpdateLoopingClipsVolume = function() {
    for (var i = 0; i < this.loopingClips.length; i++)
        if (this.loopingSources[this.loopingClips[i].handler].volume != this.loopingClips[i].GetVolume() * this.volumeFX * this.internalVolumeFX)
            this.loopingSources[this.loopingClips[i].handler].volume = this.loopingClips[i].GetVolume() * this.volumeFX * this.internalVolumeFX
}
;
SoundManager.prototype.ComputeMusicClipsVolume = function() {
    for (var i = 0; i < this.musicClips.length; i++) {
        if (this.musicClips[i].volumeState == MusicVolumeState.fadingIn) {
            if (this.musicClips[i].volumeLevel < 1)
                this.musicClips[i].volumeLevel += Time.deltaTime * (1 / this.musicClips[i].volumeFadeInDuration);
            if (this.musicClips[i].volumeLevel >= 1) {
                this.musicClips[i].volumeLevel = 1;
                this.musicClips[i].volumeState = MusicVolumeState.idle
            }
        } else if (this.musicClips[i].volumeState == MusicVolumeState.fadingOut) {
            if (this.musicClips[i].volumeLevel > 0)
                this.musicClips[i].volumeLevel -= Time.deltaTime * (1 / this.musicClips[i].volumeFadeOutDuration);
            if (this.musicClips[i].volumeLevel <= 0) {
                this.musicClips[i].volumeLevel = 0;
                this.musicClips[i].volumeState = MusicVolumeState.idle;
                if (!this.musicClips[i].isPlaying)
                    this.StopMusicClip(this.musicClips[i], false)
            }
        }
        for (var j = 0; j < this.musicClips[i].duckingSteps.length; j++)
            if (this.musicClips[i].duckingSteps[j].autoUnduck)
                if (this.musicClips[i].duckingSteps[j].autoUnduckTimer > 0)
                    this.musicClips[i].duckingSteps[j].autoUnduckTimer -= Time.deltaTime;
                else {
                    this.musicClips[i].duckingSteps[j].autoUnduck = false;
                    this.UnduckMusicClip(this.musicClips[i], j, this.musicClips[i].duckingSteps[j].autoUnduckShouldFade)
                }
        if (this.musicClips[i].duckingState == MusicVolumeState.fadingIn)
            if (this.musicClips[i].duckingVolume < this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                this.musicClips[i].duckingVolume += Time.deltaTime * (1 / this.musicClips[i].duckingFadeOutDuration);
                if (this.musicClips[i].duckingVolume >= this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.musicClips[i].duckingVolume = this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume;
                    this.musicClips[i].duckingState = MusicVolumeState.idle
                }
            } else {
                if (this.musicClips[i].duckingVolume > this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.musicClips[i].duckingVolume -= Time.deltaTime * (1 / this.musicClips[i].duckingFadeInDuration);
                    if (this.musicClips[i].duckingVolume <= this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume) {
                        this.musicClips[i].duckingVolume = this.musicClips[i].duckingSteps[this.musicClips[i].priorityDuckingStepIndex].targetVolume;
                        this.musicClips[i].duckingState = MusicVolumeState.idle
                    }
                }
            }
        else if (this.musicClips[i].duckingState == MusicVolumeState.fadingOut) {
            if (this.musicClips[i].duckingVolume < 1)
                this.musicClips[i].duckingVolume += Time.deltaTime * (1 / this.musicClips[i].duckingFadeOutDuration);
            if (this.musicClips[i].duckingVolume >= 1) {
                this.musicClips[i].duckingVolume = 1;
                this.musicClips[i].duckingState = MusicVolumeState.idle
            }
        }
    }
}
;
SoundManager.prototype.ComputeLoopingClipsVolume = function() {
    for (var i = 0; i < this.loopingClips.length; i++) {
        if (this.loopingClips[i].volumeState == MusicVolumeState.fadingIn) {
            if (this.loopingClips[i].volumeLevel < 1)
                this.loopingClips[i].volumeLevel += Time.deltaTime * (1 / this.loopingClips[i].volumeFadeInDuration);
            if (this.loopingClips[i].volumeLevel >= 1) {
                this.loopingClips[i].volumeLevel = 1;
                this.loopingClips[i].volumeState = MusicVolumeState.idle
            }
        } else if (this.loopingClips[i].volumeState == MusicVolumeState.fadingOut) {
            if (this.loopingClips[i].volumeLevel > 0)
                this.loopingClips[i].volumeLevel -= Time.deltaTime * (1 / this.loopingClips[i].volumeFadeOutDuration);
            if (this.loopingClips[i].volumeLevel <= 0) {
                this.loopingClips[i].volumeLevel = 0;
                this.loopingClips[i].volumeState = MusicVolumeState.idle;
                if (!this.loopingClips[i].isPlaying)
                    this.StopLoopingClip(this.loopingClips[i], false)
            }
        }
        for (var j = 0; j < this.loopingClips[i].duckingSteps.length; j++)
            if (this.loopingClips[i].duckingSteps[j].autoUnduck)
                if (this.loopingClips[i].duckingSteps[j].autoUnduckTimer > 0)
                    this.loopingClips[i].duckingSteps[j].autoUnduckTimer -= Time.deltaTime;
                else {
                    this.loopingClips[i].duckingSteps[j].autoUnduck = false;
                    this.UnduckLoopingClip(this.loopingClips[i], j, this.loopingClips[i].duckingSteps[j].autoUnduckShouldFade)
                }
        if (this.loopingClips[i].duckingState == MusicVolumeState.fadingIn)
            if (this.loopingClips[i].duckingVolume < this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                this.loopingClips[i].duckingVolume += Time.deltaTime * (1 / this.loopingClips[i].duckingFadeOutDuration);
                if (this.loopingClips[i].duckingVolume >= this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.loopingClips[i].duckingVolume = this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume;
                    this.loopingClips[i].duckingState = MusicVolumeState.idle
                }
            } else {
                if (this.loopingClips[i].duckingVolume > this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                    this.loopingClips[i].duckingVolume -= Time.deltaTime * (1 / this.loopingClips[i].duckingFadeInDuration);
                    if (this.loopingClips[i].duckingVolume <= this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume) {
                        this.loopingClips[i].duckingVolume = this.loopingClips[i].duckingSteps[this.loopingClips[i].priorityDuckingStepIndex].targetVolume;
                        this.loopingClips[i].duckingState = MusicVolumeState.idle
                    }
                }
            }
        else if (this.loopingClips[i].duckingState == MusicVolumeState.fadingOut) {
            if (this.loopingClips[i].duckingVolume < 1)
                this.loopingClips[i].duckingVolume += Time.deltaTime * (1 / this.loopingClips[i].duckingFadeOutDuration);
            if (this.loopingClips[i].duckingVolume >= 1) {
                this.loopingClips[i].duckingVolume = 1;
                this.loopingClips[i].duckingState = MusicVolumeState.idle
            }
        }
    }
}
;
SoundManager.prototype.Update = function() {
    this.ComputeMusicClipsVolume();
    this.ComputeLoopingClipsVolume();
    this.UpdateMusicVolume();
    this.UpdateLoopingClipsVolume()
}
;
goog.provide("UHT.SoundLoader");
goog.require("UHT.AudioClip");
goog.require("UHT.SoundManager");
var SoundHelper = {};
SoundHelper.AudioFormat = {
    none: "none",
    mp3: "mp3",
    ogg: "ogg"
};
SoundHelper.audioFormat = SoundHelper.AudioFormat.none;
SoundHelper.ParsePath = function(value) {
    var ret = {
        name: value,
        src: value,
        extension: SoundHelper.audioFormat
    };
    return ret
}
;
SoundHelper.wasTouchMove = false;
SoundHelper.OnTouchStart = function() {
    SoundHelper.wasTouchMove = false
}
;
SoundHelper.OnTouchMove = function() {
    SoundHelper.wasTouchMove = true
}
;
SoundHelper.OnIOSTouchEnd = function() {
    if (SoundHelper.wasTouchMove)
        return;
    var audioCtx = createjs.Sound.activePlugin.context;
    if (audioCtx.state == "interrupted") {
        console.warn("SoundHelper.OnIOSTouchEnd: state interrupted");
        audioCtx.resume().then(function() {
            console.warn("SoundHelper.OnIOSTouchEnd: resumed context");
            XT.GetObject(Vars.SoundManagerObject).RestartMusic()
        })
    }
}
;
var SoundLoader = {};
SoundLoader.AudioProcessor = function(settings) {
    this.id = settings.id;
    this.url = settings.url;
    this.base64 = settings.base64;
    this.context = settings.context;
    this.handler = settings.handler;
    this.audioSource = null;
    this.state = SoundLoader.AudioState.none
}
;
SoundLoader.AudioProcessor.decodeIsLocked = false;
SoundLoader.AudioProcessor.prototype.ProcessWebAudio = function() {
    var instance = this;
    if (window["UHT_SOUNDSLOADER_LOWERMEMORYPEAK"] == true && SoundLoader.AudioProcessor.decodeIsLocked) {
        setTimeout(function() {
            instance.ProcessWebAudio()
        }, 10);
        return
    }
    SoundLoader.AudioProcessor.decodeIsLocked = true;
    var binary = window.atob(this.base64);
    var base64AsArrayBuffer = new ArrayBuffer(binary.length);
    var bytes = new Uint8Array(base64AsArrayBuffer);
    for (var i = 0; i < base64AsArrayBuffer.byteLength; i++)
        bytes[i] = binary.charCodeAt(i) & 255;
    this.context.decodeAudioData(base64AsArrayBuffer, function(buffer) {
        instance.audioSource = buffer;
        instance.state = SoundLoader.AudioState.success;
        instance.handler.call(instance);
        SoundLoader.AudioProcessor.decodeIsLocked = false
    }, function() {
        console.error("decode error: ", instance.id, instance.url);
        instance.state = SoundLoader.AudioState.error;
        instance.handler.call(instance);
        SoundLoader.AudioProcessor.decodeIsLocked = false
    })
}
;
SoundLoader.AudioProcessor.prototype.ProcessHtmlAudio = function() {
    this.url = "data:audio/" + SoundHelper.audioFormat + ";base64," + this.base64;
    var src = {};
    src[SoundHelper.audioFormat] = this.url;
    createjs.Sound.registerSound(src, this.id, undefined, "");
    this.state = SoundLoader.AudioState.success
}
;
SoundLoader.AudioType = {
    none: "none",
    web: "web",
    html: "html"
};
SoundLoader.AudioState = {
    none: 0,
    success: 1,
    error: 2
};
SoundLoader.audioType = SoundLoader.AudioType.none;
SoundLoader.clips = {};
SoundLoader.processors = {};
SoundLoader.touchStartHandler = null;
SoundLoader.touchMoveHandler = null;
SoundLoader.touchEndHandler = null;
SoundLoader.initialized = false;
SoundLoader.numSounds = 0;
SoundLoader.numClips = 0;
SoundLoader.soundsAreBeingLoaded = false;
SoundLoader.soundsAreLoaded = false;
SoundLoader.checkLoadCompleteTimeout = null;
SoundLoader.DelayCheckLoadComplete = function() {
    if (SoundLoader.checkLoadCompleteTimeout != null)
        clearTimeout(SoundLoader.checkLoadCompleteTimeout);
    SoundLoader.checkLoadCompleteTimeout = setTimeout(SoundLoader.CheckLoadComplete, 200)
}
;
SoundLoader.LoadSound = function(clip) {
    SoundLoader.clips[clip.name] = clip;
    SoundLoader.numClips++
}
;
SoundLoader.OnSoundDecoded = function(processor) {
    if (processor.state != SoundLoader.AudioState.success)
        return;
    createjs.Sound._idHash[processor.id] = {
        src: processor.url
    };
    createjs.Sound.activePlugin._soundInstances[processor.url] = [];
    createjs.Sound.activePlugin._audioSources[processor.url] = processor.audioSource
}
;
var GA_SND_MOBILE_SENT = false;
SoundLoader.LoadSounds = function() {
    if (UHT_DEVICE_TYPE.DESKTOP == false && !GA_SND_MOBILE_SENT) {
        var timer = globalTracking.GetTimerValue("uht_behaviour", "Session_timer", "BehaviourTracker");
        globalTracking.SendEvent("uht_behaviour", "SND_MOBILE_download_started", timer, "BehaviourTracker");
        GA_SND_MOBILE_SENT = true
    }
    if (SoundHelper.audioFormat == SoundHelper.AudioFormat.none)
        return;
    SoundLoader.soundsAreBeingLoaded = true;
    if (UHT_PACKAGES_INFO_OBJ == null || globalGamePath == undefined) {
        setTimeout(SoundLoader.LoadSounds, 100);
        return
    }
    var info = UHT_PACKAGES_INFO_OBJ["languages"] || [];
    var language = UHT_GAME_CONFIG["LANGUAGE"];
    var filename = "sounds";
    if (language != "en") {
        var soundsLocalized = false;
        for (var i = 0; i < info.length; ++i)
            if (info[i]["language"] == language) {
                if (info[i]["sound"] == 1) {
                    filename += language;
                    soundsLocalized = true
                }
                break
            }
        if (!soundsLocalized) {
            var suffix = UHT_PACKAGES_INFO_OBJ["default_sound_suffix"] || "";
            filename += suffix
        }
    }
    filename += "." + SoundHelper.audioFormat;
    if (LoaderProgress.Sound_Download_Total == -1) {
        var sizes = {};
        var nameSizes = String(UHT_SOUNDS_SIZES).split(",");
        UHT_SOUNDS_SIZES = null;
        for (var i = 0; i < nameSizes.length; ++i) {
            var nameSize = nameSizes[i].split(":");
            if (nameSize.length > 1)
                sizes[nameSize[0]] = nameSize[1]
        }
        LoaderProgress.Sound_Download_Total = Number(sizes[filename])
    }
    new ResourceRequest({
        url: (globalGamePath || "") + filename + ".json",
        complete: new EventHandler(SoundLoader,SoundLoader.OnSoundsLoaded),
        onprogress: new EventHandler(SoundLoader,SoundLoader.OnSoundsProgress)
    })
}
;
SoundLoader.OnSoundsProgress = function(progress) {
    LoaderProgress.Sound_Download_Current = progress.loaded
}
;
SoundLoader.OnSoundsLoaded = function(req) {
    if (!_string.IsNullOrEmpty(req.error)) {
        console.error("SoundLoader - failed to load sounds: " + req.url + " " + req.error);
        setTimeout(SoundLoader.LoadSounds, 250);
        return
    }
    if (!SoundLoader.initialized) {
        setTimeout(function() {
            SoundLoader.OnSoundsLoaded(req)
        }, 200);
        return
    }
    LoaderProgress.Sound_Download_Current = LoaderProgress.Sound_Download_Total;
    var data = JSON.parse(req.Data);
    var sounds = data["sounds"];
    SoundLoader.numSounds = sounds.length;
    var processAudioMethod = "ProcessWebAudio";
    if (SoundLoader.audioType == SoundLoader.AudioType.html)
        processAudioMethod = "ProcessHtmlAudio";
    for (var i = 0; i < sounds.length; ++i) {
        var id = "s" + sounds[i].id;
        var processor = new SoundLoader.AudioProcessor({
            id: id,
            url: id + "." + SoundHelper.audioFormat,
            base64: sounds[i].data,
            handler: new EventHandler(SoundLoader,SoundLoader.OnSoundDecoded),
            context: createjs.Sound.activePlugin.context
        });
        processor[processAudioMethod]();
        SoundLoader.processors[processor.id] = processor
    }
    SoundLoader.DelayCheckLoadComplete()
}
;
SoundLoader.InitSounds = function() {
    var parser = new UAParser2;
    var browser = parser.getBrowser();
    if (!createjs.Sound.initializeDefaultPlugins()) {
        console.error("SoundLoader.InitSounds - html audio & web audio are not supported !");
        return
    }
    var capabilities = createjs.Sound.getCapabilities();
    SoundHelper.audioFormat = capabilities["ogg"] ? SoundHelper.AudioFormat.ogg : SoundHelper.AudioFormat.mp3;
    if (createjs.Sound.activePlugin instanceof createjs.WebAudioPlugin)
        SoundLoader.audioType = SoundLoader.AudioType.web;
    else if (createjs.Sound.activePlugin instanceof createjs.HTMLAudioPlugin) {
        createjs.Sound._parsePath = SoundHelper.ParsePath;
        SoundLoader.audioType = SoundLoader.AudioType.html
    }
    SoundLoader.initialized = true;
    console.info("SoundLoader.InitSounds", capabilities, SoundHelper.audioFormat, SoundLoader.audioType)
}
;
SoundLoader.CheckLoadComplete = function() {
    if (!SoundLoader.IsLoadComplete()) {
        SoundLoader.DelayCheckLoadComplete();
        return
    }
    for (var id in SoundLoader.clips) {
        var clip = SoundLoader.clips[id];
        var processor = SoundLoader.processors[id];
        if (processor != undefined && processor.state == SoundLoader.AudioState.success) {
            createjs.Sound.setDefaultPlayProps(clip.name, {
                pan: 1E-4
            });
            clip.soundjsObject = createjs.Sound.createInstance(clip.name)
        }
    }
    SoundLoader.soundsAreLoaded = true;
    SoundLoader.processors = null;
    SoundLoader.checkLoadCompleteTimeout = null;
    globalTracking.StartTimer("uht_behaviour", "Sound_until_first_mute", "BehaviourTracker");
    globalTracking.StartTimer("uht_behaviour", "Sound_until_first_unmute", "BehaviourTracker")
}
;
SoundLoader.IsLoadComplete = function() {
    if (SoundLoader.numSounds != SoundLoader.numClips)
        return false;
    for (var id in SoundLoader.processors)
        if (SoundLoader.processors[id].state == SoundLoader.AudioState.none)
            return false;
    return true
}
;
SoundLoader.OnTouchEnd = function() {
    var gameLoaded = LoaderProgress.Download_Current == LoaderProgress.Download_Total && LoaderProgress.Import_Current == LoaderProgress.Import_Total;
    if (gameLoaded && !SoundHelper.wasTouchMove) {
        if (createjs.BrowserDetect.isIOS)
            globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(SoundHelper,SoundHelper.OnIOSTouchEnd));
        globalColliderInputManager.removeEventHandler(ColliderEvent.ButtonUp, SoundLoader.touchEndHandler);
        window.removeEventListener("keydown", SoundLoader.OnTouchEnd, false);
        SoundLoader.InitSounds()
    }
}
;
SoundLoader.OnLoad = function() {
    if (window["UHT_ForceClickForSounds"] != undefined || createjs.BrowserDetect.isIOS || createjs.BrowserDetect.isAndroid || createjs.BrowserDetect.isBlackberry || createjs.BrowserDetect.isWindowPhone) {
        if (globalColliderInputManager == undefined) {
            setTimeout(SoundLoader.OnLoad, 200);
            return
        }
        if (createjs.BrowserDetect.isIOS) {
            SoundLoader.touchStartHandler = new EventHandler(SoundHelper,SoundHelper.OnTouchStart);
            SoundLoader.touchMoveHandler = new EventHandler(SoundHelper,SoundHelper.OnTouchMove);
            globalColliderInputManager.addEventHandler(ColliderEvent.ButtonDown, SoundLoader.touchStartHandler);
            globalColliderInputManager.addEventHandler(ColliderEvent.MouseMove, SoundLoader.touchMoveHandler)
        }
        SoundLoader.touchEndHandler = new EventHandler(SoundLoader,SoundLoader.OnTouchEnd);
        globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, SoundLoader.touchEndHandler);
        window.addEventListener("keydown", SoundLoader.OnTouchEnd, false)
    } else {
        SoundLoader.InitSounds();
        SoundLoader.LoadSounds()
    }
}
;
SoundLoader.OnLoad();
goog.provide("UHT.Importer");
goog.require("UHT.SoundLoader");
goog.require("UHT.FontLoader");
goog.require("UHT.TextAsset");
goog.require("UHT.AudioClip");
function RawComponentData() {
    this.fileID = 0;
    this.componentType = "";
    this.enabled = false;
    this.serializableData = null
}
function Importer() {
    this.mapInstanceIdToInstanceScene = {};
    this.mapGuidToResource = {};
    this.serializableFields = {};
    this.componentToRawDataMap = [];
    this.allObjects = [];
    this.mapIdToInstance = {};
    this.state = Importer.State.Idle;
    this.timeQuota = 0;
    this.isSync = false;
    this.resourceStartIndex = -1;
    this.gameObjectStartIndex = -1;
    this.deserializeIndex = -1;
    this.importSteps = 0
}
Importer.State = {
    Idle: 0,
    Inited: 1,
    Instantiating: 2,
    Deserializing: 3,
    Finishing: 4
};
Importer.ImportRetData = function() {
    this.isDone = false;
    this.objects = null
}
;
Importer.prototype.StartImport = function(timeQuota, jsonData) {
    this.state = Importer.State.Inited;
    this.timeQuota = timeQuota;
    this.isSync = !(timeQuota > 0);
    this.resourceStartIndex = 0;
    this.gameObjectStartIndex = 0;
    this.deserializeIndex = 0;
    this.componentToRawDataMap = [];
    this.allObjects = [];
    this.importSteps = 0;
    this.currentProgress = 0;
    this.totalNumberOfSteps = 1;
    if (this.isSync == false) {
        LoaderProgress.Import_Textures_Total = 0;
        for (var resIdx = 0; resIdx < jsonData.resources.length; resIdx++) {
            var curRes = jsonData.resources[resIdx];
            this.totalNumberOfSteps++;
            if (curRes.type == "GameObject")
                for (var goIdx = 0; goIdx < curRes.data.root.length; goIdx++) {
                    var components = curRes.data.root[goIdx].components;
                    this.totalNumberOfSteps += components.length + 1;
                    for (var compIdx = 0; compIdx < components.length; compIdx++)
                        if (components[compIdx].componentType == "UIAtlas") {
                            var atlasData = components[compIdx].serializableData;
                            var usesLowEndResource = UHT_LOW_END_DEVICE && atlasData.hasLowEndResource;
                            if (!(atlasData.resourcePriority > 0 && !usesLowEndResource)) {
                                LoaderProgress.Import_Textures_Total++;
                                console.log("TEX to be loaded for: " + curRes.data.root[goIdx].name + " " + LoaderProgress.Import_Textures_Total)
                            }
                        }
                }
        }
    }
    if (!this.isSync)
        globalTracking.StartTimer("uht_loading", "_X_import_instantiate_duration", "LoadingTracker")
}
;
Importer.prototype.Advance = function(jsonData, resourcesPath) {
    var ret = new Importer.ImportRetData;
    var time0 = (new Date).getTime();
    this.importSteps++;
    if (this.state == Importer.State.Inited)
        this.state = Importer.State.Instantiating;
    if (this.state == Importer.State.Instantiating) {
        for (var resIdx = this.resourceStartIndex; resIdx < jsonData.resources.length; resIdx++) {
            var curRes = jsonData.resources[resIdx];
            switch (curRes.type) {
            case "Texture":
                var src = null;
                if (curRes.data.isInline)
                    src = curRes.data.src;
                else
                    src = resourcesPath + curRes.data.src;
                this.mapGuidToResource["g" + curRes.id] = {
                    type: curRes.type,
                    data: src
                };
                break;
            case "Font":
                var fontName = curRes.data.fontName;
                this.mapGuidToResource["g" + curRes.id] = {
                    type: curRes.type,
                    data: fontName
                };
                FontLoader.LoadFont(fontName, curRes.data.path);
                break;
            case "GameObject":
                if (this.gameObjectStartIndex == 0)
                    this.mapIdToInstance = {};
                for (var goIdx = this.gameObjectStartIndex; goIdx < curRes.data.root.length; goIdx++) {
                    this.allObjects[this.allObjects.length] = this.createGameObject(curRes.data.root[goIdx], this.mapIdToInstance, this.componentToRawDataMap);
                    this.gameObjectStartIndex++;
                    this.currentProgress++;
                    if (this.IsQuantaFinished(time0))
                        return ret
                }
                this.mapGuidToResource["g" + curRes.id] = {
                    type: curRes.type,
                    data: this.mapIdToInstance
                };
                this.gameObjectStartIndex = 0;
                break;
            case "TextAsset":
                var t = new TextAsset(curRes.data.text);
                this.mapGuidToResource["g" + curRes.id] = {
                    type: curRes.type,
                    data: t
                };
                break;
            case "AudioClip":
                var ac = new AudioClip("s" + curRes.id,resourcesPath + curRes.data.path);
                SoundLoader.LoadSound(ac);
                this.mapGuidToResource["g" + curRes.id] = {
                    type: curRes.type,
                    data: ac
                };
                break;
            case "AnimationClip":
                var clip = new AnimationClip;
                deserializeComponentRec(curRes.data, clip, this, "resolveReference");
                if (clip.wrapMode == WrapMode.PingPong)
                    console.error("Wrapmode PingPong not supported! (name: " + clip.name + ")");
                this.mapGuidToResource["g" + curRes.id] = {
                    type: curRes.type,
                    data: clip
                };
                break;
            default:
                console.error("Unknown resource type: " + curRes.type + "!");
                break
            }
            this.resourceStartIndex++;
            this.currentProgress++;
            if (this.IsQuantaFinished(time0))
                return ret
        }
        if (!this.isSync) {
            globalTracking.StopTimerAndSend("uht_loading", "_X_import_instantiate_duration", "LoadingTracker");
            globalTracking.StartTimer("uht_loading", "_X_import_deserialize_duration", "LoadingTracker")
        }
        this.state = Importer.State.Deserializing;
        if (this.IsQuantaFinished(time0))
            return ret
    }
    if (this.state == Importer.State.Deserializing) {
        for (var j = this.deserializeIndex; j < this.componentToRawDataMap.length; j++) {
            this.componentToRawDataMap[j].comp.deserialize(this.componentToRawDataMap[j].rawData.serializableData, this, "resolveReference");
            this.deserializeIndex++;
            this.currentProgress++;
            if (this.IsQuantaFinished(time0))
                return ret
        }
        this.state = Importer.State.Finishing;
        if (this.IsQuantaFinished(time0))
            return ret
    }
    if (this.state == Importer.State.Finishing) {
        this.currentProgress++;
        ret.isDone = true;
        ret.objects = [];
        for (var k = 0; k < this.allObjects.length; k++) {
            if (this.allObjects[k].transform.parent == null)
                ret.objects.push(this.allObjects[k]);
            for (var compIdx = 0; compIdx < this.allObjects[k].components.length; compIdx++)
                if (this.allObjects[k].components[compIdx]["AfterDeserialize"] != undefined)
                    this.allObjects[k].components[compIdx].AfterDeserialize()
        }
        console.log("Loaded " + this.allObjects.length + " gameobjects in " + this.importSteps + " steps.");
        this.state = Importer.State.Idle;
        if (!this.isSync)
            globalTracking.StopTimerAndSend("uht_loading", "_X_import_deserialize_duration", "LoadingTracker");
        return ret
    }
    return ret
}
;
Importer.prototype.IsQuantaFinished = function(curTime) {
    if (this.isSync)
        return false;
    var t = (new Date).getTime();
    return t - curTime > this.timeQuota
}
;
Importer.prototype.clear = function() {
    this.mapInstanceIdToInstanceScene = {};
    this.mapGuidToResource = {}
}
;
Importer.prototype.createGameObject = function(rawGOData, idToInstanceMap, componentToRawDataMap) {
    var newGO = new GameObject;
    newGO.internalCopyFromOther(rawGOData);
    idToInstanceMap["m" + rawGOData.fileID] = newGO;
    for (var i = 0; i < rawGOData.components.length; i++) {
        var compData = rawGOData.components[i];
        this.registerSerializedFields(compData.componentType, compData.serializableData);
        var newComp = createComponent(compData.componentType, compData.enabled);
        if (newComp != null) {
            idToInstanceMap["m" + compData.fileID] = newComp;
            componentToRawDataMap.push({
                comp: newComp,
                rawData: compData
            });
            newComp.gameObject = newGO;
            newGO.components.push(newComp);
            newGO.internalCacheComponent(newComp)
        }
    }
    for (var l = 0; l < newGO.components.length; l++)
        newGO.components[l].transform = newGO.transform;
    return newGO
}
;
Importer.prototype.resolveReference = function(rawData) {
    if (rawData == null)
        return null;
    if (Array.isArray(rawData)) {
        var ret = new Array(rawData.length);
        for (var i = 0; i < rawData.length; i++)
            ret[i] = this.resolveReference(rawData[i]);
        return ret
    } else if (rawData.hasOwnProperty("fileID")) {
        var id = rawData["fileID"];
        var hasGUID = rawData.hasOwnProperty("guid");
        if (!hasGUID) {
            if (id == 0)
                return null;
            var propName = "m" + id;
            if (this.mapInstanceIdToInstanceScene.hasOwnProperty(propName))
                return this.mapInstanceIdToInstanceScene[propName]
        } else {
            var resId = "g" + rawData["guid"];
            if (this.mapGuidToResource.hasOwnProperty(resId)) {
                var resDesc = this.mapGuidToResource[resId];
                switch (resDesc.type) {
                case "Texture":
                    return resDesc.data;
                    break;
                case "Font":
                    return resDesc.data;
                    break;
                case "GameObject":
                    var mapIdToInstance = resDesc.data;
                    if (id == 0)
                        return null;
                    var propName = "m" + id;
                    if (mapIdToInstance.hasOwnProperty(propName))
                        return mapIdToInstance[propName];
                    break;
                case "TextAsset":
                    return resDesc.data;
                    break;
                case "AudioClip":
                    return resDesc.data;
                    break;
                case "AnimationClip":
                    return resDesc.data;
                    break;
                default:
                    console.error("Unknown resource type: " + resDesc.type + "!");
                    break
                }
            } else
                console.error("Trying to reference an unregistered resource! id: " + resId + "!")
        }
    }
    console.error("Could not resolve reference");
    return null
}
;
Importer.prototype.registerSerializedFields = function(compName, fields) {
    if (this.serializableFields.hasOwnProperty(compName) == false)
        this.serializableFields[compName] = fields
}
;
Importer.prototype.getSerializedFields = function(compName) {
    if (this.serializableFields.hasOwnProperty(compName))
        return this.serializableFields[compName];
    return null
}
;
goog.require("UHT.Runtime");
goog.require("UHT.Renderer");
goog.require("UHT.Importer");
goog.require("UHT.ColliderInputManager");
goog.require("UHT.KeyboardManager");
var globalRuntime = new Runtime;
var globalRenderer = new Renderer;
var globalImporter = new Importer;
var globalColliderInputManager = new ColliderInputManager;
var globalClientPath = UHT_CONFIG.GAME_URL + "client/";
var globalGamePath = UHT_CONFIG.GAME_URL + "game/";
var globalResourcesNeededList = [];
var globalResourcesNeededInfo = [];
var globalPauseForResources = false;
var currentDownloadingAtlas = null;
var globalListOfDeferredLoadingAtlases = [];
var filterStrength = 20;
var frameTimeForFPSCounter = 0;
var prevFrameDate = new Date;
var thisFrameDate;
var mainGameJsonData = null;
var PageVisible = true;
var IS_UCBROWSER = navigator.userAgent.indexOf("UCBrowser") > -1;
function main() {
    console.log("Main started");
    UHTInterfaceBOSS.PostMessage("gameLoadingStarted");
    globalTracking._internalUseStartTime("uht_loading", "_1_loader_downloaded_and_shown", GA_timer_load_start, "LoadingTracker");
    globalTracking._internalUseStartTime("uht_loading", "_4_loading_total_time", GA_timer_load_start, "LoadingTracker");
    LoadingStep = 1;
    globalTracking.StartTimer("uht_loading", "_CLOSED_at_" + LoadingStep, "LoadingTracker");
    loadJsonWithCallback(globalClientPath + "game.json", onClientLoaded);
    setInterval(function() {
        globalRenderer.setFPSCount(1 / frameTimeForFPSCounter)
    }, 1E3);
    document.addEventListener("visibilitychange", function() {
        PageVisible = document.visibilityState == "visible";
        var volume = Globals.isMobile ? 1 : XT.GetFloat(Vars.SoundVolume);
        volume = isFinite(volume) && !isNaN(volume) ? volume : 1;
        createjs.Sound.setVolume(PageVisible ? volume : 1E-5);
        if (!PageVisible)
            globalTracking.PauseTimers();
        else
            globalTracking.ResumeTimers()
    })
}
function loadJsonWithCallback(url, loadedCallback, progressCallback) {
    var xmlhttp = new XMLHttpRequest;
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4)
            if (xmlhttp.status == 200)
                loadedCallback(xmlhttp.responseText);
            else {
                if (progressCallback != undefined)
                    progressCallback();
                setTimeout(function() {
                    loadJsonWithCallback(url, loadedCallback, progressCallback)
                }, 250)
            }
    }
    ;
    xmlhttp.onprogress = function(progress) {
        if (xmlhttp.readyState != 4)
            if (progressCallback != undefined)
                progressCallback(progress)
    }
    ;
    xmlhttp.open("GET", url, true);
    xmlhttp.send()
}
function onClientLoaded(text) {
    window["UHTLogotype"]["GameLoadingStarted"]();
    globalTracking.StopTimerAndSend("uht_loading", "_1_loader_downloaded_and_shown", "LoadingTracker");
    var timer = globalTracking.GetTimerValue("uht_loading", "_1_loader_downloaded_and_shown", "LoadingTracker");
    globalTracking.SendEvent("uht_loading", "_1_loader_downloaded_and_shown", timer, "LoadingTracker");
    LoadingStep = 2;
    globalTracking.StartTimer("uht_loading", "_CLOSED_at_" + LoadingStep, "LoadingTracker");
    globalTracking.StartTimer("uht_loading", "_2_game_downloading", "LoadingTracker");
    console.log("client loaded!");
    globalRenderer.init();
    var myArr = JSON.parse(text);
    globalImporter.StartImport(0, myArr);
    var ret = globalImporter.Advance(myArr, globalClientPath);
    globalImporter.clear();
    KeyboardManager.Init();
    globalColliderInputManager.initInput();
    globalRuntime.addNewSceneRoot(ret.objects[0]);
    globalDoFrame()
}
var UpdateStep = true;
function CheckAndSetPauseForResources() {
    var mustPause = false;
    for (var i = 0; i < globalResourcesNeededList.length; i++)
        if (globalResourcesNeededList[i].isLoaded()) {
            globalResourcesNeededList.splice(i, 1);
            i--
        } else
            mustPause = true;
    if (mustPause != globalPauseForResources) {
        globalPauseForResources = mustPause;
        var mustShowPauseIndicator = globalPauseForResources && !loaderIsVisible;
        if (!mustPause) {
            globalResourcesNeededInfo = [];
            document.getElementById("progressbar").style.display = "none"
        }
        var show = mustShowPauseIndicator ? "block" : "none";
        document.getElementById("PauseRoot").style.display = show;
        document.getElementById("pauseindicator").style.display = show;
        var ccl = document.getElementsByTagName("canvas")[0].classList;
        if (mustShowPauseIndicator)
            ccl.add("paused");
        else
            ccl.remove("paused")
    }
    if (!loaderIsVisible) {
        if (mustPause) {
            var percentLoaded = 0;
            for (var j = 0; j < globalResourcesNeededInfo.length; j++) {
                var loaded = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeLoaded;
                var total = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeTotal;
                if (total > 0)
                    percentLoaded += loaded / total / globalResourcesNeededInfo.length;
                else if (globalResourcesNeededInfo[j].valid)
                    percentLoaded += 1 / globalResourcesNeededInfo.length
            }
            document.getElementById("progressbar").style.display = "block";
            document.getElementById("progressvalue").style.width = Number(percentLoaded * 100).toFixed(2) + "%"
        }
        if (!(UHTEngine.SoundsAreLoaded() || UHTEngine.SoundsAreLoading()))
            UHTEngine.StartLoadingSounds()
    }
}
var hasSomethingToDraw = false;
var batterySaverIsOff = true;
function globalDoFrame() {
    if ((!globalPauseForResources || loaderIsVisible) && (!UpdateStep || batterySaverIsOff) && hasSomethingToDraw) {
        if (globalPauseForResources) {
            var list = globalRuntime.onWillRenderList.components;
            for (var i = 0; i < list.length; i++) {
                var cur = list[i];
                if (cur == null)
                    continue;
                if (cur instanceof UIPanel)
                    cur.container.children = []
            }
        }
        globalRenderer.doFrame();
        if (!loaderIsVisible)
            Time.frameCount++
    }
    if (globalPauseForResources) {
        CheckAndSetPauseForResources();
        prevFrameDate = new Date;
        requestAnimationFrame(globalDoFrame);
        return
    } else {
        if (timerToStartPrefetching > 0)
            timerToStartPrefetching--;
        if (timerToStartPrefetching == 0)
            internalContinuePrefetchingTextures()
    }
    if (UpdateStep || batterySaverIsOff) {
        globalRenderer.checkWindowSize();
        if (canvasSizeDirty) {
            globalRenderer.resizeUHTScreen();
            EventManager.Trigger("EVT_UHT_RESIZE", null)
        }
        internalContinueImporting();
        var thisFrameTime = ((thisFrameDate = new Date) - prevFrameDate) / 1E3;
        if (thisFrameTime < 0)
            thisFrameTime = 0;
        prevFrameDate = thisFrameDate;
        frameTimeForFPSCounter += (thisFrameTime - frameTimeForFPSCounter) / filterStrength;
        Time.deltaTime = thisFrameTime > .1 ? .1 : thisFrameTime;
        Time.time += Time.deltaTime;
        KeyboardManager.Update();
        globalColliderInputManager.updateInput();
        EventManager.Trigger("EVT_UHT_BEFOREUPDATE", null);
        globalRuntime.doFrame();
        EventManager.Trigger("EVT_UHT_UPDATE", null);
        hasSomethingToDraw = true;
        CheckAndSetPauseForResources()
    }
    UpdateStep = !UpdateStep;
    requestAnimationFrame(globalDoFrame)
}
var loaderController = null;
var loaderCallbackDownloadDone = "";
var loaderCallbackHide = "";
var loaderIsVisible = true;
var gameRequests = [];
function downloadMainGame(listener, callbackDownloadDone, callbackHide) {
    loaderController = listener;
    loaderCallbackDownloadDone = callbackDownloadDone;
    loaderCallbackHide = callbackHide;
    for (var i = 0; i < UHT_GAME_FILES.length; ++i)
        gameRequests.push(new ResourceRequest({
            url: globalGamePath + UHT_GAME_FILES[i],
            complete: new EventHandler(null,onGamePartComplete),
            onprogress: new EventHandler(null,onGameJSONProgress),
            callbackArg: String(i)
        }))
}
function onGamePartComplete(req, arg) {
    if (!_string.IsNullOrEmpty(req.error)) {
        onGameJSONProgress();
        setTimeout(function() {
            gameRequests[Number(arg)] = new ResourceRequest({
                url: req.url,
                complete: req.complete,
                onprogress: req.onprogress,
                callbackArg: req.callbackArg
            })
        }, 250);
        return
    }
    var data = "";
    for (var i = 0; i < gameRequests.length; ++i) {
        if (!(gameRequests[i].Done && _string.IsNullOrEmpty(gameRequests[i].error)))
            return;
        data += gameRequests[i].Data
    }
    gameRequests = null;
    onGameJSONLoaded(data);
    UHT_GAME_FILES = null;
    UHT_GAME_FILES_SIZES = null
}
function onGameJSONLoaded(text) {
    globalTracking.StopTimerAndSend("uht_loading", "_2_game_downloading", "LoadingTracker");
    var timer = globalTracking.GetTimerValue("uht_loading", "_2_game_downloading", "LoadingTracker");
    globalTracking.SendEvent("uht_loading", "_2_game_downloading", timer, "LoadingTracker");
    LoadingStep = 3;
    globalTracking.StartTimer("uht_loading", "_CLOSED_at_" + LoadingStep, "LoadingTracker");
    globalTracking.StartTimer("uht_loading", "_3_game_opening_and_connecting", "LoadingTracker");
    LoaderProgress.Download_Current = LoaderProgress.Download_Total;
    console.log("maingame loaded!");
    mainGameJsonData = JSON.parse(text);
    loaderController[loaderCallbackDownloadDone]()
}
function importMainGame() {
    globalImporter.StartImport(UHT_DEVICE_TYPE.DESKTOP == true ? 25 : 40, mainGameJsonData);
    LoaderProgress.Import_Total = globalImporter.totalNumberOfSteps;
    LoaderProgress.Import_Current = globalImporter.currentProgress
}
var timerToStartPrefetching = -1;
function internalContinuePrefetchingTextures() {
    if (currentDownloadingAtlas != null && currentDownloadingAtlas.isLoaded()) {
        currentDownloadingAtlas.internalTextureLoadedCallback();
        currentDownloadingAtlas = null
    }
    if (globalListOfDeferredLoadingAtlases.length > 0 && currentDownloadingAtlas == null) {
        currentDownloadingAtlas = globalListOfDeferredLoadingAtlases[0];
        currentDownloadingAtlas.loadAtlasTexture();
        globalListOfDeferredLoadingAtlases.splice(0, 1)
    }
}
function internalContinueImporting() {
    if (globalImporter.state != Importer.State.Idle) {
        var ret = globalImporter.Advance(mainGameJsonData, globalGamePath);
        LoaderProgress.Import_Current = globalImporter.currentProgress;
        if (ret.isDone) {
            LoaderProgress.Import_Current = globalImporter.totalNumberOfSteps;
            globalImporter.clear();
            globalRuntime.addNewSceneRoot(ret.objects[0]);
            mainGameJsonData = {}
        }
    }
}
function onGameJSONProgress() {
    var done = 0;
    var loading = 0;
    var i = 0;
    for (i = 0; i < gameRequests.length; ++i) {
        var req = gameRequests[i];
        if (req.Done) {
            if (_string.IsNullOrEmpty(req.error))
                done += UHT_GAME_FILES_SIZES[i]
        } else
            loading += req.progressLoaded
    }
    if (loading + done > LoaderProgress.Download_Current)
        LoaderProgress.Download_Current = loading + done;
    LoaderProgress.Download_Total = UHT_GAME_SIZE
}
var LoaderProgress = {
    Download_AlreadyDownloaded: -1,
    Download_SoundAlreadyDownloaded: -1,
    Download_Retried_LockedPercent: 0,
    Download_Current: 0,
    Sound_Download_Current: 0,
    Import_Current: 0,
    Import_Textures_Current: 0,
    InitConnection_Current: 0,
    InitConnection_Visual: 0,
    Localize_Current: 0,
    Blocking_Current: 0,
    Blocking_Visual: 0,
    SymbolsManagers_Current: 0,
    Download_Total: -1,
    Sound_Download_Total: -1,
    Import_Total: -1,
    Import_Textures_Total: -1,
    InitConnection_Total: 1,
    Localize_Total: 1,
    Blocking_Total: -1,
    SymbolsManagers_Total: -1,
    Download_Weight: .7,
    Sound_Download_Weight: 0,
    GameAndSound_Download_Weight: .7,
    Import_Weight: .1,
    Import_Textures_Weight: .2,
    InitConnection_Weight: .025,
    Localize_Weight: .025,
    Blocking_Weight: .01,
    SymbolsManagers_Weight: .1
};
var LoadingWheelSentOnce = false;
function signalNeedPauseForTexture(atlas) {
    if (atlas.requested)
        return;
    if (!LoadingWheelSentOnce && !loaderIsVisible) {
        globalTracking.SendEvent("uht_behaviour", "Loading_wheel_once", 1, "BehaviourTracker");
        LoadingWheelSentOnce = true
    }
    if (!loaderIsVisible)
        globalTracking.SendEvent("uht_behaviour_loading_wheel", "Initiated_for_" + atlas.gameObject.name, 1, "BehaviourTracker");
    globalResourcesNeededList.push(atlas);
    atlas.requested = true;
    for (var i = 0; i < globalListOfDeferredLoadingAtlases.length; i++) {
        var curAtlas = globalListOfDeferredLoadingAtlases[i];
        if (!curAtlas.requested && curAtlas.isBlockingResource && curAtlas.resourcePriority == atlas.resourcePriority) {
            curAtlas.loadAtlasTexture();
            globalResourcesNeededList.push(curAtlas);
            curAtlas.requested = true;
            if (!loaderIsVisible && !curAtlas.pixiTexture.valid)
                globalTracking.SendEvent("uht_behaviour_loading_wheel", "Loaded_also_" + curAtlas.gameObject.name, 1, "BehaviourTracker");
            if (loaderIsVisible) {
                if (LoaderProgress.Blocking_Total == -1)
                    LoaderProgress.Blocking_Total = 0;
                LoaderProgress.Blocking_Total++
            }
        }
    }
    globalResourcesNeededInfo = [];
    for (var k = 0; k < globalResourcesNeededList.length; k++)
        globalResourcesNeededInfo.push(globalResourcesNeededList[k].pixiTexture)
}
function registerAtlasForDeferredLoading(atlas) {
    var index = 0;
    for (var i = 0; i < globalListOfDeferredLoadingAtlases.length; i++)
        if (globalListOfDeferredLoadingAtlases[i].resourcePriority <= atlas.resourcePriority)
            index++;
    globalListOfDeferredLoadingAtlases.splice(index, 0, atlas)
}
goog.provide("UHT.AudioClassesUtils");
goog.require("UHT.SoundManager");
goog.require("UHT.AudioClip");
function AudioClipDelay() {
    this.currentDelay = 0;
    this.clipToPlay = null
}
AudioClipDelay.prototype.GetClip = function() {
    return this.clipToPlay
}
;
AudioClipDelay.prototype.Reset = function() {
    this.clipToPlay = null
}
;
AudioClipDelay.prototype.CountToPlayClip = function(clip, delay) {
    this.currentDelay = delay;
    this.clipToPlay = clip
}
;
AudioClipDelay.prototype.MustPlay = function() {
    if (this.clipToPlay == null)
        return false;
    if (this.currentDelay > 0) {
        this.currentDelay -= Time.deltaTime;
        return false
    }
    return true
}
;
function AudioClipMusicAware() {
    this.clipMusicOn = null;
    this.clipMusicOff = null
}
AudioClipMusicAware.prototype.GetClip = function() {
    if (XT.GetBool(Vars.MusicIsOn))
        return this.clipMusicOn;
    return this.clipMusicOff
}
;
function AudioClipFastPlayAware() {
    this.clipFastPlayOff = null;
    this.clipFastPlayOn = null
}
AudioClipFastPlayAware.prototype.GetClip = function() {
    if (XT.GetBool(Vars.FastPlay))
        return this.clipFastPlayOn.GetClip();
    return this.clipFastPlayOff.GetClip()
}
;
function AudioClipSpinTypeAware() {
    this.clipNormalSpin = null;
    this.clipFreeSpin = null;
    this.useNormalClipAtFreeSpinsStart = false
}
AudioClipSpinTypeAware.prototype.GetClip = function() {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (XT.GetBool(Vars.Logic_IsFreeSpin))
        if (!(this.useNormalClipAtFreeSpinsStart && fsr.IsFreeSpinsStart))
            return this.clipFreeSpin.GetClip();
    return this.clipNormalSpin.GetClip()
}
;
function AudioClipSpecialSymbolAware() {
    this.specialSymbolId = -1;
    this.hasExcitedClip = false;
    this.clipDefault = null;
    this.clipExcited = null
}
AudioClipSpecialSymbolAware.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
}
;
AudioClipSpecialSymbolAware.prototype.GetExcitedClip = function() {
    if (this.hasExcitedClip)
        return this.clipExcited.GetClip();
    else
        return this.GetClip()
}
;
function VS_AudioClipLoopable() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}
VS_AudioClipLoopable.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
}
;
VS_AudioClipLoopable.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
}
;
function BG_AudioClipLoopable() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}
function MusicClip() {
    this.friendlyName = "friendly name";
    this.handler = SoundManager.InvalidSoundHandle;
    this.clip = null;
    this.maxVolume = 1;
    this.volumeFadeInDuration = 1;
    this.volumeFadeOutDuration = 1;
    this.duckingFadeInDuration = .5;
    this.duckingFadeOutDuration = .5;
    this.volumeLevel = 0;
    this.duckingVolume = 1;
    this.isPlaying = false;
    this.isMuted = false;
    this.duckingSteps = [];
    this.priorityDuckingStepIndex = -1;
    this.volumeState = MusicVolumeState.idle;
    this.duckingState = MusicVolumeState.idle;
    for (var i = 0; i < 3; i++) {
        this.duckingSteps.push(new MusicDucking);
        this.duckingSteps[i].targetVolume = .3 + i * .2
    }
}
MusicClip.prototype.GetVolume = function() {
    var currentVolume = this.maxVolume * this.volumeLevel;
    return currentVolume * this.duckingVolume
}
;
MusicClip.prototype.UpdateDuckingStepPriority = function() {
    this.priorityDuckingStepIndex = -1;
    for (var i = 0; i < this.duckingSteps.length; i++)
        if (this.duckingSteps[i].duckCount > 0)
            if (this.priorityDuckingStepIndex == -1)
                this.priorityDuckingStepIndex = i;
            else if (this.duckingSteps[i].targetVolume < this.duckingSteps[this.priorityDuckingStepIndex].targetVolume)
                this.priorityDuckingStepIndex = i
}
;
var MusicVolumeState = {
    idle: 0,
    fadingIn: 1,
    fadingOut: 2
};
function MusicDucking() {
    this.targetVolume = .3;
    this.autoUnduck = false;
    this.autoUnduckShouldFade = false;
    this.autoUnduckTimer = 0;
    this.fadeInDuration = .5;
    this.fadeOutDuration = .5;
    this.duckCount = 0
}
BG_AudioClipLoopable.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
}
;
BG_AudioClipLoopable.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
}
;
function AudioClipValueAnimator() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipSmallWin = null;
    this.clipNormalWin = null;
    this.clipBigWin = null;
    this.clipMegaWin = null;
    this.clipEpicWin = null;
    this.clipFinal = null
}
var ClipStage = {
    smallWin: 0,
    normalWin: 1,
    bigWin: 2,
    megaWin: 3,
    epicWin: 4,
    finalStage: 5
};
AudioClipValueAnimator.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
}
;
AudioClipValueAnimator.prototype.GetClip = function(clipIdx) {
    var clip = null;
    switch (clipIdx) {
    case ClipStage.smallWin:
        clip = this.clipSmallWin.GetClip();
        break;
    case ClipStage.normalWin:
        clip = this.clipNormalWin.GetClip();
        break;
    case ClipStage.bigWin:
        clip = this.clipBigWin.GetClip();
        break;
    case ClipStage.megaWin:
        clip = this.clipMegaWin.GetClip();
        break;
    case ClipStage.epicWin:
        clip = this.clipEpicWin.GetClip();
        break;
    case ClipStage.finalStage:
        clip = this.clipFinal.GetClip();
        break
    }
    return clip
}
;
function AudioClipLoopable() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}
AudioClipLoopable.prototype.GetClip = function() {
    return this.clipDefault
}
;
AudioClipLoopable.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
}
;
function AudioClipLoopableMusicAware() {
    this.handler = SoundManager.InvalidSoundHandle;
    this.clipDefault = null
}
AudioClipLoopableMusicAware.prototype.GetClip = function() {
    return this.clipDefault.GetClip()
}
;
AudioClipLoopableMusicAware.prototype.IsPlaying = function() {
    return this.handler != SoundManager.InvalidSoundHandle
}
;
function GambleSounds() {
    this.shufflingCardLoopable = null;
    this.shufflingCardStop = null;
    this.resultWindowWin = null;
    this.resultWindowLose = null;
    this.newProgressItem = null
}
function ReelStopSounds() {
    this.reelStopWithSpecialSymbol = null;
    this.reelStopExcitedWin = null;
    this.reelStopExcitedLose = null;
    this.reelStopDefault = null
}
function ReelStartSounds() {
    this.clipsReelStart = null;
    this.clipsReelStartExcited = null;
    this.clipsReelMusicExcited = null
}
goog.require("UHT.XTLink");
VS_MusicLogic.prototype = Object.create(XTLink.prototype);
VS_MusicLogic.prototype.constructor = VS_MusicLogic;
function VS_MusicLogic() {
    XTLink.call(this);
    this.normalMusic = [];
    this.fsMusic = [];
    this.bgMusic = [];
    this.loopingSoundFX = [];
    this.soundManager = null
}
VS_MusicLogic.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.MusicLogicObject, this)
}
;
VS_MusicLogic.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this)
}
;
VS_MusicLogic.prototype.OnDestroy = function() {
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this)
}
;
VS_MusicLogic.prototype.OnSoundManagerChanged = function(sndMgr) {
    this.soundManager = sndMgr
}
;
VS_MusicLogic.prototype.PlayMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeInDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1)
        this.soundManager.PlayLoopingClip(mClip, useFading);
    else
        this.soundManager.PlayMusicClip(mClip, useFading)
}
;
VS_MusicLogic.prototype.StopMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeOutDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1)
        this.soundManager.StopLoopingClip(mClip, useFading);
    else
        this.soundManager.StopMusicClip(mClip, useFading)
}
;
VS_MusicLogic.prototype.MuteMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeOutDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1)
        this.soundManager.MuteLoopingClip(mClip, useFading);
    else
        this.soundManager.MuteMusicClip(mClip, useFading)
}
;
VS_MusicLogic.prototype.UnmuteMusicClip = function(friendlyName, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.volumeFadeInDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1)
        this.soundManager.UnmuteLoopingClip(mClip, useFading);
    else
        this.soundManager.UnmuteMusicClip(mClip, useFading)
}
;
VS_MusicLogic.prototype.DuckMusicClip = function(friendlyName, duckingStepIndex, delayToAutoUnduck, fadeInDuration, fadeOutDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeInDuration > 0 || fadeOutDuration > 0) {
        useFading = true;
        mClip.duckingSteps[duckingStepIndex].fadeInDuration = fadeInDuration;
        mClip.duckingSteps[duckingStepIndex].fadeOutDuration = fadeOutDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1)
        this.soundManager.DuckLoopingClip(mClip, duckingStepIndex, delayToAutoUnduck, useFading);
    else
        this.soundManager.DuckMusicClip(mClip, duckingStepIndex, delayToAutoUnduck, useFading)
}
;
VS_MusicLogic.prototype.UnduckMusicClip = function(friendlyName, duckingStepIndex, fadeDuration) {
    var mClip = this.FindClipWithFriendlyName(friendlyName);
    if (mClip == null) {
        console.log("There is no music or loopingSoundFX clip with friendly name " + friendlyName + " in VS_MusicLogic!");
        return
    }
    var useFading = false;
    if (fadeDuration > 0) {
        useFading = true;
        mClip.duckingSteps[duckingStepIndex].fadeOutDuration = fadeDuration
    }
    if (this.loopingSoundFX.indexOf(mClip) != -1)
        this.soundManager.UnduckLoopingClip(mClip, duckingStepIndex, useFading);
    else
        this.soundManager.UnduckMusicClip(mClip, duckingStepIndex, useFading)
}
;
VS_MusicLogic.prototype.MuteMusic = function(mute) {
    if (mute)
        this.soundManager.MuteMusic();
    else
        this.soundManager.UnmuteMusic()
}
;
VS_MusicLogic.prototype.MuteSoundFX = function(mute) {
    if (mute)
        this.soundManager.MuteSoundFX();
    else
        this.soundManager.UnmuteSoundFX()
}
;
VS_MusicLogic.prototype.FindClipWithFriendlyName = function(friendlyName) {
    var i;
    for (i = 0; i < this.normalMusic.length; i++)
        if (this.normalMusic[i].friendlyName == friendlyName)
            return this.normalMusic[i];
    for (i = 0; i < this.fsMusic.length; i++)
        if (this.fsMusic[i].friendlyName == friendlyName)
            return this.fsMusic[i];
    for (i = 0; i < this.bgMusic.length; i++)
        if (this.bgMusic[i].friendlyName == friendlyName)
            return this.bgMusic[i];
    for (i = 0; i < this.loopingSoundFX.length; i++)
        if (this.loopingSoundFX[i].friendlyName == friendlyName)
            return this.loopingSoundFX[i];
    return null
}
;
VS_MusicLogic.prototype.GetMusicClipByAudioClip = function(clip) {
    if (clip == null)
        return null;
    var i;
    for (i = 0; i < this.normalMusic.length; i++)
        if (this.normalMusic[i].clip == clip)
            return this.normalMusic[i];
    for (i = 0; i < this.fsMusic.length; i++)
        if (this.fsMusic[i].clip == clip)
            return this.fsMusic[i];
    for (i = 0; i < this.bgMusic.length; i++)
        if (this.bgMusic[i].clip == clip)
            return this.bgMusic[i];
    return null
}
;
VS_MusicLogic.prototype.GetLoopingClipByAudioClip = function(clip) {
    if (clip == null)
        return null;
    for (var i = 0; i < this.loopingSoundFX.length; i++)
        if (this.loopingSoundFX[i].clip == clip)
            return this.loopingSoundFX[i];
    return null
}
;
goog.require("UHT.XTLink");
goog.require("UHT.SoundManager");
goog.require("UHT.AudioClassesUtils");
VS_SoundLogic.prototype = Object.create(XTLink.prototype);
VS_SoundLogic.prototype.constructor = VS_SoundLogic;
function VS_SoundLogic() {
    XTLink.call(this);
    this.playSpecialSymbolSoundsInOrder = false;
    this.startFSSoundsOnSpecificEvent = false;
    this.clipMusic = null;
    this.clipsReelSpin = null;
    this.reelsStartingSounds = null;
    this.reelsStartingAll = null;
    this.reelsStoppingSounds = null;
    this.reelsStoppingAll = null;
    this.clipSpinWin = null;
    this.clipSpinNoWin = null;
    this.clipShowWinLine = null;
    this.clipsSymbolWin = null;
    this.clipsSymbolWinOverride = null;
    this.reelStopDelay = 0;
    this.reelsStopAllDelay = 0;
    this.reelsFastStopAllDelay = 0;
    this.clipFSWonBeforeResult = null;
    this.clipBonusWonBeforeResult = null;
    this.reelMustStop = [];
    this.reelsMustStopAll = null;
    this.sndManager = null;
    this.numberOfReels = 0;
    this.reelIndex = 0;
    this.reelIndices = null;
    this.reelsExcited = null;
    this.resultSymbols = null;
    this.isInactive = true;
    this.allReelsStopped = false;
    this.fastStop = false;
    this.oldClipReelSpinIndex = -1;
    this.reelsStoppedWithSpecialSymbol = null;
    this.canPlaySpinEndedBWSound = true;
    this.stillPossibleWinComboBonus = null;
    this.stillPossibleWinComboScatter = null;
    this.stillPossibleWinComboWild = null;
    this.stillPossibleWinComboPerSymbol = null
}
VS_SoundLogic.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSoundLogicSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.OnVSSoundLogicSpinEnded, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlaySpinEndedBWSound, this.OnVSSoundLogicSpinEndedBWSound, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStopStarted, this.OnSoundLogicReelStopReceived, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStarted, this.OnSoundLogicReelHasStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultSymbolWinPlaySound, this.OnSoundLogicShowWinLine, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsEnded, this.OnSoundLogicStartFreeSpins, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartVSLogicSounds, this.OnVSLogicStartSounds, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopVSLogicSounds, this.OnVSLogicStopSounds, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ExcitedReel, this.OnSoundLogicReelHasExcited, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnStopSpin, this);
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this);
    XT.RegisterCallbackObject(Vars.ReelInitialPositions, this.OnSoundLogicReelPositions, this);
    XT.RegisterCallbackObject(Vars.ResultScreenSymbols, this.OnSoundLogicResultSymbolsReceived, this);
    XT.RegisterCallbackObject(Vars.SymbolsManagerObject, this.OnSymbolsManagerObject, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelStopEnded, this.OnSoundLogicReelStopEnded, this);
    XT.RegisterCallbackBool(Vars.MusicIsOn, this.OnMusicStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowFSWonBeforeResult, this.OnPlayFSWonBeforeResult, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowBonusWonBeforeResult, this.OnPlayBonusWonBeforeResult, this);
    if (this.startFSSoundsOnSpecificEvent)
        XT.RegisterCallbackEvent(Vars.Evt_Internal_SwitchToFSSounds, this.OnSoundLogicStartFreeSpins, this);
    else
        XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsStarted, this.OnSoundLogicStartFreeSpins, this)
}
;
VS_SoundLogic.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.Logic_IsFreeSpin, false);
    XT.SetBool(Vars.CanPlayReelStopSounds, true);
    XT.SetBool(Vars.VSSoundLogic_IgnoreFastStop, false)
}
;
VS_SoundLogic.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSoundLogicSpinStarted, this);
    XT.UnregisterCallbackEvent(this.OnVSSoundLogicSpinEnded, this);
    XT.UnregisterCallbackEvent(this.OnVSSoundLogicSpinEndedBWSound, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelStopReceived, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelHasStarted, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicShowWinLine, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicStartFreeSpins, this);
    XT.UnregisterCallbackEvent(this.OnVSLogicStartSounds, this);
    XT.UnregisterCallbackEvent(this.OnVSLogicStopSounds, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelHasExcited, this);
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this);
    XT.UnregisterCallbackObject(this.OnSoundLogicReelPositions, this);
    XT.UnregisterCallbackObject(this.OnSoundLogicResultSymbolsReceived, this);
    XT.UnregisterCallbackObject(this.OnSymbolsManagerObject, this);
    XT.UnregisterCallbackEvent(this.OnSoundLogicReelStopEnded, this);
    XT.UnregisterCallbackBool(this.OnMusicStateChanged, this)
}
;
VS_SoundLogic.prototype.OnSoundManagerChanged = function(mgr) {
    this.sndManager = mgr
}
;
VS_SoundLogic.prototype.OnSymbolsManagerObject = function(mgr) {
    var symbolsManager = mgr;
    var biggestSymbolId = 0;
    for (var i = 0; i < symbolsManager.symbols.length; i++)
        if (biggestSymbolId < symbolsManager.symbols[i].symbolId)
            biggestSymbolId = symbolsManager.symbols[i].symbolId;
    this.reelsStoppedWithSpecialSymbol = _array.create(biggestSymbolId + 1, 0)
}
;
VS_SoundLogic.prototype.OnMusicStateChanged = function(unused) {
    this.UpdateSounds()
}
;
VS_SoundLogic.prototype.UpdateSounds = function() {
    if (this.isInactive)
        return;
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle;
            this.clipsReelSpin[crsIndex].handler = this.sndManager.PlayLooping(this.clipsReelSpin[crsIndex].GetClip())
        }
    for (var ermIndex = 0; ermIndex < this.numberOfReels; ermIndex++)
        if (this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.IsPlaying()) {
            var args = {
                handle: this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler = args.handle;
            this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler = this.sndManager.PlayLooping(this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.GetClip())
        }
    this.UpdateBackgroundMusic()
}
;
VS_SoundLogic.prototype.OnSoundLogicReelPositions = function(reelPos) {
    this.numberOfReels = reelPos.length;
    this.reelsExcited = []
}
;
VS_SoundLogic.prototype.OnSoundLogicResultSymbolsReceived = function(resultScreenSymbols) {
    this.resultSymbols = resultScreenSymbols;
    this.reelsExcited = [];
    for (var reIndex = 0; reIndex < this.numberOfReels; reIndex++)
        this.reelsExcited.push(false);
    this.allReelsStopped = false
}
;
VS_SoundLogic.prototype.OnSoundLogicSpinStarted = function() {
    this.fastStop = false;
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle
        }
    var randomClipReelSpinIndex = Random.Range(0, this.clipsReelSpin.length);
    while (this.clipsReelSpin.length > 1 && randomClipReelSpinIndex == this.oldClipReelSpinIndex)
        randomClipReelSpinIndex = Random.Range(0, this.clipsReelSpin.length);
    this.clipsReelSpin[randomClipReelSpinIndex].handler = this.sndManager.PlayLooping(this.clipsReelSpin[randomClipReelSpinIndex].GetClip());
    this.oldClipReelSpinIndex = randomClipReelSpinIndex;
    for (var i = 0; i < this.reelsStoppedWithSpecialSymbol.length; i++)
        this.reelsStoppedWithSpecialSymbol[i] = 0
}
;
VS_SoundLogic.prototype.OnStopSpin = function() {
    if (!XT.GetBool(Vars.VSSoundLogic_IgnoreFastStop))
        this.fastStop = true
}
;
VS_SoundLogic.prototype.OnVSSoundLogicSpinEnded = function() {
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle
        }
    var winReceived = XT.GetDouble(Vars.WinReceived);
    if (winReceived > 0) {
        var coinCounter = XT.GetObject(Vars.CoinCounterObject);
        if (winReceived >= CoinManager.GetLastTotalBet() * coinCounter.BigWinSteps[0])
            this.sndManager.PlaySimple(this.GetSpinWinClip())
    } else
        this.sndManager.PlaySimple(this.clipSpinNoWin.GetClip())
}
;
VS_SoundLogic.prototype.OnVSSoundLogicSpinEnded = function() {
    for (var crsIndex = 0; crsIndex < this.clipsReelSpin.length; crsIndex++)
        if (this.clipsReelSpin[crsIndex].IsPlaying()) {
            var args = {
                handle: this.clipsReelSpin[crsIndex].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.clipsReelSpin[crsIndex].handler = args.handle
        }
    var winReceived = XT.GetDouble(Vars.WinReceived);
    if (winReceived <= 0)
        this.sndManager.PlaySimple(this.clipSpinNoWin.GetClip());
    this.canPlaySpinEndedBWSound = true
}
;
VS_SoundLogic.prototype.OnVSSoundLogicSpinEndedBWSound = function() {
    if (this.canPlaySpinEndedBWSound) {
        this.canPlaySpinEndedBWSound = false;
        this.sndManager.PlaySimple(this.GetSpinWinClip())
    }
}
;
VS_SoundLogic.prototype.OnSoundLogicReelHasStarted = function() {
    this.reelIndices = XT.GetObject(Vars.LastStartedReelIndices);
    this.reelIndex = this.reelIndices[this.reelIndices.length - 1];
    if (this.reelIndices.length == this.numberOfReels)
        this.sndManager.PlaySimple(this.reelsStartingAll.GetClip());
    else
        this.sndManager.PlaySimple(this.reelsStartingSounds[this.reelIndex].clipsReelStart.GetClip())
}
;
VS_SoundLogic.prototype.OnSoundLogicReelHasExcited = function() {
    var _reelIndex = XT.GetInt(Vars.LastExcitedReelIndex);
    this.reelsExcited[_reelIndex] = true
}
;
VS_SoundLogic.prototype.OnSoundLogicReelStopReceived = function() {
    this.reelIndices = XT.GetObject(Vars.LastStoppedReelIndices);
    this.reelIndex = this.reelIndices[this.reelIndices.length - 1];
    this.stillPossibleWinComboBonus = XT.GetObject(Vars.StillPossibleWinComboBonus);
    this.stillPossibleWinComboScatter = XT.GetObject(Vars.StillPossibleWinComboScatter);
    this.stillPossibleWinComboWild = XT.GetObject(Vars.StillPossibleWinComboWild);
    this.stillPossibleWinComboPerSymbol = XT.GetObject(Vars.StillPossibleWinComboPerSymbol);
    var reelStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    if (this.reelIndex == reelStopOrder[this.numberOfReels - 1])
        this.allReelsStopped = true;
    if (this.reelIndices.length > 1 || this.fastStop && this.allReelsStopped) {
        this.PlayReelsStopAllSound(this.reelsStoppingAll.GetClip());
        this.reelMustStop = [];
        return
    }
    if (this.fastStop)
        return;
    var i;
    var rsIndex;
    var sIdx;
    if (this.playSpecialSymbolSoundsInOrder) {
        var clipToPlay = null;
        for (sIdx = 0; sIdx < this.reelsStoppedWithSpecialSymbol.length; sIdx++) {
            if (sIdx == 0 && !this.stillPossibleWinComboBonus[this.reelIndex])
                continue;
            if (sIdx == 1 && !this.stillPossibleWinComboScatter[this.reelIndex])
                continue;
            if (sIdx == 2 && !this.stillPossibleWinComboWild[this.reelIndex])
                continue;
            if (sIdx > 2 && !this.stillPossibleWinComboPerSymbol[this.reelIndex][sIdx])
                continue;
            var goToNextSIdx = false;
            for (rsIndex = 0; rsIndex < this.resultSymbols[this.reelIndex].length; rsIndex++) {
                if (this.resultSymbols[this.reelIndex][rsIndex] == sIdx)
                    for (i = 0; i < this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol.length; i++)
                        if (this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol[i].specialSymbolId == sIdx) {
                            if (clipToPlay == null)
                                if (this.reelsExcited[this.reelIndex])
                                    clipToPlay = this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol[i].GetExcitedClip();
                                else
                                    clipToPlay = this.reelsStoppingSounds[this.reelsStoppedWithSpecialSymbol[sIdx]].reelStopWithSpecialSymbol[i].GetClip();
                            this.reelsStoppedWithSpecialSymbol[sIdx]++;
                            goToNextSIdx = true;
                            break
                        }
                if (goToNextSIdx)
                    break
            }
            if (clipToPlay != null) {
                this.PlayReelStopSound(clipToPlay);
                return
            }
        }
    } else
        for (i = 0; i < this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol.length; i++) {
            sIdx = this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol[i].specialSymbolId;
            if (sIdx == 0 && !this.stillPossibleWinComboBonus[this.reelIndex])
                continue;
            if (sIdx == 1 && !this.stillPossibleWinComboScatter[this.reelIndex])
                continue;
            if (sIdx == 2 && !this.stillPossibleWinComboWild[this.reelIndex])
                continue;
            if (sIdx > 2 && !this.stillPossibleWinComboPerSymbol[this.reelIndex][sIdx])
                continue;
            for (rsIndex = 0; rsIndex < this.resultSymbols[this.reelIndex].length; rsIndex++)
                if (sIdx == this.resultSymbols[this.reelIndex][rsIndex]) {
                    if (this.reelsExcited[this.reelIndex])
                        this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol[i].GetExcitedClip());
                    else
                        this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopWithSpecialSymbol[i].GetClip());
                    return
                }
        }
    if (this.reelsExcited[this.reelIndex]) {
        var reelwin = XT.GetObject(Vars.ReelsWinInfo)[this.reelIndex];
        if (reelwin)
            this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopExcitedWin.GetClip());
        else
            this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopExcitedLose.GetClip());
        return
    }
    this.PlayReelStopSound(this.reelsStoppingSounds[this.reelIndex].reelStopDefault.GetClip())
}
;
VS_SoundLogic.prototype.OnSoundLogicReelStopEnded = function() {
    this.reelIndex = XT.GetInt(Vars.LastStopEndedReelIndex);
    var reelStopOrder = XT.GetObject(Vars.ReelsStopOrder);
    var nextReelToStop = -1;
    var reelStopIndex = 0;
    for (var i = 0; i < this.numberOfReels; i++)
        if (reelStopOrder[i] == this.reelIndex) {
            reelStopIndex = i;
            if (i < this.numberOfReels - 1)
                nextReelToStop = i + 1
        }
    for (var ermIndex = reelStopIndex; ermIndex >= 0; ermIndex--)
        if (this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.IsPlaying()) {
            var args = {
                handle: this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.reelsStartingSounds[ermIndex].clipsReelMusicExcited.handler = args.handle
        }
    if (this.allReelsStopped)
        return;
    if (nextReelToStop != -1)
        if (this.reelsExcited[reelStopOrder[nextReelToStop]]) {
            this.sndManager.PlaySimple(this.reelsStartingSounds[nextReelToStop].clipsReelStartExcited.GetClip());
            this.reelsStartingSounds[nextReelToStop].clipsReelMusicExcited.handler = this.sndManager.PlayLooping(this.reelsStartingSounds[nextReelToStop].clipsReelMusicExcited.GetClip())
        }
}
;
VS_SoundLogic.prototype.OnPlayFSWonBeforeResult = function() {
    if (!XT.GetBool(Vars.LastWinIsCounting))
        this.sndManager.PlaySimple(this.clipFSWonBeforeResult)
}
;
VS_SoundLogic.prototype.OnPlayBonusWonBeforeResult = function() {
    if (!XT.GetBool(Vars.LastWinIsCounting))
        this.sndManager.PlaySimple(this.clipBonusWonBeforeResult)
}
;
VS_SoundLogic.prototype.OnSoundLogicShowWinLine = function() {
    var resultSymbolWinID = XT.GetInt(Vars.ResultSymbolWinID);
    if (resultSymbolWinID == -1 || this.clipsSymbolWin.length <= resultSymbolWinID || this.clipsSymbolWin[resultSymbolWinID].GetClip() == null)
        this.sndManager.PlaySimple(this.clipShowWinLine.GetClip());
    else
        this.sndManager.PlaySimple(this.clipsSymbolWin[resultSymbolWinID].GetClip())
}
;
VS_SoundLogic.prototype.OnSoundLogicStartFreeSpins = function() {
    this.UpdateSounds()
}
;
VS_SoundLogic.prototype.OnVSLogicStartSounds = function() {
    this.isInactive = false;
    this.UpdateSounds()
}
;
VS_SoundLogic.prototype.OnVSLogicStopSounds = function() {
    if (this.clipMusic.IsPlaying()) {
        var args = {
            handle: this.clipMusic.handler
        };
        this.sndManager.StopMusic(args);
        this.clipMusic.handler = args.handle
    }
    this.isInactive = true
}
;
VS_SoundLogic.prototype.UpdateBackgroundMusic = function() {
    if (this.clipMusic.IsPlaying()) {
        var args = {
            handle: this.clipMusic.handler
        };
        this.sndManager.StopMusic(args);
        this.clipMusic.handler = args.handle
    }
    this.clipMusic.handler = this.sndManager.PlayMusic(this.clipMusic.GetClip())
}
;
VS_SoundLogic.prototype.PlayReelStopSound = function(clip) {
    if (!XT.GetBool(Vars.CanPlayReelStopSounds))
        return;
    if (this.reelStopDelay <= 0)
        this.sndManager.PlaySimple(clip);
    else {
        var clipDelay = new AudioClipDelay;
        clipDelay.CountToPlayClip(clip, this.reelStopDelay);
        this.reelMustStop.push(clipDelay)
    }
}
;
VS_SoundLogic.prototype.PlayReelsStopAllSound = function(clip) {
    if (!XT.GetBool(Vars.CanPlayReelStopSounds))
        return;
    if (!this.fastStop && this.reelsStopAllDelay <= 0 || this.fastStop && this.reelsFastStopAllDelay <= 0)
        this.sndManager.PlaySimple(clip);
    else {
        this.reelsMustStopAll = new AudioClipDelay;
        this.reelsMustStopAll.CountToPlayClip(clip, this.fastStop ? this.reelsFastStopAllDelay : this.reelsStopAllDelay)
    }
}
;
VS_SoundLogic.prototype.Update = function() {
    for (var i = 0; i < this.reelMustStop.length; i++)
        if (this.reelMustStop[i].MustPlay()) {
            this.sndManager.PlaySimple(this.reelMustStop[i].GetClip());
            this.reelMustStop[i].Reset();
            this.reelMustStop.splice(i, 1)
        }
    if (this.reelsMustStopAll != null && this.reelsMustStopAll.MustPlay()) {
        this.sndManager.PlaySimple(this.reelsMustStopAll.GetClip());
        this.reelsMustStopAll.Reset();
        this.reelsMustStopAll = null
    }
}
;
VS_SoundLogic.prototype.GetSpinWinClip = function() {
    var winLines = XT.GetObject(Vars.ReceivedWinLines);
    var symbols = XT.GetObject(Vars.OrderedSymbolList);
    var winSymbolsIds = [];
    for (var i = 0; i < winLines.length; ++i) {
        var positions = winLines[i].WinPositions;
        for (var j = 0; j < positions.length; ++j)
            if (winSymbolsIds.indexOf(symbols[positions[j]].symbolId) == -1)
                winSymbolsIds.push(symbols[positions[j]].symbolId)
    }
    for (var i = 0; i < this.clipsSymbolWinOverride.length; ++i) {
        var clip = this.clipsSymbolWinOverride[i].GetClip();
        if (clip != null && winSymbolsIds.indexOf(i) != -1)
            return clip
    }
    return this.clipSpinWin.GetClip()
}
;
goog.require("UHT.Engine");
PlayStartSpinActiveLines.prototype = Object.create(XTLink.prototype);
PlayStartSpinActiveLines.prototype.constructor = PlayStartSpinActiveLines;
function PlayStartSpinActiveLines() {
    XTLink.call(this);
    this.spinStartActiveLines = []
}
PlayStartSpinActiveLines.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStart, this)
}
;
PlayStartSpinActiveLines.prototype.XTInitVariablesAndEvents = function() {}
;
PlayStartSpinActiveLines.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSpinStart, this)
}
;
PlayStartSpinActiveLines.prototype.OnSpinStart = function() {
    var numberOfLines = XT.GetInt(Vars.Lines);
    numberOfLines--;
    this.spinStartActiveLines[numberOfLines].Start()
}
;
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
GUIMessageZoneSettings.prototype = Object.create(ArrangeableBase.prototype);
GUIMessageZoneSettings.prototype.constructor = GUIMessageZoneSettings;
function SymbolThumbnailDesc() {
    this.id = -1;
    this.atlas = null;
    this.sprite = ""
}
function GUIMessageZoneSettings() {
    ArrangeableBase.call(this);
    this.thumbnails = [];
    this.spacing = 33;
    this.spacingMobile_landscape = 33;
    this.spacingMobile_portrait = 85;
    this.spacingExtraLabel = 5;
    this.spacingExtraLabelMobile_landscape = 5;
    this.spacingExtraLabelMobile_portrait = 5;
    this.thumbnailSize = 28;
    this.thumbnailSizeMobile_landscape = 32;
    this.thumbnailSizeMobile_portrait = 80;
    this.miniResize = .4;
    this.portraitOrientation = false
}
GUIMessageZoneSettings.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(InterfaceVars.GUIMessageZoneSettings, this)
}
;
GUIMessageZoneSettings.prototype.GetSpacing = function() {
    if (XT.GetBool(InterfaceVars.IsMobileGUI))
        return this.portraitOrientation ? this.spacingMobile_portrait : this.spacingMobile_landscape / (Globals.isMini ? this.miniResize : 1);
    else
        return this.spacing
}
;
GUIMessageZoneSettings.prototype.GetSpacingExtraLabel = function() {
    if (XT.GetBool(InterfaceVars.IsMobileGUI))
        return this.portraitOrientation ? this.spacingExtraLabelMobile_portrait : this.spacingExtraLabelMobile_landscape / (Globals.isMini ? this.miniResize : 1);
    else
        return this.spacingExtraLabel
}
;
GUIMessageZoneSettings.prototype.GetThumbnailSize = function() {
    if (XT.GetBool(InterfaceVars.IsMobileGUI))
        return this.portraitOrientation ? this.thumbnailSizeMobile_portrait : Math.floor(this.thumbnailSizeMobile_landscape / (Globals.isMini ? this.miniResize : 1));
    else
        return this.thumbnailSize
}
;
GUIMessageZoneSettings.prototype.OnSwitchToPortrait = function() {
    this.portraitOrientation = true
}
;
GUIMessageZoneSettings.prototype.OnSwitchToLandscape = function() {
    this.portraitOrientation = false
}
;
GUIMessageZoneSettings.prototype.GetThumbnail = function(id) {
    for (var i = 0; i < this.thumbnails.length; ++i)
        if (this.thumbnails[i].id == id)
            return this.thumbnails[i];
    return null
}
;
goog.require("UHT.Engine");
function ClipLevel() {
    this.clips = null;
    this.repeat = 0
}
var CoinCounterType = {
    CoinCounter: 0,
    AlternateMusic: 1,
    IndividualBigWinSounds: 2
};
function CoinCounterSettings() {
    this.coinCounterType = CoinCounterType.CoinCounter;
    this.muteBackgroundMusic = false;
    this.useAlternateMusicForSmallWin = false;
    this.muteBackgroundMusicForBigWin = true
}
CoinCounter.prototype = Object.create(XTLink.prototype);
CoinCounter.prototype.constructor = CoinCounter;
function CoinCounter() {
    XTLink.call(this);
    this.levels = null;
    this.BigWinSteps = [];
    this.finalSound = null;
    this.delay = 0;
    this.secondsToCountOneTotalBet = 1;
    this.secondsToCountOneTotalBetOldValue = 1;
    this.normalSettings = null;
    this.freeSpinsSettings = null;
    this.useBonusGameSettings = false;
    this.bonusGameSettings = null;
    this.currentSettings = null;
    this.normalAlternateMusic = null;
    this.freeSpinsAlternateMusic = null;
    this.bonusGameAlternateMusic = null;
    this.finalAlternateSound = null;
    this.finalAlternateSoundFS = null;
    this.currentAlternateMusic = null;
    this.individualBigWinClips = null;
    this.finalIndividualBigWinClips = null;
    this.IndividualBigWinSoundsDuration = [];
    this.finalIndividualBigWinSound = null;
    this.targetBigWinLevel = 0;
    this.timesTotalBet = 0;
    this.target = 0;
    this.counting = false;
    this.counter = 0;
    this.level = 0;
    this.idxInLevel = 0;
    this.inLevelRepeatCounter = 0;
    this.sndManager = null;
    this.timer = 0;
    this.totalWinReceivedSoFarInFS = 0
}
CoinCounter.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinCounterStart, this.StartCount, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinCounterStop, this.StopCount, this);
    XT.RegisterCallbackInt(Vars.CurrentCoinCountTarget, this.OnCountTarget, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartVSLogicSounds, this.ResetAlternateMusic, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_MusicBtn, this.ResetAlternateMusic, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_SoundBtn, this.ResetAlternateMusic, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_SpinResultReceived, this.SpinResultIsBigWin, this);
    if (this.useBonusGameSettings)
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this);
    else {
        XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsStarted, this.OnFreeSpins, this);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_FreeSpinsEnded, this.OnFreeSpins, this)
    }
}
;
CoinCounter.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(Vars.CoinCounterObject, this)
}
;
CoinCounter.prototype.OnDestroy = function() {
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this);
    XT.UnregisterCallbackEvent(this.StartCount, this);
    XT.UnregisterCallbackEvent(this.StopCount, this);
    XT.UnregisterCallbackEvent(this.ResetAlternateMusic, this);
    XT.UnregisterCallbackEvent(this.OnGameInit, this);
    XT.UnregisterCallbackEvent(this.OnFreeSpins, this);
    XT.UnregisterCallbackEvent(this.SpinResultIsBigWin, this)
}
;
CoinCounter.prototype.GetTargetBigWinLevel = function() {
    return this.targetBigWinLevel
}
;
CoinCounter.prototype.GetCurentCoinCounterSettings = function() {
    return this.currentSettings
}
;
CoinCounter.prototype.OnCountTarget = function(tgt) {
    this.target = tgt
}
;
CoinCounter.prototype.OnSoundManagerChanged = function(mgr) {
    this.sndManager = mgr
}
;
CoinCounter.prototype.StartCount = function() {
    this.counting = true;
    var sndState = XT.GetObject(Vars.SoundState);
    if (this.currentSettings.coinCounterType == CoinCounterType.CoinCounter || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && !this.currentSettings.useAlternateMusicForSmallWin) {
        this.timer = 0;
        this.counter = 0;
        this.level = 0;
        this.idxInLevel = 0;
        this.inLevelRepeatCounter = 0
    } else if (this.currentSettings.coinCounterType == CoinCounterType.AlternateMusic || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && this.currentSettings.useAlternateMusicForSmallWin) {
        if (this.currentAlternateMusic.IsPlaying())
            if (sndState.soundFXIsOn)
                this.sndManager.UnmuteLoopingSound(this.currentAlternateMusic.handler);
            else
                this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler)
    } else
        this.PlayIndividualBigWinSounds();
    if (sndState.soundFXIsOn)
        if (this.timesTotalBet < this.BigWinSteps[0]) {
            if (this.currentSettings.muteBackgroundMusic)
                this.sndManager.MuteMusic()
        } else if (this.currentSettings.muteBackgroundMusicForBigWin)
            this.sndManager.MuteMusic()
}
;
CoinCounter.prototype.StopCount = function() {
    this.counting = false;
    if (this.currentSettings.coinCounterType == CoinCounterType.CoinCounter || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && !this.currentSettings.useAlternateMusicForSmallWin)
        this.PlayClip(this.finalSound);
    else if (this.currentSettings.coinCounterType == CoinCounterType.AlternateMusic || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && this.currentSettings.useAlternateMusicForSmallWin) {
        this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler);
        if (this.currentSettings == this.freeSpinsSettings && this.finalAlternateSoundFS != null)
            this.PlayClip(this.finalAlternateSoundFS);
        else
            this.PlayClip(this.finalAlternateSound)
    } else
        this.StopIndividualBigWinSounds();
    if (XT.GetBool(Vars.WaitInResultForBigWin) && this.currentSettings.muteBackgroundMusicForBigWin || this.currentSettings.muteBackgroundMusic)
        this.sndManager.UnmuteMusic();
    this.targetBigWinLevel = 0;
    this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue
}
;
CoinCounter.prototype.PlayClip = function(clip) {
    this.sndManager.PlaySimple(clip)
}
;
CoinCounter.prototype.ComputeLevelRepeatCounters = function() {
    this.levels[0].repeat = Math.round(this.BigWinSteps[0] * this.secondsToCountOneTotalBet / (this.levels[0].clips.length * this.delay));
    for (var i = 1; i < this.levels.length - 1; i++)
        this.levels[i].repeat = Math.round((this.BigWinSteps[i] - this.BigWinSteps[i - 1]) * this.secondsToCountOneTotalBet / (this.levels[i].clips.length * this.delay));
    this.levels[this.levels.length - 1].repeat = 0
}
;
CoinCounter.prototype.Start = function() {
    this.currentAlternateMusic = this.normalAlternateMusic;
    this.currentSettings = this.normalSettings;
    this.secondsToCountOneTotalBetOldValue = this.secondsToCountOneTotalBet;
    this.ComputeLevelRepeatCounters()
}
;
CoinCounter.prototype.OnGameInit = function() {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin) {
        this.currentAlternateMusic = this.freeSpinsAlternateMusic;
        this.currentSettings = this.freeSpinsSettings
    }
}
;
CoinCounter.prototype.OnVSGameStateChanged = function() {
    var newState = VSGameStateManager.GetState();
    var newAltMusic;
    var newSettings;
    if (newState == VSGameState.Bonus) {
        newAltMusic = this.bonusGameAlternateMusic;
        newSettings = this.bonusGameSettings
    } else if (newState == VSGameState.SpinFreeSpins || newState == VSGameState.ResultFreeSpins || newState == VSGameState.ResultFreeSpinsPrepare) {
        newAltMusic = this.freeSpinsAlternateMusic;
        newSettings = this.freeSpinsSettings
    } else {
        newAltMusic = this.normalAlternateMusic;
        newSettings = this.normalSettings
    }
    if (this.currentSettings != newSettings) {
        if (this.currentAlternateMusic.IsPlaying()) {
            var args = {
                handle: this.currentAlternateMusic.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.currentAlternateMusic.handler = args.handle
        }
        this.currentSettings = newSettings;
        this.currentAlternateMusic = newAltMusic;
        this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue;
        this.ResetAlternateMusic()
    }
}
;
CoinCounter.prototype.OnFreeSpins = function() {
    if (this.currentAlternateMusic.IsPlaying()) {
        var args = {
            handle: this.currentAlternateMusic.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.currentAlternateMusic.handler = args.handle
    }
    this.currentAlternateMusic = this.currentSettings == this.normalSettings ? this.freeSpinsAlternateMusic : this.normalAlternateMusic;
    this.currentSettings = this.currentSettings == this.normalSettings ? this.freeSpinsSettings : this.normalSettings;
    this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue;
    this.ResetAlternateMusic()
}
;
CoinCounter.prototype.ResetAlternateMusic = function() {
    if (this.currentSettings.coinCounterType == CoinCounterType.AlternateMusic || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.currentSettings.useAlternateMusicForSmallWin) {
        if (this.currentAlternateMusic.IsPlaying()) {
            var args = {
                handle: this.currentAlternateMusic.handler
            };
            this.sndManager.StopLoopingSound(args);
            this.currentAlternateMusic.handler = args.handle
        }
        this.currentAlternateMusic.handler = IS_UCBROWSER ? -1 : this.sndManager.PlayLooping(this.currentAlternateMusic.GetClip());
        this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler)
    }
}
;
CoinCounter.prototype.PlayIndividualBigWinSounds = function() {
    if (this.individualBigWinClips.length >= this.targetBigWinLevel)
        this.individualBigWinClips[this.targetBigWinLevel - 1].handler = this.sndManager.PlayLooping(this.individualBigWinClips[this.targetBigWinLevel - 1].GetClip())
}
;
CoinCounter.prototype.StopIndividualBigWinSounds = function() {
    if (this.individualBigWinClips.length >= this.targetBigWinLevel)
        if (this.individualBigWinClips[this.targetBigWinLevel - 1].IsPlaying()) {
            var args = {
                handle: this.individualBigWinClips[this.targetBigWinLevel - 1].handler
            };
            this.sndManager.StopLoopingSound(args);
            this.individualBigWinClips[this.targetBigWinLevel - 1].handler = args.handle
        }
    if (this.timesTotalBet >= this.BigWinSteps[0])
        if (this.finalIndividualBigWinClips.length > 0)
            this.PlayClip(this.finalIndividualBigWinClips[this.targetBigWinLevel - 1]);
        else
            this.PlayClip(this.finalIndividualBigWinSound)
}
;
CoinCounter.prototype.ComputeTargetBigWinLevel = function(totalWin, totalBet) {
    if (this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && totalWin > 0) {
        this.timesTotalBet = Math.floor(totalWin / totalBet * 100) / 100;
        this.targetBigWinLevel = 0;
        for (var i = 0; i < this.BigWinSteps.length; i++)
            if (this.timesTotalBet >= this.BigWinSteps[i])
                this.targetBigWinLevel++;
        this.secondsToCountOneTotalBet = this.targetBigWinLevel > 0 ? this.IndividualBigWinSoundsDuration[this.targetBigWinLevel - 1] / this.timesTotalBet : this.secondsToCountOneTotalBetOldValue
    }
}
;
CoinCounter.prototype.Update = function() {
    if (this.currentSettings.coinCounterType == CoinCounterType.CoinCounter || this.currentSettings.coinCounterType == CoinCounterType.IndividualBigWinSounds && this.timesTotalBet < this.BigWinSteps[0] && !this.currentSettings.useAlternateMusicForSmallWin)
        if (this.counting) {
            this.timer += Time.deltaTime;
            if (this.timer > this.delay) {
                this.timer -= this.delay;
                this.counter++;
                if (this.counter >= this.target)
                    this.StopCount();
                else {
                    this.PlayClip(this.levels[this.level].clips[this.idxInLevel]);
                    this.idxInLevel++;
                    if (this.idxInLevel >= this.levels[this.level].clips.length) {
                        this.idxInLevel = 0;
                        this.inLevelRepeatCounter++;
                        if (this.inLevelRepeatCounter >= this.levels[this.level].repeat) {
                            this.inLevelRepeatCounter = 0;
                            this.level++;
                            if (this.level >= this.levels.length)
                                this.level--
                        }
                    }
                }
            }
        }
    if (this.currentAlternateMusic.IsPlaying() && !this.counting)
        this.sndManager.MuteLoopingSound(this.currentAlternateMusic.handler)
}
;
CoinCounter.prototype.SpinResultIsBigWin = function() {
    var isBigWin = false;
    var totalWin = 0;
    var totalBet = CoinManager.GetLastTotalBet();
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin)
        if (fsr.IsLastFreeSpin) {
            totalWin = (fsr.CurrentWin - this.totalWinReceivedSoFarInFS) * fsr.TotalMultiplier;
            this.totalWinReceivedSoFarInFS = 0
        } else {
            totalWin = XT.GetDouble(Vars.WinReceived) * fsr.TotalMultiplier;
            this.totalWinReceivedSoFarInFS = fsr.CurrentWin
        }
    else if (!XT.GetBool(Vars.MustOpenBonus))
        totalWin = XT.GetDouble(Vars.WinReceived);
    this.timesTotalBet = Math.floor(totalWin / totalBet * 100) / 100;
    isBigWin = this.timesTotalBet >= this.BigWinSteps[0];
    XT.SetInt(Vars.SpinResultBigWinLevel, 0);
    for (var i = 0; i < this.BigWinSteps.length; i++)
        if (this.timesTotalBet >= this.BigWinSteps[i])
            XT.SetInt(Vars.SpinResultBigWinLevel, i);
    XT.SetBool(Vars.SpinResultIsBigWin, isBigWin)
}
;
CoinCounter.prototype.ForceChangeToState = function(state) {
    var newAlternateMusic = null;
    var newSettings = null;
    if (state == "normal") {
        newAlternateMusic = this.normalAlternateMusic;
        newSettings = this.normalSettings
    } else if (state == "freespins") {
        newAlternateMusic = this.freeSpinsAlternateMusic;
        newSettings = this.freeSpinsSettings
    } else if (state == "bonus") {
        newAlternateMusic = this.bonusGameAlternateMusic;
        newSettings = this.bonusGameSettings
    }
    if (this.currentSettings != newSettings)
        this.secondsToCountOneTotalBet = this.secondsToCountOneTotalBetOldValue;
    this.currentAlternateMusic = newAlternateMusic;
    this.currentSettings = newSettings;
    this.ResetAlternateMusic()
}
;
CoinCounter.prototype.ForceResetToExpectedState = function() {
    this.OnVSGameStateChanged()
}
;
goog.require("UHT.Engine");
BigWin.prototype = Object.create(XTLink.prototype);
BigWin.prototype.constructor = BigWin;
function BigWin() {
    XTLink.call(this);
    this.catContainter = null;
    this.nextLevelToShow = -1;
    this.isAnyLevelActive = false
}
BigWin.CatEvents = {
    hide: 0,
    lvl_1: 1,
    lvl_2: 2,
    lvl_3: 3,
    lvl_4: 4,
    lvl_5: 5,
    jackpot: 6,
    counter: 7
};
BigWin.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackInt(Vars.BigWinLevel, this.OnShowBigWinLevel, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ShowBigWin, this.OnShowBigWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ClearBigWin, this.OnClearBigWin, this)
}
;
BigWin.prototype.OnDestroy = function() {
    XT.UnregisterCallbackInt(this.OnShowBigWinLevel, this);
    XT.UnregisterCallbackEvent(this.OnShowBigWin, this);
    XT.UnregisterCallbackEvent(this.OnClearBigWin, this)
}
;
BigWin.prototype.OnShowBigWinLevel = function(lvl) {
    this.nextLevelToShow = lvl
}
;
var GA_BW_SENDONESKIP = false;
BigWin.prototype.OnShowBigWin = function() {
    this.isAnyLevelActive = true;
    this.catContainter.StartEvent(this.nextLevelToShow);
    if (this.nextLevelToShow > 0 && this.nextLevelToShow < 6) {
        globalTracking.SendEvent("uht_behaviour_BigWin", "GotLevel_" + this.nextLevelToShow.toString(), this.nextLevelToShow, "BehaviourTracker");
        GA_BW_SENDONESKIP = true
    }
}
;
BigWin.prototype.OnClearBigWin = function() {
    if (!this.isAnyLevelActive)
        return;
    this.catContainter.StartEvent(BigWin.CatEvents.hide);
    this.isAnyLevelActive = false
}
;
goog.require("UHT.XTLink");
BigWinJackpotActivator.prototype = Object.create(XTLink.prototype);
BigWinJackpotActivator.prototype.constructor = BigWinJackpotActivator;
function BigWinJackpotActivator() {
    XTLink.call(this);
    this.orderedClassicJackpotRoots = [];
    this.singleJackpotRoot = null
}
BigWinJackpotActivator.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ShowBigWin, this.ShowBigWin, this)
}
;
BigWinJackpotActivator.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.ShowBigWin, this)
}
;
BigWinJackpotActivator.prototype.ShowBigWin = function() {
    if (XT.GetBool(Vars.FromServer_IsJackpotWin)) {
        var jpInfo = XT.GetObject(Vars.FromServer_LastValidJackpotsInformation);
        if (jpInfo == null || jpInfo.length == 1 && jpInfo[0].JackpotGroupType == "S") {
            this.singleJackpotRoot.SetActive(true);
            for (var i = 0; i < this.orderedClassicJackpotRoots.length; i++)
                this.orderedClassicJackpotRoots[i].SetActive(false)
        } else {
            this.singleJackpotRoot.SetActive(false);
            for (var i = 0; i < this.orderedClassicJackpotRoots.length; i++)
                this.orderedClassicJackpotRoots[i].SetActive(i == XT.GetInt(Vars.FromServer_JackpotWonOrder))
        }
    }
}
;
goog.require("UHT.Engine");
BigWinSkipper.prototype = Object.create(XTLink.prototype);
BigWinSkipper.prototype.constructor = BigWinSkipper;
function BigWinSkipper() {
    XTLink.call(this)
}
BigWinSkipper.timeOfFirstClick = -1;
BigWinSkipper.prototype.OnClick = function() {
    if (UHT_DEVICE_TYPE.MOBILE)
        if (BigWinSkipper.timeOfFirstClick > 0) {
            if (Time.time - BigWinSkipper.timeOfFirstClick > 4) {
                BigWinSkipper.timeOfFirstClick = Time.time;
                return
            }
        } else {
            BigWinSkipper.timeOfFirstClick = Time.time;
            return
        }
    BigWinSkipper.timeOfFirstClick = -1;
    if (XT.GetBool(Vars.WaitInResultForBigWin))
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin)
}
;
goog.require("UHT.Engine");
HotKeyClicker.prototype = Object.create(Component.prototype);
HotKeyClicker.prototype.constructor = HotKeyClicker;
function HotKeyClicker() {
    Component.call(this);
    this.inactiveDuringBigWin = false
}
HotKeyClicker.prototype.Update = function() {
    if (!Globals.InputBlocked && (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))) {
        if (this.inactiveDuringBigWin && XT.GetBool(Vars.WaitInResultForBigWin))
            return;
        var cd = this.gameObject.GetComponent(ClickDelay);
        if (cd == null || cd.CanClick())
            this.gameObject.SendMessage("OnClick")
    }
}
;
goog.require("UHT.Engine");
ScreenAnchor.prototype = Object.create(Component.prototype);
ScreenAnchor.prototype.constructor = ScreenAnchor;
function ScreenAnchor() {
    Component.call(this);
    this.targetTransform = null;
    this.alsoScaleTheSprite = false;
    this.anchorTop = false;
    this.topOffset = 0;
    this.anchorBottom = false;
    this.bottomOffset = 0;
    this.anchorLeft = false;
    this.leftOffset = 0;
    this.anchorRight = false;
    this.rightOffset = 0;
    this.scaleHorizontaly = false;
    this.widthOffset = 0;
    this.scaleVerticaly = false;
    this.heightOffset = 0;
    this.callWhenChanged = null;
    this.limitByGameAnchors = false;
    this.lastScreenWidth = 0;
    this.lastScreenHeight = 0;
    this.updateIsNeeded = false
}
ScreenAnchor.prototype.Update = function() {
    if (this.lastScreenWidth != UHTScreen.width || this.lastScreenHeight != UHTScreen.height) {
        this.lastScreenWidth = UHTScreen.width;
        this.lastScreenHeight = UHTScreen.height;
        this.updateIsNeeded = true;
        return
    }
    if (!this.updateIsNeeded)
        return;
    var myCamera = this.GetMyCamera();
    if (myCamera == null)
        return;
    this.updateIsNeeded = false;
    var posOnScreen = new UHTMath.Vector3(0,0,0);
    if (this.anchorBottom)
        posOnScreen.y = this.lastScreenHeight;
    if (this.anchorRight)
        posOnScreen.x = this.lastScreenWidth;
    var posOnWorld = myCamera.ScreenToWorldPoint(posOnScreen);
    var pos = this.targetTransform.position();
    if (this.limitByGameAnchors) {
        var ga = XT.GetObject(InterfaceVars.GameAnchors);
        var UL = ga.upLeft.position();
        var DR = ga.downRight.position();
        var x = this.anchorLeft || this.anchorRight ? posOnWorld.x : pos.x;
        var y = this.anchorTop || this.anchorBottom ? posOnWorld.y : pos.y;
        if (this.anchorLeft && x < UL.x)
            x = UL.x;
        if (this.anchorRight && x > DR.x)
            x = DR.x;
        if (this.anchorTop && y > UL.y)
            y = UL.y;
        if (this.anchorBottom && y < DR.y)
            y = DR.y;
        posOnWorld = new UHTMath.Vector3(x,y,0)
    }
    this.targetTransform.position(this.anchorLeft || this.anchorRight ? posOnWorld.x : pos.x, this.anchorTop || this.anchorBottom ? posOnWorld.y : pos.y, pos.z);
    var offset = new UHTMath.Vector3(0,0,0);
    if (this.anchorTop)
        offset.y = -this.topOffset;
    else if (this.anchorBottom)
        offset.y = this.bottomOffset;
    if (this.anchorLeft)
        offset.x = this.leftOffset;
    else if (this.anchorRight)
        offset.x = -this.rightOffset;
    this.targetTransform.localPosition(this.targetTransform.localPosition().x + offset.x, this.targetTransform.localPosition().y + offset.y, this.targetTransform.localPosition().z);
    if (this.alsoScaleTheSprite) {
        var uiRoot = Component.FindObjectOfType(ArrangeableUIRoot).gameObject.GetComponent(UIRoot);
        var targetRatio = uiRoot.manualWidth / uiRoot.manualHeight;
        var currentRatio = this.lastScreenWidth / this.lastScreenHeight;
        var sceneScale = 1;
        if (currentRatio < targetRatio)
            sceneScale = this.lastScreenWidth / uiRoot.manualWidth;
        else
            sceneScale = this.lastScreenHeight / uiRoot.manualHeight;
        var sprite = this.targetTransform.GetComponent(UISprite);
        if (this.scaleHorizontaly) {
            var w = this.lastScreenWidth / sceneScale;
            w *= uiRoot.gameObject.transform._internal_get_scale().x / sprite.gameObject.transform._internal_get_scale().x;
            sprite.width = _number.otoi(w + this.widthOffset)
        }
        if (this.scaleVerticaly) {
            var h = this.lastScreenHeight / sceneScale;
            h *= uiRoot.gameObject.transform._internal_get_scale().y / sprite.gameObject.transform._internal_get_scale().y;
            sprite.height = _number.otoi(h + this.heightOffset)
        }
    }
    if (this.callWhenChanged != null)
        this.callWhenChanged.Start()
}
;
ScreenAnchor.prototype.GetMyCamera = function() {
    var allCameras = Camera.allCameras;
    var layerMask = 1 << this.targetTransform.gameObject.layer;
    for (var i = 0; i < allCameras.length; i++)
        if (allCameras[i].cullingMask == layerMask)
            return allCameras[i];
    return null
}
;
goog.provide("UHT.GUIArrangerSettings");
goog.require("UHT.XTLink");
GUIArrangerSettings.prototype = Object.create(XTLink.prototype);
GUIArrangerSettings.prototype.constructor = GUIArrangerSettings;
function GUIArrangerSettings() {
    XTLink.call(this);
    this.applyToExtraElements = false;
    this.logoTargetAnchorDesktop = null;
    this.logoTargetArrangeableDesktop = null;
    this.gameAnchorUpLeftDesktop = null;
    this.gameAnchorDownRightDesktop = null;
    this.logoTargetAnchorMobile = null;
    this.logoTargetArrangeableMobile = null;
    this.gameAnchorUpLeftMobile = null;
    this.gameAnchorDownRightMobile = null;
    this.portraitTargets = null;
    this.landscapeTargets = null
}
GUIArrangerSettings.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(InterfaceVars.GUIArrangerSettings, this)
}
;
goog.provide("UHT.VSGameStateManager");
goog.require("UHT.Engine");
var VSGameState = {
    Spin: 0,
    SpinAutoplay: 1,
    SpinFreeSpins: 2,
    SpinBonusRounds: 3,
    SpinBonusRoundsAutoplay: 4,
    Result: 5,
    ResultAutoplay: 6,
    ResultBonusRounds: 7,
    ResultBonusRoundsAutoplay: 8,
    ResultFreeSpins: 9,
    ResultFreeSpinsPrepare: 10,
    ResultPrepareForBonus: 11,
    Bonus: 12,
    Gamble: 13,
    GambleCustom: 14,
    FSBG: 15,
    Invalid: 16
};
function VSGameStateManager() {}
VSGameStateManager.ChangeTo = function(_newState) {
    VSGameStateManager.previousState = VSGameStateManager.internalState;
    VSGameStateManager.internalState = _newState;
    XT.TriggerEvent(Vars.Evt_Internal_ChangeVSGameState)
}
;
VSGameStateManager.GetState = function() {
    return VSGameStateManager.internalState
}
;
VSGameStateManager.GetPreviousState = function() {
    return VSGameStateManager.previousState
}
;
VSGameStateManager.internalState = VSGameState.Invalid;
VSGameStateManager.previousState = VSGameState.Invalid;
goog.provide("UHT.RequestManager");
goog.require("UHT.VSGameStateManager");
var RequestManager = {};
RequestManager.blockRequests = false;
RequestManager.spinTimer = 0;
RequestManager.freeSpinsStates = [VSGameState.SpinFreeSpins, VSGameState.ResultFreeSpins, VSGameState.ResultFreeSpinsPrepare];
RequestManager.requestList = null;
RequestManager.notStartedList = null;
RequestManager.Init = function() {
    RequestManager.requestList = [];
    RequestManager.notStartedList = []
}
;
RequestManager.Update = function() {
    if (RequestManager.blockRequests)
        return;
    RequestManager.spinTimer += Time.deltaTime;
    for (var i = 0; i < RequestManager.notStartedList.length; ++i) {
        if (RequestManager.IsSpinRequest(RequestManager.notStartedList[i]))
            RequestManager.spinTimer = 0;
        RequestManager.notStartedList[i].Start();
        RequestManager.requestList.push(RequestManager.notStartedList[i])
    }
    RequestManager.notStartedList.splice(0);
    var notFinishedList = [];
    for (var i = 0; i < RequestManager.requestList.length; ++i)
        if (RequestManager.requestList[i].IsDone())
            if (RequestManager.IsSpinRequest(RequestManager.requestList[i]))
                if (!RequestManager.MustLimitSpinRequest(RequestManager.requestList[i]))
                    RequestManager.requestList[i].Finish();
                else
                    notFinishedList.push(RequestManager.requestList[i]);
            else
                RequestManager.requestList[i].Finish();
        else
            notFinishedList.push(RequestManager.requestList[i]);
    RequestManager.requestList = notFinishedList
}
;
RequestManager.AddRequest = function(request, external) {
    external = external == undefined ? false : external;
    if (!external)
        if (!_string.IsNullOrEmpty(ServerOptions.mgckey))
            if (request.Method == "POST")
                request.Fields[GameProtocolDictionary.mgckey] = ServerOptions.mgckey;
            else if (!(new RegExp(GameProtocolDictionary.mgckey)).test(request.Url))
                request.Url += (!/\?/.test(request.Url) ? "?" : "&") + GameProtocolDictionary.mgckey + "=" + ServerOptions.mgckey;
    RequestManager.notStartedList.push(request)
}
;
RequestManager.IsSpinRequest = function(request) {
    return request.Fields[GameProtocolDictionary.Actions.action] != undefined && request.Fields[GameProtocolDictionary.Actions.action] == GameProtocolDictionary.Actions.doSpin && !RequestManager.freeSpinsStates.indexOf(VSGameStateManager.GetState()) > -1
}
;
RequestManager.MustLimitSpinRequest = function(request) {
    return XT.GetBool(Vars.Jurisdiction_SpinLimit) && RequestManager.spinTimer < XT.GetFloat(Vars.Jurisdiction_SpinLimit_Value)
}
;
goog.require("UHT.Engine");
goog.require("UHT.GameConnection");
goog.require("UHT.BalanceManager");
goog.require("UHT.RequestManager");
goog.require("UHT.Adapter");
goog.require("UHT.JackpotsManager");
goog.require("UHT.ServerOptions");
goog.require("UHT.SwedishRegulationManager");
ServerLink.prototype = Object.create(Component.prototype);
ServerLink.prototype.constructor = ServerLink;
function ServerLink() {
    Component.call(this);
    this.connections = null;
    this.balanceManager = null;
    this.adapter = null;
    this.jackpotsManager = null;
    this.swedishRegulationManager = null;
    this.requestQueue = null;
    this.isReady = false
}
ServerLink.prototype.scriptUpdatePriority = 6;
ServerLink.prototype.Awake = function() {
    this.requestQueue = [];
    EventManager.Init();
    this.connections = [];
    RequestManager.Init();
    this.balanceManager = new BalanceManager;
    this.balanceManager.Init();
    this.adapter = new Adapter;
    this.adapter.Init();
    this.jackpotsManager = new JackpotsManager;
    this.jackpotsManager.Init();
    this.swedishRegulationManager = new SwedishRegulationManager;
    this.swedishRegulationManager.Init();
    EventManager.AddHandler(ApplicationEvents.evtRequestInitApplication, this.OnInitApplicationRequest, this);
    EventManager.AddHandler(ApplicationEvents.evtAppConfigurationReceived, this.OnApplicationConfigReceived, this);
    EventManager.AddHandler(GameEvents.evtCreateConnectionRequest, this.OnCreateConnectionRequest, this)
}
;
ServerLink.prototype.Start = function() {
    this.gameObject.AddComponent("ResourceManager")
}
;
ServerLink.prototype.Update = function() {
    var i;
    if (this.isReady && this.requestQueue.length > 0) {
        for (i = 0; i < this.requestQueue.length; ++i) {
            var connection = new GameConnection;
            connection.Init(this.requestQueue[i]);
            this.connections.push(connection);
            console.log("ServerLink::Update", ServerOptions.gameSymbol);
            EventManager.Trigger(GameEvents.evtConnectionReady, ServerOptions.gameSymbol);
            EventManager.Trigger(GameEvents.evtGetSettingsRequest + ServerOptions.gameSymbol, null);
            EventManager.Trigger(ApplicationEvents.evtServerOptionsParsed, null)
        }
        this.requestQueue = []
    }
    RequestManager.Update();
    for (i = 0; i < this.connections.length; ++i)
        this.connections[i].Update();
    this.balanceManager.Update();
    this.jackpotsManager.Update();
    this.swedishRegulationManager.Update()
}
;
ServerLink.prototype.OnInitApplicationRequest = function(param) {
    EventManager.Trigger(ApplicationEvents.evtRequestAppConfiguration, null)
}
;
ServerLink.prototype.OnApplicationConfigReceived = function(param) {
    var configOptions = param;
    var secure = this.GetConfigValue(FrameworkConfiguration.isSecure, "true", configOptions);
    if (!_string.IsNullOrEmpty(secure))
        ServerOptions.isSecure = _bool.Parse(secure);
    ServerOptions.serverUrl = (ServerOptions.isSecure ? "https://" : "http://") + ServerInterface.GetDomain();
    ServerOptions.loginUri = this.GetConfigValue(FrameworkConfiguration.loginUri, ServerOptions.loginUri, configOptions);
    ServerOptions.logoutUri = this.GetConfigValue(FrameworkConfiguration.logoutUri, ServerOptions.logoutUri, configOptions);
    ServerOptions.sessionTimeout = this.GetConfigValue(FrameworkConfiguration.sessionTimeout, ServerOptions.sessionTimeout, configOptions);
    ServerOptions.rcSettings = this.GetConfigValue(FrameworkConfiguration.rcSettings, ServerOptions.rcSettings, configOptions);
    ServerOptions.menuUri = this.GetConfigValue(FrameworkConfiguration.menuUri, ServerOptions.menuUri, configOptions);
    ServerOptions.versionUri = this.GetConfigValue(FrameworkConfiguration.versionInfo, ServerOptions.versionUri, configOptions);
    ServerOptions.resourceseUri = this.GetConfigValue(FrameworkConfiguration.resourceUri, ServerOptions.resourceseUri, configOptions);
    ServerOptions.settingsUri = this.GetConfigValue(FrameworkConfiguration.settingsUri, ServerOptions.settingsUri, configOptions);
    ServerOptions.reloadBalanceUri = this.GetConfigValue(FrameworkConfiguration.reloadBalanceUri, ServerOptions.reloadBalanceUri, configOptions);
    ServerOptions.reloadJackpotUri = this.GetConfigValue(FrameworkConfiguration.reloadJackpotUri, ServerOptions.reloadJackpotUri, configOptions);
    ServerOptions.gameUrl = this.GetConfigValue(FrameworkConfiguration.gameUrl, ServerOptions.gameUrl, configOptions);
    ServerOptions.currency = this.GetConfigValue(FrameworkConfiguration.currency, ServerOptions.currency, configOptions);
    ServerOptions.casinoName = this.GetConfigValue(FrameworkConfiguration.casinoName, ServerOptions.casinoName, configOptions);
    ServerOptions.mgckey = this.GetConfigValue(FrameworkConfiguration.mgckey, ServerOptions.mgckey, configOptions);
    ServerOptions.resourcesUrl = (ServerOptions.isSecure ? "https://" : "http://") + this.GetConfigValue(FrameworkConfiguration.bundleDomain, ServerOptions.resourcesUrl, configOptions);
    ServerOptions.gameHistory = this.GetConfigValue(FrameworkConfiguration.gameHistory, ServerOptions.gameHistory, configOptions);
    ServerOptions.jurisdiction = this.GetConfigValue(FrameworkConfiguration.jurisdiction, ServerOptions.jurisdiction, configOptions);
    ServerOptions.jurisdictionRequirements = this.GetConfigValue(FrameworkConfiguration.jurisdictionRequirements, ServerOptions.jurisdictionRequirements, configOptions);
    ServerOptions.promotionurl = this.GetConfigValue(FrameworkConfiguration.promotionurl, ServerOptions.promotionurl, configOptions);
    ServerOptions.amountType = this.GetConfigValue(FrameworkConfiguration.amountType, ServerOptions.amountType, configOptions);
    ServerOptions.SwedishRegulation.notificationUrl = this.GetConfigValue("REGULATION_NOTIFICATION_URL", "", configOptions);
    var currentLogLevel = this.GetConfigValue(FrameworkConfiguration.clientLogLevel, "INFO", configOptions);
    if (currentLogLevel == "WARN")
        ServerOptions.logLevel = LogLevel.Warn;
    else if (currentLogLevel == "DEBUG")
        ServerOptions.logLevel = LogLevel.Debug;
    else if (currentLogLevel == "ERROR")
        ServerOptions.logLevel = LogLevel.Error;
    else
        ServerOptions.logLevel = LogLevel.None_Info;
    ServerOptions.isExternal = _bool.Parse(this.GetConfigValue(FrameworkConfiguration.external, "", configOptions));
    ServerOptions.noRating = _bool.Parse(this.GetConfigValue(FrameworkConfiguration.noRating, String(ServerOptions.noRating), configOptions));
    if (!UHT_LOCAL) {
        ServerOptions.styleName = this.GetConfigValue(FrameworkConfiguration.stylename, ServerOptions.styleName, configOptions);
        ServerOptions.language = this.GetConfigValue(FrameworkConfiguration.locale, ServerOptions.language, configOptions);
        ServerOptions.gameSymbol = this.GetConfigValue(FrameworkConfiguration.gameSymbol, ServerOptions.gameSymbol, configOptions);
        ServerOptions.gameServiceUri = this.GetConfigValue(FrameworkConfiguration.gameServiceUri, ServerOptions.gameServiceUri, configOptions)
    }
    this.OnCreateConnectionRequest(ServerOptions.gameSymbol);
    this.isReady = true
}
;
ServerLink.prototype.GetConfigValue = function(key, value, dictionary) {
    if (dictionary[key] != undefined)
        return dictionary[key];
    return value
}
;
ServerLink.prototype.OnCreateConnectionRequest = function(symbol) {
    this.requestQueue.push(symbol)
}
;
ServerLink.prototype.OnAppConfigurationResponse = function(param, statusCode) {
    EventManager.Trigger(AdapterEvents.evtGetConfiguration, param)
}
;
ServerLink.prototype.ReloadBalanceCallback = function(response) {
    var nameValues = response.split("&");
    var nameValuesDict = GameProtocolCommonParser.SplitResponseContent(nameValues);
    var balanceData = GameProtocolCommonParser.ParseBalance(nameValuesDict);
    if (balanceData != null)
        EventManager.Trigger(BalanceEvents.evtBalanceUpdateRequest, balanceData)
}
;
goog.require("UHT.Engine");
VSGameStateHelper.prototype = Object.create(Component.prototype);
VSGameStateHelper.prototype.constructor = VSGameStateHelper;
function VSGameStateHelper() {
    Component.call(this)
}
goog.require("UHT.UHTEngine");
ValueFX.prototype = Object.create(Component.prototype);
ValueFX.prototype.constructor = ValueFX;
function ValueFX() {
    Component.call(this);
    this.valueLabels = null;
    this.fxCats = null
}
ValueFX.prototype.TryStartFX = function(value, fxIdx) {
    var cat = this.fxCats[UHTMath.clamp(fxIdx, 0, this.fxCats.length - 1)];
    if (cat.IsRunning())
        return false;
    for (var i = 0; i < this.valueLabels.length; ++i)
        this.valueLabels[i].text = value;
    cat.Start();
    return true
}
;
goog.require("UHT.UHTEngine");
ValueMultiplierFX.prototype = Object.create(Component.prototype);
ValueMultiplierFX.prototype.constructor = ValueMultiplierFX;
function ValueMultiplierFX() {
    Component.call(this);
    this.fx = null;
    this.fxDurations = null;
    this.affectedMultipliers = null;
    this.startFXTime = [];
    this.curFXIndex = -1;
    this.minX = 2
}
ValueMultiplierFX.prototype.ComputeStartFXTime = function(baseValue, oldValue, newValue, animationTime) {
    this.startFXTime.splice(0);
    var deltaValue = newValue - oldValue;
    var maxX = Math.floor(newValue / baseValue);
    var deltaX = maxX - this.minX;
    var startXTime = (baseValue - oldValue) / deltaValue * animationTime;
    var oneXTime = 0;
    if (deltaX > 0)
        oneXTime = 1 / deltaX * ((baseValue * maxX - baseValue) / deltaValue * animationTime);
    for (var i = 0; i <= deltaX; ++i)
        if (this.affectedMultipliers.length == 0 || this.affectedMultipliers.indexOf(i + this.minX) > -1)
            this.startFXTime.push(oneXTime * i + startXTime - this.fxDurations[UHTMath.clamp(i, 0, this.fxDurations.length - 1)]);
    this.curFXIndex = this.startFXTime.length > 0 ? 0 : -1
}
;
ValueMultiplierFX.prototype.StartFX = function() {
    var strX = String(this.affectedMultipliers.length == 0 ? this.curFXIndex + this.minX : this.affectedMultipliers[this.curFXIndex]);
    for (var i = 0; i < this.fx.length; ++i)
        if (this.fx[i].TryStartFX(strX, this.curFXIndex))
            break;
    this.curFXIndex++;
    if (this.curFXIndex >= this.startFXTime.length)
        this.curFXIndex = -1
}
;
goog.require("UHT.XTLink");
goog.require("UHT.AudioClassesUtils");
var WinAnimState = {
    idle: 0,
    level0: 1,
    level1: 2,
    level2: 3,
    level3: 4,
    level4: 5,
    level5: 6,
    jackpot: 7,
    hidingBigWin: 8
};
ValueAnimatorWithBigWin.prototype = Object.create(XTLink.prototype);
ValueAnimatorWithBigWin.prototype.constructor = ValueAnimatorWithBigWin;
ValueAnimatorWithBigWin.prototype.scriptUpdatePriority = 6;
function ValueAnimatorWithBigWin() {
    XTLink.call(this);
    this.vdVariable = null;
    this.reallyTriggersBigWin = true;
    this.setSkipTheNextBigWin = true;
    this.canBeSkippedByPreviousBigWin = true;
    this.animateWhenIncreasing = true;
    this.playSoundsWhenAnimating = false;
    this.isJackPot = false;
    this.makeTrueWhenAnimating = null;
    this.minimumBigWinDuration = 2;
    this.multiplierFX = null;
    this.oldValue = 0;
    this.newValue = 0;
    this.delta = 0;
    this.currentValue = 0;
    this.isAnimating = false;
    this.curTime = -1;
    this.animationTime = 1;
    this.normalWinTime = .5;
    this.totalBet = 0;
    this.coinCounter = null;
    this.currentState = WinAnimState.idle;
    this.skipClicks = 0;
    this.lastFinalizeReceived = -1
}
ValueAnimatorWithBigWin.counterVars = [];
ValueAnimatorWithBigWin.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_LastBetsChanged, this.ComputeTotalBet, this);
    XT.RegisterCallbackDouble(this.vdVariable.variable.name, this.OnTargetValueChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_BigWinHasFinished, this.OnBigWinFinished, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_FinalizeDisplayedWin, this.OnFinalizeValue, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnInit, this)
}
;
ValueAnimatorWithBigWin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), 0);
    XT.SetBool(Vars.SkipNextBigWin, false);
    if (this.makeTrueWhenAnimating.name != "")
        XT.SetBool(this.makeTrueWhenAnimating.name, false)
}
;
ValueAnimatorWithBigWin.prototype.ComputeTotalBet = function() {
    this.totalBet = CoinManager.GetLastTotalBet()
}
;
ValueAnimatorWithBigWin.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnTargetValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnBigWinFinished, this);
    XT.UnregisterCallbackEvent(this.OnFinalizeValue, this);
    XT.UnregisterCallbackEvent(this.ComputeTotalBet, this)
}
;
ValueAnimatorWithBigWin.prototype.OnInit = function() {
    this.coinCounter = XT.GetObject(Vars.CoinCounterObject)
}
;
ValueAnimatorWithBigWin.prototype.OnTargetValueChanged = function(newVal) {
    this.newValue = newVal;
    this.skipClicks = 0;
    var justSetTheValue = true;
    var epsilon = 1E-4;
    if (this.isAnimating)
        this.oldValue = this.currentValue;
    this.delta = this.newValue - this.oldValue;
    if (XT.GetBool(Vars.CanAnimateValues) && this.newValue > this.oldValue + epsilon && this.animateWhenIncreasing && this.totalBet > 0 && CoinManager.IsInit()) {
        if (this.reallyTriggersBigWin)
            this.coinCounter.ComputeTargetBigWinLevel(this.delta, this.totalBet);
        var skip = this.CalculateAnimationTime(this.delta);
        if (!skip) {
            this.isAnimating = true;
            this.curTime = 0;
            if (this.multiplierFX != null) {
                this.multiplierFX.ComputeStartFXTime(this.oldValue, this.oldValue, this.newValue, this.animationTime);
                if (this.multiplierFX.curFXIndex > -1)
                    this.curTime = this.multiplierFX.startFXTime[this.multiplierFX.curFXIndex]
            }
            if (this.makeTrueWhenAnimating.name != "")
                XT.SetBool(this.makeTrueWhenAnimating.name, true);
            var allowShowVisual = true;
            if (this.vdVariable.variable.name != Vars.BalanceDisplayed) {
                if (XT.GetInt(Vars.VAWBWCounters) == 0)
                    XT.SetBool(Vars.LastWinIsCounting, true);
                this.IncreaseVAWBWCounter(this.vdVariable.variable.name)
            } else
                XT.SetBool(Vars.BalanceIsCounting, true);
            if (!(newVal >= this.totalBet * this.coinCounter.BigWinSteps[0] || this.isJackPot))
                allowShowVisual = false;
            if (this.reallyTriggersBigWin && allowShowVisual) {
                XT.SetInt(Vars.BigWinLevel, 7);
                XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin);
                XT.SetBool(Vars.WaitInResultForBigWin, true)
            }
            if (this.setSkipTheNextBigWin)
                XT.SetBool(Vars.SkipNextBigWin, true);
            if (this.playSoundsWhenAnimating)
                XT.SetInt(Vars.CurrentCoinCountTarget, CoinManager.ConvertMoneyToCoins(this.newValue));
            if (this.playSoundsWhenAnimating && !this.isJackPot) {
                this.coinCounter.ComputeTargetBigWinLevel(this.delta, this.totalBet);
                XT.TriggerEvent(Vars.Evt_Internal_CoinCounterStart)
            }
            justSetTheValue = false
        }
    }
    if (justSetTheValue) {
        this.oldValue = this.newValue;
        this.currentValue = this.newValue;
        XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue);
        if (this.isJackPot && newVal > 0 && !XT.GetBool(Vars.CanAnimateValues))
            XT.TriggerEvent(Vars.Evt_Internal_JackpotCounterEnded)
    }
    this.Update()
}
;
ValueAnimatorWithBigWin.prototype.OnBigWinFinished = function() {
    this.currentState = WinAnimState.idle;
    XT.SetBool(Vars.WaitInResultForBigWin, false)
}
;
ValueAnimatorWithBigWin.prototype.SendGASkipEvent = function() {
    var level = XT.GetInt(Vars.BigWinLevel);
    if (level > 0 && level < 6 && this.curTime < this.animationTime && this.reallyTriggersBigWin && GA_BW_SENDONESKIP) {
        globalTracking.SendEvent("uht_behaviour_BigWin", "SkippedTimeLevel_" + level.toString(), this.curTime | 0, "BehaviourTracker");
        GA_BW_SENDONESKIP = false
    }
}
;
ValueAnimatorWithBigWin.prototype.OnFinalizeValue = function() {
    if (this.gameObject.activeInHierarchy && this.isAnimating) {
        if (this.isJackPot) {
            if (this.curTime > XT.GetFloat(Vars.MinimumJackpotBigWinDuration)) {
                this.curTime = this.animationTime;
                this.SendGASkipEvent();
                this.Update()
            }
            return
        }
        if (XT.GetInt(Vars.BigWinLevel) > 0) {
            this.curTime = this.animationTime;
            this.SendGASkipEvent()
        } else {
            this.curTime = this.animationTime;
            this.SendGASkipEvent()
        }
        this.Update()
    }
}
;
ValueAnimatorWithBigWin.prototype.UpdateAnimationLevel = function(currAnimTime) {
    if (this.isJackPot) {
        if (this.reallyTriggersBigWin)
            if (this.currentState != WinAnimState.jackpot) {
                this.currentState = WinAnimState.jackpot;
                XT.SetInt(Vars.BigWinLevel, WinAnimState.jackpot - 1);
                XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin)
            }
    } else {
        var progress = currAnimTime / this.animationTime;
        var n = this.oldValue + progress * this.delta;
        if (this.coinCounter.GetCurentCoinCounterSettings().coinCounterType == CoinCounterType.IndividualBigWinSounds && this.coinCounter.GetTargetBigWinLevel() > 0) {
            if (currAnimTime == 0 && this.reallyTriggersBigWin) {
                var lvl = this.coinCounter.GetTargetBigWinLevel();
                XT.SetInt(Vars.BigWinLevel, lvl);
                var wantedState = WinAnimState.level0 + lvl;
                this.currentState = wantedState;
                XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin)
            }
        } else {
            var lvl = 0;
            for (lvl = 0; lvl < this.coinCounter.BigWinSteps.length; lvl++)
                if (this.totalBet * this.coinCounter.BigWinSteps[lvl] > n)
                    break;
            var wantedState = WinAnimState.level0 + lvl;
            if (this.currentState != wantedState) {
                this.currentState = wantedState;
                if (lvl > 0)
                    if (this.reallyTriggersBigWin && this.animationTime != this.normalWinTime) {
                        XT.SetInt(Vars.BigWinLevel, this.currentState - WinAnimState.level0);
                        XT.TriggerEvent(Vars.Evt_Internal_ShowBigWin)
                    }
            }
        }
    }
    if (currAnimTime == this.animationTime) {
        if (!this.reallyTriggersBigWin)
            this.currentState = WinAnimState.idle;
        else if (this.currentState == WinAnimState.level0) {
            this.currentState = WinAnimState.idle;
            if (this.playSoundsWhenAnimating && !this.isJackPot)
                XT.TriggerEvent(Vars.Evt_Internal_CoinCounterStop)
        } else {
            this.currentState = WinAnimState.hidingBigWin;
            XT.TriggerEvent(Vars.Evt_Internal_ClearBigWin);
            if (this.playSoundsWhenAnimating && !this.isJackPot)
                XT.TriggerEvent(Vars.Evt_Internal_CoinCounterStop);
            if (this.isJackPot)
                XT.TriggerEvent(Vars.Evt_Internal_JackpotCounterEnded)
        }
        if (this.vdVariable.variable.name != Vars.BalanceDisplayed) {
            this.DecreaseVAWBWCounter(this.vdVariable.variable.name);
            if (XT.GetInt(Vars.VAWBWCounters) == 0)
                XT.SetBool(Vars.LastWinIsCounting, false)
        } else
            XT.SetBool(Vars.BalanceIsCounting, false)
    }
}
;
ValueAnimatorWithBigWin.prototype.CalculateAnimationTime = function(deltaValue) {
    if (this.coinCounter == null)
        return true;
    if (this.isJackPot) {
        this.animationTime = 18;
        return false
    } else
        this.animationTime = CoinManager.ConvertMoneyToCoins(deltaValue);
    this.normalWinTime = this.coinCounter.BigWinSteps[0] - 1;
    var speedUp = CoinManager.ConvertMoneyToCoins(this.totalBet) / this.coinCounter.secondsToCountOneTotalBet;
    this.animationTime /= speedUp;
    this.normalWinTime /= speedUp;
    if (this.canBeSkippedByPreviousBigWin && XT.GetBool(Vars.SkipNextBigWin)) {
        this.animationTime = this.normalWinTime;
        return true
    }
    return false
}
;
ValueAnimatorWithBigWin.prototype.Update = function() {
    if (this.totalBet > 0 && CoinManager.IsInit())
        if (this.isAnimating) {
            if (this.multiplierFX != null && this.multiplierFX.curFXIndex > -1) {
                var fxTime = this.multiplierFX.startFXTime[this.multiplierFX.curFXIndex];
                if (this.curTime <= fxTime && this.curTime + Time.deltaTime > fxTime)
                    this.multiplierFX.StartFX()
            }
            if (this.curTime > -.001) {
                var progress = this.curTime / this.animationTime;
                this.currentValue = this.oldValue + progress * this.delta;
                if (this.curTime < this.animationTime) {
                    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.currentValue);
                    this.UpdateAnimationLevel(this.curTime);
                    this.curTime += Time.deltaTime
                } else {
                    this.isAnimating = false;
                    this.curTime = -1;
                    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue);
                    this.UpdateAnimationLevel(this.animationTime);
                    this.oldValue = this.newValue;
                    if (this.makeTrueWhenAnimating.name != "")
                        XT.SetBool(this.makeTrueWhenAnimating.name, false)
                }
            } else
                this.curTime += Time.deltaTime
        }
}
;
ValueAnimatorWithBigWin.prototype.IncreaseVAWBWCounter = function(name) {
    var idx = ValueAnimatorWithBigWin.counterVars.indexOf(name);
    if (idx < 0) {
        XT.SetInt(Vars.VAWBWCounters, XT.GetInt(Vars.VAWBWCounters) + 1);
        ValueAnimatorWithBigWin.counterVars.push(name)
    }
}
;
ValueAnimatorWithBigWin.prototype.DecreaseVAWBWCounter = function(name) {
    var idx = ValueAnimatorWithBigWin.counterVars.indexOf(name);
    if (idx > -1) {
        XT.SetInt(Vars.VAWBWCounters, XT.GetInt(Vars.VAWBWCounters) - 1);
        ValueAnimatorWithBigWin.counterVars.splice(idx, 1)
    }
}
;
goog.require("UHT.XTLink");
goog.require("UHT.AnimationCurve");
ValueAnimator.prototype = Object.create(XTLink.prototype);
ValueAnimator.prototype.constructor = ValueAnimator;
function ValueAnimator() {
    XTLink.call(this);
    this.vdVariable = null;
    this.animationTime = 2;
    this.animateWhenIncreasing = true;
    this.animCurveIncreasing = null;
    this.animateWhenDecreasing = true;
    this.animCurveDecreasing = null;
    this.curAnimCurve = null;
    this.oldValue = 0;
    this.newValue = 0;
    this.delta = 0;
    this.currentValue = 0;
    this.curTime = -1
}
ValueAnimator.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackDouble(this.vdVariable.variable.name, this.OnTargetValueChanged, this)
}
;
ValueAnimator.prototype.XTInitVariablesAndEvents = function() {
    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), 0)
}
;
ValueAnimator.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnTargetValueChanged, this)
}
;
ValueAnimator.prototype.OnTargetValueChanged = function(newVal) {
    this.newValue = newVal;
    var justSetTheValue = true;
    var epsilon = 1E-4;
    if (this.curTime > -.001)
        if (this.curTime < this.animationTime)
            this.oldValue = this.currentValue;
    if (this.newValue > this.oldValue + epsilon && this.animateWhenIncreasing) {
        this.curTime = 0;
        this.delta = this.newValue - this.oldValue;
        this.curAnimCurve = this.animCurveIncreasing;
        justSetTheValue = false
    } else if (this.newValue < this.oldValue - epsilon && this.animateWhenDecreasing) {
        this.curTime = 0;
        this.delta = this.newValue - this.oldValue;
        this.curAnimCurve = this.animCurveDecreasing;
        justSetTheValue = false
    }
    if (justSetTheValue) {
        this.oldValue = this.newValue;
        this.currentValue = this.newValue;
        XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue)
    }
}
;
ValueAnimator.prototype.Update = function() {
    if (this.curTime > -.001) {
        var progress = this.curTime / this.animationTime;
        if (this.curAnimCurve.keys.length >= 2) {
            var startKey = this.curAnimCurve.keys[0];
            var endKey = this.curAnimCurve.keys[this.curAnimCurve.keys.length - 1];
            var totalCurveTime = endKey.time - startKey.time;
            var curCurveTime = progress * totalCurveTime;
            progress = this.curAnimCurve.Evaluate(curCurveTime)
        }
        this.currentValue = this.oldValue + progress * this.delta;
        if (this.curTime < this.animationTime) {
            this.curTime += Time.deltaTime;
            XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.currentValue)
        } else {
            this.curTime = -1;
            this.curAnimCurve = null;
            this.oldValue = this.newValue;
            XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue)
        }
    }
}
;
ValueAnimator.prototype.Stop = function() {
    this.curTime = -1;
    this.curAnimCurve = null;
    this.oldValue = this.newValue;
    XT.SetDouble(this.vdVariable.GetAnimatedVarName(), this.newValue)
}
;
goog.require("UHT.XTLink");
CoinsAndCashHint.prototype = Object.create(XTLink.prototype);
CoinsAndCashHint.prototype.constructor = CoinsAndCashHint;
function CoinsAndCashHint() {
    XTLink.call(this);
    this.catShowHint = null;
    this.catHideHint = null;
    this.canHideHint = false
}
CoinsAndCashHint.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this)
}
;
CoinsAndCashHint.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.ShowCoinsAndCashHint, true)
}
;
CoinsAndCashHint.prototype.UnregisterCallbacks = function() {
    XT.UnregisterCallbackBool(this.OnHasCoinsChanged, this)
}
;
CoinsAndCashHint.prototype.OnGUIInit = function() {
    if (XT.GetBool(InterfaceVars.ShowCoinsAndCashHint) && XT.GetBool(Vars.FromServer_AllowCoins))
        XT.RegisterCallbackEvent(Vars.Evt_CodeToData_IntroClosedOrSkipped, this.ShowHint, this)
}
;
CoinsAndCashHint.prototype.OnHasCoinsChanged = function(unused) {
    if (this.canHideHint)
        this.HideHint()
}
;
CoinsAndCashHint.prototype.ShowHint = function() {
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this);
    this.canHideHint = true;
    this.StopRunningEvents();
    this.catShowHint.Start();
    XT.SetBool(InterfaceVars.ShowCoinsAndCashHint, false);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
}
;
CoinsAndCashHint.prototype.HideHint = function() {
    this.canHideHint = false;
    this.StopRunningEvents();
    this.catHideHint.Start()
}
;
CoinsAndCashHint.prototype.HideHintForever = function() {
    this.OnHasCoinsChanged(true)
}
;
CoinsAndCashHint.prototype.StopRunningEvents = function() {
    if (this.catShowHint.IsRunning())
        this.catShowHint.Stop();
    if (this.catHideHint.IsRunning())
        this.catHideHint.Stop()
}
;
CoinsAndCashHint.prototype.HideHintIfVisible = function() {
    if (this.canHideHint)
        this.HideHint()
}
;
goog.require("UHT.Engine");
AnchorToUILabel.prototype = Object.create(Component.prototype);
AnchorToUILabel.prototype.constructor = AnchorToUILabel;
function AnchorToUILabel() {
    Component.call(this);
    this.targetLabel = null;
    this.updateSpriteSize = false;
    this.extraSize = 0;
    this.keepAspectRatio = false;
    this.snapToLabelsPosition = false;
    this.labelPositionOffset = UHTMath.Vector3.zero;
    this.transformToChangeIfSnap = null;
    this.labelScale = null;
    this.curWidth = -1
}
AnchorToUILabel.prototype.Update = function() {
    var w = this.targetLabel.GetWidth();
    if (this.labelScale != null)
        w = Math.round(w * this.labelScale.localScale().x);
    if (w != this.curWidth && this.updateSpriteSize) {
        this.curWidth = w;
        var sprite = this.GetComponent(UISprite);
        var oldWidth = sprite.width;
        sprite.width = w + this.extraSize;
        if (this.keepAspectRatio)
            sprite.height = sprite.height * (sprite.width / oldWidth) | 0;
        sprite.SetSpriteName(sprite.spriteName)
    }
    if (this.snapToLabelsPosition && this.transformToChangeIfSnap.position().equals(this.targetLabel.transform.position()) == false) {
        var pos = this.targetLabel.transform.transformPoint(new UHTMath.Vector3(this.targetLabel.GetWidth() * this.labelPositionOffset.x,this.targetLabel.GetHeight() * this.labelPositionOffset.y,0));
        this.transformToChangeIfSnap.position(new UHTMath.Vector3(pos.x,pos.y,this.transformToChangeIfSnap.position().z))
    }
}
;
goog.require("UHT.Engine");
ClickDelay.prototype = Object.create(Component.prototype);
ClickDelay.prototype.constructor = ClickDelay;
function ClickDelay() {
    Component.call(this);
    this.delay = 2;
    this.timer = 0
}
ClickDelay.prototype.OnEnable = function() {
    this.timer = 0
}
;
ClickDelay.prototype.Update = function() {
    this.timer += Time.deltaTime
}
;
ClickDelay.prototype.CanClick = function() {
    return this.timer > this.delay
}
;
goog.provide("UHT.InterfaceUtils");
function ButtonOpenClose() {
    this.opened = null;
    this.closed = null
}
goog.require("UHT.XTLink");
MenuWindowControllerMobile.prototype = Object.create(XTLink.prototype);
MenuWindowControllerMobile.prototype.constructor = MenuWindowControllerMobile;
function MenuWindowControllerMobile() {
    XTLink.call(this);
    this.content = null;
    this.menuButtons = [];
    this.fastPlayEnabled = null;
    this.fastPlayDisabled = null;
    this.batterySaverEnabled = null;
    this.batterySaverDisabled = null
}
MenuWindowControllerMobile.prototype.ShowMenuWindow = function(enableButtons) {
    this.content.SetActive(true);
    this.ToggleMenuButtons(enableButtons);
    this.UpdateButtons();
    XT.TriggerEvent(Vars.Evt_CodeToData_SettingsWindowOpened)
}
;
MenuWindowControllerMobile.prototype.HideMenuWindow = function() {
    this.content.SetActive(false);
    XT.TriggerEvent(Vars.Evt_CodeToData_SettingsWindowClosed)
}
;
MenuWindowControllerMobile.prototype.ToggleMenuButtons = function(enable) {
    for (var i = 0; i < this.menuButtons.length; i++) {
        var be = this.menuButtons[i].GetComponentInChildren(ButtonEnabler);
        if (be != null)
            if (enable)
                be.EnableButton();
            else
                be.DisableButton()
    }
}
;
MenuWindowControllerMobile.prototype.ToggleFastPlay = function() {
    XT.SetBool(Vars.FastPlay, !XT.GetBool(Vars.FastPlay));
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.UpdateButtons()
}
;
MenuWindowControllerMobile.prototype.ToggleBatterySaver = function() {
    XT.SetBool(Vars.BatterySaver, !XT.GetBool(Vars.BatterySaver));
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.UpdateButtons()
}
;
MenuWindowControllerMobile.prototype.UpdateButtons = function() {
    var b = XT.GetBool(Vars.FastPlay);
    this.fastPlayEnabled.SetActive(b);
    this.fastPlayDisabled.SetActive(!b);
    var bb = XT.GetBool(Vars.BatterySaver);
    this.batterySaverEnabled.SetActive(bb);
    this.batterySaverDisabled.SetActive(!bb)
}
;
goog.require("UHT.XTLink");
BetsControllerMobile.prototype = Object.create(XTLink.prototype);
BetsControllerMobile.prototype.constructor = BetsControllerMobile;
function BetsControllerMobile() {
    XTLink.call(this);
    this.windowShow = null;
    this.windowHide = null;
    this.increaseBetButton = null;
    this.decreaseBetButton = null;
    this.increaseBetButtonCash = null;
    this.decreaseBetButtonCash = null;
    this.increaseCoinValueButton = null;
    this.decreaseCoinValueButton = null;
    this.increaseBetAndCoinValueButtons = null;
    this.decreaseBetAndCoinValueButtons = null;
    this.cashContent = null;
    this.coinsContent = null
}
BetsControllerMobile.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.MinBetReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MaxBetReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MinCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MaxCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MinBetAndCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MaxBetAndCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.FromServer_AllowCoins, this.OnAllowCoinsChanged, this)
}
;
BetsControllerMobile.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnBetStateUpdated, this);
    XT.UnregisterCallbackBool(this.OnAllowCoinsChanged, this)
}
;
BetsControllerMobile.prototype.ShowBetsWindow = function() {
    if (this.windowShow != null && this.windowShow.cat != null)
        this.windowShow.Start()
}
;
BetsControllerMobile.prototype.HideBetsWindow = function() {
    if (this.windowHide != null && this.windowHide.cat != null)
        this.windowHide.Start()
}
;
BetsControllerMobile.prototype.UpdateBetButtons = function(enabled) {
    this.UpdateBetIncDecButtons(enabled)
}
;
BetsControllerMobile.prototype.OnBetStateUpdated = function(unused) {
    this.UpdateBetIncDecButtons(true)
}
;
BetsControllerMobile.prototype.UpdateBetIncDecButtons = function(enabled) {
    if (enabled) {
        if (XT.GetBool(Vars.MinBetReached)) {
            this.decreaseBetButton.DisableButton();
            this.decreaseBetButtonCash.DisableButton()
        } else {
            this.decreaseBetButton.EnableButton();
            this.decreaseBetButtonCash.EnableButton()
        }
        if (XT.GetBool(Vars.MaxBetReached)) {
            this.increaseBetButton.DisableButton();
            this.increaseBetButtonCash.DisableButton()
        } else {
            this.increaseBetButton.EnableButton();
            this.increaseBetButtonCash.EnableButton()
        }
        if (XT.GetBool(Vars.MinCoinValueReached))
            this.decreaseCoinValueButton.DisableButton();
        else
            this.decreaseCoinValueButton.EnableButton();
        if (XT.GetBool(Vars.MaxCoinValueReached))
            this.increaseCoinValueButton.DisableButton();
        else
            this.increaseCoinValueButton.EnableButton();
        if (XT.GetBool(Vars.MinBetAndCoinValueReached))
            for (var i = 0; i < this.decreaseBetAndCoinValueButtons.length; ++i)
                this.decreaseBetAndCoinValueButtons[i].DisableButton();
        else
            for (var i = 0; i < this.decreaseBetAndCoinValueButtons.length; ++i)
                this.decreaseBetAndCoinValueButtons[i].EnableButton();
        if (XT.GetBool(Vars.MaxBetAndCoinValueReached))
            for (var i = 0; i < this.increaseBetAndCoinValueButtons.length; ++i)
                this.increaseBetAndCoinValueButtons[i].DisableButton();
        else
            for (var i = 0; i < this.increaseBetAndCoinValueButtons.length; ++i)
                this.increaseBetAndCoinValueButtons[i].EnableButton()
    } else {
        this.decreaseBetButton.DisableButton();
        this.increaseBetButton.DisableButton();
        this.decreaseBetButtonCash.DisableButton();
        this.increaseBetButtonCash.DisableButton();
        this.decreaseCoinValueButton.DisableButton();
        this.increaseCoinValueButton.DisableButton();
        for (var i = 0; i < this.decreaseBetAndCoinValueButtons.length; ++i)
            this.decreaseBetAndCoinValueButtons[i].DisableButton();
        for (var i = 0; i < this.increaseBetAndCoinValueButtons.length; ++i)
            this.increaseBetAndCoinValueButtons[i].DisableButton()
    }
}
;
BetsControllerMobile.prototype.OnAllowCoinsChanged = function(allow) {
    this.coinsContent.SetActive(allow);
    this.cashContent.SetActive(!allow)
}
;
goog.require("UHT.Engine");
FSMultiplierToggle.prototype = Object.create(Component.prototype);
FSMultiplierToggle.prototype.constructor = FSMultiplierToggle;
function FSMultiplierToggle() {
    Component.call(this);
    this.hideWhenMultiplierIs1 = false;
    this.hideWhenMultiplierIsNot1 = false;
    this.changeLocalPositions = false;
    this.newLocalPosWhenMultiplierIs1 = null;
    this.newLocalPosWhenMultiplierIsNot1 = null
}
FSMultiplierToggle.prototype.FSMultiplierChanged = function(newMultiplier) {
    var visible = !(this.hideWhenMultiplierIs1 && newMultiplier == 1) && !(this.hideWhenMultiplierIsNot1 && newMultiplier != 1);
    this.gameObject.SetActive(visible);
    if (this.changeLocalPositions)
        if (newMultiplier == 1)
            this.transform.localPosition(this.newLocalPosWhenMultiplierIs1);
        else
            this.transform.localPosition(this.newLocalPosWhenMultiplierIsNot1)
}
;
goog.require("UHT.Engine");
ToggleOnHideWin.prototype = Object.create(Component.prototype);
ToggleOnHideWin.prototype.constructor = ToggleOnHideWin;
function ToggleOnHideWin() {
    Component.call(this);
    this.visibleOnHideWin = false
}
ToggleOnHideWin.prototype.WinIsHidden = function() {
    this.gameObject.SetActive(this.visibleOnHideWin)
}
;
goog.provide("UHT.GUIMessageBase");
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
GUIMessageBase.prototype = Object.create(XTLink.prototype);
GUIMessageBase.prototype.constructor = GUIMessageBase;
function GUIMessageBase() {
    XTLink.call(this);
    this.label = null;
    this.messages = null
}
GUIMessageBase.prototype.Init = function(texts) {
    this.messages = texts
}
;
GUIMessageBase.prototype.Show = function() {
    if (this.messages != null && this.messages.length > 0) {
        var i = Random.Range(0, this.messages.length);
        this.label.text = this.messages[i]
    }
    this.gameObject.SetActive(true)
}
;
GUIMessageBase.prototype.Hide = function() {
    this.gameObject.SetActive(false)
}
;
goog.require("UHT.Engine");
WinLinesInformationDisplayer.prototype = Object.create(Component.prototype);
WinLinesInformationDisplayer.prototype.constructor = WinLinesInformationDisplayer;
function WinLineDesc() {
    this.text = "";
    this.atlases = [];
    this.spriteNames = [];
    this.spacing = 0;
    this.spacingExtraLabel = 0;
    this.thumbnailSize = 0
}
function WinLinesInformationDisplayer() {
    Component.call(this);
    this.symbolSprites = [];
    this.showLineEvent = null;
    this.hideLineEvent = null;
    this.targetLabel = null;
    this.widthLabel = null;
    this.parent = null;
    this.targetPosLeft = null;
    this.targetPosCentered = null;
    this.isCentered = false;
    this.oldWidth = -1;
    this.spriteWidth = -1
}
WinLinesInformationDisplayer.prototype.scriptUpdatePriority = 8;
WinLinesInformationDisplayer.prototype.ShowWinLine = function(desc, centered) {
    this.targetLabel.InternalSetText(desc.text, true);
    this.spriteWidth = 0;
    this.isCentered = centered;
    var pos = new UHTMath.Vector3(0,0,0);
    var idxInSpriteArray = 0;
    for (var i = 0; i < this.symbolSprites.length; i++) {
        if (idxInSpriteArray < desc.spriteNames.length) {
            this.symbolSprites[i].width = desc.thumbnailSize;
            this.symbolSprites[i].height = desc.thumbnailSize;
            this.symbolSprites[i].atlas = desc.atlases[idxInSpriteArray];
            this.symbolSprites[i].SetSpriteName(desc.spriteNames[idxInSpriteArray]);
            this.symbolSprites[i].gameObject.SetActive(true);
            this.symbolSprites[i].gameObject.transform.localPosition(pos);
            pos.x += desc.spacing;
            this.spriteWidth += desc.spacing
        } else
            this.symbolSprites[i].gameObject.SetActive(false);
        idxInSpriteArray++
    }
    pos.x += desc.spacingExtraLabel;
    this.spriteWidth += desc.spacingExtraLabel;
    this.targetLabel.transform.localPosition(pos);
    this.oldWidth = -1;
    this.parent.localPosition(this.targetPosLeft.localPosition());
    this.showLineEvent.Start()
}
;
WinLinesInformationDisplayer.prototype.HideWinLine = function() {
    this.hideLineEvent.Start()
}
;
WinLinesInformationDisplayer.prototype.Update = function() {
    if (this.isCentered) {
        var newWidth = this.spriteWidth + this.targetLabel.GetWidth();
        if (this.oldWidth != newWidth) {
            this.oldWidth = newWidth;
            var p = this.targetPosCentered.localPosition();
            this.parent.localPosition(p.x - newWidth / 2, p.y, p.z);
            if (this.widthLabel != null)
                this.widthLabel.width = _number.otoi(newWidth)
        }
    }
}
;
goog.require("UHT.Engine");
goog.require("UHT.GUIMessageBase");
GUIMessageResultWin.prototype = Object.create(GUIMessageBase.prototype);
GUIMessageResultWin.prototype.constructor = GUIMessageResultWin;
function GUIMessageResultWin() {
    GUIMessageBase.call(this);
    this.labelCentered = null;
    this.winLineDisplayer = null;
    this.currentTotalWin = null;
    this.localized_GamePays = null;
    this.localized_WinTeasers = null;
    this.localized_Pays = null;
    this.localized_Line = null;
    this.label_FSWon = null;
    this.label_BonusWon = null;
    this.forceWinLineHasCoins = false;
    this.forceWinLineHasCash = false;
    this.catShowAllLines = null;
    this.catHideAllLines = null;
    this.orderedJPText = ["MINI JACKPOT", "MINOR JACKPOT", "MAJOR JACKPOT", "GRAND JACKPOT"];
    this.singleJPText = "JACKPOT";
    this.curWinDesc = [];
    this.settings = null;
    this.receivedWinLines = null;
    this.isBonusWon = false;
    this.isFSWon = false;
    this.isCentered = false;
    this.formatOptions = null;
    this.payingSymbolsDesc = [];
    this.jackpotText = "";
    this.gamePaysText = ""
}
GUIMessageResultWin.prototype.XTRegisterCallbacks = function() {}
;
GUIMessageResultWin.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(InterfaceVars.ExtraWinMultiplier, 1)
}
;
GUIMessageResultWin.prototype.OnDestroy = function() {}
;
GUIMessageResultWin.prototype.OnDisable = function() {
    this.Hide()
}
;
GUIMessageResultWin.prototype.SetSpecialFlags = function(bonusWon, FSWon) {
    this.isBonusWon = bonusWon;
    this.isFSWon = FSWon;
    this.isCentered = !this.isBonusWon && !this.isFSWon
}
;
GUIMessageResultWin.prototype.Show = function() {
    this.Hide();
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartDisplayWinLine, this.OnWinLineShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopDisplayWinLine, this.OnWinLineHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowAllLinesWin, this.OnAllLinesShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideAllLinesWin, this.OnAllLinesHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowJackpotWin, this.OnJackpotShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideJackpotWin, this.OnAllLinesHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_ShowScattersWin, this.OnScattersWinShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_HideScattersWin, this.OnWinLineHide, this);
    XT.RegisterCallbackEvent(PayingSymbolVars.Evt_Internal_ShowPayingSymbol, this.OnPayingSymbolShow, this);
    XT.RegisterCallbackEvent(PayingSymbolVars.Evt_Internal_HidePayingSymbol, this.OnWinLineHide, this);
    this.gameObject.SetActive(true);
    this.settings = XT.GetObject(InterfaceVars.GUIMessageZoneSettings);
    this.Prepare();
    if (this.isBonusWon)
        this.label_BonusWon.gameObject.SetActive(true);
    else if (this.isFSWon)
        this.label_FSWon.gameObject.SetActive(true)
}
;
GUIMessageResultWin.prototype.Hide = function() {
    XT.UnregisterCallbackEvent(this.OnWinLineShow, this);
    XT.UnregisterCallbackEvent(this.OnWinLineHide, this);
    XT.UnregisterCallbackEvent(this.OnAllLinesShow, this);
    XT.UnregisterCallbackEvent(this.OnAllLinesHide, this);
    XT.UnregisterCallbackEvent(this.OnJackpotShow, this);
    XT.UnregisterCallbackEvent(this.OnScattersWinShow, this);
    XT.UnregisterCallbackEvent(this.OnPayingSymbolShow, this);
    this.label_BonusWon.gameObject.SetActive(false);
    this.label_FSWon.gameObject.SetActive(false);
    this.winLineDisplayer.HideWinLine();
    this.label.gameObject.SetActive(false);
    this.labelCentered.gameObject.SetActive(false);
    this.gameObject.SetActive(false)
}
;
GUIMessageResultWin.prototype.Prepare = function() {
    var screenSymbols = XT.GetObject(Vars.ResultScreenSymbols);
    var numberOfReels = screenSymbols.length;
    var numberOfSymbolsPerReel = screenSymbols[0].length;
    this.curWinDesc.splice(0);
    this.receivedWinLines = XT.GetObject(Vars.ReceivedWinLines);
    for (var i = 0; i < this.receivedWinLines.length; i++) {
        var l = this.receivedWinLines[i];
        var desc = this.ComputeWinLineDesc(screenSymbols, numberOfReels, numberOfSymbolsPerReel, l.WinPositions);
        desc.text = this.ComputeWinLineText(l.WinAmount, false, l.Multiplier, l.LineNumber);
        this.curWinDesc.push(desc)
    }
    this.payingSymbolsDesc.splice(0);
    var payingSymbols = XT.GetObject(PayingSymbolVars.PayingSymbols);
    for (var i = 0; i < payingSymbols.length; ++i) {
        var s = payingSymbols[i];
        var desc = this.ComputeWinLineDesc(screenSymbols, numberOfReels, numberOfSymbolsPerReel, s.positions);
        desc.text = this.ComputeWinLineText(s.amount, true, 1, -1);
        this.payingSymbolsDesc.push(desc)
    }
    this.gamePaysText = "";
    var win = VSGameStateManager.GetState() == VSGameState.ResultFreeSpins ? XT.GetDouble(Vars.FreeSpinsLastWinDisplayed) : XT.GetDouble(Vars.SpinCycleWinDisplayed);
    if (win > 1E-4)
        this.gamePaysText = this.ComputeText(win, null, this.localized_GamePays.text, false);
    this.jackpotText = "";
    if (ResultDisplayer.isJackpotWin) {
        var jpInfo = XT.GetObject(Vars.FromServer_LastValidJackpotsInformation);
        var text;
        if (jpInfo == null || jpInfo.length == 1 && jpInfo[0].JackpotGroupType == "S")
            text = this.singleJPText;
        else
            text = this.orderedJPText[XT.GetInt(Vars.FromServer_JackpotWonOrder)];
        this.jackpotText = this.ComputeText(XT.GetDouble(Vars.FromServer_JackpotAmountWon), null, text, true)
    }
    this.winLineDisplayer.targetLabel.fontName = this.localized_Pays.fontName;
    this.winLineDisplayer.targetLabel.fontNameExpectedFromCallback = this.winLineDisplayer.targetLabel.fontName
}
;
GUIMessageResultWin.prototype.ComputeWinLineDesc = function(screenSymbols, numberOfReels, numberOfSymbolsPerReel, positions) {
    var desc = new WinLineDesc;
    desc.spacing = this.settings.GetSpacing();
    desc.spacingExtraLabel = this.settings.GetSpacingExtraLabel();
    desc.thumbnailSize = this.settings.GetThumbnailSize();
    for (var i = 0; i < positions.length; i++) {
        var symbolPos = positions[i];
        var symbolId = screenSymbols[symbolPos % numberOfReels][numberOfSymbolsPerReel - 1 - (symbolPos / numberOfReels | 0)];
        var thumbnail = this.settings.GetThumbnail(symbolId);
        if (thumbnail == null)
            continue;
        desc.atlases.push(thumbnail.atlas);
        desc.spriteNames.push(thumbnail.sprite + (XT.GetBool(Vars.HasReelAwareSymbolContent) ? "_" + symbolPos % numberOfReels : ""))
    }
    return desc
}
;
GUIMessageResultWin.prototype.ComputeWinLineText = function(amount, premultiplied, multiplier, lineNumber) {
    var fsmultiplier = XT.GetDouble(Vars.CurrentWinMultiplier);
    var multipliers = [];
    multipliers.push(multiplier);
    multipliers.push(fsmultiplier);
    multipliers.push(XT.GetInt(InterfaceVars.ExtraWinMultiplier));
    var lineText = null;
    if (lineNumber > -1)
        if (XT.GetBool(Vars.GameHasWaysInsteadOfLines) == false)
            lineText = this.localized_Line.text + " " + (lineNumber + 1);
    return this.ComputeText(premultiplied ? amount : amount * fsmultiplier, multipliers, lineText, true)
}
;
GUIMessageResultWin.prototype.WinLineHasCoins = function() {
    if (this.forceWinLineHasCash)
        return false;
    if (this.forceWinLineHasCoins)
        return true;
    return XT.GetBool(Vars.HasCoins)
}
;
GUIMessageResultWin.prototype.OnWinLineShow = function() {
    var lineIndex = XT.GetInt(Vars.CurrentDisplayedWinLineIndex);
    this.winLineDisplayer.ShowWinLine(this.curWinDesc[lineIndex], this.isCentered);
    this.label.gameObject.SetActive(false);
    this.labelCentered.gameObject.SetActive(false)
}
;
GUIMessageResultWin.prototype.OnWinLineHide = function() {
    this.winLineDisplayer.HideWinLine()
}
;
GUIMessageResultWin.prototype.OnAllLinesHide = function() {
    this.OnWinLineHide();
    this.HideLabel();
    if (this.catHideAllLines != null)
        this.catHideAllLines.Start()
}
;
GUIMessageResultWin.prototype.OnAllLinesShow = function() {
    if (this.receivedWinLines.length == 1 && !ResultDisplayer.isJackpotWin)
        this.ShowWinLine(this.curWinDesc[0]);
    else {
        var text;
        this.winLineDisplayer.HideWinLine();
        if (XT.GetBool(Vars.LastWinIsCounting)) {
            var i = XT.GetInt(Vars.BigWinLevel);
            if (XT.GetObject(Vars.CoinCounterObject).BigWinSteps.length == 4 && i >= 3)
                i++;
            if (i == null || i < 0 || i >= this.localized_WinTeasers.length)
                i = 0;
            text = this.localized_WinTeasers[i].text
        } else
            text = this.gamePaysText;
        this.ShowLabel(text);
        if (this.catShowAllLines != null)
            this.catShowAllLines.Start()
    }
}
;
GUIMessageResultWin.prototype.OnJackpotShow = function() {
    this.ShowLabel(this.jackpotText)
}
;
GUIMessageResultWin.prototype.OnPayingSymbolShow = function() {
    this.ShowWinLine(this.payingSymbolsDesc[XT.GetInt(PayingSymbolVars.CurrentDisplayedPayingSymbolIndex)])
}
;
GUIMessageResultWin.prototype.OnScattersWinShow = function() {
    var idx = XT.GetInt(PayingSymbolVars.PayingSymbolsScatterIndex);
    if (idx > -1)
        this.ShowWinLine(this.payingSymbolsDesc[idx])
}
;
GUIMessageResultWin.prototype.ShowWinLine = function(desc) {
    this.winLineDisplayer.ShowWinLine(desc, this.isCentered);
    this.HideLabel()
}
;
GUIMessageResultWin.prototype.ShowLabel = function(text) {
    this.OnWinLineHide();
    var l = this.isCentered ? this.labelCentered : this.label;
    l.text = text;
    l.gameObject.SetActive(true)
}
;
GUIMessageResultWin.prototype.HideLabel = function() {
    this.label.gameObject.SetActive(false);
    this.labelCentered.gameObject.SetActive(false)
}
;
GUIMessageResultWin.prototype.ComputeText = function(amount, multipliers, subject, usePaysText) {
    var ret = [];
    if (subject != null)
        ret.push(subject);
    if (usePaysText)
        ret.push(this.localized_Pays.text);
    if (multipliers != null) {
        var totalMultiplier = 1;
        for (var i = 0; i < multipliers.length; i++)
            totalMultiplier *= multipliers[i];
        if (totalMultiplier > 1) {
            ret.push(this.FormatValue(amount / totalMultiplier));
            for (var i = 0; i < multipliers.length; i++)
                if (multipliers[i] > 1) {
                    ret.push("x");
                    ret.push(String(multipliers[i]))
                }
            ret.push("=")
        }
    }
    ret.push(this.FormatValue(amount));
    return ret.join(" ")
}
;
GUIMessageResultWin.prototype.FormatValue = function(value) {
    if (this.WinLineHasCoins())
        return String(CoinManager.ConvertMoneyToCoins(value));
    if (this.formatOptions == null)
        this.formatOptions = new FormatOptions;
    return LocaleManager.FormatValue(value, this.formatOptions)
}
;
goog.require("UHT.Engine");
CoinsAndCashDisplayer.prototype = Object.create(Component.prototype);
CoinsAndCashDisplayer.prototype.constructor = CoinsAndCashDisplayer;
function CoinsAndCashDisplayer() {
    Component.call(this);
    this.cashGameObjects = null;
    this.hiddenWhenCashIsVisible = null;
    this.coinsGameObjects = null;
    this.hiddenWhenCoinsAreVisible = null
}
CoinsAndCashDisplayer.prototype.UpdateDisplay = function(showCash, showCoins) {
    var i = 0;
    for (i = 0; i < this.cashGameObjects.length; i++)
        this.cashGameObjects[i].SetActive(showCash);
    for (i = 0; i < this.hiddenWhenCashIsVisible.length; i++)
        this.hiddenWhenCashIsVisible[i].SetActive(!showCash);
    for (i = 0; i < this.coinsGameObjects.length; i++)
        this.coinsGameObjects[i].SetActive(showCoins);
    for (i = 0; i < this.hiddenWhenCoinsAreVisible.length; i++)
        this.hiddenWhenCoinsAreVisible[i].SetActive(!showCoins)
}
;
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
MessageController.prototype = Object.create(XTLink.prototype);
MessageController.prototype.constructor = MessageController;
function MessageController() {
    XTLink.call(this);
    this.rq = null;
    this.hasFeatureWonText = true;
    this.dynamicContentNormal = null;
    this.dynamicContentAutoplay = null;
    this.dynamicContentFreeSpins = null;
    this.dynamicContentFreeSpinsMysteryScatter = null;
    this.dynamicContentBonusRounds = null;
    this.dynamicContentBonusRoundsAutoplay = null;
    this.msg_RandomSpin = null;
    this.showMsgRandomSpinAfterWin = false;
    this.msg_ResultWin = null;
    this.messagesResultWin = null;
    this.useMessagesResultWin = false;
    this.msg_ResultTeaser = null;
    this.msg_ResultBeforeWinIsDisplayed = null;
    this.LocalizedSpinMessages = null;
    this.LocalizedResultTeaserMessages = null;
    this.event_Win = null;
    this.event_BigWin = null;
    this.event_Reset = null;
    this.winDisplayedContainers = null;
    this.mysteryScatterSymbolHolder = null;
    this.mysteryScatterScaleFactor = 1;
    this.freeSpinsFeatureCompleted = [];
    this.bonusGameFeatureCompleted = [];
    this.internalState = VSGameState.Invalid;
    this.coinValueChanged = false;
    this.requestToUpdateDisplayedWinInUICame = false
}
MessageController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_MysteryScatterSymbol_Show, this.OnMysteryScatterSymbolShow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_MysteryScatterSymbol_Hide, this.OnMysteryScatterSymbolHide, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_CoinValueChanged, this.OnCoinValueChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI, this.OnRequestToUpdateDisplayedWinInUI, this)
}
;
MessageController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.HasGUIMessageBeforeWinCount, false)
}
;
MessageController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this);
    XT.UnregisterCallbackEvent(this.OnMysteryScatterSymbolShow, this);
    XT.UnregisterCallbackEvent(this.OnMysteryScatterSymbolHide, this);
    XT.UnregisterCallbackEvent(this.OnCoinValueChanged, this);
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this);
    XT.UnregisterCallbackEvent(this.OnRequestToUpdateDisplayedWinInUI, this)
}
;
MessageController.prototype.OnGUIInit = function() {
    this.msg_RandomSpin.Init(this.GetListOfMessages(this.LocalizedSpinMessages, InterfaceVars.GUIMessage_RandomSpin));
    this.msg_ResultTeaser.Init(this.GetListOfMessages(this.LocalizedResultTeaserMessages, InterfaceVars.GUIMessage_RandomResultTeaser));
    if (Globals.isMini) {
        this.msg_RandomSpin.label.anchorX = 0;
        this.msg_ResultTeaser.label.anchorX = 0
    }
}
;
MessageController.prototype.GetListOfMessages = function(labels, varName) {
    var ret = [];
    for (var i = 0; i < labels.length; i++)
        ret.push(labels[i].text);
    XT.SetObject(varName, ret);
    return ret
}
;
MessageController.prototype.ChangeToState = function(newState) {
    var sameState = this.internalState == newState;
    this.internalState = newState;
    if (!sameState)
        this.HideAllMessages();
    this.event_Reset.Start();
    this.UpdateDynamicContent(true);
    switch (this.internalState) {
    case VSGameState.Spin:
    case VSGameState.SpinAutoplay:
    case VSGameState.SpinFreeSpins:
    case VSGameState.SpinBonusRounds:
    case VSGameState.SpinBonusRoundsAutoplay:
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(.5));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HideWin,null,this));
        if (this.showMsgRandomSpinAfterWin && this.IsWinDisplayed())
            this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.ShowMessage,this.msg_RandomSpin,this));
        else
            this.ShowMessage(this.msg_RandomSpin);
        this.rq.StartRoutines();
        this.requestToUpdateDisplayedWinInUICame = false;
        break;
    case VSGameState.Result:
    case VSGameState.ResultAutoplay:
    case VSGameState.ResultBonusRounds:
    case VSGameState.ResultBonusRoundsAutoplay:
    case VSGameState.ResultFreeSpins:
    case VSGameState.ResultFreeSpinsPrepare:
    case VSGameState.ResultPrepareForBonus:
        this.UpdateWinDisplayedState();
        if (this.requestToUpdateDisplayedWinInUICame)
            this.OnRequestToUpdateDisplayedWinInUI();
        var isBonusRounds = this.internalState == VSGameState.ResultBonusRounds || this.internalState == VSGameState.ResultBonusRoundsAutoplay;
        if (VSGameStateManager.GetPreviousState() == VSGameState.ResultFreeSpins && newState != VSGameStateManager.GetPreviousState()) {
            this.InternalSetActive(this.freeSpinsFeatureCompleted, !isBonusRounds);
            this.InternalSetActive(this.bonusGameFeatureCompleted, false);
            this.HideMessage(this.msg_ResultTeaser)
        }
        if (VSGameStateManager.GetPreviousState() == VSGameState.Bonus) {
            this.InternalSetActive(this.bonusGameFeatureCompleted, !isBonusRounds);
            this.InternalSetActive(this.freeSpinsFeatureCompleted, false);
            this.HideMessage(this.msg_ResultTeaser)
        }
        break;
    case VSGameState.Bonus:
    case VSGameState.Gamble:
    case VSGameState.GambleCustom:
    case VSGameState.FSBG:
    case VSGameState.Invalid:
        this.requestToUpdateDisplayedWinInUICame = false;
        break
    }
}
;
MessageController.prototype.InternalSetActive = function(arr, active) {
    for (var i = 0; i < arr.length; i++)
        arr[i].SetActive(active)
}
;
MessageController.prototype.ShowMessage = function(param) {
    var m = param;
    m.Show()
}
;
MessageController.prototype.HideMessage = function(param) {
    var m = param;
    m.Hide()
}
;
MessageController.prototype.UpdateDynamicContent = function(param) {
    var visible = param;
    switch (this.internalState) {
    case VSGameState.Spin:
    case VSGameState.Result:
    case VSGameState.ResultFreeSpinsPrepare:
    case VSGameState.ResultPrepareForBonus:
        this.InternalSetActive(this.dynamicContentNormal, visible);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        break;
    case VSGameState.SpinAutoplay:
    case VSGameState.ResultAutoplay:
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentAutoplay, visible);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        break;
    case VSGameState.SpinFreeSpins:
    case VSGameState.ResultFreeSpins:
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        if (XT.GetObject(Vars.ReceivedFreeSpinsResponse).MysteryScatter == null) {
            this.InternalSetActive(this.dynamicContentFreeSpins, visible);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false)
        } else {
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, visible)
        }
        break;
    case VSGameState.SpinBonusRounds:
    case VSGameState.ResultBonusRounds:
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, visible);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        break;
    case VSGameState.SpinBonusRoundsAutoplay:
    case VSGameState.ResultBonusRoundsAutoplay:
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, visible);
        break;
    default:
        break
    }
}
;
MessageController.prototype.IsWinDisplayed = function() {
    var win = 0;
    if (this.internalState == VSGameState.ResultFreeSpins)
        win = XT.GetDouble(Vars.FreeSpinsLastWinDisplayed);
    else
        win = XT.GetDouble(Vars.SpinCycleWinDisplayed);
    return win > 1E-4
}
;
MessageController.prototype.UpdateWinDisplayedState = function() {
    var b = this.IsWinDisplayed();
    this.UpdateDisplayForWinContainers(b, b && !this.coinValueChanged)
}
;
MessageController.prototype.HideWin = function(param) {
    if (this.internalState == VSGameState.Spin || this.internalState == VSGameState.SpinAutoplay || this.internalState == VSGameState.SpinFreeSpins)
        this.UpdateDisplayForWinContainers(false, false)
}
;
MessageController.prototype.OnSpinStarted = function() {
    this.coinValueChanged = false
}
;
MessageController.prototype.OnCoinValueChanged = function() {
    if (this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds) {
        this.coinValueChanged = true;
        var isWin = this.IsWinDisplayed();
        this.UpdateDisplayForWinContainers(isWin, false);
        if (isWin)
            this.HideAllMessages()
    }
}
;
MessageController.prototype.UpdateDisplayForWinContainers = function(showCash, showCoins) {
    for (var i = 0; i < this.winDisplayedContainers.length; i++)
        this.winDisplayedContainers[i].UpdateDisplay(showCash, showCoins)
}
;
MessageController.prototype.OnRequestToUpdateDisplayedWinInUI = function() {
    this.requestToUpdateDisplayedWinInUICame = true;
    if (this.gameObject.activeInHierarchy) {
        this.UpdateWinDisplayedState();
        if (this.IsWinDisplayed()) {
            var isFS = this.internalState == VSGameState.ResultFreeSpinsPrepare;
            var isBonus = this.internalState == VSGameState.ResultPrepareForBonus;
            if (this.useMessagesResultWin)
                for (var i = 0; i < this.messagesResultWin.length; ++i) {
                    this.messagesResultWin[i].SetSpecialFlags(isBonus && this.hasFeatureWonText, isFS && this.hasFeatureWonText);
                    this.ShowMessage(this.messagesResultWin[i])
                }
            else {
                this.msg_ResultWin.SetSpecialFlags(isBonus && this.hasFeatureWonText, isFS && this.hasFeatureWonText);
                this.ShowMessage(this.msg_ResultWin)
            }
            this.HideMessage(this.msg_ResultTeaser);
            if (XT.GetInt(Vars.BigWinLevel) == 0) {
                var i = Random.Range(0, this.event_Win.length);
                this.event_Win[i].Start()
            } else
                this.event_BigWin.Start()
        } else {
            if (this.useMessagesResultWin)
                for (var i = 0; i < this.messagesResultWin.length; ++i)
                    this.HideMessage(this.messagesResultWin[i]);
            else
                this.HideMessage(this.msg_ResultWin);
            if (this.internalState != VSGameState.ResultFreeSpins && this.internalState != VSGameState.ResultFreeSpinsPrepare && this.internalState != VSGameState.ResultAutoplay)
                this.ShowMessage(this.msg_ResultTeaser);
            else
                this.HideMessage(this.msg_ResultTeaser)
        }
    }
}
;
MessageController.prototype.HideAllMessages = function() {
    this.rq.StopRoutines();
    this.msg_RandomSpin.Hide();
    this.msg_ResultTeaser.Hide();
    this.msg_ResultBeforeWinIsDisplayed.Hide();
    if (this.useMessagesResultWin)
        for (var i = 0; i < this.messagesResultWin.length; ++i)
            this.messagesResultWin[i].Hide();
    else
        this.msg_ResultWin.Hide();
    this.InternalSetActive(this.freeSpinsFeatureCompleted, false);
    this.InternalSetActive(this.bonusGameFeatureCompleted, false)
}
;
MessageController.prototype.OnMysteryScatterSymbolHide = function() {
    if (this.mysteryScatterSymbolHolder != null) {
        var mss = XT.GetObject(Vars.MysteryScatterSymbol_GameObject);
        if (mss == null) {
            this.mysteryScatterSymbolHolder.SetActive(false);
            return
        }
        var mssHolder = XT.GetObject(Vars.MysteryScatterSymbol_ParentGameObject);
        mss.transform.SetParent(mssHolder.transform, false)
    }
}
;
MessageController.prototype.OnMysteryScatterSymbolShow = function() {
    if (this.mysteryScatterSymbolHolder != null) {
        var mss = XT.GetObject(Vars.MysteryScatterSymbol_GameObject);
        mss.transform.localScale(this.mysteryScatterScaleFactor, this.mysteryScatterScaleFactor, 1);
        mss.transform.SetParent(this.mysteryScatterSymbolHolder.transform, false)
    }
}
;
goog.require("UHT.Engine");
goog.require("UHT.InterfaceUtils");
InterfaceController.prototype = Object.create(XTLink.prototype);
InterfaceController.prototype.constructor = InterfaceController;
function InterfaceController() {
    XTLink.call(this);
    this.settingsBtns = null;
    this.autoplayBtn = null;
    this.autoplayStopBtn = null;
    this.betBtn = null;
    this.gambleButton = null;
    this.hiddenPaytableBtn = null;
    this.payTableBtn = null;
    this.betHiddenBtn = null;
    this.betUpBtn = null;
    this.betDownBtn = null;
    this.spinBtn = null;
    this.stopBtn = null;
    this.dynamicContentNormal = null;
    this.dynamicContentFreeSpins = null;
    this.dynamicContentAutoplay = null;
    this.dynamicContentFreeSpinsMysteryScatter = null;
    this.dynamicContentBonusRounds = null;
    this.dynamicContentBonusRoundsAutoplay = null;
    this.settingsWindow = null;
    this.autoplayWindow = null;
    this.betsWindow = null;
    this.buttons_resultFSWithGamble = null;
    this.buttons_resultFSWithoutGamble = null;
    this.toggledInHiddenMode = null;
    this.toggledInInterfaceGamble = null;
    this.visibleInSpecialFeatures = null;
    this.fsMultiplierToggles = [];
    this.toggledOnHideWin = [];
    this.visibleIfGameHasLines = null;
    this.visibleIfGameHasWays = null;
    this.rq = null;
    this.messageController = null;
    this.balanceParent = null;
    this.bonusBalanceParent = null;
    this.internalState = VSGameState.Invalid;
    this.currentOpenedWindow = InterfaceController.WindowTypes.None;
    this.betChangeAllowed = false
}
InterfaceController.AutoplayState = {
    Normal: 0,
    Pressed: 1,
    Stop: 2
};
InterfaceController.WindowTypes = {
    None: 0,
    Settings: 1,
    Autoplay: 2,
    Bets: 3,
    Paytable: 4
};
InterfaceController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.IsMobileGUI, false)
}
;
InterfaceController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Pressed_PaytableClosed, this.OnRequestToClosePaytable, this);
    XT.RegisterCallbackBool(Vars.MinBetAndCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.MaxBetAndCoinValueReached, this.OnBetStateUpdated, this);
    XT.RegisterCallbackBool(Vars.CanSpin, this.OnCanSpinChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_EnableGambleButton, this.OnEnableGambleButton, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_DisableGambleButton, this.OnDisableGambleButton, this);
    XT.RegisterCallbackEvent(InterfaceVars.Evt_DataToCode_CloseAllInterfaceWindows, this.CloseCurrentOpenedWindow, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this);
    XT.RegisterCallbackDouble(Vars.BonusBalance, this.UpdateBalanceContent, this)
}
;
InterfaceController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this);
    XT.UnregisterCallbackEvent(this.OnRequestToClosePaytable, this);
    XT.UnregisterCallbackBool(this.OnBetStateUpdated, this);
    XT.UnregisterCallbackEvent(this.OnEnableGambleButton, this);
    XT.UnregisterCallbackEvent(this.OnDisableGambleButton, this);
    XT.UnregisterCallbackEvent(this.OnVSGameStateChanged, this);
    XT.UnregisterCallbackDouble(this.UpdateBalanceContent, this)
}
;
InterfaceController.prototype.OnVSGameStateChanged = function() {
    this.ChangeState(VSGameStateManager.GetState())
}
;
InterfaceController.prototype.Pressed_Settings_Open = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Settings, true)
}
;
InterfaceController.prototype.Pressed_Settings_Close = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Settings, false)
}
;
InterfaceController.prototype.Pressed_TotalBet_Open = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Bets, true)
}
;
InterfaceController.prototype.Pressed_TotalBet_Close = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Bets, false)
}
;
InterfaceController.prototype.Pressed_Autoplay_Open = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Autoplay, true)
}
;
InterfaceController.prototype.Pressed_Autoplay_Close = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Autoplay, false)
}
;
InterfaceController.prototype.Pressed_Paytable_Open = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Paytable, true)
}
;
InterfaceController.prototype.Pressed_Paytable_Close = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Paytable, false)
}
;
InterfaceController.prototype.OnRequestToClosePaytable = function() {
    this.UpdateWindows(InterfaceController.WindowTypes.Paytable, false)
}
;
InterfaceController.prototype.Pressed_AutoplayStart = function() {
    this.CloseCurrentOpenedWindow()
}
;
InterfaceController.prototype.Pressed_BetSelect = function() {
    this.CloseCurrentOpenedWindow()
}
;
InterfaceController.prototype.OnBetStateUpdated = function(unused) {
    if (this.betChangeAllowed)
        this.UpdateBetIncDecButtons(true)
}
;
InterfaceController.prototype.Pressed_Balance = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_OpenCashier)
}
;
InterfaceController.prototype.Pressed_Home = function() {
    XT.TriggerEvent(Vars.Evt_ToServer_CloseGame)
}
;
InterfaceController.prototype.Pressed_SkipScreens = function() {
    XT.SetBool(Vars.Autoplay_SkipScreens, !XT.GetBool(Vars.Autoplay_SkipScreens))
}
;
InterfaceController.prototype.OnGUIInit = function() {
    var b = XT.GetBool(Vars.CanGamble_Spin);
    this.gambleButton.SetActive(b);
    var b_fs = XT.GetBool(Vars.CanGamble_FreeSpin);
    this.buttons_resultFSWithGamble.SetActive(b_fs);
    this.buttons_resultFSWithoutGamble.SetActive(!b_fs);
    var hasWays = XT.GetBool(Vars.GameHasWaysInsteadOfLines);
    this.InternalSetActive(this.visibleIfGameHasLines, !hasWays);
    this.InternalSetActive(this.visibleIfGameHasWays, hasWays);
    this.ChangeState(VSGameState.Invalid)
}
;
InterfaceController.prototype.ChangeState = function(newState) {
    this.internalState = newState;
    var isMisteryScatter = false;
    var isDuringFS = false;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr != null) {
        isMisteryScatter = fsr.MysteryScatter != null;
        isDuringFS = fsr.IsFreeSpin
    }
    this.rq.StopRoutines();
    if (this.internalState == VSGameState.Spin || this.internalState == VSGameState.SpinAutoplay || this.internalState == VSGameState.SpinFreeSpins || this.internalState == VSGameState.SpinBonusRounds || this.internalState == VSGameState.SpinBonusRoundsAutoplay) {
        this.rq.AddRoutineQueueItem(new RQIWaitForSeconds(.5));
        this.rq.AddRoutineQueueItem(new RQITriggerCallback(this.HideWin,null,this));
        this.rq.StartRoutines()
    }
    switch (newState) {
    case VSGameState.Spin:
        this.CloseCurrentOpenedWindow();
        this.UpdateBetBtns(false);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, true);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, false);
        this.messageController.ChangeToState(VSGameState.Spin);
        break;
    case VSGameState.SpinAutoplay:
        this.UpdateBetBtns(false);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, true);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Stop, true);
        this.messageController.ChangeToState(VSGameState.SpinAutoplay);
        break;
    case VSGameState.SpinFreeSpins:
        this.UpdateBetBtns(false);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(true);
        this.InternalSetActive(this.dynamicContentNormal, false);
        if (isMisteryScatter) {
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, isDuringFS)
        } else {
            this.InternalSetActive(this.dynamicContentFreeSpins, isDuringFS);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false)
        }
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, false);
        this.messageController.ChangeToState(VSGameState.SpinFreeSpins);
        break;
    case VSGameState.SpinBonusRounds:
        this.CloseCurrentOpenedWindow();
        this.UpdateBetBtns(false);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, true);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, false);
        this.messageController.ChangeToState(VSGameState.SpinBonusRounds);
        break;
    case VSGameState.SpinBonusRoundsAutoplay:
        this.UpdateBetBtns(false);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, true);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Stop, true);
        this.messageController.ChangeToState(VSGameState.SpinBonusRoundsAutoplay);
        break;
    case VSGameState.Result:
        var canSpin = this.InternalCanSpin();
        this.gambleButton.SetActive(XT.GetBool(Vars.CanGamble_Spin));
        this.UpdateBetBtns(canSpin);
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.InternalSetActive(this.toggledInInterfaceGamble, true);
        this.spinBtn.SetActive(canSpin);
        this.stopBtn.SetActive(!canSpin);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, true);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, canSpin);
        this.messageController.ChangeToState(VSGameState.Result);
        break;
    case VSGameState.ResultPrepareForBonus:
        this.UpdateBetBtns(false);
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, true);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, false);
        this.messageController.ChangeToState(VSGameState.ResultPrepareForBonus);
        break;
    case VSGameState.ResultAutoplay:
        this.gambleButton.SetActive(XT.GetBool(Vars.CanGamble_Spin));
        this.UpdateBetBtns(false);
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.InternalSetActive(this.toggledInInterfaceGamble, true);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, true);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Stop, true);
        this.messageController.ChangeToState(VSGameState.ResultAutoplay);
        break;
    case VSGameState.ResultFreeSpinsPrepare:
        this.UpdateBetBtns(false);
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.InternalSetActive(this.toggledInInterfaceGamble, true);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, true);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, false);
        this.messageController.ChangeToState(VSGameState.ResultFreeSpinsPrepare);
        break;
    case VSGameState.ResultFreeSpins:
        this.UpdateBetBtns(false);
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.InternalSetActive(this.toggledInInterfaceGamble, true);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(true);
        this.InternalSetActive(this.dynamicContentNormal, false);
        if (isMisteryScatter) {
            this.InternalSetActive(this.dynamicContentFreeSpins, false);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, isDuringFS)
        } else {
            this.InternalSetActive(this.dynamicContentFreeSpins, isDuringFS);
            this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false)
        }
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, false);
        this.messageController.ChangeToState(VSGameState.ResultFreeSpins);
        break;
    case VSGameState.ResultBonusRounds:
        this.gambleButton.SetActive(false);
        this.UpdateBetBtns(false);
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.InternalSetActive(this.toggledInInterfaceGamble, true);
        var canSpin = this.InternalCanSpin();
        this.spinBtn.SetActive(canSpin);
        this.stopBtn.SetActive(!canSpin);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, true);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, false);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, canSpin);
        this.messageController.ChangeToState(VSGameState.ResultBonusRounds);
        break;
    case VSGameState.ResultBonusRoundsAutoplay:
        this.gambleButton.SetActive(false);
        this.UpdateBetBtns(false);
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.InternalSetActive(this.toggledInInterfaceGamble, true);
        this.spinBtn.SetActive(false);
        this.stopBtn.SetActive(true);
        this.ToggleFSMultiplier(false);
        this.InternalSetActive(this.dynamicContentNormal, false);
        this.InternalSetActive(this.dynamicContentFreeSpins, false);
        this.InternalSetActive(this.dynamicContentFreeSpinsMysteryScatter, false);
        this.InternalSetActive(this.dynamicContentAutoplay, false);
        this.InternalSetActive(this.dynamicContentBonusRounds, false);
        this.InternalSetActive(this.dynamicContentBonusRoundsAutoplay, true);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Stop, true);
        this.messageController.ChangeToState(VSGameState.ResultBonusRoundsAutoplay);
        break;
    case VSGameState.Bonus:
        this.ToggleFSMultiplier(isDuringFS);
        this.CloseCurrentOpenedWindow();
        this.InternalSetActive(this.toggledInHiddenMode, false);
        this.InternalSetActive(this.visibleInSpecialFeatures, true);
        this.messageController.ChangeToState(VSGameState.Bonus);
        break;
    case VSGameState.Gamble:
        this.ToggleFSMultiplier(false);
        this.CloseCurrentOpenedWindow();
        this.InternalSetActive(this.toggledInHiddenMode, true);
        this.InternalSetActive(this.visibleInSpecialFeatures, false);
        this.InternalSetActive(this.toggledInInterfaceGamble, false);
        this.messageController.ChangeToState(VSGameState.Gamble);
        break;
    case VSGameState.GambleCustom:
        this.ToggleFSMultiplier(false);
        this.CloseCurrentOpenedWindow();
        this.InternalSetActive(this.toggledInHiddenMode, false);
        this.InternalSetActive(this.visibleInSpecialFeatures, true);
        this.messageController.ChangeToState(VSGameState.GambleCustom);
        break;
    case VSGameState.FSBG:
        this.ToggleFSMultiplier(false);
        this.CloseCurrentOpenedWindow();
        this.InternalSetActive(this.toggledInHiddenMode, false);
        this.InternalSetActive(this.visibleInSpecialFeatures, true);
        this.messageController.ChangeToState(VSGameState.FSBG);
        break;
    default:
    case VSGameState.Invalid:
        this.ToggleFSMultiplier(false);
        this.CloseCurrentOpenedWindow();
        this.InternalSetActive(this.toggledInHiddenMode, false);
        this.InternalSetActive(this.visibleInSpecialFeatures, true);
        this.messageController.ChangeToState(VSGameState.Invalid);
        break
    }
}
;
InterfaceController.prototype.InternalSetActive = function(arr, active) {
    for (var i = 0; i < arr.length; ++i)
        arr[i].SetActive(active)
}
;
InterfaceController.prototype.UpdateAutoplayButtons = function(newState, enabled) {
    switch (newState) {
    case InterfaceController.AutoplayState.Normal:
        this.autoplayBtn.opened.SetActive(false);
        this.autoplayBtn.closed.SetActive(true);
        var be = this.autoplayBtn.closed.GetComponent(ButtonEnabler);
        if (enabled)
            be.EnableButton();
        else
            be.DisableButton();
        this.autoplayStopBtn.SetActive(false);
        break;
    case InterfaceController.AutoplayState.Pressed:
        this.autoplayBtn.opened.SetActive(true);
        this.autoplayBtn.closed.SetActive(false);
        this.autoplayStopBtn.SetActive(false);
        break;
    case InterfaceController.AutoplayState.Stop:
        this.autoplayBtn.opened.SetActive(false);
        this.autoplayBtn.closed.SetActive(false);
        this.autoplayStopBtn.SetActive(true);
        break
    }
}
;
InterfaceController.prototype.CloseCurrentOpenedWindow = function() {
    if (this.currentOpenedWindow != InterfaceController.WindowTypes.None) {
        this.ShowHideWindow(this.currentOpenedWindow, false);
        this.currentOpenedWindow = InterfaceController.WindowTypes.None
    }
}
;
InterfaceController.prototype.UpdateWindows = function(type, open) {
    if (this.currentOpenedWindow != InterfaceController.WindowTypes.None && this.currentOpenedWindow != type) {
        this.ShowHideWindow(this.currentOpenedWindow, false);
        this.currentOpenedWindow = InterfaceController.WindowTypes.None
    }
    if (type != InterfaceController.WindowTypes.None) {
        this.ShowHideWindow(type, open);
        this.currentOpenedWindow = open ? type : InterfaceController.WindowTypes.None;
        if (open)
            XT.TriggerEvent(InterfaceVars.Evt_CodeToData_InterfaceWindowOpen)
    }
}
;
InterfaceController.prototype.ShowHideWindow = function(type, open) {
    switch (type) {
    case InterfaceController.WindowTypes.Settings:
        if (open)
            this.settingsWindow.ShowMenuWindow(this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds);
        else
            this.settingsWindow.HideMenuWindow();
        for (var i = 0; i < this.settingsBtns.length; ++i) {
            this.settingsBtns[i].opened.SetActive(open);
            this.settingsBtns[i].closed.SetActive(!open)
        }
        break;
    case InterfaceController.WindowTypes.Autoplay:
        var instantAutoplay = XT.GetBool(Vars.InstantAutoplay);
        if (!instantAutoplay)
            this.autoplayWindow.SetActive(open);
        if (open) {
            if (instantAutoplay) {
                this.autoplayWindow.GetComponentsInChildren(AutoplayControllerAdvanced, true)[0].StartAutoplayPressed();
                this.Pressed_AutoplayStart()
            }
            this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Pressed, true)
        } else
            this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, true);
        break;
    case InterfaceController.WindowTypes.Bets:
        if (open)
            this.betsWindow.ShowBetsWindow();
        else
            this.betsWindow.HideBetsWindow();
        this.betBtn.opened.SetActive(open);
        this.betBtn.closed.SetActive(!open);
        this.betHiddenBtn.opened.SetActive(open);
        this.betHiddenBtn.closed.SetActive(!open);
        break;
    case InterfaceController.WindowTypes.Paytable:
        if (open)
            XT.TriggerEvent(Vars.Evt_Internal_PaytableOpen);
        else
            XT.TriggerEvent(Vars.Evt_Internal_PaytableClose);
        this.payTableBtn.opened.SetActive(open);
        this.payTableBtn.closed.SetActive(!open);
        this.hiddenPaytableBtn.opened.SetActive(open);
        this.hiddenPaytableBtn.closed.SetActive(!open);
        break;
    default:
        console.error("Interface: Trying to start / close an invalid window");
        break
    }
}
;
InterfaceController.prototype.UpdateBetBtns = function(enabled) {
    this.betChangeAllowed = enabled;
    var be = this.betBtn.closed.GetComponent(ButtonEnabler);
    if (enabled)
        be.EnableButton();
    else
        be.DisableButton();
    this.betHiddenBtn.closed.SetActive(enabled);
    this.betsWindow.UpdateBetButtons(enabled);
    this.UpdateBetIncDecButtons(enabled)
}
;
InterfaceController.prototype.UpdateBetIncDecButtons = function(enabled) {
    var beUp = this.betUpBtn.GetComponent(ButtonEnabler);
    var beDown = this.betDownBtn.GetComponent(ButtonEnabler);
    if (enabled) {
        var bMin = XT.GetBool(Vars.MinBetAndCoinValueReached);
        if (bMin)
            beDown.DisableButton();
        else
            beDown.EnableButton();
        var bMax = XT.GetBool(Vars.MaxBetAndCoinValueReached);
        if (bMax)
            beUp.DisableButton();
        else
            beUp.EnableButton()
    } else {
        beUp.DisableButton();
        beDown.DisableButton()
    }
}
;
InterfaceController.prototype.OnDisableGambleButton = function() {
    var be = this.gambleButton.GetComponentsInChildren(ButtonEnabler, true);
    if (be != null)
        for (var i = 0; i < be.length; i++)
            be[i].DisableButton()
}
;
InterfaceController.prototype.OnEnableGambleButton = function() {
    var be = this.gambleButton.GetComponentsInChildren(ButtonEnabler, true);
    if (be != null)
        for (var i = 0; i < be.length; i++)
            be[i].EnableButton()
}
;
InterfaceController.prototype.OnCanSpinChanged = function() {
    if (this.internalState == VSGameState.Result || this.internalState == VSGameState.ResultBonusRounds) {
        var canSpin = this.InternalCanSpin();
        this.spinBtn.SetActive(canSpin);
        this.stopBtn.SetActive(!canSpin);
        this.UpdateBetBtns(canSpin && this.internalState == VSGameState.Result);
        this.UpdateAutoplayButtons(InterfaceController.AutoplayState.Normal, canSpin)
    }
}
;
InterfaceController.prototype.HideWin = function(param) {
    for (var i = 0; i < this.toggledOnHideWin.length; i++)
        this.toggledOnHideWin[i].WinIsHidden()
}
;
InterfaceController.prototype.InternalCanSpin = function() {
    var respinData = XT.GetObject(Vars.RespinData);
    var canSpin = XT.GetBool(Vars.CanSpin) && (respinData == null || respinData.IsDone || XT.GetBool(Vars.ManualRespin));
    return canSpin
}
;
InterfaceController.prototype.ToggleFSMultiplier = function(isFreeSpin) {
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    var multiplier = isFreeSpin ? Math.floor(fsr.TotalMultiplier) : 1;
    for (var i = 0; i < this.fsMultiplierToggles.length; i++)
        this.fsMultiplierToggles[i].FSMultiplierChanged(multiplier)
}
;
InterfaceController.prototype.UpdateBalanceContent = function(value) {
    var balance = _number.otod(value);
    if (XT.GetBool(Vars.Jurisdiction_SplitBalance)) {
        this.balanceParent.SetActive(balance <= 0);
        this.bonusBalanceParent.SetActive(balance > 0)
    }
}
;
goog.require("UHT.Engine");
SmallWinSkipper.prototype = Object.create(XTLink.prototype);
SmallWinSkipper.prototype.constructor = SmallWinSkipper;
function SmallWinSkipper() {
    XTLink.call(this)
}
SmallWinSkipper.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnWinCount, this)
}
;
SmallWinSkipper.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnWinCount, this)
}
;
SmallWinSkipper.prototype.OnWinCount = function(b) {
    var shouldBeActive = b && !XT.GetBool(Vars.WaitInResultForBigWin);
    this.gameObject.SetActive(shouldBeActive)
}
;
SmallWinSkipper.prototype.SkipSmallWinCount = function() {
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    this.gameObject.SetActive(false)
}
;
goog.require("UHT.Component");
goog.require("UHT.AudioClip");
var WhenToPlay = {
    OnClick: 0,
    OnHover: 1,
    Custom: 2
};
var PlayMode = {
    OneShot: 0,
    Loop: 1
};
SoundPlayer.prototype = Object.create(Component.prototype);
SoundPlayer.prototype.constructor = SoundPlayer;
function SoundPlayer() {
    Component.call(this);
    this.audioClip = null;
    this.whenToPlay = WhenToPlay.Custom;
    this.playMode = PlayMode.OneShot;
    this.playOnlyIfEnabled = false;
    this.muteBackgroundMusic = false;
    this.handler = -1;
    this.canPlayHoverSound = true
}
SoundPlayer.prototype.PlaySound = function() {
    this.InternalPlayClip(this.audioClip)
}
;
SoundPlayer.prototype.StopPlayingSound = function() {
    if (this.handler >= 0) {
        var mgr = XT.GetObject(Vars.SoundManagerObject);
        var args = {
            handle: this.handler
        };
        mgr.StopLoopingSound(args);
        this.handler = args.handle;
        if (this.muteBackgroundMusic)
            mgr.UnmuteMusic()
    }
}
;
SoundPlayer.prototype.OnClick = function() {
    if (this.gameObject.collider == null || !this.gameObject.collider.enabled)
        return;
    if (this.whenToPlay == WhenToPlay.OnClick)
        this.InternalPlayClip(this.audioClip)
}
;
SoundPlayer.prototype.OnHover = function(isOver) {
    if (isOver == false)
        this.canPlayHoverSound = true;
    if (this.gameObject.collider == null || !this.gameObject.collider.enabled || !isOver)
        return;
    if (this.whenToPlay == WhenToPlay.OnHover && this.canPlayHoverSound) {
        this.InternalPlayClip(this.audioClip);
        this.canPlayHoverSound = false
    }
}
;
SoundPlayer.prototype.InternalPlayClip = function(clip) {
    if (this.playOnlyIfEnabled && !this.gameObject.activeInHierarchy)
        return;
    var mgr = XT.GetObject(Vars.SoundManagerObject);
    if (this.muteBackgroundMusic)
        mgr.MuteMusic();
    switch (this.playMode) {
    case PlayMode.OneShot:
        mgr.PlaySimple(clip);
        break;
    case PlayMode.Loop:
        this.handler = mgr.PlayLooping(clip);
        break;
    default:
        break
    }
}
;
goog.require("UHT.Engine");
LabelGroupScaler.prototype = Object.create(Component.prototype);
LabelGroupScaler.prototype.constructor = LabelGroupScaler;
function LabelGroupScaler() {
    Component.call(this);
    this.target = null;
    this.sources = null
}
LabelGroupScaler.prototype.Update = function() {
    var minScale = this.sources[0].localScale().x;
    for (var i = 1; i < this.sources.length; ++i)
        if (this.sources[i].localScale().x < minScale)
            minScale = this.sources[i].localScale().x;
    if (minScale != this.target.GetNormalizedTime())
        this.target.Sample(UHTMath.clamp(minScale, 0, 1))
}
;
goog.require("UHT.Engine");
MultipleLabelAnchor.prototype = Object.create(Component.prototype);
MultipleLabelAnchor.prototype.constructor = MultipleLabelAnchor;
function MultipleLabelAnchor() {
    Component.call(this);
    this.labels = null;
    this.spacing = 0;
    this.alignment = MultipleLabelAnchor.Alignment.Right;
    this.maxWidth = 0;
    this.ignoreInactiveLabels = false;
    this.cachedLabelWidths = [];
    this.cachedActiveState = [];
    this.mustForcedNextUpdate = false;
    this.initialScale = null
}
MultipleLabelAnchor.prototype.scriptUpdatePriority = 8;
MultipleLabelAnchor.Alignment = {
    Right: 0,
    Left: 1,
    Center: 2
};
MultipleLabelAnchor.prototype.Start = function() {
    this.initialScale = this.gameObject.transform.localScale();
    for (var i = 0; i < this.labels.length; i++) {
        this.cachedLabelWidths.push(-69);
        this.cachedActiveState.push(false)
    }
}
;
MultipleLabelAnchor.prototype.Update = function() {
    var i = 0;
    var needUpdate = false;
    for (i = 0; i < this.labels.length; i++) {
        var w = this.labels[i].GetWidth();
        if (w != this.cachedLabelWidths[i] || this.ignoreInactiveLabels && this.labels[i].gameObject.activeInHierarchy != this.cachedActiveState[i]) {
            this.cachedLabelWidths[i] = w;
            this.cachedActiveState[i] = this.labels[i].gameObject.activeInHierarchy;
            needUpdate = true
        }
    }
    if (needUpdate || this.mustForcedNextUpdate) {
        this.mustForcedNextUpdate = false;
        var offset = 0;
        var p;
        for (i = 0; i < this.labels.length; i++) {
            if (this.ignoreInactiveLabels && this.cachedActiveState[i] == false)
                continue;
            var x = (this.alignment == MultipleLabelAnchor.Alignment.Left ? -1 : 1) * offset;
            p = this.labels[i].gameObject.transform.localPosition();
            this.labels[i].gameObject.transform.localPosition(x, p.y, p.z);
            offset += this.cachedLabelWidths[i] + this.spacing
        }
        var size = offset - this.spacing;
        if (this.alignment == MultipleLabelAnchor.Alignment.Center) {
            var halfSize = size / 2;
            for (i = 0; i < this.labels.length; i++) {
                if (this.ignoreInactiveLabels && this.cachedActiveState[i] == false)
                    continue;
                var xOffset = this.labels[i].gameObject.transform.localPosition().x - halfSize;
                p = this.labels[i].gameObject.transform.localPosition();
                this.labels[i].gameObject.transform.localPosition(xOffset, p.y, p.z)
            }
        }
        if (this.maxWidth > 0 && size > this.maxWidth) {
            var scale = this.maxWidth / size;
            this.gameObject.transform.localScale(scale, scale, this.initialScale.z)
        } else
            this.gameObject.transform.localScale(this.initialScale)
    }
}
;
MultipleLabelAnchor.prototype.ForceNextUpdate = function() {
    this.mustForcedNextUpdate = true
}
;
MultipleLabelAnchor.prototype.DiscardCache = function() {
    this.cachedLabelWidths.splice(0);
    this.cachedActiveState.splice(0);
    for (var i = 0; i < this.labels.length; i++) {
        this.cachedLabelWidths.push(-69);
        this.cachedActiveState.push(false)
    }
}
;
goog.require("UHT.XTLink");
CoinsSwitcher.prototype = Object.create(XTLink.prototype);
CoinsSwitcher.prototype.constructor = CoinsSwitcher;
function CoinsSwitcher() {
    XTLink.call(this)
}
CoinsSwitcher.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.FromServer_AllowCoins, this.OnAllowCoinsChanged, this)
}
;
CoinsSwitcher.prototype.OnAllowCoinsChanged = function(allow) {
    this.gameObject.GetComponent(Collider).enabled = allow
}
;
CoinsSwitcher.prototype.OnPress = function(isPressed) {
    if (isPressed) {
        XT.SetBool(Vars.HasCoins, !XT.GetBool(Vars.HasCoins));
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
    }
}
;
goog.require("UHT.Engine");
goog.require("UHT.GUIMessageBase");
GUIMessageTurboSpin.prototype = Object.create(GUIMessageBase.prototype);
GUIMessageTurboSpin.prototype.constructor = GUIMessageTurboSpin;
function GUIMessageTurboSpin() {
    GUIMessageBase.call(this);
    this.localized_SpaceToTurboSpin = null;
    this.turboSpinUsageCount = 0
}
GUIMessageTurboSpin.randomMessagesBetweenTurboSpinMessage = 0;
GUIMessageTurboSpin.prototype.Show = function() {
    if (XT.GetBool(Vars.ContinuousSpin))
        XT.SetInt(Vars.DesktopTurboSpinMessageShowCount, XT.GetInt(Vars.DesktopTurboSpinMessageShowCount) + 1);
    var ok = false;
    if (XT.GetInt(Vars.DesktopTurboSpinMessageShowCount) <= this.turboSpinUsageCount && GUIMessageTurboSpin.randomMessagesBetweenTurboSpinMessage % 3 == 0) {
        this.label.text = this.localized_SpaceToTurboSpin.text;
        ok = true
    }
    if (!ok && this.messages != null && this.messages.length > 0) {
        var i = Random.Range(0, this.messages.length);
        this.label.text = this.messages[i]
    }
    GUIMessageTurboSpin.randomMessagesBetweenTurboSpinMessage++;
    this.gameObject.SetActive(true)
}
;
GUIMessageTurboSpin.prototype.Hide = function() {
    this.gameObject.SetActive(false)
}
;
goog.require("UHT.XTLink");
ValueControlledActive.prototype = Object.create(XTLink.prototype);
ValueControlledActive.prototype.constructor = ValueControlledActive;
function ValueControlledActive() {
    XTLink.call(this);
    this.vdVariable = null;
    this.visibleWhenPositive = null;
    this.visibleWhenZeroOrNegative = null
}
ValueControlledActive.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackDouble(this.vdVariable.variable.name, this.OnTargetValueChanged, this)
}
;
ValueControlledActive.prototype.OnTargetValueChanged = function(value) {
    var positive = value > 0;
    for (var i = 0; i < this.visibleWhenPositive.length; ++i)
        this.visibleWhenPositive[i].SetActive(positive);
    for (var i = 0; i < this.visibleWhenZeroOrNegative.length; ++i)
        this.visibleWhenZeroOrNegative[i].SetActive(!positive)
}
;
goog.require("UHT.Engine");
HasCoinsSwitcher.prototype = Object.create(XTLink.prototype);
HasCoinsSwitcher.prototype.constructor = HasCoinsSwitcher;
function HasCoinsSwitcher() {
    XTLink.call(this);
    this.visibleIfCoins = null;
    this.visibleIfNoCoins = null
}
HasCoinsSwitcher.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.HasCoins, this.OnHasCoinsChanged, this)
}
;
HasCoinsSwitcher.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnHasCoinsChanged, this)
}
;
HasCoinsSwitcher.prototype.OnHasCoinsChanged = function(newVal) {
    var i = 0;
    for (i = 0; i < this.visibleIfCoins.length; i++)
        if (this.visibleIfCoins[i] != null)
            this.visibleIfCoins[i].SetActive(newVal);
    for (i = 0; i < this.visibleIfNoCoins.length; i++)
        if (this.visibleIfNoCoins[i] != null)
            this.visibleIfNoCoins[i].SetActive(!newVal)
}
;
goog.require("UHT.Engine");
IdleSpinCounter.prototype = Object.create(XTLink.prototype);
IdleSpinCounter.prototype.constructor = IdleSpinCounter;
function IdleSpinCounter() {
    XTLink.call(this);
    this.activeState = null;
    this.idleState = null;
    this.timeToIdleState = 5;
    this.timer = 0;
    this.isIdle = false;
    this.isCounting = false
}
IdleSpinCounter.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StartIdleSpinCounter, this.StartCounter, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopIdleSpinCounter, this.StopCounter, this)
}
;
IdleSpinCounter.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.IdleStateActive, false)
}
;
IdleSpinCounter.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.StartCounter, this);
    XT.UnregisterCallbackEvent(this.StopCounter, this)
}
;
IdleSpinCounter.prototype.StopCounter = function() {
    if (this.isIdle) {
        if (this.idleState.IsRunning())
            this.idleState.Stop();
        this.activeState.Start()
    }
    this.isIdle = false;
    this.isCounting = false;
    XT.SetBool(Vars.IdleStateActive, false);
    XT.TriggerEvent(Vars.Evt_Internal_ExitIdleSpinState)
}
;
IdleSpinCounter.prototype.StartCounter = function() {
    if (!this.isCounting) {
        this.isCounting = true;
        this.timer = 0
    }
}
;
IdleSpinCounter.prototype.Update = function() {
    if (this.isCounting && !this.isIdle) {
        this.timer += Time.deltaTime;
        if (this.timer >= this.timeToIdleState) {
            XT.SetBool(Vars.IdleStateActive, true);
            XT.TriggerEvent(Vars.Evt_Internal_EnterIdleSpinState);
            this.isIdle = true;
            this.idleState.Start()
        }
    }
}
;
goog.require("UHT.Engine");
OrderedCATStarter.prototype = Object.create(Component.prototype);
OrderedCATStarter.prototype.constructor = OrderedCATStarter;
function OrderedCATStarter() {
    Component.call(this);
    this.cats = null;
    this.resetAutomatically = false;
    this.nextCAT = 0
}
OrderedCATStarter.prototype.StartMextCAT = function() {
    if (this.resetAutomatically && this.nextCAT >= this.cats.length)
        this.ResetCATCount();
    if (this.nextCAT >= this.cats.length || this.cats[this.nextCAT].cat == null)
        return;
    this.cats[this.nextCAT].Start();
    this.nextCAT++
}
;
OrderedCATStarter.prototype.ResetCATCount = function() {
    this.nextCAT = 0
}
;
goog.require("UHT.UHTEngine");
var V3AnimationProperty = {
    Position: 0,
    LocalScale: 1,
    LocalPosition: 2,
    LocalRotation: 3
};
var V3AnimationMode = {
    Default: 0,
    Loop: 1
};
var V3AnimatorAction = {
    NoAction: 0,
    Play: 1,
    PlayReversed: 2
};
var V3AnimatorUpdateMethod = {
    Update: 0,
    LateUpdate: 1
};
V3Animator.prototype = Object.create(Component.prototype);
V3Animator.prototype.constructor = V3Animator;
function V3Animator() {
    Component.call(this);
    this.target = null;
    this.from = null;
    this.to = null;
    this.animationTime = 0;
    this.animationCurve = AnimationCurve.linear(0, 0, 1, 1);
    this.animationProperty = V3AnimationProperty.Position;
    this.animationMode = V3AnimationMode.Default;
    this.staticFromAndTo = false;
    this.staticFrom = false;
    this.staticTo = false;
    this.animationCurveX = null;
    this.animationCurveY = null;
    this.useXAndYCurves = false;
    this.onEnable = V3AnimatorAction.NoAction;
    this.updateOn = V3AnimatorUpdateMethod.Update;
    this.callWhenFinished = null;
    this.unclamped = false;
    this.useMultipleTargets = false;
    this.multipleTargets = null;
    this.useManualFrom = false;
    this.manualFrom = null;
    this.useManualTo = false;
    this.manualTo = null;
    this.affectX = true;
    this.affectY = true;
    this.affectZ = true;
    this.v3From = null;
    this.v3To = null;
    this.currentTime = 0;
    this.isPlaying = false;
    this.isReversed = false;
    this.isStuck = false;
    this.stickTime = 0
}
V3Animator.prototype.Play = function() {
    this.currentTime = 0;
    this.isPlaying = true;
    this.isReversed = false;
    this.GetFromAndTo()
}
;
V3Animator.prototype.PlayReversed = function() {
    this.currentTime = 0;
    this.isPlaying = true;
    this.isReversed = true;
    this.GetFromAndTo()
}
;
V3Animator.prototype.Stop = function() {
    this.currentTime = 0;
    this.isPlaying = false
}
;
V3Animator.prototype.Pause = function() {
    this.isPlaying = false
}
;
V3Animator.prototype.IsPlaying = function() {
    return this.isPlaying
}
;
V3Animator.prototype.Sample = function(normalizedTime) {
    this.isPlaying = false;
    this.isReversed = false;
    this.GetFromAndTo();
    this.UpdateValue(Number(normalizedTime))
}
;
V3Animator.prototype.Stick = function(normalizedTime) {
    this.isStuck = true;
    this.stickTime = Number(normalizedTime)
}
;
V3Animator.prototype.Unstick = function() {
    this.isStuck = false
}
;
V3Animator.prototype.InternalUpdate = function() {
    if (this.isPlaying) {
        this.GetFromAndTo(true);
        this.UpdateValue(this.currentTime / this.animationTime);
        if (this.currentTime >= this.animationTime)
            if (this.animationMode == V3AnimationMode.Default) {
                this.isPlaying = false;
                if (this.callWhenFinished != null)
                    this.callWhenFinished.Start()
            } else if (this.animationMode == V3AnimationMode.Loop) {
                this.currentTime -= this.animationTime;
                this.UpdateValue(this.currentTime / this.animationTime)
            }
        this.currentTime += Time.deltaTime
    }
    if (this.isStuck) {
        this.GetFromAndTo(true);
        this.UpdateValue(this.stickTime)
    }
}
;
V3Animator.prototype.GetFromAndTo = function(onlyNonStatic) {
    var v3F = UHTMath.Vector3.zero;
    var v3T = UHTMath.Vector3.zero;
    switch (this.animationProperty) {
    case V3AnimationProperty.Position:
        if (!this.useManualFrom)
            v3F = this.from.transform.position();
        if (!this.useManualTo)
            v3T = this.to.transform.position();
        break;
    case V3AnimationProperty.LocalPosition:
        if (!this.useManualFrom)
            v3F = this.from.transform.localPosition();
        if (!this.useManualTo)
            v3T = this.to.transform.localPosition();
        break;
    case V3AnimationProperty.LocalRotation:
        if (!this.useManualFrom)
            v3F = this.from.transform.localEulerAngles();
        if (!this.useManualTo)
            v3T = this.to.transform.localEulerAngles();
        break;
    case V3AnimationProperty.LocalScale:
        if (!this.useManualFrom)
            v3F = this.from.transform.localScale();
        if (!this.useManualTo)
            v3T = this.to.transform.localScale();
        break
    }
    onlyNonStatic = Boolean(onlyNonStatic);
    if (this.useManualFrom)
        this.v3From = this.manualFrom;
    else if (!onlyNonStatic || !this.staticFrom)
        this.v3From = v3F;
    if (this.useManualTo)
        this.v3To = this.manualTo;
    else if (!onlyNonStatic || !this.staticTo)
        this.v3To = v3T
}
;
V3Animator.prototype.UpdateValue = function(normalizedTime) {
    var time = UHTMath.clamp(normalizedTime, 0, 1);
    if (this.isReversed)
        time = 1 - time;
    time *= this.animationCurve.keys[this.animationCurve.keys.length - 1].time;
    var curveX = this.animationCurve;
    var curveY = this.animationCurve;
    var curveZ = this.animationCurve;
    if (this.useXAndYCurves) {
        curveX = this.animationCurveX;
        curveY = this.animationCurveY
    }
    var x;
    var y;
    var z;
    if (this.unclamped) {
        x = UHTMath.lerpUnclamped(this.v3From.x, this.v3To.x, curveX.Evaluate(time));
        y = UHTMath.lerpUnclamped(this.v3From.y, this.v3To.y, curveY.Evaluate(time));
        z = UHTMath.lerpUnclamped(this.v3From.z, this.v3To.z, curveZ.Evaluate(time))
    } else {
        x = UHTMath.lerp(this.v3From.x, this.v3To.x, curveX.Evaluate(time));
        y = UHTMath.lerp(this.v3From.y, this.v3To.y, curveY.Evaluate(time));
        z = UHTMath.lerp(this.v3From.z, this.v3To.z, curveZ.Evaluate(time))
    }
    var value = new UHTMath.Vector3(x,y,z);
    switch (this.animationProperty) {
    case V3AnimationProperty.Position:
        if (!this.useMultipleTargets)
            this.target.transform.position(this.GetValue(this.target.transform.position(), value));
        else
            for (var i = 0; i < this.multipleTargets.length; ++i)
                this.multipleTargets[i].transform.position(this.GetValue(this.multipleTargets[i].transform.position(), value));
        break;
    case V3AnimationProperty.LocalPosition:
        if (!this.useMultipleTargets)
            this.target.transform.localPosition(this.GetValue(this.target.transform.localPosition(), value));
        else
            for (var i = 0; i < this.multipleTargets.length; ++i)
                this.multipleTargets[i].transform.localPosition(this.GetValue(this.multipleTargets[i].transform.localPosition(), value));
        break;
    case V3AnimationProperty.LocalRotation:
        if (!this.useMultipleTargets)
            this.target.transform.localRotation(UHTMath.Quaternion.euler(this.GetValue(this.target.transform.localEulerAngles(), value)));
        else
            for (var i = 0; i < this.multipleTargets.length; ++i)
                this.multipleTargets[i].transform.localRotation(UHTMath.Quaternion.euler(this.GetValue(this.multipleTargets[i].transform.localEulerAngles(), value)));
        break;
    case V3AnimationProperty.LocalScale:
        if (!this.useMultipleTargets)
            this.target.transform.localScale(this.GetValue(this.target.transform.localScale(), value));
        else
            for (var i = 0; i < this.multipleTargets.length; ++i)
                this.multipleTargets[i].transform.localScale(this.GetValue(this.multipleTargets[i].transform.localScale(), value));
        break
    }
}
;
V3Animator.prototype.OnEnable = function() {
    switch (this.onEnable) {
    case V3AnimatorAction.Play:
        this.Play();
        break;
    case V3AnimatorAction.PlayReversed:
        this.PlayReversed();
        break
    }
}
;
V3Animator.prototype.Update = function() {
    if (this.updateOn == V3AnimatorUpdateMethod.Update)
        this.InternalUpdate()
}
;
V3Animator.prototype.LateUpdate = function() {
    if (this.updateOn == V3AnimatorUpdateMethod.LateUpdate)
        this.InternalUpdate()
}
;
V3Animator.prototype.Awake = function() {
    if (this.staticFromAndTo)
        this.staticFrom = this.staticTo = this.staticFromAndTo
}
;
V3Animator.prototype.GetValue = function(curValue, newValue) {
    var x = this.affectX ? newValue.x : curValue.x;
    var y = this.affectY ? newValue.y : curValue.y;
    var z = this.affectZ ? newValue.z : curValue.z;
    return new UHTMath.Vector3(x,y,z)
}
;
goog.require("UHT.XTLink");
function SoundSliderVolume2Cat() {
    this.value = 0;
    this.cat = null
}
SoundSlider.prototype = Object.create(XTLink.prototype);
SoundSlider.prototype.constructor = SoundSlider;
function SoundSlider() {
    XTLink.call(this);
    this.thumb = null;
    this.localPositionMin = null;
    this.localPositionMax = null;
    this.scrollWheelMovement = null;
    this.scrollWheels = null;
    this.labels = null;
    this.bars = null;
    this.catMute = null;
    this.catUnmute = null;
    this.catVolume = null;
    this.cachedCamera = null;
    this.prevThumbPos = new UHTMath.Vector3(-1,-1,-1);
    this.soundManagerInit = false;
    this.volumePercent = 0;
    this.mustUpdateVolume = false
}
SoundSlider.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Init_SoundManager, this.OnInitSoundManager, this, -1);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SoundStateChanged, this.OnSoundStateChanged, this)
}
;
SoundSlider.prototype.OnInitSoundManager = function() {
    this.thumb.limitPosition = true;
    this.thumb.useScrollWheel = true;
    this.thumb.localPositionLimitMin = this.localPositionMin;
    this.thumb.localPositionLimitMax = this.localPositionMax;
    this.thumb.scrollWheelMovement = this.scrollWheelMovement;
    for (var i = 0; i < this.scrollWheels.length; ++i) {
        this.scrollWheels[i].limitPosition = true;
        this.scrollWheels[i].useScrollWheel = true;
        this.scrollWheels[i].useOnlyScrollWheel = true;
        this.scrollWheels[i].localPositionLimitMin = this.localPositionMin;
        this.scrollWheels[i].localPositionLimitMax = this.localPositionMax;
        this.scrollWheels[i].scrollWheelMovement = this.scrollWheelMovement
    }
    this.UpdateVolume(XT.GetFloat(Vars.SoundVolume));
    this.OnSoundStateChanged()
}
;
SoundSlider.prototype.LateUpdate = function() {
    var thumbPos = this.thumb.target.localPosition();
    if (!thumbPos.equals(this.prevThumbPos))
        this.UpdateVolume((thumbPos.x - this.thumb.localPositionLimitMin.x) / (this.thumb.localPositionLimitMax.x - this.thumb.localPositionLimitMin.x));
    if (this.mustUpdateVolume)
        this.InternalUpdateVolume(XT.GetFloat(Vars.SoundVolume))
}
;
SoundSlider.prototype.InternalUpdateVolume = function(volume) {
    if (!SoundLoader.initialized) {
        this.mustUpdateVolume = true;
        return
    }
    createjs.Sound.setVolume(volume);
    this.mustUpdateVolume = false
}
;
SoundSlider.prototype.UpdateVolume = function(volume) {
    volume = UHTMath.clamp(volume, 1E-5, 1);
    this.InternalUpdateVolume(volume);
    this.volumePercent = Math.round(volume * 100);
    var text = String(this.volumePercent);
    for (var i = 0; i < this.labels.length; ++i)
        this.labels[i].text = text;
    var idx = 0;
    for (var i = 0; i < this.catVolume.length; ++i)
        if (this.volumePercent >= this.catVolume[i].value)
            idx = i;
    this.catVolume[idx].cat.Start();
    for (var i = 0; i < this.bars.length; ++i)
        this.bars[i].transform.localScale(new UHTMath.Vector3(volume,1,1));
    var thumbPos = UHTMath.Vector3.lerp(this.thumb.localPositionLimitMin, this.thumb.localPositionLimitMax, volume);
    this.thumb.target.localPosition(thumbPos);
    this.prevThumbPos = thumbPos;
    if (this.soundManagerInit) {
        var on = XT.GetObject(Vars.SoundState).gameSoundIsOn;
        if (on && this.volumePercent == 0 || !on && this.volumePercent > 0)
            XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
    }
    XT.SetFloat(Vars.SoundVolume, volume);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.soundManagerInit = true
}
;
SoundSlider.prototype.OnPress = function(pressed) {
    if (pressed) {
        if (this.cachedCamera == null)
            this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
        this.thumb.target.position(this.thumb.GetPosition(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition)))
    }
    this.thumb.OnPress(pressed)
}
;
SoundSlider.prototype.OnSoundStateChanged = function() {
    if (XT.GetObject(Vars.SoundState).gameSoundIsOn)
        this.catUnmute.Start();
    else
        this.catMute.Start()
}
;
SoundSlider.prototype.SoundButtonPressed = function() {
    if (!XT.GetObject(Vars.SoundState).gameSoundIsOn && this.volumePercent == 0)
        return;
    XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
}
;
goog.provide("UHT.SoundButtonControllerMobile");
goog.require("UHT.Engine");
SoundButtonControllerMobile.prototype = Object.create(XTLink.prototype);
SoundButtonControllerMobile.prototype.constructor = SoundButtonControllerMobile;
function SoundButtonControllerMobile() {
    XTLink.call(this);
    this.buttonOn = null;
    this.buttonOff = null;
    this.buttonDownload = null;
    this.waiting = null;
    this.mustUpdate = true;
    this.enableSoundsWhenReady = false
}
SoundButtonControllerMobile.buttonsUpdatedAfterDownload = false;
SoundButtonControllerMobile.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SoundStateChanged, this.OnSoundStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnSoundStateChanged, this)
}
;
SoundButtonControllerMobile.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnSoundStateChanged, this)
}
;
SoundButtonControllerMobile.prototype.OnSoundStateChanged = function() {
    if (UHTEngine.SoundsAreLoaded())
        this.InternalUpdateButtons()
}
;
SoundButtonControllerMobile.prototype.Start = function() {
    this.buttonOn.SetActive(false);
    this.buttonOff.SetActive(false);
    this.buttonDownload.SetActive(true);
    this.waiting.SetActive(false)
}
;
SoundButtonControllerMobile.prototype.Update = function() {
    if (UHTEngine.SoundsAreLoading() && !this.waiting.activeInHierarchy) {
        this.buttonDownload.SetActive(false);
        this.waiting.SetActive(true)
    } else if (UHTEngine.SoundsAreLoaded() && this.mustUpdate) {
        this.mustUpdate = false;
        this.waiting.SetActive(false);
        this.buttonDownload.SetActive(false);
        this.InternalUpdateButtons();
        SoundButtonControllerMobile.buttonsUpdatedAfterDownload = true
    }
}
;
SoundButtonControllerMobile.prototype.SoundOffButtonClicked = function() {
    XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
}
;
SoundButtonControllerMobile.prototype.SoundOnButtonClicked = function() {
    XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
}
;
SoundButtonControllerMobile.prototype.InternalUpdateButtons = function() {
    var sndState = XT.GetObject(Vars.SoundState);
    var bon = sndState.gameSoundIsOn;
    this.buttonOn.SetActive(bon);
    this.buttonOff.SetActive(!bon)
}
;
SoundButtonControllerMobile.prototype.SoundDownloadClicked = function() {
    UHTEngine.StartLoadingSounds();
    if (this.enableSoundsWhenReady)
        XT.SetBool(InterfaceVars.EnableSoundsWhenReady, true)
}
;
goog.require("UHT.Engine");
GameHistoryButton.prototype = Object.create(XTLink.prototype);
GameHistoryButton.prototype.constructor = GameHistoryButton;
function GameHistoryButton() {
    XTLink.call(this);
    this.wasTouchMove = false;
    this.touchStartHandler = null;
    this.touchMoveHandler = null;
    this.touchEndHandler = null
}
GameHistoryButton.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.HasGameHistory, this.OnValueChanged, this)
}
;
GameHistoryButton.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnValueChanged, this)
}
;
GameHistoryButton.prototype.OnValueChanged = function(newValue) {
    var b = this.gameObject.GetComponent(ButtonEnabler);
    if (newValue)
        b.EnableButton();
    else
        b.DisableButton()
}
;
GameHistoryButton.prototype.Awake = function() {
    if (createjs.BrowserDetect.isIOS) {
        this.touchStartHandler = new EventHandler(this,this.OnTouchStart);
        this.touchMoveHandler = new EventHandler(this,this.OnTouchMove);
        globalColliderInputManager.addEventHandler(ColliderEvent.ButtonDown, this.touchStartHandler);
        globalColliderInputManager.addEventHandler(ColliderEvent.MouseMove, this.touchMoveHandler)
    }
    this.touchEndHandler = new EventHandler(this,this.OnTouchEnd);
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, this.touchEndHandler);
    this.cachedCamera = Globals.GetCameraForObject(this.gameObject)
}
;
GameHistoryButton.prototype.OnTouchStart = function() {
    this.wasTouchMove = false
}
;
GameHistoryButton.prototype.OnTouchMove = function() {
    this.wasTouchMove = true
}
;
GameHistoryButton.prototype.OnTouchEnd = function() {
    if (this.gameObject.activeInHierarchy && XT.GetBool(Vars.HasGameHistory)) {
        var mask = new LayerMask;
        mask.mask = 1 << this.gameObject.layer;
        var c = globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask);
        if (!this.wasTouchMove && c == this.gameObject.collider)
            if (UHT_GAME_CONFIG["openHistoryInTab"])
                window.open(ServerOptions.gameHistory);
            else
                (new GameHistoryWindow).Open()
    }
}
;
function GameHistoryWindow() {
    this.root = null;
    this.btn = null;
    this.resizeHandler = null
}
GameHistoryWindow.prototype.CreateElement = function(tag, attributes, append) {
    var el = document.createElement(tag);
    for (var name in attributes)
        el.setAttribute(name, attributes[name]);
    if (append)
        document.body.appendChild(el);
    return el
}
;
GameHistoryWindow.prototype.Open = function() {
    var hw = this;
    var frame = hw.CreateElement("iframe", {
        "src": ServerOptions.gameHistory,
        "class": "history-frame",
        "frameborder": "0"
    }, false);
    hw.btn = hw.CreateElement("div", {
        "class": "history-button"
    }, true);
    hw.btn.addEventListener("click", function() {
        hw.Close()
    }, false);
    hw.root = hw.CreateElement("div", {
        "class": "history-root"
    }, true);
    hw.root.appendChild(frame);
    hw.resizeHandler = function() {
        hw.OnResize()
    }
    ;
    window.addEventListener("resize", hw.resizeHandler, true);
    hw.OnResize();
    hw.SetVisible(true)
}
;
GameHistoryWindow.prototype.Close = function() {
    this.SetVisible(false);
    document.body.removeChild(this.root);
    document.body.removeChild(this.btn);
    window.removeEventListener("resize", this.resizeHandler, false)
}
;
GameHistoryWindow.prototype.OnResize = function() {
    var width = 600;
    var height = 650;
    var zoom = 1;
    if (window.innerHeight / window.innerWidth > height / width)
        zoom = window.innerWidth / width;
    else
        zoom = window.innerHeight / height;
    var newStyle = "-moz-transform:scale(VAL);-webkit-transform:scale(VAL);-ms-transform:scale(VAL);-o-transform:scale(VAL);transform:scale(VAL)".replace(new RegExp("VAL","g"), String(zoom));
    this.root.setAttribute("style", newStyle);
    if (!UHT_DEVICE_TYPE.DESKTOP)
        this.btn.setAttribute("style", newStyle)
}
;
GameHistoryWindow.prototype.SetVisible = function(visible) {
    var doc = document.documentElement;
    var visibleClass = "history-visible";
    var newClass = String(doc.className).replace(new RegExp(visibleClass,"g"), "").replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
    if (visible)
        newClass = [newClass, visibleClass].join(" ");
    doc.className = newClass
}
;
goog.require("UHT.Engine");
JurisdictionPromoUrlButton.prototype = Object.create(XTLink.prototype);
JurisdictionPromoUrlButton.prototype.constructor = JurisdictionPromoUrlButton;
function JurisdictionPromoUrlButton() {
    XTLink.call(this);
    this.wasTouchMove = false;
    this.touchStartHandler = null;
    this.touchMoveHandler = null;
    this.touchEndHandler = null
}
JurisdictionPromoUrlButton.prototype.Awake = function() {
    if (createjs.BrowserDetect.isIOS) {
        this.touchStartHandler = new EventHandler(this,this.OnTouchStart);
        this.touchMoveHandler = new EventHandler(this,this.OnTouchMove);
        globalColliderInputManager.addEventHandler(ColliderEvent.ButtonDown, this.touchStartHandler);
        globalColliderInputManager.addEventHandler(ColliderEvent.MouseMove, this.touchMoveHandler)
    }
    this.touchEndHandler = new EventHandler(this,this.OnTouchEnd);
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, this.touchEndHandler);
    this.cachedCamera = Globals.GetCameraForObject(this.gameObject)
}
;
JurisdictionPromoUrlButton.prototype.OnTouchStart = function() {
    this.wasTouchMove = false
}
;
JurisdictionPromoUrlButton.prototype.OnTouchMove = function() {
    this.wasTouchMove = true
}
;
JurisdictionPromoUrlButton.prototype.OnTouchEnd = function() {
    if (this.gameObject.activeInHierarchy) {
        var mask = new LayerMask;
        mask.mask = 1 << this.gameObject.layer;
        var c = globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask);
        if (!this.wasTouchMove && c == this.gameObject.collider)
            window.open(ServerOptions.promotionurl)
    }
}
;
goog.require("UHT.Engine");
JurisdictionPromoUrl.prototype = Object.create(XTLink.prototype);
JurisdictionPromoUrl.prototype.constructor = JurisdictionPromoUrl;
function JurisdictionPromoUrl() {
    XTLink.call(this);
    this.mobile = false;
    this.newPos = null;
    this.newScale = null;
    this.settingWindows = []
}
JurisdictionPromoUrl.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_SettingsWindowOpened, this.OnShowPromo, this);
    XT.RegisterCallbackEvent(Vars.Evt_CodeToData_SettingsWindowClosed, this.OnHidePromo, this);
    this.settingWindows = [];
    if (this.mobile) {
        this.settingWindows.push(globalRuntime.sceneRoots[1].GetComponentsInChildren(MenuWindowControllerMobile, true)[0].gameObject);
        this.settingWindows.push(globalRuntime.sceneRoots[1].GetComponentsInChildren(MenuWindowControllerMobile, true)[1].gameObject)
    }
}
;
JurisdictionPromoUrl.prototype.OnShowPromo = function() {
    if (XT.GetBool(Vars.Jurisdiction_PromotionURL))
        if (ServerOptions.promotionurl != null)
            this.gameObject.SetActive(true)
}
;
JurisdictionPromoUrl.prototype.OnEnable = function() {
    if (this.mobile)
        for (var i = 0; i < this.settingWindows.length; i++)
            if (this.settingWindows[i].activeInHierarchy) {
                this.settingWindows[i].transform.localPosition(this.newPos);
                this.settingWindows[i].transform.localScale(this.newScale)
            }
}
;
JurisdictionPromoUrl.prototype.OnHidePromo = function() {
    this.gameObject.SetActive(false)
}
;
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
AutoplayTypeSwitcher.prototype = Object.create(XTLink.prototype);
AutoplayTypeSwitcher.prototype.constructor = AutoplayTypeSwitcher;
function AutoplayTypeSwitcher() {
    XTLink.call(this);
    this.simpleAutoplay = null;
    this.advancedAutoplay = null;
    this.isAllowed = true;
    this.isAdvanced = false
}
AutoplayTypeSwitcher.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.HasAdvancedAutoplay, this.OnAdvancedAutoplay, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_DisableAutoplay, this.OnDisableAutoplay, this)
}
;
AutoplayTypeSwitcher.prototype.OnAdvancedAutoplay = function(param) {
    this.isAdvanced = param;
    this.DoIt()
}
;
AutoplayTypeSwitcher.prototype.OnDisableAutoplay = function(param) {
    this.isAllowed = !param;
    this.DoIt()
}
;
AutoplayTypeSwitcher.prototype.DoIt = function() {
    this.simpleAutoplay.SetActive(!this.isAdvanced && this.isAllowed);
    this.advancedAutoplay.SetActive(this.isAdvanced && this.isAllowed)
}
;
goog.require("UHT.XTLink");
var SliderType = {
    Bool: 0,
    Int: 1,
    Double: 2,
    Float: 3
};
Slider.prototype = Object.create(XTLink.prototype);
Slider.prototype.constructor = Slider;
function Slider() {
    XTLink.call(this);
    this.thumb = null;
    this.thumbVisual = null;
    this.localPositionMin = null;
    this.localPositionMax = null;
    this.scrollWheelMovement = null;
    this.scrollWheels = null;
    this.valueDisplayers = null;
    this.bars = null;
    this.slicedBars = null;
    this.slicedBarsMinimumScale = null;
    this.colorAnimators = null;
    this.type = SliderType.Bool;
    this.minValue = 0;
    this.maxValue = 0;
    this.values = null;
    this.value = 0;
    this.valueIndex = 0;
    this.notifyWhenValueChanged = true;
    this.autocomplete = false;
    this.animator = null;
    this.animationTime = 0;
    this.inverseAnimationTime = 0;
    this.xtVariableName = "";
    this.xtVariableIsIndex = false;
    this.soundPlayer = null;
    this.playClickSoundOnRelease = false;
    this.cachedCamera = null;
    this.prevThumbPos = new UHTMath.Vector3(-1,-1,-1);
    this.isInit = false;
    this.internalValue = 0;
    this.autocompleteFrameCount = 0
}
Slider.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this, -1)
}
;
Slider.prototype.OnGameInit = function() {
    this.thumb.limitPosition = true;
    this.thumb.useScrollWheel = true;
    this.thumb.localPositionLimitMin = this.localPositionMin;
    this.thumb.localPositionLimitMax = this.localPositionMax;
    this.thumb.scrollWheelMovement = this.scrollWheelMovement;
    for (var i = 0; i < this.scrollWheels.length; ++i) {
        this.scrollWheels[i].limitPosition = true;
        this.scrollWheels[i].useScrollWheel = true;
        this.scrollWheels[i].useOnlyScrollWheel = true;
        this.scrollWheels[i].localPositionLimitMin = this.localPositionMin;
        this.scrollWheels[i].localPositionLimitMax = this.localPositionMax;
        this.scrollWheels[i].scrollWheelMovement = this.scrollWheelMovement
    }
    this.OnEnable();
    this.UpdateValue(this.value);
    this.isInit = true
}
;
Slider.prototype.OnEnable = function() {
    if (_string.IsNullOrEmpty(this.xtVariableName))
        return;
    var val = 0;
    if (this.type == SliderType.Bool)
        val = XT.GetBool(this.xtVariableName) ? 1 : 0;
    else if (this.type == SliderType.Int)
        val = XT.GetInt(this.xtVariableName);
    else if (this.type == SliderType.Float)
        val = XT.GetFloat(this.xtVariableName);
    else if (this.type == SliderType.Double)
        val = XT.GetDouble(this.xtVariableName);
    this.notifyWhenValueChanged = false;
    if (this.xtVariableIsIndex)
        this.SetValueIndex(val);
    else
        this.SetValue(val);
    this.notifyWhenValueChanged = true
}
;
Slider.prototype.LateUpdate = function() {
    if (!this.isInit)
        return;
    var thumbPos = this.thumb.target.localPosition();
    if (!thumbPos.equals(this.prevThumbPos))
        this.UpdateValue((thumbPos.x - this.thumb.localPositionLimitMin.x) / (this.thumb.localPositionLimitMax.x - this.thumb.localPositionLimitMin.x))
}
;
Slider.prototype.SetValue = function(param) {
    this.UpdateValue(UHTMath.inverseLerp(this.minValue, this.maxValue, param))
}
;
Slider.prototype.SetValueIndex = function(param) {
    this.UpdateValue(UHTMath.inverseLerp(0, this.values.length - 1, param))
}
;
Slider.prototype.UpdateValue = function(param) {
    var snapped = param;
    this.internalValue = param;
    if (this.type == SliderType.Bool)
        this.value = Math.round(param);
    else if (this.values.length > 0) {
        this.valueIndex = Math.round(UHTMath.lerp(0, this.values.length - 1, param));
        snapped = this.valueIndex / (this.values.length - 1);
        this.value = this.values[this.valueIndex]
    } else {
        this.value = UHTMath.lerp(this.minValue, this.maxValue, param);
        if (this.type == SliderType.Int)
            this.value = Math.round(this.value)
    }
    for (var i = 0; i < this.valueDisplayers.length; ++i) {
        this.valueDisplayers[i].callEventWhenValueChangedAllowed = this.notifyWhenValueChanged;
        this.valueDisplayers[i].SetValueManually(this.value)
    }
    for (var i = 0; i < this.bars.length; ++i)
        this.bars[i].transform.localScale(new UHTMath.Vector3(snapped,1,1));
    for (var i = 0; i < this.slicedBars.length; ++i)
        this.slicedBars[i].Sample(snapped > this.slicedBarsMinimumScale[i] ? snapped : this.slicedBarsMinimumScale[i]);
    for (var i = 0; i < this.colorAnimators.length; ++i)
        this.colorAnimators[i].Sample(snapped);
    var thumbPos = UHTMath.Vector3.lerp(this.thumb.localPositionLimitMin, this.thumb.localPositionLimitMax, param);
    this.thumb.target.localPosition(thumbPos);
    this.prevThumbPos = thumbPos;
    thumbPos = UHTMath.Vector3.lerp(this.thumb.localPositionLimitMin, this.thumb.localPositionLimitMax, snapped);
    this.thumbVisual.localPosition(thumbPos);
    if (!_string.IsNullOrEmpty(this.xtVariableName))
        if (this.type == SliderType.Bool)
            XT.SetBool(this.xtVariableName, this.value >= .5);
        else if (this.type == SliderType.Int)
            XT.SetInt(this.xtVariableName, this.value);
        else if (this.type == SliderType.Float)
            XT.SetFloat(this.xtVariableName, this.value);
        else if (this.type == SliderType.Double)
            XT.SetDouble(this.xtVariableName, this.value)
}
;
Slider.prototype.OnPress = function(pressed) {
    if (pressed) {
        if (this.cachedCamera == null)
            this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
        this.thumb.target.position(this.thumb.GetPosition(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition)))
    } else {
        this.Autocomplete();
        if (this.playClickSoundOnRelease)
            this.soundPlayer.OnClick()
    }
    this.thumb.OnPress(pressed)
}
;
Slider.prototype.Autocomplete = function() {
    if (this.autocomplete)
        if (this.type == SliderType.Bool) {
            var targetValue = this.internalValue >= .5 ? 1 : 0;
            if (targetValue != this.internalValue) {
                this.animator.manualTo = this.internalValue >= .5 ? this.thumb.localPositionLimitMax : this.thumb.localPositionLimitMin;
                this.animator.animationTime = this.animationTime * Math.abs(targetValue - this.internalValue);
                this.animator.Play()
            }
        }
    this.autocompleteFrameCount = Time.frameCount
}
;
Slider.prototype.InverseAutocomplete = function() {
    if (this.autocomplete && this.autocompleteFrameCount != Time.frameCount)
        if (this.type == SliderType.Bool) {
            var targetValue = this.internalValue >= .5 ? 0 : 1;
            if (targetValue != this.internalValue) {
                this.animator.manualTo = targetValue == 1 ? this.thumb.localPositionLimitMax : this.thumb.localPositionLimitMin;
                this.animator.animationTime = this.inverseAnimationTime * Math.abs(targetValue - this.internalValue);
                this.animator.Play()
            }
        }
}
;
goog.require("UHT.SoundButtonControllerMobile");
SoundButtonControllerMobileV10.prototype = Object.create(SoundButtonControllerMobile.prototype);
SoundButtonControllerMobileV10.prototype.constructor = SoundButtonControllerMobileV10;
function SoundButtonControllerMobileV10() {
    SoundButtonControllerMobile.call(this);
    this.musicSlider = null;
    this.effectsSlider = null;
    this.soundSlider = null;
    this.soundSliderContent = null
}
SoundButtonControllerMobileV10.prototype.OnEnable = function() {
    if (this.soundSlider != null) {
        this.soundSlider.notifyWhenValueChanged = false;
        this.soundSlider.SetValue(XT.GetObject(Vars.SoundState).gameSoundIsOn ? 1 : 0);
        this.soundSlider.notifyWhenValueChanged = true
    }
    if (this.musicSlider != null) {
        this.musicSlider.notifyWhenValueChanged = false;
        this.musicSlider.SetValue(XT.GetObject(Vars.SoundState).musicIsOn ? 1 : 0);
        this.musicSlider.notifyWhenValueChanged = true
    }
    if (this.effectsSlider != null) {
        this.effectsSlider.notifyWhenValueChanged = false;
        this.effectsSlider.SetValue(XT.GetObject(Vars.SoundState).soundFXIsOn ? 1 : 0);
        this.effectsSlider.notifyWhenValueChanged = true
    }
}
;
SoundButtonControllerMobileV10.prototype.Start = function() {
    SoundButtonControllerMobile.prototype.Start.call(this);
    if (this.soundSliderContent != null)
        this.soundSliderContent.SetActive(false)
}
;
SoundButtonControllerMobileV10.prototype.InternalUpdateButtons = function() {
    SoundButtonControllerMobile.prototype.InternalUpdateButtons.call(this);
    if (this.soundSliderContent != null)
        this.soundSliderContent.SetActive(true)
}
;
goog.require("UHT.Engine");
SkipIntroButtonController.prototype = Object.create(XTLink.prototype);
SkipIntroButtonController.prototype.constructor = SkipIntroButtonController;
function SkipIntroButtonController() {
    XTLink.call(this);
    this.buttonSkipToOn = null;
    this.buttonSkipToOff = null
}
SkipIntroButtonController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.ShouldDisplayIntro, this.UpdateState, this)
}
;
SkipIntroButtonController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.UpdateState, this)
}
;
SkipIntroButtonController.prototype.UpdateState = function(shouldDisplay) {
    this.buttonSkipToOff.SetActive(!shouldDisplay);
    this.buttonSkipToOn.SetActive(shouldDisplay)
}
;
SkipIntroButtonController.prototype.OnClick = function() {
    XT.SetBool(Vars.ShouldDisplayIntro, !XT.GetBool(Vars.ShouldDisplayIntro));
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
}
;
goog.require("UHT.Engine");
NoMoneyWindowController.prototype = Object.create(XTLink.prototype);
NoMoneyWindowController.prototype.constructor = NoMoneyWindowController;
function NoMoneyWindowController() {
    XTLink.call(this)
}
NoMoneyWindowController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdated, this.OnBalanceUpdated, this);
    XT.RegisterCallbackEvent(Vars.Evt_FromServer_BalanceUpdatedFromResult, this.OnBalanceUpdated, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_NotEnoughMoney_pressedOK, this.OnNoMoneyPressedOK, this)
}
;
NoMoneyWindowController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnBalanceUpdated, this)
}
;
NoMoneyWindowController.prototype.OnBalanceUpdated = function() {
    if (this.gameObject.activeSelf)
        if (CoinManager.GetNextTotalBet() <= XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived))
            XT.TriggerEvent(Vars.Evt_CodeToData_HideNoMoneyWindow)
}
;
NoMoneyWindowController.prototype.OnNoMoneyPressedOK = function() {
    XT.TriggerEvent(Vars.Evt_CodeToData_HideNoMoneyWindow);
    UHTInterfaceBOSS.PostMessage("openCashier")
}
;
goog.provide("UHT.AutoplayControllerMobile");
goog.require("UHT.XTLink");
AutoplayControllerMobile.prototype = Object.create(XTLink.prototype);
AutoplayControllerMobile.prototype.constructor = AutoplayControllerMobile;
function AutoplayControllerMobile() {
    XTLink.call(this);
    this.windowShow = null;
    this.windowHide = null;
    this.content = null;
    this.increaseAutoSpinsButton = null;
    this.decreaseAutoSpinsButton = null;
    this.startAutoplayButton = null;
    this.quickStartAutoplayButtons = null;
    this.selectSpinsLabel = null;
    this.autoplayStartAllowed = false;
    this.requestedAutoSpins = [10, 20, 30, 50, 70, 100, 500, 1E3]
}
AutoplayControllerMobile.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, 0)
}
;
AutoplayControllerMobile.prototype.ShowAutoplayWindow = function() {
    if (this.windowShow != null && this.windowShow.cat != null)
        this.windowShow.Start()
}
;
AutoplayControllerMobile.prototype.HideAutoplayWindow = function() {
    if (this.windowHide != null && this.windowHide.cat != null)
        this.windowHide.Start()
}
;
AutoplayControllerMobile.prototype.AllowAutoplay = function(allow) {
    this.autoplayStartAllowed = allow;
    this.UpdateAutoplaySelectionButtons()
}
;
AutoplayControllerMobile.prototype.UpdateAutospinsLabel = function() {
    this.selectSpinsLabel.text = this.requestedAutoSpins[XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex)]
}
;
AutoplayControllerMobile.prototype.IncreaseAutoSpins = function() {
    var currIndex = XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex);
    currIndex++;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, currIndex);
    this.UpdateAutoplaySelectionButtons();
    this.UpdateAutospinsLabel();
    this.SetNumberOfAutoSpins()
}
;
AutoplayControllerMobile.prototype.DecreaseAutoSpins = function() {
    var currIndex = XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex);
    currIndex--;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, currIndex);
    this.UpdateAutoplaySelectionButtons();
    this.UpdateAutospinsLabel();
    this.SetNumberOfAutoSpins()
}
;
AutoplayControllerMobile.prototype.SetNumberOfAutoSpins = function() {
    var xtbStartAutoplay = this.startAutoplayButton.GetComponent(XTButton);
    xtbStartAutoplay.paramValue = this.requestedAutoSpins[XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex)]
}
;
AutoplayControllerMobile.prototype.UpdateAutoplaySelectionButtons = function() {
    var beUp = this.increaseAutoSpinsButton.GetComponent(ButtonEnabler);
    var beDown = this.decreaseAutoSpinsButton.GetComponent(ButtonEnabler);
    var beStartAutoplay = this.startAutoplayButton.GetComponent(ButtonEnabler);
    var i;
    var beQuickStartAutoplay = [];
    for (i = 0; i < this.quickStartAutoplayButtons.length; i++)
        beQuickStartAutoplay.push(this.quickStartAutoplayButtons[i].GetComponent(ButtonEnabler));
    if (!this.autoplayStartAllowed) {
        beUp.DisableButton();
        beDown.DisableButton();
        beStartAutoplay.DisableButton();
        for (i = 0; i < beQuickStartAutoplay.length; i++)
            beQuickStartAutoplay[i].DisableButton();
        return
    }
    beStartAutoplay.EnableButton();
    for (i = 0; i < beQuickStartAutoplay.length; i++)
        beQuickStartAutoplay[i].EnableButton();
    if (XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex) <= 0)
        beDown.DisableButton();
    else
        beDown.EnableButton();
    if (XT.GetInt(InterfaceVars.SelectedAutoSpinsIndex) >= this.requestedAutoSpins.length - 1)
        beUp.DisableButton();
    else
        beUp.EnableButton()
}
;
AutoplayControllerMobile.prototype.UpdateAutoplayContent = function() {
    this.UpdateAutospinsLabel();
    this.UpdateAutoplaySelectionButtons();
    this.SetNumberOfAutoSpins()
}
;
goog.require("UHT.AutoplayControllerMobile");
AutoplayControllerMobileV10.prototype = Object.create(AutoplayControllerMobile.prototype);
AutoplayControllerMobileV10.prototype.constructor = AutoplayControllerMobileV10;
function AutoplayControllerMobileV10() {
    AutoplayControllerMobile.call(this);
    this.sliderSpins = null
}
AutoplayControllerMobileV10.prototype.ShowAutoplayWindow = function() {
    AutoplayControllerMobile.prototype.ShowAutoplayWindow.call(this);
    this.sliderSpins.SetValueIndex(5);
    this.SliderValueChanged()
}
;
AutoplayControllerMobileV10.prototype.UpdateAutoplaySelectionButtons = function() {
    var beStartAutoplay = this.startAutoplayButton.GetComponent(ButtonEnabler);
    var i;
    var beQuickStartAutoplay = [];
    for (i = 0; i < this.quickStartAutoplayButtons.length; i++)
        beQuickStartAutoplay.push(this.quickStartAutoplayButtons[i].GetComponent(ButtonEnabler));
    if (!this.autoplayStartAllowed) {
        beStartAutoplay.DisableButton();
        for (i = 0; i < beQuickStartAutoplay.length; i++)
            beQuickStartAutoplay[i].DisableButton();
        return
    }
    beStartAutoplay.EnableButton();
    for (i = 0; i < beQuickStartAutoplay.length; i++)
        beQuickStartAutoplay[i].EnableButton()
}
;
AutoplayControllerMobileV10.prototype.UpdateAutoplayContent = function() {
    this.UpdateAutoplaySelectionButtons();
    this.SetNumberOfAutoSpins()
}
;
AutoplayControllerMobileV10.prototype.SliderValueChanged = function() {
    var currIndex = this.sliderSpins.valueIndex;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndex, currIndex);
    this.SetNumberOfAutoSpins()
}
;
goog.require("UHT.Engine");
CheckBoxControl.prototype = Object.create(Component.prototype);
CheckBoxControl.prototype.constructor = CheckBoxControl;
function CheckBoxControl() {
    Component.call(this);
    this.checkedGO = null;
    this.uncheckedGO = null;
    this.checkedByDefault = false;
    this.isChecked = false;
    this.needsInit = true;
    this.allowChange = true
}
CheckBoxControl.prototype.Awake = function() {
    if (this.needsInit)
        this.SetValue(this.checkedByDefault)
}
;
CheckBoxControl.prototype.SetValue = function(newValue) {
    this.isChecked = newValue;
    this.needsInit = false;
    this.checkedGO.SetActive(newValue);
    this.uncheckedGO.SetActive(!newValue)
}
;
CheckBoxControl.prototype.GetValue = function() {
    return this.isChecked
}
;
CheckBoxControl.prototype.OnClick = function() {
    if (this.allowChange)
        this.SetValue(!this.isChecked)
}
;
CheckBoxControl.prototype.Check = function() {
    if (!this.isChecked)
        this.gameObject.SendMessage("OnClick")
}
;
goog.require("UHT.Engine");
MobileKeyboard.prototype = Object.create(Component.prototype);
MobileKeyboard.prototype.constructor = MobileKeyboard;
function MobileKeyboard() {
    Component.call(this);
    this.titleLabel = null;
    this.input = null;
    this.origInput = null;
    this.isHacked = false
}
MobileKeyboard.prototype.OnEnable = function() {
    if (!this.isHacked) {
        this.isHacked = true;
        this.input.validation = UIInput.Validation.Float;
        var zeroBtns = this.gameObject.transform.Find("Keys/0").GetComponentsInChildren(UIButton, true);
        var zeroBtn = null;
        for (var i = 0; i < zeroBtns.length; ++i)
            if (zeroBtns[i].target.gameObject.name == "Label") {
                zeroBtn = zeroBtns[i];
                break
            }
        var zeroMessageSender = zeroBtn.GetComponent(MessageSender);
        var xSprite = this.gameObject.transform.Find("Keys/Cancel/X/SpriteX").GetComponent(UISprite);
        xSprite.color = zeroBtn.color_normal;
        xSprite.width = 200;
        xSprite.height = 200;
        xSprite.spriteType = UISprite.Type.Filled;
        xSprite.fillDirection = UISprite.FillDirection.Custom;
        xSprite.fillAmountTop = .7;
        xSprite.fillAmountBottom = .4;
        xSprite.fillAmountLeft = .6;
        xSprite.fillAmountRight = .6;
        xSprite.SetSpriteName("menuIcon_info");
        xSprite.transform.localPosition(new UHTMath.Vector3(0,-50,0));
        xSprite.transform.parent.localPosition(UHTMath.Vector3.zero);
        xSprite.transform.parent.localScale(UHTMath.Vector3.one);
        var bgSprite = this.gameObject.transform.Find("Keys/Cancel/Bg/SpriteBG").GetComponent(UISprite);
        bgSprite.color = zeroBtn.color_normal;
        var cancelBtns = this.gameObject.transform.Find("Keys/Cancel").GetComponentsInChildren(UIButton, true);
        var cancelMessageData = new MessageData(zeroMessageSender.onClickEvents[0].eventReceiver,zeroMessageSender.onClickEvents[0].methodToCall,zeroMessageSender.onClickEvents[0].useParam,".");
        var cancelMessageSender = cancelBtns[0].gameObject.AddComponent("MessageSender");
        cancelMessageSender.onEnabledEvents = [];
        cancelMessageSender.animationEvents = [];
        cancelMessageSender.onClickEvents = [];
        cancelMessageSender.onClickEvents.push(cancelMessageData);
        for (var i = 0; i < cancelBtns.length; ++i) {
            if (cancelBtns[i].normal != "ContainerBorder") {
                cancelBtns[i].normal = xSprite.spriteName;
                cancelBtns[i].hover = xSprite.spriteName;
                cancelBtns[i].pressed = xSprite.spriteName;
                cancelBtns[i].disabled = xSprite.spriteName;
                cancelBtns[i].color_pressed = zeroBtn.color_pressed
            }
            cancelBtns[i].color_normal = zeroBtn.color_normal;
            cancelBtns[i].color_hover = zeroBtn.color_hover;
            if (cancelBtns[i].onClick != null)
                cancelBtns[i].onClick.splice(0)
        }
    }
}
;
MobileKeyboard.prototype.OnDisable = function() {
    this.gameObject.SetActive(false)
}
;
MobileKeyboard.prototype.ShowKeyboard = function(_label, _input) {
    this.gameObject.SetActive(true);
    this.titleLabel.text = _label.text;
    this.origInput = _input;
    this.input.SetValue([null, "", "0"].indexOf(_input.value) > -1 ? "" : _input.value);
    this.input.Select(true)
}
;
MobileKeyboard.prototype.CloseKeyboard = function() {
    this.gameObject.SetActive(false)
}
;
MobileKeyboard.prototype.ApplyAndCloseKeyboard = function() {
    this.gameObject.SetActive(false);
    this.origInput.SetValue(this.input.value)
}
;
goog.require("UHT.Engine");
MobileKeyboardStarter.prototype = Object.create(Component.prototype);
MobileKeyboardStarter.prototype.constructor = MobileKeyboardStarter;
function MobileKeyboardStarter() {
    Component.call(this);
    this.keyboard = null;
    this.titleLabel = null;
    this.input = null
}
MobileKeyboardStarter.prototype.OnClick = function() {
    this.keyboard.ShowKeyboard(this.titleLabel, this.input)
}
;
goog.provide("UHT.AutoplayControllerAdvanced");
goog.require("UHT.XTLink");
AutoplayControllerAdvanced.prototype = Object.create(XTLink.prototype);
AutoplayControllerAdvanced.prototype.constructor = AutoplayControllerAdvanced;
function AutoplayControllerAdvanced() {
    XTLink.call(this);
    this.startAutoplayButton = null;
    this.fastPlayToOn = null;
    this.fastPlayToOff = null;
    this.turboSpinToOn = null;
    this.turboSpinToOff = null;
    this.checkSpins = null;
    this.checkOnAnyWin = null;
    this.checkIfAnyFeature = null;
    this.checkIfSingleWin = null;
    this.inputWin = null;
    this.checkIfCashIncreases = null;
    this.inputCashIncrease = null;
    this.checkIfCashDecreases = null;
    this.inputCashDecrease = null;
    this.requestedAutoSpins = [10, 20, 30, 50, 70, 100];
    this.mallHacked = false;
    this.isCashDecreaseValid = true;
    this.wasCashDecreaseSelected = false;
    this.cashDecreaseValidColor = null;
    this.cashDecreasesUIButtons = null;
    this.cashDecreasesLabels = null;
    this.inputCashDecreaseSprite = null;
    this.startAutoplayButtonLabel = null;
    this.startAutoplayButtonSprite = null;
    this.startAutoplayUIButtons = null;
    this.startAutoplayUIButtonOnClick = null;
    this.cashDecreaseKeyboardStarter = null;
    this.validColor = null;
    this.validColorHover = null;
    this.validColorPressed = null;
    this.invalidColor = null;
    this.invalidColorHover = null;
    this.invalidColorPressed = null;
    this.startAutoplayInvalidColor = null
}
AutoplayControllerAdvanced.formatOptions = null;
AutoplayControllerAdvanced.layoutMode = LayoutManager.Mode.Invalid;
AutoplayControllerAdvanced.layoutSwitchedFrame = 0;
AutoplayControllerAdvanced.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayout, this.OnSwitchToLandscape, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWide, this.OnSwitchToLandscape, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToLandscapeLayoutWideFull, this.OnSwitchToLandscape, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayout, this.OnSwitchToPortrait, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPhone, this.OnSwitchToPortrait, this, -1);
    XT.RegisterCallbackEvent(LMVars.Evt_Internal_SwitchToPortraitLayoutIPad, this.OnSwitchToPortrait, this, -1)
}
;
AutoplayControllerAdvanced.prototype.XTInitVariablesAndEvents = function() {
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced, 3);
    XT.SetObject(Vars.AdvancedAutoplaySettings, new AdvancedAutoplaySettings)
}
;
AutoplayControllerAdvanced.prototype.OnEnable = function() {
    if (!this.mallHacked) {
        this.mallHacked = true;
        this.inputWin.validation = UIInput.Validation.Float;
        this.inputCashIncrease.validation = UIInput.Validation.Float;
        this.inputCashDecrease.validation = UIInput.Validation.Float;
        if (XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit)) {
            this.checkIfCashDecreases.SetValue(true);
            this.checkIfCashDecreases.allowChange = false;
            this.cashDecreaseValidColor = this.inputCashDecrease.activeTextColor;
            var self = this;
            this.inputCashDecrease.TextExtraHandler = function(value) {
                return self.ProcessCashDecreaseText(value)
            }
            ;
            this.cashDecreasesLabels = this.checkIfCashDecreases.GetComponentsInChildren(UILabel, true);
            this.cashDecreasesUIButtons = this.checkIfCashDecreases.GetComponentsInChildren(UIButton, true);
            this.inputCashDecreaseSprite = this.inputCashDecrease.gameObject.transform.Find("Background/Sprite").GetComponent(UISprite);
            this.cashDecreaseKeyboardStarter = this.inputCashDecrease.GetComponent(MobileKeyboardStarter);
            this.startAutoplayUIButtons = this.startAutoplayButton.GetComponents(UIButton);
            var startAPHandlersThis = [];
            var startAPHandlersOther = [];
            for (var i = 0; i < this.startAutoplayUIButtons.length; ++i) {
                var uib = this.startAutoplayUIButtons[i];
                for (var j = 0; j < uib.onClick.length; ++j)
                    if (uib.onClick[j].target == this)
                        startAPHandlersThis.push(uib.onClick[j]);
                    else
                        startAPHandlersOther.push(uib.onClick[j]);
                uib.onClick = []
            }
            this.startAutoplayUIButtons[0].onClick = startAPHandlersThis;
            this.startAutoplayUIButtonOnClick = startAPHandlersOther;
            this.startAutoplayButtonSprite = this.startAutoplayButton.GetComponent(UISprite);
            this.startAutoplayButtonLabel = this.startAutoplayButton.transform.parent.GetComponentInChildren(UILabel);
            this.validColor = this.RGBToColor(1, 1, 1);
            this.validColorHover = this.RGBToColor(.5294117647058824, .8823529411764706, .0705882352941176);
            this.validColorPressed = this.RGBToColor(.3058823529411765, .5372549019607843, .007843137254902);
            this.invalidColor = this.RGBToColor(1, 0, 0);
            this.invalidColorHover = this.RGBToColor(1, .5568627450980392, .5568627450980392);
            this.invalidColorPressed = this.RGBToColor(1, .1607843137254902, .1607843137254902);
            this.startAutoplayInvalidColor = this.RGBToColor(.4862745098039216, .4862745098039216, .4862745098039216)
        }
        var collider = this.GetComponent(Collider);
        if (collider != null) {
            var c = collider.center;
            collider.center = new UHTMath.Vector3(c.x,c.y,20);
            collider.UpdateCachedMembers()
        }
    }
    this.wasCashDecreaseSelected = XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit);
    if (AutoplayControllerAdvanced.layoutSwitchedFrame != Time.frameCount)
        XT.SetObject(Vars.AdvancedAutoplaySettings, new AdvancedAutoplaySettings);
    this.UpdateAutoplayContent()
}
;
AutoplayControllerAdvanced.prototype.SetAutoSpinsIndex = function(strValue) {
    var i = _number.otoi(strValue);
    if (i < 0 || i >= this.requestedAutoSpins.length)
        return;
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced, i);
    this.UpdateAutoplayContent()
}
;
AutoplayControllerAdvanced.prototype.StartAutoplayPressed = function() {
    if (XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit) && !this.isCashDecreaseValid) {
        if (Globals.isMobile)
            this.cashDecreaseKeyboardStarter.OnClick();
        else
            this.inputCashDecrease.Select(true);
        return
    }
    this.FillAutoplaySettings();
    XT.SetInt(Vars.AutoplaySpinsRequested, this.requestedAutoSpins[XT.GetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced)]);
    XT.TriggerEvent(Vars.Evt_DataToCode_StartAutoplay);
    if (this.startAutoplayUIButtonOnClick != null)
        for (var i = 0; i < this.startAutoplayUIButtonOnClick.length; i++)
            if (this.startAutoplayUIButtonOnClick[i].target != null)
                this.startAutoplayUIButtonOnClick[i].target[this.startAutoplayUIButtonOnClick[i].methodName]()
}
;
AutoplayControllerAdvanced.prototype.UpdateAutoplayContent = function() {
    var s = XT.GetObject(Vars.AdvancedAutoplaySettings);
    this.checkOnAnyWin.SetValue(s.stopOnAnyWin);
    this.checkIfAnyFeature.SetValue(s.stopIfFeature);
    this.checkIfSingleWin.SetValue(s.stopIfSingleWinExceeds);
    this.inputWin.SetValue(String(s.singleWinValue > 0 ? s.singleWinValue : ""));
    this.checkIfCashIncreases.SetValue(s.stopIfCashIncreases);
    this.inputCashIncrease.SetValue(String(s.cashIncreasesValue > 0 ? s.cashIncreasesValue : ""));
    if (!XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit))
        this.checkIfCashDecreases.SetValue(s.stopIfCashDecreases);
    this.inputCashDecrease.SetValue(String(s.cashDecreasesValue > 0 ? s.cashDecreasesValue : ""));
    var idx = XT.GetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced);
    for (var i = 0; i < this.checkSpins.length; i++)
        this.checkSpins[i].SetValue(i == idx);
    this.UpdateFastPlayButtons()
}
;
AutoplayControllerAdvanced.prototype.FillAutoplaySettings = function() {
    var s = new AdvancedAutoplaySettings;
    s.stopOnAnyWin = this.checkOnAnyWin.GetValue();
    s.stopIfFeature = this.checkIfAnyFeature.GetValue();
    s.stopIfSingleWinExceeds = this.checkIfSingleWin.GetValue();
    s.singleWinValue = _number.otod(this.inputWin.value);
    s.stopIfCashIncreases = this.checkIfCashIncreases.GetValue();
    s.cashIncreasesValue = _number.otod(this.inputCashIncrease.value);
    s.cashDecreasesValue = _number.otod(this.inputCashDecrease.value);
    s.stopIfCashDecreases = s.cashDecreasesValue > 0;
    s.initialBalance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
    XT.SetObject(Vars.AdvancedAutoplaySettings, s)
}
;
AutoplayControllerAdvanced.prototype.ProcessCashDecreaseText = function(value) {
    var val = 0;
    if (!_string.IsNullOrEmpty(value))
        val = _number.otod(value);
    var ret = value;
    if (!this.wasCashDecreaseSelected && this.inputCashDecrease.isSelected)
        this.wasCashDecreaseSelected = true;
    if (!this.wasCashDecreaseSelected)
        ret = [null, "", "0"].indexOf(value) > -1 ? "" : value;
    var totalBet = CoinManager.GetNextTotalBet();
    var balance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
    this.isCashDecreaseValid = (ret == "" || val > totalBet || Math.abs(val - totalBet) < UHTMath.numberError) && (val < balance || Math.abs(val - balance) < UHTMath.numberError);
    if (this.isCashDecreaseValid) {
        this.inputCashDecrease.label.SetColor(this.cashDecreaseValidColor);
        this.startAutoplayButtonLabel.SetColor(this.validColor);
        this.startAutoplayButtonSprite.color = this.validColor;
        this.inputCashDecreaseSprite.color = this.validColor;
        this.UpdateUIButtonsColors(this.startAutoplayUIButtons, this.validColor, this.validColorHover, this.validColorPressed);
        if (Globals.isMobile)
            for (var i = 0; i < this.cashDecreasesLabels.length; ++i)
                this.cashDecreasesLabels[i].SetColor(this.cashDecreaseValidColor);
        else
            this.UpdateUIButtonsColors(this.cashDecreasesUIButtons, this.validColor, this.validColorHover, this.validColorPressed)
    } else {
        this.inputCashDecrease.label.SetColor(this.invalidColor);
        this.startAutoplayButtonLabel.SetColor(this.invalidColor);
        this.startAutoplayButtonSprite.color = this.invalidColor;
        this.inputCashDecreaseSprite.color = this.invalidColor;
        this.UpdateUIButtonsColors(this.startAutoplayUIButtons, this.startAutoplayInvalidColor, this.startAutoplayInvalidColor, this.startAutoplayInvalidColor);
        if (Globals.isMobile)
            for (var i = 0; i < this.cashDecreasesLabels.length; ++i)
                this.cashDecreasesLabels[i].SetColor(this.invalidColor);
        else
            this.UpdateUIButtonsColors(this.cashDecreasesUIButtons, this.invalidColor, this.invalidColorHover, this.invalidColorPressed)
    }
    return ret
}
;
AutoplayControllerAdvanced.prototype.RGBToColor = function(r, g, b) {
    var c = new Color;
    c.r = r;
    c.g = g;
    c.b = b;
    c.a = 1;
    return c
}
;
AutoplayControllerAdvanced.prototype.UpdateUIButtonsColors = function(buttons, normalColor, hoverColor, pressedColor) {
    for (var i = 0; i < buttons.length; ++i) {
        var b = buttons[i];
        b.color_normal = normalColor;
        b.color_hover = hoverColor;
        b.color_pressed = pressedColor;
        var s = b.curState;
        if (s == UIButton.State.None)
            s = b.gameObject.collider != null && b.gameObject.collider.enabled ? UIButton.State.Normal : UIButton.State.Disabled;
        buttons[i].InternalChangeState(s)
    }
}
;
AutoplayControllerAdvanced.prototype.UpdateFastPlayButtons = function() {
    var isFastPlay = XT.GetBool(Vars.FastPlay);
    this.fastPlayToOn.SetActive(!isFastPlay);
    this.fastPlayToOff.SetActive(isFastPlay);
    if (isFastPlay && XT.GetBool(Vars.AutoplayContinuousSpin))
        this.UpdateTurboSpinButtons()
}
;
AutoplayControllerAdvanced.prototype.UpdateTurboSpinButtons = function() {
    XT.SetBool(Vars.AutoplayContinuousSpin, !XT.GetBool(Vars.AutoplayContinuousSpin));
    var isAutoplayContinousSpin = XT.GetBool(Vars.AutoplayContinuousSpin);
    var isFastPlay = XT.GetBool(Vars.FastPlay);
    this.turboSpinToOn.SetActive(!isAutoplayContinousSpin);
    this.turboSpinToOff.SetActive(isAutoplayContinousSpin);
    if (isAutoplayContinousSpin && isFastPlay) {
        XT.SetBool(Vars.FastPlay, !isFastPlay);
        this.fastPlayToOn.SetActive(isFastPlay);
        this.fastPlayToOff.SetActive(!isFastPlay)
    }
}
;
AutoplayControllerAdvanced.prototype.OnSwitchToPortrait = function() {
    this.OnLayoutSwitched(LayoutManager.Mode.Portrait)
}
;
AutoplayControllerAdvanced.prototype.OnSwitchToLandscape = function() {
    this.OnLayoutSwitched(LayoutManager.Mode.Landscape)
}
;
AutoplayControllerAdvanced.prototype.OnLayoutSwitched = function(mode) {
    if (AutoplayControllerAdvanced.layoutMode == mode)
        return;
    AutoplayControllerAdvanced.layoutMode = mode;
    AutoplayControllerAdvanced.layoutSwitchedFrame = Time.frameCount
}
;
goog.require("UHT.AutoplayControllerAdvanced");
AutoplayControllerAdvancedV10.prototype = Object.create(AutoplayControllerAdvanced.prototype);
AutoplayControllerAdvancedV10.prototype.constructor = AutoplayControllerAdvancedV10;
function AutoplayControllerAdvancedV10() {
    AutoplayControllerAdvanced.call(this);
    this.sliderSpins = null;
    this.sliderWinExceeds = null;
    this.sliderCashIncreases = null;
    this.sliderCashDecreases = null;
    this.startAutoplayButtonEnablers = null
}
AutoplayControllerAdvancedV10.prototype.OnEnable = function() {
    var canReset = AutoplayControllerAdvanced.layoutSwitchedFrame != Time.frameCount;
    if (canReset)
        XT.SetObject(Vars.AdvancedAutoplaySettings, new AdvancedAutoplaySettings);
    this.UpdateAutoplayContent();
    this.sliderSpins.SetValueIndex(canReset ? 3 : XT.GetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced));
    this.SetAutoSpinsIndex()
}
;
AutoplayControllerAdvancedV10.prototype.SetAutoSpinsIndex = function() {
    XT.SetInt(InterfaceVars.SelectedAutoSpinsIndexAdvanced, this.sliderSpins.valueIndex);
    this.UpdateAutoplayContent()
}
;
AutoplayControllerAdvancedV10.prototype.UpdateAutoplayContent = function() {
    var s = XT.GetObject(Vars.AdvancedAutoplaySettings);
    this.checkOnAnyWin.SetValue(s.stopOnAnyWin);
    this.checkIfAnyFeature.SetValue(s.stopIfFeature);
    var totalBet = CoinManager.GetNextTotalBet();
    this.sliderWinExceeds.maxValue = 500 * totalBet;
    this.sliderWinExceeds.SetValue(s.singleWinValue);
    this.sliderCashIncreases.maxValue = 5E3 * totalBet;
    this.sliderCashIncreases.SetValue(s.cashIncreasesValue);
    this.sliderCashDecreases.maxValue = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
    this.sliderCashDecreases.SetValue(s.cashDecreasesValue);
    this.UpdateFastPlayButtons();
    this.UpdateStartAutoplayButton(s)
}
;
AutoplayControllerAdvancedV10.prototype.FillAutoplaySettings = function() {
    var s = new AdvancedAutoplaySettings;
    s.stopOnAnyWin = this.checkOnAnyWin.GetValue();
    s.stopIfFeature = this.checkIfAnyFeature.GetValue();
    s.singleWinValue = this.sliderWinExceeds.value;
    s.stopIfSingleWinExceeds = s.singleWinValue > 0;
    s.cashIncreasesValue = this.sliderCashIncreases.value;
    s.stopIfCashIncreases = s.cashIncreasesValue > 0;
    s.cashDecreasesValue = this.sliderCashDecreases.value;
    s.stopIfCashDecreases = XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit) || s.cashDecreasesValue > 0;
    s.initialBalance = XT.GetDouble(Vars.BalanceReceived) + XT.GetDouble(Vars.BonusBalanceReceived);
    XT.SetObject(Vars.AdvancedAutoplaySettings, s);
    this.UpdateStartAutoplayButton(s)
}
;
AutoplayControllerAdvancedV10.prototype.UpdateStartAutoplayButton = function(s) {
    if (XT.GetBool(Vars.Jurisdiction_MandatoryAutoplayLossLimit)) {
        if (this.startAutoplayButtonEnablers == null)
            this.startAutoplayButtonEnablers = this.startAutoplayButton.GetComponents(ButtonEnabler);
        if (s.cashDecreasesValue < CoinManager.GetNextTotalBet())
            for (var i = 0; i < this.startAutoplayButtonEnablers.length; ++i)
                this.startAutoplayButtonEnablers[i].DisableButton();
        else
            for (var i = 0; i < this.startAutoplayButtonEnablers.length; ++i)
                this.startAutoplayButtonEnablers[i].EnableButton()
    }
}
;
goog.require("UHT.Engine");
Interface_GambleCard.prototype = Object.create(XTLink.prototype);
Interface_GambleCard.prototype.constructor = Interface_GambleCard;
function Interface_GambleCard() {
    XTLink.call(this);
    this.animatedObject = null;
    this.stopInLoops = 2;
    this.loopsBeforeStop = 0;
    this.isRed = false;
    this.mustStop = false
}
Interface_GambleCard.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_PickResult_Handled, this.OnResultHandled, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
}
;
Interface_GambleCard.prototype.OnGameHasCustomGamble = function(param) {
    if (param)
        this.OnDestroy()
}
;
Interface_GambleCard.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnResultHandled, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
}
;
Interface_GambleCard.prototype.OnDisable = function() {
    XT.TriggerEvent(Vars.Evt_Internal_StopGambleShuffleCard)
}
;
Interface_GambleCard.prototype.OnResultHandled = function() {
    var pickedID = XT.GetInt(Vars.Gamble_PickResult_ItemID);
    if (pickedID < 26)
        this.SetAsBlack();
    else
        this.SetAsRed()
}
;
Interface_GambleCard.prototype.IsVisibleRed = function() {
    if (this.mustStop)
        this.loopsBeforeStop--;
    if (this.mustStop && this.isRed)
        if (this.loopsBeforeStop < 1) {
            this.animatedObject.animation.GetAnimationState(this.animatedObject.animation.clip.name).speed = 0;
            XT.TriggerEvent(Vars.Evt_Internal_StopGambleShuffleCard);
            XT.TriggerEvent(Vars.Evt_Internal_PlayGambleShufflingStop)
        }
}
;
Interface_GambleCard.prototype.IsVisibleBlack = function() {
    if (this.mustStop)
        this.loopsBeforeStop--;
    if (this.mustStop && !this.isRed)
        if (this.loopsBeforeStop < 1) {
            this.animatedObject.animation.GetAnimationState(this.animatedObject.animation.clip.name).speed = 0;
            XT.TriggerEvent(Vars.Evt_Internal_StopGambleShuffleCard);
            XT.TriggerEvent(Vars.Evt_Internal_PlayGambleShufflingStop)
        }
}
;
Interface_GambleCard.prototype.SetAsRed = function() {
    this.isRed = true
}
;
Interface_GambleCard.prototype.SetAsBlack = function() {
    this.isRed = false
}
;
Interface_GambleCard.prototype.StartShuffling = function() {
    this.mustStop = false;
    this.loopsBeforeStop = this.stopInLoops;
    if (!this.animatedObject.animation.isPlaying)
        this.animatedObject.animation.Play();
    this.animatedObject.animation.GetAnimationState(this.animatedObject.animation.clip.name).speed = 1;
    XT.TriggerEvent(Vars.Evt_Internal_PlayGambleShuffleCard)
}
;
Interface_GambleCard.prototype.StopShuffling = function() {
    this.mustStop = true
}
;
goog.require("UHT.Engine");
VS_GambleVisual.prototype = Object.create(XTLink.prototype);
VS_GambleVisual.prototype.constructor = VS_GambleVisual;
function VS_GambleVisual() {
    XTLink.call(this);
    this.colorMultiplier = 2;
    this.suitMultiplier = 4;
    this.currentWin = 0;
    this.openedResultWindow = ""
}
VS_GambleVisual.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackDouble(Vars.Gamble_CurrentBalance, this.OnGambleBalanceReceived, this);
    XT.RegisterCallbackDouble(Vars.Gamble_ColorMultiplier, this.OnColorMultiplierUpdate, this);
    XT.RegisterCallbackDouble(Vars.Gamble_SuitMultiplier, this.OnSuitMultiplierUpdate, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Gamble_UpdateDisplayedLabels, this.UpdateDisplayedLabels, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GambleCloseCurrentResultWindow, this.OnResultWindowClose, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
}
;
VS_GambleVisual.prototype.OnGameHasCustomGamble = function(param) {
    if (param)
        this.OnDestroy()
}
;
VS_GambleVisual.prototype.OnDestroy = function() {
    XT.UnregisterCallbackDouble(this.OnGambleBalanceReceived, this);
    XT.UnregisterCallbackDouble(this.OnColorMultiplierUpdate, this);
    XT.UnregisterCallbackDouble(this.OnSuitMultiplierUpdate, this);
    XT.UnregisterCallbackEvent(this.UpdateDisplayedLabels, this);
    XT.UnregisterCallbackEvent(this.OnResultWindowClose, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
}
;
VS_GambleVisual.prototype.UpdateDisplayedLabels = function() {
    XT.SetDouble(Vars.Gamble_CurrentBalanceDisplayed, this.currentWin);
    this.UpdatePossibleWins(this.currentWin)
}
;
VS_GambleVisual.prototype.UpdatePossibleWins = function(currentWin) {
    XT.SetDouble(Vars.Gamble_ColorWinDisplayed, currentWin * this.colorMultiplier);
    XT.SetDouble(Vars.Gamble_SuitWinDisplayed, currentWin * this.suitMultiplier)
}
;
VS_GambleVisual.prototype.OnGambleBalanceReceived = function(win) {
    this.currentWin = win
}
;
VS_GambleVisual.prototype.OnColorMultiplierUpdate = function(multiplier) {
    this.colorMultiplier = multiplier
}
;
VS_GambleVisual.prototype.OnSuitMultiplierUpdate = function(multiplier) {
    this.suitMultiplier = multiplier
}
;
VS_GambleVisual.prototype.OnResultWindowClose = function() {
    if (this.openedResultWindow == "WIN")
        XT.TriggerEvent(Vars.Evt_CodeToData_GambleCloseResultWindowWin);
    else if (this.openedResultWindow == "LOSE")
        XT.TriggerEvent(Vars.Evt_CodeToData_GambleCloseResultWindowLose);
    this.openedResultWindow = ""
}
;
VS_GambleVisual.prototype.ShowResultWindow = function(param) {
    this.openedResultWindow = param;
    if (param == "WIN") {
        XT.SetDouble(Vars.Gamble_FinalBalanceDisplayed, this.currentWin);
        XT.TriggerEvent(Vars.Evt_CodeToData_GambleShowResultWindowWin)
    } else
        XT.TriggerEvent(Vars.Evt_CodeToData_GambleShowResultWindowLose)
}
;
goog.require("UHT.Engine");
VS_GambleProgressDisplayer.prototype = Object.create(XTLink.prototype);
VS_GambleProgressDisplayer.prototype.constructor = VS_GambleProgressDisplayer;
function GambleProgressObject() {
    this.itemIndex = 0;
    this.itemID = 0;
    this.isFromInit = false
}
function VS_GambleProgressDisplayer() {
    XTLink.call(this)
}
VS_GambleProgressDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_DisplayHistory, this.OnHistoryDisplayed, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_Gamble_DisplayProgress, this.OnProgressDisplayed, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_ClearProgress, this.OnProgressClear, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
}
;
VS_GambleProgressDisplayer.prototype.OnGameHasCustomGamble = function(param) {
    if (param)
        this.OnDestroy()
}
;
VS_GambleProgressDisplayer.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnHistoryDisplayed, this);
    XT.UnregisterCallbackEvent(this.OnProgressDisplayed, this);
    XT.UnregisterCallbackEvent(this.OnProgressClear, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
}
;
VS_GambleProgressDisplayer.prototype.OnHistoryDisplayed = function() {
    var histoyObj = XT.GetObject(Vars.FromServer_GambleHistory);
    var history = histoyObj.History;
    for (var i = 0; i < history.length; i++) {
        var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
        progObj.isFromInit = true;
        progObj.itemIndex = i + 1;
        progObj.itemID = history[i].GetCard();
        XT.TriggerEvent(Vars.Evt_Internal_Gamble_UpdateCurrentProgress)
    }
}
;
VS_GambleProgressDisplayer.prototype.OnProgressDisplayed = function() {
    var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
    progObj.isFromInit = false;
    var gamblingResp = XT.GetObject(Vars.FromServer_GambleResult);
    progObj.itemID = gamblingResp.GetCard();
    progObj.itemIndex++;
    XT.TriggerEvent(Vars.Evt_Internal_Gamble_UpdateCurrentProgress)
}
;
VS_GambleProgressDisplayer.prototype.OnProgressClear = function() {
    var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
    progObj.itemIndex = 0
}
;
goog.require("UHT.Engine");
VS_GambleProgressItem.prototype = Object.create(XTLink.prototype);
VS_GambleProgressItem.prototype.constructor = VS_GambleProgressItem;
function VS_GambleProgressItem() {
    XTLink.call(this);
    this.itemIndex = 0;
    this.Cat = null;
    this.EventSetRed = null;
    this.EventSetBlack = null;
    this.EventShowOnInit = null;
    this.EventShowAfterPick = null;
    this.EventReset = null
}
VS_GambleProgressItem.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_ClearProgress, this.OnProgressClear, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_Gamble_UpdateCurrentProgress, this.OnProgressUpdate, this);
    XT.RegisterCallbackBool(Vars.GameHasCustomGamble, this.OnGameHasCustomGamble, this)
}
;
VS_GambleProgressItem.prototype.OnGameHasCustomGamble = function(param) {
    if (param)
        this.OnDestroy()
}
;
VS_GambleProgressItem.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnProgressClear, this);
    XT.UnregisterCallbackEvent(this.OnProgressUpdate, this);
    XT.UnregisterCallbackBool(this.OnGameHasCustomGamble, this)
}
;
VS_GambleProgressItem.prototype.OnProgressClear = function() {
    this.Cat.StartEvent(this.EventReset.id)
}
;
VS_GambleProgressItem.prototype.OnProgressUpdate = function() {
    var progObj = XT.GetObject(Vars.Gamble_CurrentProgressObject);
    if (this.itemIndex != progObj.itemIndex)
        return;
    switch (Math.floor(progObj.itemID / 26)) {
    case 0:
        this.Cat.StartEvent(this.EventSetBlack.id);
        break;
    case 1:
        this.Cat.StartEvent(this.EventSetRed.id);
        break
    }
    if (progObj.isFromInit)
        this.Cat.StartEvent(this.EventShowOnInit.id);
    else
        this.Cat.StartEvent(this.EventShowAfterPick.id)
}
;
goog.require("UHT.XTLink");
QuickSpinWindowController.prototype = Object.create(XTLink.prototype);
QuickSpinWindowController.prototype.constructor = QuickSpinWindowController;
function QuickSpinWindowController() {
    XTLink.call(this);
    this.showWindow = null;
    this.disableWindow = null;
    this.numberOfSpinsBeforeWindow = 5;
    this.numberOfStopsBeforeWindow = 3;
    this.numberOfSpins = 0;
    this.numberOfStops = 0;
    this.isFreeSpin = false;
    this.isAutoSpin = false;
    this.spinStopped = false
}
QuickSpinWindowController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
}
;
QuickSpinWindowController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.ShowFastPlayHint, true)
}
;
QuickSpinWindowController.prototype.OnGameInit = function() {
    if (XT.GetBool(Vars.FastPlay) || !XT.GetBool(InterfaceVars.ShowFastPlayHint)) {
        this.disableWindow.Start();
        return
    }
    XT.RegisterCallbackBool(Vars.Logic_IsFreeSpin, this.OnIsFreeSpinChanged, this);
    XT.RegisterCallbackBool(Vars.FastPlay, this.OnQuickSpinChanged, this);
    XT.RegisterCallbackBool(Vars.ContinuousSpin, this.OnQuickSpinChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.OnSpinEnded, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ReelManager_StopSpin, this.OnStopSpin, this);
    XT.RegisterCallbackInt(Vars.AutoplaySpinsLeft, this.OnAutoplaySpinsLeftChanged, this)
}
;
QuickSpinWindowController.prototype.OnAutoplaySpinsLeftChanged = function(param) {
    this.isAutoSpin = param >= 0;
    if (this.isAutoSpin) {
        this.numberOfSpins = 0;
        this.numberOfStops = 0;
        this.spinStopped = false
    }
}
;
QuickSpinWindowController.prototype.OnIsFreeSpinChanged = function(param) {
    this.isFreeSpin = param;
    if (this.isFreeSpin) {
        this.numberOfSpins = 0;
        this.numberOfStops = 0;
        this.spinStopped = false
    }
}
;
QuickSpinWindowController.prototype.OnQuickSpinChanged = function(param) {
    if (param)
        this.xtEnabled = false
}
;
QuickSpinWindowController.prototype.OnStopSpin = function() {
    if (this.isFreeSpin || this.isAutoSpin)
        return;
    this.spinStopped = true
}
;
QuickSpinWindowController.prototype.OnSpinEnded = function() {
    if (this.isFreeSpin || this.isAutoSpin)
        return;
    this.numberOfSpins++;
    if (this.spinStopped)
        this.numberOfStops++;
    else
        this.numberOfStops = 0;
    this.spinStopped = false;
    if (XT.GetDouble(Vars.WinReceived) <= 0)
        if (this.numberOfSpins >= this.numberOfSpinsBeforeWindow && this.numberOfStops >= this.numberOfStopsBeforeWindow) {
            this.showWindow.Start();
            this.xtEnabled = false;
            XT.SetBool(InterfaceVars.ShowFastPlayHint, false);
            XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
            XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
        }
}
;
goog.require("UHT.XTLink");
var FeatureManagerParamType = {
    None: 0,
    Bool: 1,
    Int: 2,
    Float: 3,
    Double: 4,
    String: 5,
    XT_Bool: 6,
    XT_Int: 7,
    XT_Float: 8,
    XT_Double: 9,
    XT_String: 10,
    XT_Object: 11
};
var FeatureManagerCallbackType = {
    XT_Event: 0,
    XT_Object: 1,
    XT_String: 2,
    XT_Double: 3,
    XT_Float: 4,
    XT_Int: 5,
    XT_Bool: 6
};
var FeatureManagerIDSource = {
    None: 0,
    Bonus: 1,
    FreeSpin: 2,
    RandomAward: 3,
    RandomAwardFreeSpin: 4
};
function FeatureManagerMessage() {
    this.eventReceiver = null;
    this.methodToCall = "";
    this.paramType = FeatureManagerParamType.None;
    this.param = ""
}
function FeatureManagerXTCallback() {
    this.onlyDuringFeature = true;
    this.type = FeatureManagerCallbackType.XT_Event;
    this.name = "";
    this.priority = 0;
    this.cat = null;
    this.messages = null;
    this.mng = null
}
FeatureManagerXTCallback.prototype.RegisterCallback = function(param) {
    this.mng = param;
    switch (this.type) {
    case FeatureManagerCallbackType.XT_Event:
        XT.RegisterCallbackEvent(this.name, this.OnEvent, this, this.priority);
        break;
    case FeatureManagerCallbackType.XT_Object:
        XT.RegisterCallbackObject(this.name, this.OnObject, this);
        break;
    case FeatureManagerCallbackType.XT_String:
        XT.RegisterCallbackString(this.name, this.OnString, this);
        break;
    case FeatureManagerCallbackType.XT_Double:
        XT.RegisterCallbackDouble(this.name, this.OnDouble, this);
        break;
    case FeatureManagerCallbackType.XT_Float:
        XT.RegisterCallbackFloat(this.name, this.OnFloat, this);
        break;
    case FeatureManagerCallbackType.XT_Int:
        XT.RegisterCallbackInt(this.name, this.OnInt, this);
        break;
    case FeatureManagerCallbackType.XT_Bool:
        XT.RegisterCallbackBool(this.name, this.OnBool, this);
        break
    }
}
;
FeatureManagerXTCallback.prototype.OnEvent = function() {
    this.mng.XTCallback(this)
}
;
FeatureManagerXTCallback.prototype.OnObject = function(param) {
    this.mng.XTCallback(this)
}
;
FeatureManagerXTCallback.prototype.OnString = function(param) {
    this.mng.XTCallback(this)
}
;
FeatureManagerXTCallback.prototype.OnDouble = function(param) {
    this.mng.XTCallback(this)
}
;
FeatureManagerXTCallback.prototype.OnFloat = function(param) {
    this.mng.XTCallback(this)
}
;
FeatureManagerXTCallback.prototype.OnInt = function(param) {
    this.mng.XTCallback(this)
}
;
FeatureManagerXTCallback.prototype.OnBool = function(param) {
    this.mng.XTCallback(this)
}
;
FeatureManager.prototype = Object.create(XTLink.prototype);
FeatureManager.prototype.constructor = FeatureManager;
function FeatureManager() {
    XTLink.call(this);
    this.featureID = 0;
    this.featureIDSources = null;
    this.XTCallbacks = null;
    this.awardsConfig = null;
    this.awardsResponse = null;
    this.freeSpinsResponse = null;
    this.bonusData = null
}
FeatureManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.RandomAwardsConfig, this.OnAwardsConfig, this);
    XT.RegisterCallbackObject(Vars.RandomAwardsResponse, this.OnAwardsResponse, this);
    XT.RegisterCallbackObject(Vars.ReceivedFreeSpinsResponse, this.OnFreeSpinsResponse, this);
    XT.RegisterCallbackObject(Vars.BonusData, this.OnBonusData, this);
    for (var i = 0; i < this.XTCallbacks.length; ++i)
        this.XTCallbacks[i].RegisterCallback(this)
}
;
FeatureManager.prototype.OnBonusData = function(param) {
    this.bonusData = param
}
;
FeatureManager.prototype.OnFreeSpinsResponse = function(param) {
    this.freeSpinsResponse = param
}
;
FeatureManager.prototype.OnAwardsConfig = function(obj) {
    this.awardsConfig = obj
}
;
FeatureManager.prototype.OnAwardsResponse = function(obj) {
    this.awardsResponse = obj
}
;
FeatureManager.prototype.XTCallback = function(param) {
    if (param.onlyDuringFeature) {
        var id = -1;
        for (var i = 0; i < this.featureIDSources.length; ++i)
            switch (this.featureIDSources[i]) {
            case FeatureManagerIDSource.Bonus:
                if (this.bonusData != null)
                    id = this.bonusData.GameID;
                break;
            case FeatureManagerIDSource.FreeSpin:
                if (this.freeSpinsResponse != null && this.freeSpinsResponse.IsFreeSpin)
                    id = this.freeSpinsResponse.FreeSpinsType;
                break;
            case FeatureManagerIDSource.RandomAward:
                if (this.awardsConfig != null && this.awardsResponse != null)
                    id = this.awardsConfig.awardSymbolsNormal[this.awardsResponse.awardIndex].FeatureID;
                break;
            case FeatureManagerIDSource.RandomAwardFreeSpin:
                if (this.awardsConfig != null && this.awardsResponse != null)
                    id = this.awardsConfig.awardSymbolsFreeSpins[this.awardsResponse.awardIndex].FeatureID;
                break
            }
        if (this.featureID != id)
            return
    }
    if (param.cat != null)
        param.cat.Start();
    for (var i = 0; i < param.messages.length; ++i) {
        var msg = param.messages[i];
        switch (msg.paramType) {
        case FeatureManagerParamType.Bool:
            msg.eventReceiver.SendMessage(msg.methodToCall, _bool.Parse(msg.param));
            break;
        case FeatureManagerParamType.Int:
            msg.eventReceiver.SendMessage(msg.methodToCall, _number.otoi(msg.param));
            break;
        case FeatureManagerParamType.Float:
            msg.eventReceiver.SendMessage(msg.methodToCall, _number.otod(msg.param));
            break;
        case FeatureManagerParamType.Double:
            msg.eventReceiver.SendMessage(msg.methodToCall, _number.otod(msg.param));
            break;
        case FeatureManagerParamType.String:
            msg.eventReceiver.SendMessage(msg.methodToCall, msg.param);
            break;
        case FeatureManagerParamType.XT_Bool:
            msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetBool(msg.param));
            break;
        case FeatureManagerParamType.XT_Int:
            msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetInt(msg.param));
            break;
        case FeatureManagerParamType.XT_Float:
            msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetFloat(msg.param));
            break;
        case FeatureManagerParamType.XT_Double:
            msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetDouble(msg.param));
            break;
        case FeatureManagerParamType.XT_String:
            msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetString(msg.param));
            break;
        case FeatureManagerParamType.XT_Object:
            msg.eventReceiver.SendMessage(msg.methodToCall, XT.GetObject(msg.param));
            break;
        default:
            msg.eventReceiver.SendMessage(msg.methodToCall);
            break
        }
    }
}
;
goog.require("UHT.Engine");
RatingWindowController.prototype = Object.create(XTLink.prototype);
RatingWindowController.prototype.constructor = RatingWindowController;
function RatingWindowController() {
    XTLink.call(this);
    this.showWindow = null;
    this.hideWindow = null;
    this.rateLucky = null;
    this.rateLuckyUpdateState = null;
    this.ratePretty = null;
    this.ratePrettyUpdateState = null;
    this.okButton = null;
    this.happyRating = 3;
    this.numberOfWinsBeforeRating = 30;
    this.disabled = true;
    this.luckyRating = 0;
    this.prettyRating = 0;
    this.numberOfWins = 0;
    this.mustShowWindow = false;
    this.numSkipClicked = 0;
    this.numClicksToSkip = 3
}
RatingWindowController.prototype.ShowWindow = function() {
    this.SwitchOkButton();
    this.showWindow.Start()
}
;
RatingWindowController.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this)
}
;
RatingWindowController.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(Vars.GameIsRated, false);
    XT.SetBool(Vars.RatingSkipped, false)
}
;
RatingWindowController.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGameInit, this)
}
;
RatingWindowController.prototype.OnGameInit = function() {
    if (ServerOptions.noRating || this.disabled)
        return;
    if (!XT.GetBool(Vars.GameIsRated) && !XT.GetBool(Vars.RatingSkipped))
        XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinEnded, this.OnSpinEnded, this)
}
;
RatingWindowController.prototype.OnSpinEnded = function() {
    if (XT.GetDouble(Vars.WinReceived) > 0) {
        this.numberOfWins++;
        if (this.numberOfWins >= this.numberOfWinsBeforeRating)
            this.mustShowWindow = true
    } else {
        var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
        var isFreeSpin = fsr != null && fsr.IsFreeSpin;
        var isAutoSpin = XT.GetInt(Vars.AutoplaySpinsLeft) > 0;
        if (this.mustShowWindow && !isFreeSpin && !isAutoSpin) {
            this.ShowWindow();
            XT.UnregisterCallbackEvent(this.OnSpinEnded, this)
        }
    }
}
;
RatingWindowController.prototype.RateLucky = function(idx) {
    var index = _number.otoi(idx);
    var rating = index + 1;
    var updateState = this.luckyRating != rating && (this.luckyRating >= this.happyRating && rating < this.happyRating || this.luckyRating < this.happyRating && rating >= this.happyRating);
    if (updateState)
        this.rateLuckyUpdateState[index].Start();
    else
        this.rateLucky[index].Start();
    this.luckyRating = rating;
    this.SwitchOkButton()
}
;
RatingWindowController.prototype.RatePretty = function(idx) {
    var index = _number.otoi(idx);
    var rating = index + 1;
    var updateState = this.prettyRating != rating && (this.prettyRating >= this.happyRating && rating < this.happyRating || this.prettyRating < this.happyRating && rating >= this.happyRating);
    if (updateState)
        this.ratePrettyUpdateState[index].Start();
    else
        this.ratePretty[index].Start();
    this.prettyRating = rating;
    this.SwitchOkButton()
}
;
RatingWindowController.prototype.SwitchOkButton = function() {
    var buttons = this.okButton.GetComponents(UIButton);
    var isEnabled = this.luckyRating > 0 && this.prettyRating > 0;
    for (var i = 0; i < buttons.length; ++i)
        buttons[i].SetEnabled(isEnabled)
}
;
RatingWindowController.prototype.OkButtonClicked = function() {
    globalTracking.SendTimer("Rating", "Lucky", this.luckyRating * 1E3, "RatingTracker");
    globalTracking.SendTimer("Rating", "Pretty", this.prettyRating * 1E3, "RatingTracker");
    XT.SetBool(Vars.GameIsRated, true);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.hideWindow.Start()
}
;
RatingWindowController.prototype.CloseButtonClicked = function() {
    globalTracking.SendTimer("Rating", "SkippedLucky", this.luckyRating * 1E3, "RatingTracker");
    globalTracking.SendTimer("Rating", "SkippedPretty", this.prettyRating * 1E3, "RatingTracker");
    XT.SetBool(Vars.RatingSkipped, true);
    XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
    XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
    this.hideWindow.Start()
}
;
RatingWindowController.prototype.SkipButtonClicked = function() {
    ++this.numSkipClicked;
    if (this.numSkipClicked >= this.numClicksToSkip) {
        XT.SetBool(Vars.GameIsRated, true);
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer);
        this.hideWindow.Start()
    }
}
;
goog.require("UHT.Engine");
GameWindowOverrider.prototype = Object.create(XTLink.prototype);
GameWindowOverrider.prototype.constructor = GameWindowOverrider;
function DefaultGameWindowOverrideData() {
    this.customFSWinWindow = false;
    this.customFSLoseWindow = false
}
function GameWindowOverrider() {
    XTLink.call(this);
    this.FSWinWindow = null;
    this.FSLoseWindow = null
}
GameWindowOverrider.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GUIInit, this.OnGUIInit, this)
}
;
GameWindowOverrider.prototype.OnDestroy = function() {
    XT.UnregisterCallbackEvent(this.OnGUIInit, this)
}
;
GameWindowOverrider.prototype.OnGUIInit = function() {
    var data = XT.GetObject(Vars.DefaultGameWindowOverrideData);
    if (this.FSWinWindow != null)
        this.FSWinWindow.isEnabled = !data.customFSWinWindow;
    if (this.FSLoseWindow != null)
        this.FSLoseWindow.isEnabled = !data.customFSLoseWindow
}
;
goog.require("UHT.XTLink");
goog.require("UHT.SoundManager");
goog.require("UHT.AudioClassesUtils");
GUI_SoundLogic.prototype = Object.create(XTLink.prototype);
GUI_SoundLogic.prototype.constructor = GUI_SoundLogic;
function GUI_SoundLogic() {
    XTLink.call(this);
    this.clipValueAnimator = null;
    this.gambleSounds = null;
    this.sndManager = null;
    this.enableSoundsWhenReady = false
}
GUI_SoundLogic.prototype.XTInitVariablesAndEvents = function() {
    XT.SetBool(InterfaceVars.EnableSoundsWhenReady, false)
}
;
GUI_SoundLogic.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.SoundManagerObject, this.OnSoundManagerChanged, this);
    XT.RegisterCallbackBool(Vars.MusicIsOn, this.OnMusicStateChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlayValueAnimatorSound, this.OnValueAnimatorIsCounting, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopValueAnimatorSound, this.OnValueAnimatorFinishedCounting, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlayGambleShuffleCard, this.OnGambleShuffleStart, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PlayGambleShufflingStop, this.OnGambleShufflePlayStop, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_StopGambleShuffleCard, this.OnGambleShuffleStop, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayGambleNewProgressItem, this.OnGambleNewProgressItem, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayGambleResultWin, this.OnGambleResultWindowWin, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_PlayGambleResultLose, this.OnGambelResultWindowLose, this);
    XT.RegisterCallbackBool(InterfaceVars.EnableSoundsWhenReady, this.OnEnableSoundsWhenReadyChanged, this)
}
;
GUI_SoundLogic.prototype.OnDestroy = function() {
    XT.UnregisterCallbackObject(this.OnSoundManagerChanged, this);
    XT.UnregisterCallbackBool(this.OnMusicStateChanged, this);
    XT.UnregisterCallbackEvent(this.OnValueAnimatorIsCounting, this);
    XT.UnregisterCallbackEvent(this.OnValueAnimatorFinishedCounting, this);
    XT.UnregisterCallbackEvent(this.OnGambleShuffleStart, this);
    XT.UnregisterCallbackEvent(this.OnGambleShuffleStop, this);
    XT.UnregisterCallbackEvent(this.OnGambleNewProgressItem, this);
    XT.UnregisterCallbackEvent(this.OnGambleResultWindowWin, this);
    XT.UnregisterCallbackEvent(this.OnGambelResultWindowLose, this)
}
;
GUI_SoundLogic.prototype.OnSoundManagerChanged = function(mgr) {
    this.sndManager = mgr
}
;
GUI_SoundLogic.prototype.OnMusicStateChanged = function(unused) {
    if (this.clipValueAnimator.IsPlaying()) {
        var args = {
            handle: this.clipValueAnimator.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.clipValueAnimator.handler = args.handle;
        this.clipValueAnimator.handler = this.sndManager.PlayLooping(this.clipValueAnimator.GetClip(XT.GetInt(Vars.ValueAnimatorSoundIndex)))
    }
}
;
GUI_SoundLogic.prototype.OnGambleShuffleStart = function() {
    this.gambleSounds.shufflingCardLoopable.handler = this.sndManager.PlayLooping(this.gambleSounds.shufflingCardLoopable.GetClip())
}
;
GUI_SoundLogic.prototype.OnGambleShuffleStop = function() {
    if (this.gambleSounds.shufflingCardLoopable.IsPlaying()) {
        var args = {
            handle: this.gambleSounds.shufflingCardLoopable.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.gambleSounds.shufflingCardLoopable.handler = args.handle
    }
}
;
GUI_SoundLogic.prototype.OnGambleShufflePlayStop = function() {
    this.sndManager.PlaySimple(this.gambleSounds.shufflingCardStop)
}
;
GUI_SoundLogic.prototype.OnGambleNewProgressItem = function() {
    this.sndManager.PlaySimple(this.gambleSounds.newProgressItem)
}
;
GUI_SoundLogic.prototype.OnGambleResultWindowWin = function() {
    this.sndManager.PlaySimple(this.gambleSounds.resultWindowWin)
}
;
GUI_SoundLogic.prototype.OnGambelResultWindowLose = function() {
    this.sndManager.PlaySimple(this.gambleSounds.resultWindowLose)
}
;
GUI_SoundLogic.prototype.OnValueAnimatorIsCounting = function() {
    if (this.clipValueAnimator.IsPlaying()) {
        var args = {
            handle: this.clipValueAnimator.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.clipValueAnimator.handler = args.handle
    }
    this.clipValueAnimator.handler = this.sndManager.PlayLooping(this.clipValueAnimator.GetClip(XT.GetInt(Vars.ValueAnimatorSoundIndex)))
}
;
GUI_SoundLogic.prototype.OnValueAnimatorFinishedCounting = function() {
    if (this.clipValueAnimator.IsPlaying()) {
        var args = {
            handle: this.clipValueAnimator.handler
        };
        this.sndManager.StopLoopingSound(args);
        this.clipValueAnimator.handler = args.handle
    }
    this.sndManager.PlaySimple(this.clipValueAnimator.GetClip(ClipStage.finalStage))
}
;
GUI_SoundLogic.prototype.OnEnableSoundsWhenReadyChanged = function(param) {
    this.enableSoundsWhenReady = param
}
;
GUI_SoundLogic.prototype.Update = function() {
    if (this.enableSoundsWhenReady)
        if (UHTEngine.SoundsAreLoaded()) {
            this.enableSoundsWhenReady = false;
            if (XT.GetObject(Vars.SoundState).gameSoundIsOn == false)
                XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_SoundBtn)
        }
}
;
goog.require("UHT.XTLink");
CoinManager.prototype = Object.create(XTLink.prototype);
CoinManager.prototype.constructor = CoinManager;
function CoinManager() {
    XTLink.call(this)
}
CoinManager.instance = null;
CoinManager.isInited = false;
CoinManager.lastBet = -1;
CoinManager.lastTotalBet = -1;
CoinManager.lastIndicesPair = null;
CoinManager.isStrictMode = false;
CoinManager.canStillGoToStrictMode = false;
CoinManager.desiredBetIndex = -1;
CoinManager.desiredCoinIndex = -1;
CoinManager.desiredBet = -1;
CoinManager.savedDesiredBet = -1;
CoinManager.defaultBet = -1;
CoinManager.computedCoinValues = null;
CoinManager.betsFromServer = null;
CoinManager.prototype.XTInitVariablesAndEvents = function() {
    CoinManager.instance = this;
    XT.SetObject(Vars.TotalBets, null);
    XT.SetObject(Vars.CoinValues, []);
    XT.SetInt(Vars.CoinValueIndex, -1);
    XT.SetInt(Vars.NextBetIndex, 0);
    XT.SetDouble(Vars.MinTotalBetFromServer, 0);
    XT.SetDouble(Vars.MaxTotalBetFromServer, 0)
}
;
CoinManager.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_IncreaseBet, this.IncreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_DecreaseBet, this.DecreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_IncreaseCoinValue, this.IncreaseCoinValue, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_DecreaseCoinValue, this.DecreaseCoinValue, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_SmartIncreaseBet, this.SmartIncreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_SmartDecreaseBet, this.SmartDecreaseBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_RevertToLastBet, this.RevertToLastBet, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ForceUpdateBetValues, this.UpdateBetValues, this)
}
;
CoinManager.prototype.OnDestroy = function() {}
;
CoinManager.prototype.SmartIncreaseBet = function() {
    if (XT.GetBool(Vars.FromServer_AllowCoins))
        if (XT.GetBool(Vars.HasCoins)) {
            var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
            var bets = XT.GetObject(Vars.Bets);
            var coinValues = XT.GetObject(Vars.CoinValues);
            var coinValueIndex = XT.GetInt(Vars.CoinValueIndex);
            if (nextBetIndex < bets.length - 1) {
                this.IncreaseBet();
                return
            }
            if (coinValueIndex < coinValues.length - 1) {
                this.IncreaseCoinValue();
                return
            }
        } else
            this.SetSmartBet(true);
    else
        this.IncreaseBet()
}
;
CoinManager.prototype.SmartDecreaseBet = function() {
    if (XT.GetBool(Vars.FromServer_AllowCoins))
        if (XT.GetBool(Vars.HasCoins)) {
            var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
            var coinValueIndex = XT.GetInt(Vars.CoinValueIndex);
            if (nextBetIndex > 0) {
                this.DecreaseBet();
                return
            }
            if (coinValueIndex > 0) {
                this.DecreaseCoinValue();
                return
            }
        } else
            this.SetSmartBet(false);
    else
        this.DecreaseBet()
}
;
CoinManager.prototype.DecreaseBet = function() {
    var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
    XT.SetInt(Vars.NextBetIndex, nextBetIndex - 1);
    this.UpdateBetValues()
}
;
CoinManager.prototype.IncreaseBet = function() {
    var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
    XT.SetInt(Vars.NextBetIndex, nextBetIndex + 1);
    this.UpdateBetValues()
}
;
CoinManager.SetBetIndex = function(newIndex) {
    XT.SetInt(Vars.NextBetIndex, newIndex);
    CoinManager.instance.UpdateBetValues()
}
;
CoinManager.prototype.UpdateBetValues = function() {
    if (CoinManager.isInited == false)
        return;
    var nextBetIndex = XT.GetInt(Vars.NextBetIndex);
    var bets = XT.GetObject(Vars.Bets);
    if (bets == null || nextBetIndex < 0 || nextBetIndex >= bets.length) {
        console.error("Invalid bet data received!!!");
        return
    }
    XT.SetDouble(Vars.BetDisplayed, bets[nextBetIndex]);
    var lines = XT.GetInt(Vars.BetToTotalBetMultiplier);
    var totalBets = [];
    for (var i = 0; i < bets.length; i++)
        totalBets.push(bets[i] * 1E3 * lines / 1E3);
    XT.SetObject(Vars.TotalBets, totalBets);
    XT.SetDouble(Vars.TotalBetDisplayed, totalBets[nextBetIndex]);
    XT.SetBool(Vars.MinBetReached, nextBetIndex == 0);
    XT.SetBool(Vars.MaxBetReached, nextBetIndex == bets.length - 1);
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        XT.SetBool(Vars.MinBetAndCoinValueReached, XT.GetBool(Vars.MinBetReached) && XT.GetBool(Vars.MinCoinValueReached));
        XT.SetBool(Vars.MaxBetAndCoinValueReached, XT.GetBool(Vars.MaxBetReached) && XT.GetBool(Vars.MaxCoinValueReached))
    } else {
        XT.SetBool(Vars.MinBetAndCoinValueReached, XT.GetBool(Vars.MinBetReached));
        XT.SetBool(Vars.MaxBetAndCoinValueReached, XT.GetBool(Vars.MaxBetReached))
    }
    XT.TriggerEvent(Vars.Evt_Internal_BetChanged)
}
;
CoinManager.prototype.IncreaseCoinValue = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    this.SetCoinValueIndex(XT.GetInt(Vars.CoinValueIndex) + 1)
}
;
CoinManager.prototype.DecreaseCoinValue = function() {
    if (XT.GetBool(Vars.WaitInResultForBigWin)) {
        XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
        return
    }
    this.SetCoinValueIndex(XT.GetInt(Vars.CoinValueIndex) - 1)
}
;
CoinManager.prototype.OnSpinStarted = function() {
    var oldBet = CoinManager.lastBet;
    var betIndex = XT.GetInt(Vars.NextBetIndex);
    var tbets = XT.GetObject(Vars.TotalBets);
    CoinManager.lastTotalBet = tbets[betIndex];
    var bets = XT.GetObject(Vars.Bets);
    CoinManager.lastBet = bets[betIndex];
    var biciChanged = false;
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        if (CoinManager.lastIndicesPair.betIndex != betIndex || CoinManager.lastIndicesPair.coinIndex != XT.GetInt(Vars.CoinValueIndex))
            biciChanged = true;
        CoinManager.lastIndicesPair.betIndex = betIndex;
        CoinManager.lastIndicesPair.coinIndex = XT.GetInt(Vars.CoinValueIndex)
    }
    XT.TriggerEvent(Vars.Evt_Internal_LastBetsChanged);
    if (oldBet != CoinManager.lastBet || biciChanged) {
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
    }
}
;
CoinManager.IsInit = function() {
    return CoinManager.isInited
}
;
CoinManager.InitLastBets = function() {
    CoinManager.lastBet = CoinManager.GetNextBet();
    CoinManager.lastTotalBet = CoinManager.GetNextTotalBet();
    XT.TriggerEvent(Vars.Evt_Internal_LastBetsChanged)
}
;
CoinManager.GetLastBet = function() {
    return CoinManager.lastBet
}
;
CoinManager.GetNextBet = function() {
    var bets = XT.GetObject(Vars.Bets);
    var i = XT.GetInt(Vars.NextBetIndex);
    return bets[i]
}
;
CoinManager.GetLastTotalBet = function() {
    return CoinManager.lastTotalBet
}
;
CoinManager.GetNextTotalBet = function() {
    var bets = XT.GetObject(Vars.TotalBets);
    var i = XT.GetInt(Vars.NextBetIndex);
    var alternativeWager = XT.GetDouble(Vars.AlternativeWager);
    if (alternativeWager >= 0)
        return alternativeWager;
    return bets[i]
}
;
CoinManager.GetLastBetIndices = function() {
    return CoinManager.lastIndicesPair
}
;
CoinManager.ConvertMoneyToCoins = function(value) {
    if (!CoinManager.isInited)
        return -69;
    var i = -1;
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        var coinValues = XT.GetObject(Vars.CoinValues);
        i = XT.GetInt(Vars.CoinValueIndex);
        return Math.round(value / coinValues[i])
    } else
        return Math.round(value / CoinManager.GetLastBet())
}
;
CoinManager.GetFormatedMoneyValue = function(val, multiplier) {
    var valInCurrency = val * multiplier;
    if (XT.GetBool(Vars.HasCoins))
        return CoinManager.ConvertMoneyToCoins(valInCurrency).toString();
    else {
        var textFormat = new FormatOptions;
        textFormat.fontId = 1;
        return LocaleManager.FormatValue(valInCurrency, textFormat)
    }
}
;
CoinManager.prototype.SetCoinValueIndex = function(newCoinValueIndex) {
    var coinValues = XT.GetObject(Vars.CoinValues);
    if (newCoinValueIndex < 0 || newCoinValueIndex >= coinValues.length) {
        console.error("Invalid CoinValueIndex!!!");
        return
    }
    var levels = XT.GetInt(Vars.NumberOfBetLevels);
    CoinManager.isInited = true;
    var betsPerLine = [];
    for (var j = 1; j <= levels; j++)
        betsPerLine.push(j * (coinValues[newCoinValueIndex] * 1E3) / 1E3);
    XT.SetObject(Vars.Bets, betsPerLine);
    XT.SetBool(Vars.MinCoinValueReached, newCoinValueIndex == 0);
    XT.SetBool(Vars.MaxCoinValueReached, newCoinValueIndex == coinValues.length - 1);
    XT.SetInt(Vars.CoinValueIndex, newCoinValueIndex);
    XT.SetDouble(Vars.CoinValueDisplayed, coinValues[newCoinValueIndex]);
    this.UpdateBetValues();
    XT.SetBool(Vars.MinBetAndCoinValueReached, XT.GetBool(Vars.MinBetReached) && XT.GetBool(Vars.MinCoinValueReached));
    XT.SetBool(Vars.MaxBetAndCoinValueReached, XT.GetBool(Vars.MaxBetReached) && XT.GetBool(Vars.MaxCoinValueReached));
    XT.TriggerEvent(Vars.Evt_Internal_CoinValueChanged)
}
;
CoinManager.ComputeCoinValuesAndCurrentBet = function(betsFromServer, lastBet, defaultBet) {
	
    var lines = XT.GetInt(Vars.BetToTotalBetMultiplier);
    XT.SetDouble(Vars.MinTotalBetFromServer, betsFromServer[0] * lines);
    XT.SetDouble(Vars.MaxTotalBetFromServer, betsFromServer[betsFromServer.length - 1] * lines);
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        var minBet = betsFromServer[0];
        var maxBet = betsFromServer[betsFromServer.length - 1];
        var curve = [.05, .1, .2, .4];
        var levels = XT.GetInt(Vars.NumberOfBetLevels);
        while (minBet * levels < maxBet / levels * curve[0])
            curve.unshift(curve[0] * .2);
        if (maxBet / minBet < levels) {
            levels = maxBet / minBet | 0;
            XT.SetInt(Vars.NumberOfBetLevels, levels)
        }
        var maxCoinValue = maxBet * 1E3 / levels / 1E3;
        var x = maxCoinValue - minBet;
        var coinValues = [];
        coinValues.push(minBet);
        for (var j = 0; j < curve.length; j++) {
            var computedVal = CoinManager.GetNiceCoinValue(minBet + x * curve[j]);
            if (computedVal > minBet && computedVal < maxCoinValue)
                coinValues.push(computedVal)
        }
        coinValues.push(maxCoinValue);
        for (var i = 1; i < coinValues.length; i++)
            if (Math.abs(coinValues[i] - coinValues[i - 1]) < .001) {
                coinValues.splice(i, 1);
                i--
            }
        XT.SetObject(Vars.CoinValues, coinValues);
        CoinManager.computedCoinValues = coinValues
    } else
        CoinManager.betsFromServer = betsFromServer;
    CoinManager.SetDesiredBet(lastBet);
    CoinManager.SetDefaultBet(defaultBet)
}
;
CoinManager.GetNiceCoinValue = function(value) {
    var niceValue;
    if (value > 5)
        niceValue = Math.floor(value);
    else if (value >= 1)
        niceValue = Math.floor(value * 4) / 4;
    else {
        var niceSubUnitValues = [.01, .02, .03, .05, .07, .1, .2, .3, .5, .75];
        var minDist = 5;
        var index = -1;
        for (var i = 0; i < niceSubUnitValues.length; i++) {
            var d = Math.abs(value - niceSubUnitValues[i]);
            if (d < minDist) {
                minDist = d;
                index = i
            }
        }
        niceValue = niceSubUnitValues[index]
    }
    return niceValue
}
;
CoinManager.SetPreviousBetIndices = function(betIndex, coinIndex) {
    CoinManager.desiredBetIndex = betIndex;
    CoinManager.desiredCoinIndex = coinIndex
}
;
CoinManager.SetDesiredBet = function(bet) {
    CoinManager.desiredBet = bet;
    CoinManager.savedDesiredBet = bet;
    CoinManager.canStillGoToStrictMode = true
}
;
CoinManager.SetDefaultBet = function(bet) {
    CoinManager.defaultBet = bet
}
;
CoinManager.SetStrictBetMode = function(isStrict) {
    var mustUpdateServerSettings = false;
    var i;
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        var betIndex = 0;
        var coinIndex = CoinManager.computedCoinValues.length > 3 ? 2 : 0;
        var haveSettings = false;
        if (CoinManager.lastIndicesPair == null)
            CoinManager.lastIndicesPair = {};
        if (CoinManager.desiredBetIndex != -1 && CoinManager.desiredCoinIndex != -1) {
            if (CoinManager.desiredBetIndex >= 0 && CoinManager.desiredBetIndex < XT.GetInt(Vars.NumberOfBetLevels))
                betIndex = CoinManager.desiredBetIndex;
            if (CoinManager.desiredCoinIndex >= 0 && CoinManager.desiredCoinIndex < CoinManager.computedCoinValues.length)
                coinIndex = CoinManager.desiredCoinIndex;
            haveSettings = true
        }
        if (isStrict && CoinManager.canStillGoToStrictMode && (!CoinManager.isStrictMode || !CoinManager.isInited || CoinManager.desiredBet > 0)) {
            CoinManager.isInited = true;
            CoinManager.canStillGoToStrictMode = false;
            CoinManager.isStrictMode = true;
            var newCoinValues = [];
            var newBetIndex = 0;
            var newCoinIndex = 0;
            newCoinValues.push(CoinManager.savedDesiredBet);
            if (haveSettings && coinIndex == CoinManager.desiredCoinIndex && betIndex == CoinManager.desiredBetIndex) {
                var newCoinVal = CoinManager.computedCoinValues[coinIndex];
                if (Math.abs(CoinManager.savedDesiredBet / newCoinVal - (betIndex + 1)) <= .001) {
                    newCoinValues = [];
                    for (i = 0; i < CoinManager.computedCoinValues.length; i++)
                        newCoinValues.push(CoinManager.computedCoinValues[i]);
                    newCoinIndex = coinIndex;
                    newBetIndex = betIndex
                }
            }
            XT.SetObject(Vars.CoinValues, newCoinValues);
            XT.SetInt(Vars.NextBetIndex, newBetIndex);
            CoinManager.lastIndicesPair.betIndex = newBetIndex;
            CoinManager.lastIndicesPair.coinIndex = newCoinIndex;
            CoinManager.instance.SetCoinValueIndex(newCoinIndex)
        } else if (!isStrict && (CoinManager.isStrictMode || !CoinManager.isInited || CoinManager.desiredBet > 0)) {
            CoinManager.isInited = true;
            CoinManager.canStillGoToStrictMode = false;
            CoinManager.isStrictMode = false;
            XT.SetObject(Vars.CoinValues, CoinManager.computedCoinValues);
            var isMatching = haveSettings && Math.abs(CoinManager.savedDesiredBet - CoinManager.computedCoinValues[coinIndex] * (betIndex + 1)) < .001;
            if (CoinManager.defaultBet > 0 && CoinManager.desiredBetIndex == -1 || !isMatching) {
                var targetBet = !isMatching ? CoinManager.savedDesiredBet : CoinManager.defaultBet;
                var p = CoinManager.GetClosestIndices(targetBet);
                betIndex = p.betIndex;
                coinIndex = p.coinIndex;
                CoinManager.defaultBet = -1;
                mustUpdateServerSettings = true
            } else if (CoinManager.desiredBet > 0) {
                var n = XT.GetInt(Vars.NumberOfBetLevels);
                var found = false;
                for (var idxLevel = 0; idxLevel < n; idxLevel++) {
                    for (var idxCoin = 0; idxCoin < CoinManager.computedCoinValues.length; idxCoin++)
                        if (Math.abs(CoinManager.desiredBet - CoinManager.computedCoinValues[idxCoin] * (idxLevel + 1)) <= .001) {
                            betIndex = idxLevel;
                            coinIndex = idxCoin;
                            found = true;
                            break
                        }
                    if (found)
                        break
                }
            }
            XT.SetInt(Vars.NextBetIndex, betIndex);
            CoinManager.lastIndicesPair.betIndex = betIndex;
            CoinManager.lastIndicesPair.coinIndex = coinIndex;
            CoinManager.instance.SetCoinValueIndex(coinIndex)
        }
    } else if (isStrict && CoinManager.canStillGoToStrictMode && (!CoinManager.isStrictMode || !CoinManager.isInited || CoinManager.desiredBet > 0)) {
        CoinManager.isInited = true;
        CoinManager.canStillGoToStrictMode = false;
        CoinManager.isStrictMode = true;
        XT.SetInt(Vars.NextBetIndex, 0);
        var newBets = [];
        newBets.push(CoinManager.savedDesiredBet);
        XT.SetObject(Vars.Bets, newBets);
        CoinManager.instance.UpdateBetValues()
    } else if (!isStrict && (CoinManager.isStrictMode || !CoinManager.isInited)) {
        CoinManager.isInited = true;
        CoinManager.canStillGoToStrictMode = false;
        CoinManager.isStrictMode = false;
        var betUsed = CoinManager.savedDesiredBet;
        if (CoinManager.desiredBetIndex == -1 && CoinManager.defaultBet > 0)
            betUsed = CoinManager.defaultBet;
        var idx = CoinManager.betsFromServer.length > 2 ? 2 : CoinManager.betsFromServer.length;
        for (i = 0; i < CoinManager.betsFromServer.length; i++)
            if (Math.abs(betUsed - CoinManager.betsFromServer[i]) <= .001) {
                idx = i;
                break
            }
        XT.SetInt(Vars.NextBetIndex, idx);
        XT.SetObject(Vars.Bets, CoinManager.betsFromServer);
        CoinManager.instance.UpdateBetValues()
    }
    CoinManager.desiredBet = -1;
    if (mustUpdateServerSettings) {
        XT.SetBool(Vars.SkipCooldownWhenUpdatingSettingsOnServer, true);
        XT.TriggerEvent(Vars.Evt_ToServer_UpdateSettingsOnServer)
    }
}
;
CoinManager.GetClosestIndices = function(bet) {
    var ret = {};
    var dist = 1E30;
    var n = XT.GetInt(Vars.NumberOfBetLevels);
    for (var idxLevel = 0; idxLevel < n; idxLevel++)
        for (var idxCoin = 0; idxCoin < CoinManager.computedCoinValues.length; idxCoin++) {
            var d = Math.abs(bet - CoinManager.computedCoinValues[idxCoin] * (idxLevel + 1));
            if (d < dist) {
                ret.betIndex = idxLevel;
                ret.coinIndex = idxCoin;
                dist = d
            }
        }
    return ret
}
;
CoinManager.prototype.RevertToLastBet = function() {
    if (XT.GetBool(Vars.FromServer_AllowCoins)) {
        XT.SetInt(Vars.NextBetIndex, CoinManager.lastIndicesPair.betIndex);
        CoinManager.instance.SetCoinValueIndex(CoinManager.lastIndicesPair.coinIndex)
    } else {
        var bets = XT.GetObject(Vars.Bets);
        var betIndex = 0;
        for (var i = 0; i < bets.length; i++)
            if (CoinManager.lastBet == bets[i])
                betIndex = i;
        XT.SetInt(Vars.NextBetIndex, betIndex);
        this.UpdateBetValues()
    }
}
;
CoinManager.SmartBet = function() {
    this.betIndex = -1;
    this.coinValueIndex = -1;
    this.betValue = 0
}
;
CoinManager.smartBets = null;
CoinManager.prototype.InitSmartBets = function() {
    var coinValues = XT.GetObject(Vars.CoinValues);
    var betsCount = XT.GetObject(Vars.Bets).length;
    var smartBets = [];
    var betVals = [];
    for (var i = 0; i < coinValues.length; ++i)
        for (var j = betsCount; j > 0; --j) {
            var betVal = coinValues[i] * j;
            var unique = true;
            for (var k = 0; k < betVals.length; ++k)
                if (Math.abs(betVals[k] - betVal) < 1E-6) {
                    unique = false;
                    break
                }
            if (unique) {
                var sb = new CoinManager.SmartBet;
                sb.coinValueIndex = i;
                sb.betIndex = j - 1;
                sb.betValue = betVal;
                smartBets.push(sb);
                betVals.push(betVal)
            }
        }
    CoinManager.smartBets = smartBets.sort(function(a, b) {
        return a.betValue > b.betValue ? 1 : b.betValue > a.betValue ? -1 : 0
    })
}
;
CoinManager.prototype.SetSmartBet = function(increase) {
    if (CoinManager.smartBets == null)
        this.InitSmartBets();
    var betIdx = XT.GetInt(Vars.NextBetIndex);
    var betVal = XT.GetObject(Vars.Bets)[betIdx];
    var smartBets = CoinManager.smartBets;
    var sb = null;
    if (increase)
        for (var i = 0; i < smartBets.length; ++i) {
            if (betVal < smartBets[i].betValue && Math.abs(betVal - smartBets[i].betValue) > 1E-6) {
                sb = smartBets[i];
                break
            }
        }
    else
        for (var i = smartBets.length - 1; i >= 0; --i)
            if (betVal > smartBets[i].betValue && Math.abs(betVal - smartBets[i].betValue) > 1E-6) {
                sb = smartBets[i];
                break
            }
    if (sb == null)
        return;
    if (XT.GetInt(Vars.CoinValueIndex) != sb.coinValueIndex) {
        if (XT.GetBool(Vars.WaitInResultForBigWin)) {
            XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
            return
        }
        this.SetCoinValueIndex(sb.coinValueIndex)
    }
    if (betIdx != sb.betIndex) {
        XT.SetInt(Vars.NextBetIndex, sb.betIndex);
        this.UpdateBetValues()
    }
}
;
goog.require("UHT.Engine");
AutoplayReopen.prototype = Object.create(XTLink.prototype);
AutoplayReopen.prototype.constructor = AutoplayReopen;
function AutoplayReopen() {
    XTLink.call(this);
    this.shouldReopen = false;
    this.reopenAutoplay = null;
    this.oldState = VSGameState.Invalid
}
AutoplayReopen.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StartAutoplay, this.OnStartAutoplay, this);
    XT.RegisterCallbackEvent(Vars.Evt_DataToCode_StopAutoplay, this.OnStopAutoplay, this);
    XT.RegisterCallbackBool(Vars.CanSpin, this.OnCanSpin, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_ChangeVSGameState, this.OnVSGameStateChanged, this)
}
;
AutoplayReopen.prototype.OnLastWinIsCountingChanged = function(val) {
    if (!val && XT.GetInt(Vars.AutoplaySpinsLeft) < 0 && this.shouldReopen) {
        this.reopenAutoplay.Start();
        this.shouldReopen = false;
        XT.UnregisterCallbackBool(this.OnLastWinIsCountingChanged, this)
    }
}
;
AutoplayReopen.prototype.OnStartAutoplay = function() {
    this.shouldReopen = true
}
;
AutoplayReopen.prototype.OnStopAutoplay = function() {
    this.shouldReopen = false
}
;
AutoplayReopen.prototype.OnCanSpin = function(val) {
    if (val && XT.GetInt(Vars.AutoplaySpinsLeft) < 0 && this.shouldReopen)
        if (XT.GetDouble(Vars.WinReceived) <= 0) {
            this.reopenAutoplay.Start();
            this.shouldReopen = false
        } else
            XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCountingChanged, this)
}
;
AutoplayReopen.prototype.OnVSGameStateChanged = function() {
    var newState = VSGameStateManager.GetState();
    if ((this.oldState == VSGameState.Bonus || this.oldState == VSGameState.ResultFreeSpins || this.oldState == VSGameState.Gamble || this.oldState == VSGameState.GambleCustom) && newState == VSGameState.Result)
        XT.RegisterCallbackEvent(Vars.Evt_Internal_ResultDisplayer_LoopDone, this.OnResultDisplayerLoopDone, this);
    this.oldState = newState
}
;
AutoplayReopen.prototype.OnResultDisplayerLoopDone = function() {
    if (XT.GetInt(Vars.AutoplaySpinsLeft) < 0 && this.shouldReopen) {
        this.reopenAutoplay.Start();
        this.shouldReopen = false;
        XT.UnregisterCallbackEvent(this.OnResultDisplayerLoopDone, this)
    }
}
;
goog.require("UHT.GUIArrangerSettings");
function GUIArrangerPortraitObjectsBase() {
    this.DynamicContentV11 = null;
    this.TopBar = null;
    this.TopBarBackground = null;
    this.TournamentRankLocalPosition = null;
    this.AutoplaySimpleWindow = null
}
GUIArrangerPortraitObjects.prototype = Object.create(GUIArrangerPortraitObjectsBase.prototype);
GUIArrangerPortraitObjects.prototype.constructor = GUIArrangerPortraitObjects;
function GUIArrangerPortraitObjects() {
    GUIArrangerPortraitObjectsBase.call(this);
    this.TournamentRankBackgrounds = null;
    this.TopBarExtraSprite = null;
    this.BottomBarExtraSprite = null
}
GUIArrangerSettingsPortraitObjects.prototype = Object.create(GUIArrangerPortraitObjectsBase.prototype);
GUIArrangerSettingsPortraitObjects.prototype.constructor = GUIArrangerSettingsPortraitObjects;
function GUIArrangerSettingsPortraitObjects() {
    GUIArrangerPortraitObjectsBase.call(this);
    this.TournamentRankBackground = null;
    this.TopBarColor = null;
    this.BottomBarColor = null
}
function GUIArrangerLandscapeObjects() {
    this.BottomBar = null
}
function BlackBands() {
    this.up = null;
    this.down = null;
    this.left = null;
    this.right = null
}
function GameAnchors(ul, dr) {
    this.upLeft = ul;
    this.downRight = dr
}
GUIArranger.prototype = Object.create(XTLink.prototype);
GUIArranger.prototype.constructor = GUIArranger;
function GUIArranger() {
    XTLink.call(this);
    this.logoObjectAnchor = null;
    this.logoObjectArrangeable = null;
    this.portraitObjects = null;
    this.landscapeObjects = null;
    this.gameAnchorUpLeft = null;
    this.gameAnchorDownRight = null;
    this.screenAnchorUpLeft = null;
    this.screenAnchorDownRight = null;
    this.blackBands = null;
    this.gameTitles = null;
    this.settings = null;
    this.screenAnchorUpdated = false
}
GUIArranger.I = null;
GUIArranger.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(InterfaceVars.GameAnchors, new GameAnchors(this.gameAnchorUpLeft.transform,this.gameAnchorDownRight.transform))
}
;
GUIArranger.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(InterfaceVars.GUIArrangerSettings, this.OnGUIArrangerSettingsChanged, this)
}
;
GUIArranger.prototype.OnGUIArrangerSettingsChanged = function(param) {
    this.settings = param;
    if (this.settings != null)
        this.DoIt()
}
;
GUIArranger.prototype.Awake = function() {
    XTLink.prototype.Awake.call(this);
    GUIArranger.I = this
}
;
GUIArranger.prototype.DoIt = function() {
    if (Globals.isMobile) {
        this.CopyScreenAnchor(this.settings.logoTargetAnchorMobile, this.logoObjectAnchor);
        this.CopyArrangeableTransform(this.settings.logoTargetArrangeableMobile, this.logoObjectArrangeable);
        this.CopyTransform(this.settings.portraitTargets.TopBar, this.portraitObjects.TopBar);
        this.CopyTransform(this.settings.portraitTargets.TopBarBackground, this.portraitObjects.TopBarBackground);
        this.CopyTransform(this.settings.portraitTargets.DynamicContentV11, this.portraitObjects.DynamicContentV11);
        this.CopyColor(this.settings.portraitTargets.TopBarColor, this.portraitObjects.TopBarExtraSprite);
        this.CopyColor(this.settings.portraitTargets.BottomBarColor, this.portraitObjects.BottomBarExtraSprite);
        this.CopyTransform(this.settings.landscapeTargets.BottomBar, this.landscapeObjects.BottomBar);
        this.CopyArrangeableTransform(this.settings.gameAnchorUpLeftMobile, this.gameAnchorUpLeft);
        this.CopyArrangeableTransform(this.settings.gameAnchorDownRightMobile, this.gameAnchorDownRight);
        if (this.settings.applyToExtraElements) {
            this.CopyTransform(this.settings.portraitTargets.AutoplaySimpleWindow, this.portraitObjects.AutoplaySimpleWindow);
            this.CopyTransformLocalPosition(this.settings.portraitTargets.TournamentRankLocalPosition, this.portraitObjects.TournamentRankLocalPosition);
            for (var i = 0; i < this.portraitObjects.TournamentRankBackgrounds.length; ++i)
                this.CopyTransformLocalPosition(this.settings.portraitTargets.TournamentRankBackground, this.portraitObjects.TournamentRankBackgrounds[i])
        }
    } else {
        this.CopyScreenAnchor(this.settings.logoTargetAnchorDesktop, this.logoObjectAnchor);
        this.CopyArrangeableTransform(this.settings.logoTargetArrangeableDesktop, this.logoObjectArrangeable);
        this.CopyTransform(this.settings.gameAnchorUpLeftDesktop, this.gameAnchorUpLeft.gameObject);
        this.CopyTransform(this.settings.gameAnchorDownRightDesktop, this.gameAnchorDownRight.gameObject)
    }
}
;
GUIArranger.prototype.CopyTransform = function(src, dest) {
    if (src != null) {
        dest.transform.position(src.transform.position());
        dest.transform.localScale(src.transform.localScale())
    }
}
;
GUIArranger.prototype.CopyTransformLocalPosition = function(src, dest) {
    if (src != null) {
        dest.transform.localPosition(src.transform.localPosition());
        dest.transform.localScale(src.transform.localScale())
    }
}
;
GUIArranger.prototype.CopyArrangeableTransform = function(src, dest) {
    if (src != null) {
        this.CopyTransform(src.gameObject, dest.gameObject);
        dest.localPositionLandscape = src.localPositionLandscape;
        dest.localScaleLandscape = src.localScaleLandscape;
        dest.localPositionPortrait = src.localPositionPortrait;
        dest.localScalePortrait = src.localScalePortrait;
        dest.separateForIPhone = src.separateForIPhone;
        dest.localPositionIPhonePortrait = src.localPositionIPhonePortrait;
        dest.localScaleIPhonePortrait = src.localScaleIPhonePortrait;
        dest.separateForIPad = src.separateForIPad;
        dest.localPositionIPadPortrait = src.localPositionIPadPortrait;
        dest.localScaleIPadPortrait = src.localScaleIPadPortrait;
        dest.separateForLandscapeWide = src.separateForLandscapeWide;
        dest.localPositionLandscapeWide = src.localPositionLandscapeWide;
        dest.localScaleLandscapeWide = src.localScaleLandscapeWide;
        dest.separateForLandscapeWideFull = src.separateForLandscapeWideFull;
        dest.localPositionLandscapeWideFull = src.localPositionLandscapeWideFull;
        dest.localScaleLandscapeWideFull = src.localScaleLandscapeWideFull
    }
}
;
GUIArranger.prototype.CopyScreenAnchor = function(src, dest) {
    if (src != null) {
        this.CopyTransform(src.gameObject, dest.gameObject);
        dest.anchorLeft = src.anchorLeft;
        dest.leftOffset = src.leftOffset;
        dest.anchorRight = src.anchorRight;
        dest.rightOffset = src.rightOffset;
        dest.limitByGameAnchors = src.limitByGameAnchors
    }
}
;
GUIArranger.prototype.CopyColor = function(src, dest) {
    dest.color = src
}
;
GUIArranger.prototype.CopySprite = function(src, dest) {
    if (src != null && dest != null) {
        dest.atlas = src.atlas;
        dest.anchorX = src.anchorX;
        dest.anchorY = src.anchorY;
        dest.spriteType = src.spriteType;
        dest.SetSpriteName(src.spriteName)
    }
}
;
GUIArranger.prototype.CopySpriteSize = function(src, dest) {
    if (src != null && dest != null) {
        dest.width = src.width;
        dest.height = src.height
    }
}
;
GUIArranger.prototype.CopyBand = function(src, dest) {
    if (src == null || dest == null)
        return;
    dest.gameObject.SetActive(src.gameObject.activeSelf);
    if (dest.gameObject.activeSelf) {
        this.CopySpriteSize(src, dest);
        this.CopyTransform(src.gameObject, dest.gameObject)
    }
}
;
GUIArranger.prototype.ArrangeBlackBands = function() {
    var gUL = this.gameAnchorUpLeft.transform.localPosition();
    var gDR = this.gameAnchorDownRight.transform.localPosition();
    var sUL = this.screenAnchorUpLeft.transform.localPosition();
    var sDR = this.screenAnchorDownRight.transform.localPosition();
    var dU = Math.round(sUL.y - gUL.y);
    var dD = Math.round(sDR.y - gDR.y);
    var dL = Math.round(sUL.x - gUL.x);
    var dR = Math.round(sDR.x - gDR.x);
    var w = Math.round(sDR.x - sUL.x);
    var h = Math.round(sUL.y - sDR.y);
    this.blackBands.up.gameObject.SetActive(dU > 0);
    if (this.blackBands.up.gameObject.activeSelf) {
        this.blackBands.up.width = w;
        this.blackBands.up.height = dU
    }
    this.blackBands.down.gameObject.SetActive(dD < 0);
    if (this.blackBands.down.gameObject.activeSelf) {
        this.blackBands.down.width = w;
        this.blackBands.down.height = -dD
    }
    this.blackBands.left.gameObject.SetActive(dL < 0);
    if (this.blackBands.left.gameObject.activeSelf) {
        this.blackBands.left.height = h;
        this.blackBands.left.width = -dL
    }
    this.blackBands.right.gameObject.SetActive(dR > 0);
    if (this.blackBands.right.gameObject.activeSelf) {
        this.blackBands.right.height = h;
        this.blackBands.right.width = dR
    }
    XT.TriggerEvent(InterfaceVars.Evt_Internal_BlackBandsUpdated)
}
;
GUIArranger.InitBands = function(dest) {
    var I = GUIArranger.I;
    var src = I.blackBands;
    I.CopySprite(src.up, dest.up);
    I.CopySprite(src.down, dest.down);
    I.CopySprite(src.left, dest.left);
    I.CopySprite(src.right, dest.right)
}
;
GUIArranger.UpdateBands = function(dest) {
    var I = GUIArranger.I;
    var src = I.blackBands;
    I.CopyBand(src.up, dest.up);
    I.CopyBand(src.down, dest.down);
    I.CopyBand(src.left, dest.left);
    I.CopyBand(src.right, dest.right)
}
;
GUIArranger.prototype.ScreenAnchorUpdated = function() {
    this.screenAnchorUpdated = true
}
;
GUIArranger.prototype.LateUpdate = function() {
    if (this.screenAnchorUpdated) {
        this.ArrangeBlackBands();
        this.screenAnchorUpdated = false
    }
}
;
goog.require("UHT.Component");
var Nike_XTVariableType = {
    XT_Bool: 0,
    XT_Int: 1,
    XT_Float: 2,
    XT_Double: 3,
    XT_String: 4,
    None: 5
};
Nike_XTVariable.prototype = Object.create(Component.prototype);
Nike_XTVariable.prototype.constructor = Nike_XTVariable;
function Nike_XTVariable() {
    Component.call(this);
    this.variableType = Nike_XTVariableType.None;
    this.variableName = ""
}
Nike_XTVariable.prototype.JustDoIt = function(value) {
    switch (this.variableType) {
    case Nike_XTVariableType.XT_Bool:
        XT.SetBool(this.variableName, _bool.Parse(value));
        break;
    case Nike_XTVariableType.XT_Int:
        XT.SetInt(this.variableName, _number.otoi(value));
        break;
    case Nike_XTVariableType.XT_Float:
        XT.SetFloat(this.variableName, _number.otod(value));
        break;
    case Nike_XTVariableType.XT_Double:
        XT.SetDouble(this.variableName, _number.otod(value));
        break;
    case Nike_XTVariableType.XT_String:
        XT.SetString(this.variableName, value);
        break
    }
}
;
goog.require("UHT.XTLink");
PaytableArranger.prototype = Object.create(XTLink.prototype);
PaytableArranger.prototype.constructor = PaytableArranger;
function PaytableArranger() {
    XTLink.call(this);
    this.panelOver = null;
    this.panelUnder = null;
    this.zOrderNearer = null;
    this.zOrderFarther = null;
    this.updatePaytableLayer = false;
    this.paytableLayer = null;
    this.updatePaytablePosition = false;
    this.paytableLocalPosition = null
}
PaytableArranger.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackObject(Vars.MobilePaytableObject, this.OnPaytableChanged, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this)
}
;
PaytableArranger.prototype.OnPaytableChanged = function(paytable) {
    if (this.updatePaytablePosition)
        paytable.transform.localPosition(this.paytableLocalPosition);
    var back = paytable.transform.Find("Background");
    if (back != null)
        back.gameObject.SetActive(false);
    var colliders = paytable.GetComponentsInChildren(Collider, true);
    var minZ = 0;
    var maxZ = 0;
    for (var i = 0; i < colliders.length; ++i) {
        var cp = colliders[i].transform.position();
        var z = this.zOrderNearer.inverseTransformPoint(cp).z + colliders[i].center.z;
        if (i == 0 || z < minZ)
            minZ = z;
        z = this.zOrderFarther.inverseTransformPoint(cp).z + colliders[i].center.z;
        if (i == 0 || z > maxZ)
            maxZ = z
    }
    var pos = this.zOrderNearer.localPosition();
    this.zOrderNearer.localPosition(new UHTMath.Vector3(pos.x,pos.y,minZ - 1));
    pos = this.zOrderFarther.localPosition();
    this.zOrderFarther.localPosition(new UHTMath.Vector3(pos.x,pos.y,maxZ + 1));
    var minPanelDepth = this.panelUnder.depth;
    var maxPanelDepth = this.panelOver.depth;
    var panels = paytable.GetComponentsInChildren(UIPanel, true);
    for (var i = 0; i < panels.length; ++i) {
        if (panels[i].depth > maxPanelDepth)
            maxPanelDepth = panels[i].depth;
        if (panels[i].depth < minPanelDepth)
            minPanelDepth = panels[i].depth
    }
    if (this.panelOver.depth <= maxPanelDepth)
        this.panelOver.depth = maxPanelDepth + 1;
    if (this.panelUnder.depth >= minPanelDepth)
        this.panelUnder.depth = minPanelDepth - 1;
    if (this.updatePaytableLayer)
        Globals.SetLayerRecursively(paytable.gameObject, this.paytableLayer.value())
}
;
PaytableArranger.prototype.OnPressedPaytableOpen = function() {
    this.gameObject.SetActive(true)
}
;
PaytableArranger.prototype.OnPressedPaytableClose = function() {
    this.gameObject.SetActive(false)
}
;
var InterfaceVars = {
    IsMobileGUI: "IsMobileGUI",
    SelectedAutoSpinsIndex: "SelectedAutoSpinsIndex",
    SelectedAutoSpinsIndexAdvanced: "SelectedAutoSpinsIndexAdvanced",
    ExtraWinMultiplier: "ExtraWinMultiplier",
    GUIMessageZoneSettings: "GUIMessageZoneSettings",
    HasGUIMessageBeforeWinCount: "HasGUIMessageBeforeWinCount",
    GUIMessage_RandomSpin: "GUIMessage_RandomSpin",
    GUIMessage_RandomResultTeaser: "GUIMessage_RandomResultTeaser",
    LastResultHasNoWin: "LastResultHasNoWin",
    FSWinIsCounting: "FSWinIsCounting",
    Evt_DataToCode_CloseAllInterfaceWindows: "Evt_DataToCode_CloseAllInterfaceWindows",
    Evt_CodeToData_InterfaceWindowOpen: "Evt_CodeToData_InterfaceWindowOpen",
    EnableSoundsWhenReady: "EnableSoundsWhenReady",
    GUIArrangerSettings: "GUIArrangerSettings",
    Evt_DataToCode_HidePortraitMiddleBar: "Evt_DataToCode_HidePortraitMiddleBar",
    Evt_DataToCode_ShowPortraitMiddleBar: "Evt_DataToCode_ShowPortraitMiddleBar",
    ShowCoinsAndCashHint: "ShowCoinsAndCashHint",
    ShowFastPlayHint: "ShowFastPlayHint",
    Evt_Internal_BlackBandsUpdated: "Evt_Internal_BlackBandsUpdated",
    GameAnchors: "GameAnchors"
};
goog.require("UHT.Engine");
CustomNotificationButton.prototype = Object.create(Component.prototype);
CustomNotificationButton.prototype.constructor = CustomNotificationButton;
function CustomNotificationButton() {
    Component.call(this);
    this.label = null;
    this.cachedCamera = null;
    this.handlers = null
}
CustomNotificationButton.touchEndFrame = 0;
CustomNotificationButton.prototype.Awake = function() {
    globalColliderInputManager.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(this,this.OnTouchEnd))
}
;
CustomNotificationButton.prototype.UpdateButton = function(data) {
    var hasData = data != null;
    if (hasData) {
        this.handlers = data.handlers;
        this.label.text = _string.IsNullOrEmpty(data.label) ? "" : data.label
    }
    this.gameObject.SetActive(hasData);
    this.label.gameObject.SetActive(hasData)
}
;
CustomNotificationButton.prototype.OnTouchEnd = function() {
    if (CustomNotificationButton.touchEndFrame == Time.frameCount)
        return;
    if (!this.gameObject.activeInHierarchy || this.handlers == null)
        return;
    if (this.cachedCamera == null)
        this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    var mask = new LayerMask;
    mask.mask = 1 << this.gameObject.layer;
    if (this.gameObject.collider != globalColliderInputManager.getHoveredCollider(this.cachedCamera.ScreenToWorldPoint(Input.mousePosition), mask))
        return;
    for (var i = 0; i < this.handlers.length; ++i)
        this.handlers[i]();
    CustomNotificationButton.touchEndFrame = Time.frameCount
}
;
goog.require("UHT.XTLink");
var CustomNotificationVars = {
    CustomNotification: "CustomNotification",
    Evt_Internal_ShowIntrusiveNotification: "Evt_Internal_ShowIntrusiveNotification",
    Evt_Internal_HideIntrusiveNotification: "Evt_Internal_HideIntrusiveNotification",
    Evt_Internal_ShowNonIntrusiveNotification: "Evt_Internal_ShowNonIntrusiveNotification",
    Evt_Internal_HideNonIntrusiveNotification: "Evt_Internal_HideNonIntrusiveNotification"
};
CustomNotificationParser.prototype = Object.create(TournamentRule.prototype);
CustomNotificationParser.prototype.constructor = CustomNotificationParser;
function CustomNotificationParser() {
    TournamentRule.call(this)
}
CustomNotificationController.prototype = Object.create(XTLink.prototype);
CustomNotificationController.prototype.constructor = CustomNotificationController;
function CustomNotificationButtonsGroup() {
    this.buttons = null
}
CustomNotificationButtonsGroup.prototype.UpdateButtons = function(data) {
    if (data == null)
        for (var i = 0; i < this.buttons.length; ++i)
            this.buttons[i].UpdateButton(null);
    else
        for (var i = 0; i < this.buttons.length; ++i)
            this.buttons[i].UpdateButton(data[i])
}
;
function CustomNotificationExtraLayout() {
    this.scrollableList = null;
    this.parser = null;
    this.title = null;
    this.buttons = null;
    this.buttonsCat = null;
    this.textAnimator = null;
    this.responsiveLinesCat = null
}
function CustomNotificationController() {
    XTLink.call(this);
    this.defaultDelay = 7;
    this.lineDelay = 1.5;
    this.showShort = null;
    this.showLong = null;
    this.expandLong = null;
    this.hide = null;
    this.scrollableList = null;
    this.autoClicker = null;
    this.parser = null;
    this.title = null;
    this.buttons = null;
    this.useButtonsGroups = false;
    this.buttonsGroups = null;
    this.isIntrusive = false;
    this.textAnimator = null;
    this.hasExtraLayout = false;
    this.extraLayout = null;
    this.isResponsive = false;
    this.responsiveLinesCat = null;
    this.responsiveButtonsCat = null;
    this.responsiveMaxLabelWidths = null;
    this.ellipsis = " ...";
    this.mustHide = false;
    this.mustIgnoreInputBlocked = false;
    this.cachedCamera = null;
    this.notification = null
}
CustomNotificationController.prototype.XTRegisterCallbacks = function() {
    if (this.isIntrusive) {
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowIntrusiveNotification, this.ShowNotification, this);
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideIntrusiveNotification, this.HideNotification, this)
    } else {
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_ShowNonIntrusiveNotification, this.ShowNotification, this);
        XT.RegisterCallbackEvent(CustomNotificationVars.Evt_Internal_HideNonIntrusiveNotification, this.HideNotification, this)
    }
}
;
CustomNotificationController.prototype.Update = function() {
    if (this.notification != null) {
        this.InternalShowNotification();
        this.mustHide = false;
        this.notification = null
    }
    if (this.mustHide) {
        this.mustHide = false;
        this.hide.Start();
        if (this.isIntrusive)
            this.GetCamera().ignoreInputBlocked = false;
        if (this.autoClicker != null)
            this.autoClicker.enabled = false
    }
    if (this.mustIgnoreInputBlocked) {
        var camera = this.GetCamera();
        if (camera != null) {
            this.mustIgnoreInputBlocked = false;
            camera.ignoreInputBlocked = true
        }
    }
}
;
CustomNotificationController.prototype.HideNotification = function() {
    this.mustHide = true
}
;
CustomNotificationController.prototype.ShowNotification = function() {
    this.notification = XT.GetObject(CustomNotificationVars.CustomNotification)
}
;
CustomNotificationController.prototype.InternalShowNotification = function() {
    var btnsCount = 0;
    if (this.notification.buttons != null) {
        btnsCount = Math.min(this.useButtonsGroups ? this.buttonsGroups.length : this.buttons.length, this.notification.buttons.length);
        if (this.useButtonsGroups && btnsCount > 0)
            this.buttonsGroups[btnsCount - 1].UpdateButtons(this.notification.buttons);
        else
            for (var i = 0; i < btnsCount; ++i)
                this.buttons[i].UpdateButton(this.notification.buttons[i]);
        if (this.hasExtraLayout)
            for (var i = 0; i < btnsCount; ++i)
                this.extraLayout.buttons[i].UpdateButton(this.notification.buttons[i])
    }
    var titleText = _string.IsNullOrEmpty(this.notification.title) ? "" : this.notification.title;
    if (this.hasExtraLayout) {
        this.extraLayout.title.text = titleText;
        for (var i = btnsCount; i < this.extraLayout.buttons.length; ++i)
            this.extraLayout.buttons[i].UpdateButton(null);
        this.extraLayout.parser.rules = "";
        this.extraLayout.parser.UpdateRules(this.notification.text);
        while (!this.extraLayout.parser.isSplit)
            this.extraLayout.parser.Split();
        this.extraLayout.scrollableList.SetValues(this.extraLayout.parser.splitRules);
        this.extraLayout.buttonsCat.StartEvent(btnsCount);
        this.extraLayout.textAnimator.Sample(this.extraLayout.parser.splitRules.length / this.extraLayout.parser.maxNumberOfLines);
        if (this.isResponsive)
            this.extraLayout.responsiveLinesCat.StartEvent(Math.min(this.extraLayout.parser.splitRules.length, this.extraLayout.parser.maxNumberOfLines))
    }
    if (this.useButtonsGroups) {
        for (var i = 0; i < btnsCount - 1; ++i)
            this.buttonsGroups[i].UpdateButtons(null);
        for (var i = btnsCount; i < this.buttonsGroups.length; ++i)
            this.buttonsGroups[i].UpdateButtons(null)
    } else
        for (var i = btnsCount; i < this.buttons.length; ++i)
            this.buttons[i].UpdateButton(null);
    if (this.isResponsive) {
        this.parser.maxLabelWidth = this.responsiveMaxLabelWidths[btnsCount];
        this.title.width = this.responsiveMaxLabelWidths[btnsCount]
    }
    this.title.text = titleText;
    this.parser.rules = "";
    this.parser.UpdateRules(this.notification.text);
    while (!this.parser.isSplit)
        this.parser.Split();
    var shortCount = Math.min(this.showShort.length, this.parser.splitRules.length);
    var lines = [];
    for (var i = 0; i < shortCount; ++i)
        lines.push(this.parser.splitRules[i]);
    var isLong = this.parser.splitRules.length > this.showShort.length;
    if (isLong && shortCount > 0)
        lines[shortCount - 1] = this.GetTextWithEllipsis(lines[shortCount - 1]);
    this.UpdateAutoClickerDelay(this.defaultDelay);
    this.scrollableList.SetValues(lines.length > 0 ? lines : this.parser.splitRules);
    (isLong ? this.showLong : this.showShort[this.parser.splitRules.length - 1]).Start();
    if (this.textAnimator != null)
        this.textAnimator.Sample(this.parser.splitRules.length / this.parser.maxNumberOfLines);
    if (this.isResponsive) {
        this.responsiveLinesCat.StartEvent(Math.min(this.parser.splitRules.length, this.parser.maxNumberOfLines));
        this.responsiveButtonsCat.StartEvent(btnsCount)
    }
    if (this.isIntrusive)
        this.mustIgnoreInputBlocked = true
}
;
CustomNotificationController.prototype.ShowMore = function() {
    this.UpdateAutoClickerDelay(Math.max(this.defaultDelay, this.lineDelay * this.parser.splitRules.length));
    this.scrollableList.SetValues(this.parser.splitRules);
    this.expandLong[UHTMath.clamp(this.parser.splitRules.length - 1, 0, this.expandLong.length - 1)].Start()
}
;
CustomNotificationController.prototype.UpdateAutoClickerDelay = function(delay) {
    if (this.autoClicker == null)
        return;
    this.autoClicker.delay = delay;
    this.autoClicker.delayInAutoplay = delay;
    this.autoClicker.enabled = true;
    this.autoClicker.gameObject.SetActive(false);
    this.autoClicker.gameObject.SetActive(true)
}
;
CustomNotificationController.prototype.GetTextWithEllipsis = function(text) {
    this.parser.sampleLabel.text = text + this.ellipsis;
    if (this.parser.sampleLabel.width <= this.parser.maxLabelWidth)
        return this.parser.sampleLabel.text;
    var split = text.split(" ");
    var ret = null;
    if (split.length > 1) {
        var words = [];
        for (var i = 0; i < split.length; ++i) {
            words.push(split[i]);
            this.parser.sampleLabel.text = words.join(" ") + this.ellipsis;
            if (this.parser.sampleLabel.width > this.parser.maxLabelWidth)
                break;
            ret = this.parser.sampleLabel.text
        }
    }
    if (ret == null)
        ret = text.substr(0, text.length - this.ellipsis.length) + this.ellipsis;
    return ret
}
;
CustomNotificationController.prototype.CloseButtonClicked = function() {
    window["SystemMessageManager"]["CloseMessage"]()
}
;
CustomNotificationController.prototype.GetCamera = function() {
    if (this.cachedCamera == null)
        this.cachedCamera = Globals.GetCameraForObject(this.gameObject);
    return this.cachedCamera
}
;
goog.require("UHT.FOXLink");
function PayingSymbol() {
    this.id;
    this.amount;
    this.positions = []
}
var PayingSymbolVars = {
    PayingSymbols: "PayingSymbols",
    PayingSymbolIsScatter: "PayingSymbolIsScatter",
    PayingSymbolsScatterIndex: "PayingSymbolsScatterIndex",
    CurrentDisplayedPayingSymbolIndex: "CurrentDisplayedPayingSymbolIndex",
    Evt_Internal_ShowPayingSymbol: "Evt_Internal_ShowPayingSymbol",
    Evt_Internal_HidePayingSymbol: "Evt_Internal_HidePayingSymbol"
};
PayingSymbolFOX.prototype = Object.create(FOXLink.prototype);
PayingSymbolFOX.prototype.constructor = PayingSymbolFOX;
function PayingSymbolFOX() {
    FOXLink.call(this);
    this.payingSymbols = []
}
PayingSymbolFOX.prototype.XTInitVariablesAndEvents = function() {
    XT.SetObject(PayingSymbolVars.PayingSymbols, this.payingSymbols)
}
;
PayingSymbolFOX.prototype.HandleResponse = function(dict) {
    this.payingSymbols.splice(0);
    var scatterIdx = -1;
    if (dict["psym"] != undefined) {
        var symbols = null;
        if (dict["s"] != undefined)
            symbols = _array.ConvertAll(dict["s"].split(","), _number.otoi);
        var args = dict["psym"].split(";");
        for (var i = 0; i < args.length; ++i) {
            var arg = args[i].split("~");
            if (arg.length > 1) {
                var s = new PayingSymbol;
                s.id = _number.otoi(arg[0]);
                s.amount = _number.otod(arg[1]);
                s.positions = arg.length > 2 ? _array.ConvertAll(arg[2].split(","), _number.otoi) : this.FindPositions(symbols, s.id);
                this.payingSymbols.push(s);
                if (s.id == 1)
                    scatterIdx = i
            }
        }
    }
    XT.SetInt(PayingSymbolVars.PayingSymbolsScatterIndex, scatterIdx);
    XT.SetBool(PayingSymbolVars.PayingSymbolIsScatter, this.payingSymbols.length == 1 && scatterIdx == 0)
}
;
PayingSymbolFOX.prototype.FindPositions = function(symbols, id) {
    var ret = [];
    if (symbols != null)
        for (var i = 0; i < symbols.length; ++i)
            if (symbols[i] == id)
                ret.push(i);
    return ret
}
;
PayingSymbolFOX.prototype.HandleInitResponse = function(param) {
    this.HandleResponse(param)
}
;
PayingSymbolFOX.prototype.HandleSpinResponse = function(param) {
    this.HandleResponse(param)
}
;
goog.require("UHT.XTLink");
ClockDisplayer.prototype = Object.create(XTLink.prototype);
ClockDisplayer.prototype.constructor = ClockDisplayer;
function ClockDisplayer() {
    XTLink.call(this);
    this.hoursLabel = null;
    this.separatorLabel = null;
    this.minutesLabel = null;
    this.initialTimeZone = "";
    this.synchedTime = 0;
    this.useSynchedTime = false;
    this.isSynched = false
}
ClockDisplayer.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.Jurisdiction_Clock_Server, this.OnJurisdictionClockServerChanged, this);
    XT.RegisterCallbackDouble(Vars.Jurisdiction_ServerTime, this.OnServerTimeChanged, this);
    if (window["Intl"] != undefined)
        this.initialTimeZone = (new Intl.DateTimeFormat).resolvedOptions().timeZone
}
;
ClockDisplayer.prototype.OnJurisdictionClockServerChanged = function(param) {
    this.useSynchedTime = param
}
;
ClockDisplayer.prototype.OnServerTimeChanged = function(param) {
    this.synchedTime = param;
    this.isSynched = true
}
;
ClockDisplayer.prototype.UpdateTime = function() {
    var d = new Date;
    if (this.useSynchedTime && this.isSynched)
        if (this.initialTimeZone == "" || this.initialTimeZone == undefined || window["Date"]["toLocaleString"] == undefined)
            d = new Date(this.synchedTime);
        else
            d = new Date((new Date(this.synchedTime)).toLocaleString("en-US", {
                timeZone: this.initialTimeZone
            }));
    this.hoursLabel.text = d.getHours();
    var minutes = d.getMinutes();
    this.minutesLabel.text = minutes > 9 ? minutes : "0" + minutes
}
;
ClockDisplayer.prototype.Update = function() {
    this.UpdateTime();
    this.synchedTime += Time.deltaTime * 1E3
}
;
goog.require("UHT.XTLink");
JurisdictionClock.prototype = Object.create(XTLink.prototype);
JurisdictionClock.prototype.constructor = JurisdictionClock;
function JurisdictionClock() {
    XTLink.call(this)
}
JurisdictionClock.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.Jurisdiction_Clock, this.OnJurisdictionClockChanged, this)
}
;
JurisdictionClock.prototype.OnJurisdictionClockChanged = function(param) {
    this.gameObject.SetActive(param)
}
;
goog.require("UHT.XTLink");
JurisdictionClientRevision.prototype = Object.create(XTLink.prototype);
JurisdictionClientRevision.prototype.constructor = JurisdictionClientRevision;
function JurisdictionClientRevision() {
    XTLink.call(this);
    this.valueLabel = null;
    this.isActive = false
}
JurisdictionClientRevision.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_ClientRevision, this.OnJurisdictionInfoChanged, this)
}
;
JurisdictionClientRevision.prototype.OnJurisdictionInfoChanged = function(param) {
    this.isActive = param
}
;
JurisdictionClientRevision.prototype.OnPressedPaytableOpen = function() {
    if (this.isActive)
        this.gameObject.SetActive(true)
}
;
JurisdictionClientRevision.prototype.OnPressedPaytableClose = function() {
    if (this.isActive)
        this.gameObject.SetActive(false)
}
;
JurisdictionClientRevision.prototype.OnGameInit = function() {
    this.valueLabel.text = UHT_REVISION.common
}
;
goog.require("UHT.XTLink");
JurisdictionGameSymbol.prototype = Object.create(XTLink.prototype);
JurisdictionGameSymbol.prototype.constructor = JurisdictionGameSymbol;
function JurisdictionGameSymbol() {
    XTLink.call(this);
    this.valueLabel = null;
    this.isActive = false
}
JurisdictionGameSymbol.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableOpen, this.OnPressedPaytableOpen, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_PaytableClose, this.OnPressedPaytableClose, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, this.OnGameInit, this);
    XT.RegisterCallbackBool(Vars.Jurisdiction_GameSymbol, this.OnJurisdictionInfoChanged, this)
}
;
JurisdictionGameSymbol.prototype.OnJurisdictionInfoChanged = function(param) {
    this.isActive = param
}
;
JurisdictionGameSymbol.prototype.OnPressedPaytableOpen = function() {
    if (this.isActive)
        this.gameObject.SetActive(true)
}
;
JurisdictionGameSymbol.prototype.OnPressedPaytableClose = function() {
    if (this.isActive)
        this.gameObject.SetActive(false)
}
;
JurisdictionGameSymbol.prototype.OnGameInit = function() {
    this.valueLabel.text = UHT_GAME_CONFIG["GAME_SYMBOL"]
}
;
goog.require("UHT.Engine");
goog.require("UHT.XTLink");
LineByLineSkipper.prototype = Object.create(XTLink.prototype);
LineByLineSkipper.prototype.constructor = LineByLineSkipper;
function LineByLineSkipper() {
    XTLink.call(this)
}
LineByLineSkipper.prototype.XTRegisterCallbacks = function() {
    XT.RegisterCallbackBool(Vars.LastWinIsCounting, this.OnLastWinIsCounting, this);
    XT.RegisterCallbackEvent(Vars.Evt_Internal_SpinStarted, this.OnSpinStarted, this)
}
;
LineByLineSkipper.prototype.OnDestroy = function() {
    XT.UnregisterCallbackBool(this.OnLastWinIsCounting, this);
    XT.UnregisterCallbackEvent(this.OnSpinStarted, this)
}
;
LineByLineSkipper.prototype.OnLastWinIsCounting = function(b) {
    if (!b)
        return;
    if (!XT.GetBool(Vars.Jurisdiction_LineByLineGlobal) && !XT.GetBool(Vars.Jurisdiction_LineByLineFreespin))
        return;
    var fsr = XT.GetObject(Vars.ReceivedFreeSpinsResponse);
    if (fsr.IsFreeSpin || XT.GetInt(Vars.AutoplaySpinsLeft) != -1)
        this.gameObject.SetActive(true)
}
;
LineByLineSkipper.prototype.ClickedLineByLineSkipperCollider = function() {
    var rqm = XT.GetObject(Vars.RQManagerObject);
    var markerIndexes = [];
    for (var i = 0; i < rqm.rqiList.length; i++)
        if (rqm.rqiList[i].constructor.name == "RQIMarker")
            markerIndexes.push(i);
    while (markerIndexes.length > 0) {
        var tmp = rqm.rqiList[markerIndexes[0]];
        if (tmp.type == RQIMarker.MarkerType.StartLineByLine) {
            rqm.rqiList.splice(markerIndexes[0], markerIndexes[1] - markerIndexes[0]);
            markerIndexes.splice(0, 2)
        } else {
            rqm.rqiList.splice(0, markerIndexes[0]);
            markerIndexes.splice(0, 1)
        }
    }
    XT.TriggerEvent(Vars.Evt_Internal_FinalizeDisplayedWin);
    XT.TriggerEvent(Vars.Evt_DataToCode_Pressed_Spin);
    this.gameObject.SetActive(false)
}
;
LineByLineSkipper.prototype.OnSpinStarted = function() {
    this.gameObject.SetActive(false)
}
;
LineByLineSkipper.prototype.ActivateOnFSResume = function() {
    if (!XT.GetBool(Vars.Jurisdiction_LineByLineGlobal) && !XT.GetBool(Vars.Jurisdiction_LineByLineFreespin))
        this.gameObject.SetActive(false)
}
;
goog.require("UHT.VSGameStateManager");
goog.require("UHT.PaytableSymbolPayout_Ways");
goog.require("UHT.Engine");
AGCCController.prototype = Object.create(Component.prototype);
AGCCController.prototype.constructor = AGCCController;
function AGCCController() {
    Component.call(this);
    this.image = null
}
AGCCController.prototype.Update = function() {
    if (UHT_GAME_CONFIG != null) {
        this.image.SetActive(UHT_GAME_CONFIG["jurisdictionMsg"] == "imageAGCC");
        this.gameObject.SetActive(false)
    }
}
;
goog.require("UHT.Engine");
AnimatedScaledBar.prototype = Object.create(Component.prototype);
AnimatedScaledBar.prototype.constructor = AnimatedScaledBar;
function AnimatedScaledBar() {
    Component.call(this);
    this.target = null;
    this.clip = null
}
AnimatedScaledBar.prototype.Scale = function(scale) {
    var animationState = this.target.GetAnimationState(this.clip.name);
    animationState.enabled = true;
    animationState.weight = 1;
    animationState.time = scale * animationState.length;
    this.target.Sample();
    animationState.enabled = false
}
;
goog.require("UHT.Engine");
ClientLoader.prototype = Object.create(Component.prototype);
ClientLoader.prototype.constructor = ClientLoader;
var UHT_LOADER_DEBUG = false;
function ClientLoader() {
    Component.call(this);
    this.scaledBar = null;
    this.minTimeForLoader = 0;
    this.percentLabel = null;
    this.shouldHide = -1;
    this.timeSpentInLoader = 0;
    this.canStartImport = false;
    this.curScale = 0;
    this.maxDeltaScale = .01;
    this.animatedBars = null;
    this.tryToHide = false
}
ClientLoader.progressPercent = 0;
ClientLoader.prototype.Start = function() {
    UHTEngine.StartDownloadingMainGame(this, "OnGameDownloaded", "OnRequestToHideLoader");
    this.scaledBar.transform.localScale(0, 1, 1);
    for (var i = 0; i < this.animatedBars.length; ++i)
        this.animatedBars[i].Scale(0);
    this.percentLabel.gameObject.SetActive(false);
    UHTEngine.HideFirstLoader()
}
;
ClientLoader.prototype.OnGameDownloaded = function() {
    this.canStartImport = true
}
;
ClientLoader.prototype.OnRequestToHideLoader = function() {
    this.tryToHide = true
}
;
function padLeft(nr, n, str) {
    return Array(n - String(nr).length + 1).join(str || "0") + nr
}
ClientLoader.prototype.Update = function() {
    this.timeSpentInLoader += Time.deltaTime;
    if (this.timeSpentInLoader < this.minTimeForLoader)
        return;
    this.percentLabel.gameObject.SetActive(true);
    LoaderProgress.Download_Total = UHT_GAME_SIZE;
    if (LoaderProgress.Download_AlreadyDownloaded == -1) {
        LoaderProgress.Download_Weight *= 1 - (LoaderProgress.Download_Current + 1) / (LoaderProgress.Download_Total + 1);
        LoaderProgress.GameAndSound_Download_Weight *= 1 - (LoaderProgress.Download_Current + 1) / (LoaderProgress.Download_Total + 1);
        LoaderProgress.Download_AlreadyDownloaded = LoaderProgress.Download_Current
    }
    if (LoaderProgress.Download_SoundAlreadyDownloaded == -1) {
        LoaderProgress.Sound_Download_Weight *= 1 - (LoaderProgress.Sound_Download_Current + 1) / (LoaderProgress.Sound_Download_Total + 1);
        LoaderProgress.Download_SoundAlreadyDownloaded = LoaderProgress.Sound_Download_Current
    }
    if (globalResourcesNeededList.length != 0 || UHTEngine.WaitingForSounds())
        this.shouldHide = -1;
    else if (this.tryToHide && this.shouldHide < 0)
        this.shouldHide = 5;
    if (this.canStartImport) {
        this.canStartImport = false;
        UHTEngine.StartImportingMainGame()
    }
    if (this.shouldHide != 0) {
        var DL_Total = 0;
        var DL_Loaded = 0;
        for (var j = 0; j < globalResourcesNeededInfo.length; j++) {
            if (globalResourcesNeededInfo[j].baseTexture.source.downloadSizeTotal == undefined) {
                if (globalResourcesNeededInfo[j].valid)
                    DL_Loaded++;
                DL_Total++;
                continue
            }
            var loaded = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeLoaded;
            var total = globalResourcesNeededInfo[j].baseTexture.source.downloadSizeTotal;
            DL_Loaded += loaded;
            if (total == -1)
                DL_Total = -1;
            else if (DL_Total != -1)
                DL_Total += total
        }
        if (DL_Total > 0) {
            LoaderProgress.Blocking_Current = DL_Loaded;
            LoaderProgress.Blocking_Total = DL_Total
        }
        if (this.tryToHide)
            if (LoaderProgress.Blocking_Total == -1 && globalResourcesNeededInfo.length == 0) {
                LoaderProgress.Blocking_Current = 1;
                LoaderProgress.Blocking_Total = 1
            }
        if (LoaderProgress.InitConnection_Visual < LoaderProgress.InitConnection_Current)
            LoaderProgress.InitConnection_Visual += .2;
        LoaderProgress.Sound_Download_Weight = 0;
        LoaderProgress.Download_Weight = LoaderProgress.GameAndSound_Download_Weight;
        var Total_Weight = LoaderProgress.Download_Weight + (window["UHT_ForceClickForSounds"] != undefined ? 0 : UHT_DEVICE_TYPE.DESKTOP ? LoaderProgress.Sound_Download_Weight : 0) + LoaderProgress.Import_Weight + LoaderProgress.Import_Textures_Weight + LoaderProgress.InitConnection_Weight + LoaderProgress.Localize_Weight + LoaderProgress.Blocking_Weight + LoaderProgress.SymbolsManagers_Weight + .02;
        var realScale = 0;
        realScale += ((LoaderProgress.Download_Current - LoaderProgress.Download_AlreadyDownloaded + 1) / (LoaderProgress.Download_Total - LoaderProgress.Download_AlreadyDownloaded + 1) * (1 - LoaderProgress.Download_Retried_LockedPercent) + LoaderProgress.Download_Retried_LockedPercent) * (LoaderProgress.Download_Weight / Total_Weight);
        if (UHT_DEVICE_TYPE.DESKTOP && LoaderProgress.Sound_Download_Total != -1)
            realScale += (LoaderProgress.Sound_Download_Current - LoaderProgress.Download_SoundAlreadyDownloaded + 1) / (LoaderProgress.Sound_Download_Total - LoaderProgress.Download_SoundAlreadyDownloaded + 1) * (LoaderProgress.Sound_Download_Weight / Total_Weight);
        if (LoaderProgress.Import_Total != -1)
            realScale += LoaderProgress.Import_Current / LoaderProgress.Import_Total * (LoaderProgress.Import_Weight / Total_Weight);
        if (LoaderProgress.Import_Textures_Total != -1) {
            var texturesProgress = LoaderProgress.Import_Textures_Current / LoaderProgress.Import_Textures_Total;
            texturesProgress = UHTMath.clamp(texturesProgress, 0, 1);
            realScale += texturesProgress * (LoaderProgress.Import_Textures_Weight / Total_Weight)
        }
        realScale += LoaderProgress.InitConnection_Visual / LoaderProgress.InitConnection_Total * (LoaderProgress.InitConnection_Weight / Total_Weight);
        realScale += LoaderProgress.Localize_Current / LoaderProgress.Localize_Total * (LoaderProgress.Localize_Weight / Total_Weight);
        if (LoaderProgress.Blocking_Total != -1)
            realScale += LoaderProgress.Blocking_Current / LoaderProgress.Blocking_Total * (LoaderProgress.Blocking_Weight / Total_Weight);
        if (LoaderProgress.SymbolsManagers_Total != -1)
            realScale += LoaderProgress.SymbolsManagers_Current / LoaderProgress.SymbolsManagers_Total * (LoaderProgress.SymbolsManagers_Weight / Total_Weight);
        var delta = realScale - this.curScale;
        if (delta < 0)
            delta = 0;
        if (delta > this.maxDeltaScale * (2.5 / delta) * realScale)
            delta = this.maxDeltaScale * (2.5 / delta) * realScale;
        this.curScale += delta;
        if (UHT_LOADER_DEBUG)
            UHT_DEBUG_TEXT = "\nLP:   " + Number(realScale).toFixed(2) + "      " + Number(this.curScale).toFixed(2) + "      " + "\n  IC " + padLeft(LoaderProgress.Import_Current, 6, " ") + "/" + padLeft(LoaderProgress.Import_Total, 6, " ") + "\n  IT " + padLeft(LoaderProgress.Import_Textures_Current, 6, " ") + "/" + padLeft(LoaderProgress.Import_Textures_Total, 6, " ") + "\n       CC " + padLeft(LoaderProgress.InitConnection_Current, 1, " ") + "  CV " + Number(LoaderProgress.InitConnection_Visual).toFixed(2) + "  CT " + padLeft(LoaderProgress.InitConnection_Total, 1, " ") + "\n       LC " + padLeft(LoaderProgress.Localize_Current, 1, " ") + "/" + padLeft(LoaderProgress.Localize_Total, 1, " ") + "\n       BLOCK " + padLeft(LoaderProgress.Blocking_Current, 10, " ") + "  BT " + padLeft(LoaderProgress.Blocking_Total, 10, " ") + "\n       SM " + padLeft(LoaderProgress.SymbolsManagers_Current, 3, " ") + "/" + padLeft(LoaderProgress.SymbolsManagers_Total, 3, " ") + "\n       DL " + padLeft(LoaderProgress.Download_Current, 8, " ") + "/" + padLeft(LoaderProgress.Download_Total, 8, " ")
    }
    if (this.shouldHide == 0) {
        this.gameObject.SetActive(false);
        UHTEngine.SignalLoaderIsHidden();
        LoadingStep = 4;
        globalTracking.StartTimer("uht_loading", "_CLOSED_at_PLAYING", "LoadingTracker");
        globalTracking.StopTimerAndSend("uht_loading", "_3_game_opening_and_connecting", "LoadingTracker");
        var timer = globalTracking.GetTimerValue("uht_loading", "_3_game_opening_and_connecting", "LoadingTracker");
        globalTracking.SendEvent("uht_loading", "_3_game_opening_and_connecting", timer, "LoadingTracker");
        globalTracking.StopTimerAndSend("uht_loading", "_4_loading_total_time", "LoadingTracker");
        var timer_all = globalTracking.GetTimerValue("uht_loading", "_4_loading_total_time", "LoadingTracker");
        globalTracking.SendEvent("uht_loading", "_4_loading_total_time", timer_all, "LoadingTracker");
        globalTracking.SendEvent("uht_behaviour", "Session_started", Renderer.IsWebGL ? 1 : 0, "BehaviourTracker");
        globalTracking.StartTimer("uht_behaviour", "Session_timer", "BehaviourTracker");
        UHTInterfaceBOSS.PostMessage("gameLoadingEnded");
        window["RC2API"]["PostMessage"]("gameLoaded");
        window["RC_timer"] = (new Date).getTime();
        window["RC_sessionTimer"] = window["RC_timer"];
        if (UHT_GAME_CONFIG["rcSettings"] != null)
            if (UHT_GAME_CONFIG["rcSettings"]["elapsed"] != undefined)
                window["RC_sessionTimer"] -= UHT_GAME_CONFIG["rcSettings"]["elapsed"] * 6E4
    } else if (this.shouldHide > 0) {
        this.shouldHide--;
        if (this.curScale + this.shouldHide * .004 < 1)
            this.curScale += .004
    }
    this.curScale = UHTMath.clamp(this.curScale, 0, 1);
    var adjustedScale = this.curScale < .5 ? .5 - 2 * (.5 - this.curScale) * (.5 - this.curScale) : 2 * (this.curScale - .5) * (this.curScale - .5) + .5;
    this.scaledBar.transform.localScale(adjustedScale, 1, 1);
    for (var i = 0; i < this.animatedBars.length; ++i)
        this.animatedBars[i].Scale(adjustedScale);
    var clampedScale = UHTMath.clamp(adjustedScale, .01, 1);
    this.percentLabel.text = Math.round(clampedScale * 100).toString() + "%";
    this.percentLabel.mFillGradient.colorKeys[1].time = UHTMath.clamp(clampedScale - .1, .1, .9);
    this.percentLabel.mFillGradient.colorKeys[2].time = UHTMath.clamp(clampedScale + .1, .1, .9);
    ClientLoader.progressPercent = clampedScale
}
;
goog.require("UHT.Engine");
ClientLoaderAnimation.prototype = Object.create(Component.prototype);
ClientLoaderAnimation.prototype.constructor = ClientLoaderAnimation;
function ClientLoaderAnimation() {
    Component.call(this);
    this.framePrefix = "";
    this.dt = .1;
    this.digits = 2;
    this.sprite = null;
    this.oframe = -1;
    this.frame = 0;
    this.animTime = 0
}
ClientLoaderAnimation.prototype.AddDigits = function(s) {
    while (s.length < this.digits)
        s = "0" + s;
    return s
}
;
ClientLoaderAnimation.prototype.SetFrame = function() {
    this.sprite.color.a = 1
}
;
ClientLoaderAnimation.prototype.Update = function() {
    if (UHTScreen.height < 600)
        this.frame = 32;
    else
        this.frame = 33;
    this.SetFrame()
}
;
goog.require("UHT.Engine");
FullscreenVisual.prototype = Object.create(Component.prototype);
FullscreenVisual.prototype.constructor = FullscreenVisual;
function FullscreenVisual() {
    Component.call(this);
    this.catShow = null;
    this.catHide = null;
    this.mustShow = false;
    this.isShown = false;
    UHTEventBroker.AddHandler(UHTEventBroker.Type.Game, new UHTEventBroker.Handler(this,this.OnGameEvent))
}
FullscreenVisual.prototype.OnGameEvent = function(param) {
    var args = JSON.parse(param);
    switch (args["common"]) {
    case "EVT_FULLSCREEN_OVERLAY_SHOWN":
        this.mustShow = true;
        break;
    case "EVT_FULLSCREEN_OVERLAY_HIDDEN":
        this.mustShow = false;
        break
    }
}
;
FullscreenVisual.prototype.Update = function() {
    if (this.mustShow != this.isShown) {
        if (this.catShow.IsRunning())
            this.catShow.Stop();
        if (this.catHide.IsRunning())
            this.catHide.Stop();
        (this.mustShow ? this.catShow : this.catHide).Start();
        this.isShown = this.mustShow
    }
}
;
goog.require("UHT.Engine");
LoaderScaler.prototype = Object.create(Component.prototype);
LoaderScaler.prototype.constructor = LoaderScaler;
function LoaderScaler() {
    Component.call(this);
    this.curWidth = -1;
    this.curHeight = -1;
    this.background = null
}
LoaderScaler.prototype.Update = function() {
    if (UHTScreen.width != this.curWidth || UHTScreen.height != this.curHeight) {
        this.curWidth = UHTScreen.width;
        this.curHeight = UHTScreen.height;
        if (this.curWidth >= this.curHeight) {
            console.log("-- Loader - Landscape!");
            this.gameObject.transform.localScale(1.5, 1.5, 1.5);
            if (this.background != null)
                this.background.transform.localScale(1, 1, 1)
        } else if (this.curWidth < this.curHeight) {
            console.log("-- Loader - Portrait!");
            this.gameObject.transform.localScale(1.6, 1.6, 1.6);
            if (this.background != null)
                this.background.transform.localScale(1, 2, 1)
        }
    }
}
;
goog.require("UHT.Engine");
SpriteSizeProxy.prototype = Object.create(Component.prototype);
SpriteSizeProxy.prototype.constructor = SpriteSizeProxy;
function SpriteSizeProxy() {
    Component.call(this);
    this.sprite = null;
    this.width = -1;
    this.height = -1;
    this.curWidth = -1;
    this.curHeight = -1
}
SpriteSizeProxy.prototype.Update = function() {
    if (this.width != this.curWidth) {
        this.sprite.width = this.width;
        this.curWidth = this.width
    }
    if (this.height != this.curHeight) {
        this.sprite.height = this.height;
        this.curHeight = this.height
    }
}
;
goog.require("UHT.Engine");
goog.require("UHT.EventManager");
goog.require("UHT.VSGameStateManager");
var BVAPI = {};
BVAPI.isMobile = false;
BVAPI.BVFrame = null;
BVAPI.BVWindow = null;
BVAPI.canvas = null;
BVAPI.isFirstUpdate = true;
BVAPI.isXTInit = false;
BVAPI.isResultShown = false;
BVAPI.spinCycleWin = 0;
BVAPI.gameReady = false;
BVAPI.overlayReady = false;
BVAPI.postGameReady = false;
BVAPI.postGameActive = false;
BVAPI.postGameIdle = false;
BVAPI.stopGame = false;
BVAPI.restartGame = false;
BVAPI.isGamePaused = false;
BVAPI.isGameIdle = false;
BVAPI.ReceiveMessage = function(event) {
    if (!(event instanceof Object))
        return;
    var msg = String(event["data"]);
    if (msg == "restartGame")
        BVAPI.restartGame = true;
    else if (msg == "stopGame")
        BVAPI.stopGame = true;
    else if (msg == "overlayReady" || msg == "rcFrameLoaded")
        BVAPI.overlayReady = BVAPI.postGameReady = true
}
;
BVAPI.VSGameStates = [VSGameState.Result, VSGameState.ResultBonusRounds];
BVAPI.VSGameStatesAutoplay = [VSGameState.ResultAutoplay, VSGameState.ResultBonusRoundsAutoplay];
BVAPI.PauseGame = function(pause) {
    if (pause == BVAPI.isGamePaused)
        return;
    BVAPI.isGamePaused = pause;
    Globals.GamePaused = pause;
    if (!SystemMessageManager.IsMessageOpen())
        UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
            common: pause ? "EVT_MESSAGE_OPENED" : "EVT_MESSAGE_CLOSED",
            args: null
        }));
    SystemMessageManager.SetHiddenMode(pause);
    if (BVAPI.canvas == null)
        BVAPI.canvas = document.getElementsByTagName("canvas")[0];
    if (BVAPI.canvas != null)
        BVAPI.canvas.classList[pause ? "add" : "remove"]("paused");
    if (pause) {
        XT.SetInt(Vars.AutoplaySpinsLeft, -1);
        var idx = BVAPI.VSGameStatesAutoplay.indexOf(VSGameStateManager.GetState());
        if (idx > -1)
            VSGameStateManager.ChangeTo(BVAPI.VSGameStates[idx])
    }
    if (BVAPI.isMobile)
        BVAPI.OnUHTResize()
}
;
BVAPI.PostMessage = function(message) {
    if (BVAPI.BVWindow != null && BVAPI.BVWindow.postMessage instanceof Function)
        BVAPI.BVWindow.postMessage(message, "*")
}
;
BVAPI.UHTInterfaceBOSS_PostMessage = null;
BVAPI.UHTInterfaceBOSS_PostMessage_Override = function(message) {
    if (message == "gameRoundStarted")
        BVAPI.postGameActive = true;
    else if (message == "gameRoundEnded")
        BVAPI.postGameIdle = true;
    if (UHTInterfaceBOSS.enabled)
        BVAPI.UHTInterfaceBOSS_PostMessage(message)
}
;
BVAPI.OnFOXInitReceived = function() {
    var params = XT.GetObject(FOXVars.FOX_Response) || {};
    BVAPI.postGameIdle = params["na"] == "s" && params["fs"] == undefined && params["fs_total"] == undefined && params["rs"] == undefined;
    BVAPI.postGameActive = !BVAPI.postGameIdle
}
;
BVAPI.OnXTGameInit = function() {
    BVAPI.gameReady = true
}
;
BVAPI.OnXTUpdateDisplayedWinInUI = function() {
    var win = XT.GetDouble(Vars.SpinCycleWinReceived);
    if (win <= 0 || win == BVAPI.spinCycleWin)
        BVAPI.isResultShown = true;
    BVAPI.spinCycleWin = win
}
;
BVAPI.OnXTLastWinIsCountingChanged = function(isCounting) {
    var win = XT.GetDouble(Vars.SpinCycleWinReceived);
    if (win > 0 && !isCounting)
        BVAPI.isResultShown = true
}
;
BVAPI.OnUHTBeforeUpdate = function() {
    if (BVAPI.isXTInit && BVAPI.overlayReady && BVAPI.gameReady) {
        if (BVAPI.stopGame) {
            BVAPI.stopGame = false;
            BVAPI.PauseGame(true);
            if (BVAPI.isGameIdle)
                BVAPI.PostMessage("gameIdle")
        }
        if (BVAPI.restartGame) {
            BVAPI.restartGame = false;
            BVAPI.PauseGame(false)
        }
    }
}
;
BVAPI.OnUHTUpdate = function() {
    if (BVAPI.isFirstUpdate) {
        BVAPI.isFirstUpdate = false;
        if (BVAPI.isMobile)
            BVAPI.OnUHTResize()
    }
    if (!BVAPI.isXTInit && XT.RegisterAndInitDone) {
        BVAPI.isXTInit = true;
        XT.RegisterCallbackEvent(FOXVars.Evt_FOX_InitReceived, BVAPI.OnFOXInitReceived, BVAPI);
        XT.RegisterCallbackBool(Vars.LastWinIsCounting, BVAPI.OnXTLastWinIsCountingChanged, BVAPI);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_UpdateDisplayedWinInUI, BVAPI.OnXTUpdateDisplayedWinInUI, BVAPI);
        XT.RegisterCallbackEvent(Vars.Evt_Internal_GameInit, BVAPI.OnXTGameInit, BVAPI)
    }
    if (BVAPI.isXTInit && BVAPI.overlayReady && BVAPI.gameReady) {
        if (BVAPI.postGameReady) {
            BVAPI.postGameReady = false;
            BVAPI.PostMessage("gameReady")
        }
        if (BVAPI.postGameIdle && BVAPI.isResultShown) {
            BVAPI.isGameIdle = true;
            BVAPI.postGameIdle = BVAPI.isResultShown = false;
            BVAPI.PostMessage("gameIdle")
        }
        if (BVAPI.postGameActive) {
            BVAPI.isGameIdle = false;
            BVAPI.postGameActive = false;
            BVAPI.PostMessage("gameActive")
        }
    }
}
;
BVAPI.OnUHTResize = function() {
    var styles = [];
    styles.push(["width:", BVAPI.isGamePaused ? window.innerWidth : 0, "px"].join(""));
    styles.push(["height:", BVAPI.isGamePaused ? window.innerHeight : 0, "px"].join(""));
    BVAPI.BVFrame.setAttribute("style", styles.join(";"))
}
;
BVAPI.Init = function() {
    if (UHT_GAME_CONFIG_SRC["externalOverlay_BV"] == null)
        return;
    BVAPI.isMobile = UHT_DEVICE_TYPE.MOBILE;
    if (BVAPI.isMobile) {
        var frame = document.createElement("iframe");
        frame.name = "BVFrame";
        frame.className = "rciframe_visible";
        frame.setAttribute("frameborder", "0");
        frame.setAttribute("allowtransparency", "true");
        document.body.appendChild(frame);
        BVAPI.BVWindow = window.open(UHT_GAME_CONFIG_SRC["externalOverlay_BV"], frame.name);
        BVAPI.BVFrame = frame;
        BVAPI.OnUHTResize();
        EventManager.AddHandler("EVT_UHT_RESIZE", BVAPI.OnUHTResize, BVAPI)
    } else {
        BVAPI.BVWindow = window.parent;
        BVAPI.overlayReady = BVAPI.postGameReady = true
    }
    window.addEventListener("message", BVAPI.ReceiveMessage, false);
    EventManager.AddHandler("EVT_UHT_BEFOREUPDATE", BVAPI.OnUHTBeforeUpdate, BVAPI);
    EventManager.AddHandler("EVT_UHT_UPDATE", BVAPI.OnUHTUpdate, BVAPI);
    BVAPI.UHTInterfaceBOSS_PostMessage = UHTInterfaceBOSS.PostMessage;
    UHTInterfaceBOSS.PostMessage = BVAPI.UHTInterfaceBOSS_PostMessage_Override
}
;
BVAPI.Init();
var CustomMsgManager = {};
CustomMsgManager.HistoryHandler = function() {
    if (UHT_GAME_CONFIG["openHistoryInTab"])
        window.open(UHT_GAME_CONFIG["HISTORY"]);
    else
        (new GameHistoryWindow).Open()
}
;
CustomMsgManager.OpenHandler = function(url) {
    window.open(url)
}
;
CustomMsgManager.AjaxHandler = function(param) {
    var request = new ServerRequest;
    request.Url = param.url;
    if (param.wait)
        request.Handler = new EventHandler(null,CustomMsgManager.OnAjaxResponse);
    RequestManager.AddRequest(request, true)
}
;
CustomMsgManager.OnAjaxResponse = function(response, statusCode) {
    if (statusCode == 200)
        SystemMessageManager.CloseMessage()
}
;
CustomMsgManager.SendLogout = function() {
    var xhr = new XMLHttpRequest;
    xhr.open("POST", UHT_GAME_CONFIG["LOGOUT"], true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4)
            if (xhr.responseText == "OK")
                SystemMessageManager.CloseGame();
            else
                setTimeout(function() {
                    CustomMsgManager.SendLogout()
                }, 2E3)
    }
    ;
    xhr.send()
}
;
CustomMsgManager.NotifyHandler = function(message) {
    if (window.top != window)
        UHTInterfaceBOSS.PostMessageRec(window.parent, message);
    SystemMessageManager.CloseMessage()
}
;
CustomMsgManager.HandleResponse = function(response, params) {
    var messages = params["custom_msg"];
    if (messages == undefined) {
        var args;
        try {
            args = JSON.parse(response)
        } catch (e) {
            args = {}
        }
        messages = args["custom_msg"];
        if (messages == undefined)
            return
    }
    try {
        messages = decodeURIComponent(atob(String(messages)).split("").map(function(c) {
            return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)
        }).join(""))
    } catch (e) {}
    try {
        messages = JSON.parse(String(messages))
    } catch (e) {}
    if (!(messages instanceof Array))
        return;
    var isI11 = !UHT_CONFIG.MINI_MODE;
    for (var i = 0; i < messages.length; ++i) {
        var message = messages[i];
        message.id = "msg" + UID.Generate();
        var classNames = ["sys-msg", "custom"];
        if (message["title"] == undefined) {
            message["title"] = isI11 ? SystemMessageManager.LocalizedText("WindowTitle") : "";
            classNames.push("no-title")
        }
        message["title"] = SystemMessageManager.ProcessText(message["title"]);
        message.className = classNames.join(" ");
        message["text"] = SystemMessageManager.ProcessText(String(message["text"]));
        if (!isI11 && message["nonIntrusive"] != true)
            message["text"] = message["text"].replace(/\n/g, "<br>");
        var options = message["options"];
        if (options == undefined)
            if (message["nonIntrusive"] == true)
                options = [];
            else
                options = [{
                    label: SystemMessageManager.LocalizedText("BtContinuePlaying"),
                    action: "continue"
                }];
        for (var j = 0; j < options.length; ++j) {
            var option = options[j];
            var handlers;
            var action = option["action"];
            if (action == "quit")
                handlers = [SystemMessageManager.CloseGame];
            if (action == "continue")
                handlers = [SystemMessageManager.CloseMessage];
            if (action == "logout")
                handlers = [CustomMsgManager.SendLogout];
            if (action == "history")
                if (UHT_GAME_CONFIG["HISTORY"] == null)
                    action = "link";
                else
                    handlers = [SystemMessageManager.CloseMessage, CustomMsgManager.HistoryHandler];
            if (action == "link") {
                var linkType = option["linkType"];
                var url = option["url"];
                if (linkType == "redirect")
                    handlers = [SystemMessageManager.GetBtnClickHandler([SystemMessageManager.Reload], url)];
                if (linkType == "open")
                    handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.OpenHandler], url)];
                if (linkType == "openAndCloseMessage")
                    handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.OpenHandler, SystemMessageManager.CloseMessage], url)];
                if (linkType == "ajax")
                    handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.AjaxHandler, SystemMessageManager.CloseMessage], {
                        url: url,
                        wait: false
                    })];
                if (linkType == "ajaxResponse")
                    handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.AjaxHandler], {
                        url: url,
                        wait: true
                    })];
                if (linkType == "ajaxClose")
                    handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.AjaxHandler, SystemMessageManager.CloseGame], {
                        url: url,
                        wait: true
                    })];
                if (linkType == "notify")
                    handlers = [SystemMessageManager.GetBtnClickHandler([CustomMsgManager.NotifyHandler], url)]
            }
            var label = SystemMessageManager.ProcessText(option["label"]);
            if (label == undefined)
                if (action == "quit")
                    label = SystemMessageManager.LocalizedText("BtCLOSE");
                else if (action == "continue")
                    label = SystemMessageManager.LocalizedText("BtContinuePlaying");
                else if (action == "history")
                    label = SystemMessageManager.LocalizedText("BtRCHistory");
                else
                    label = SystemMessageManager.LocalizedText("BtOK");
            option.id = "";
            option.label = label;
            option.handlers = handlers
        }
        message.buttons = options;
        delete message["options"];
        message.equals = function() {
            return false
        }
    }
    SystemMessageManager.canShowMessage = false;
    for (var i = messages.length - 1; i >= 0; --i)
        SystemMessageManager.ShowMessage(messages[i].id, false, messages[i].text, null, messages[i]);
    SystemMessageManager.canShowMessage = true;
    SystemMessageManager.InternalShowMessage()
}
;
var RC1API = {};
RC1API.enabled = false;
RC1API.ReceiveMessage = function(event) {
    if (typeof event != "object")
        return;
    if (event["data"] != undefined)
        if (event["data"] != null)
            if (typeof event["data"] == "string")
                if (event["data"].indexOf("{") != -1) {
                    var msg = null;
                    try {
                        msg = JSON.parse(event["data"])
                    } catch (e) {
                        console.warn("unknown message:" + event["data"]);
                        return
                    }
                    if (msg.type == "Tilt")
                        window["globalMustStopAutoplay"] = true
                }
}
;
RC1API.PauseRC = function() {
    if (RC1API.enabled)
        window.postMessage(JSON.stringify({
            "type": "status",
            "payload": {
                "freeSpins": "true"
            }
        }), "*")
}
;
RC1API.ReinstateRC = function() {
    if (RC1API.enabled)
        window.postMessage(JSON.stringify({
            "type": "status",
            "payload": {
                "freeSpins": "false"
            }
        }), "*")
}
;
RC1API.Init = function() {
    window.addEventListener("message", RC1API.ReceiveMessage, false);
    if (UHT_GAME_CONFIG["rcSettings"] == null)
        return;
    RC1API.enabled = UHT_GAME_CONFIG["rcSettings"]["rctype"] == "RC1"
}
;
RC1API.Init();
var RC2API = {};
RC2API.enabled = false;
RC2API.rciframe = null;
RC2API.rciwindow = null;
RC2API.isGamePaused = false;
RC2API.ReceiveMessage = function(event) {
    if (!RC2API.enabled)
        return;
    if (typeof event != "object" || typeof event["data"] != "object")
        return;
    var method = event.data["method"];
    var params = event.data["params"];
    switch (method) {
    case "operatorLoaded":
        break;
    case "confirmHandshake":
        if (typeof params == "object")
            RC2API.PostMessage(String(params["success"]));
        break;
    case "pauseGame":
        if (typeof params == "object") {
            var return_data = params["return_data"]instanceof Array ? params["return_data"] : [];
            var callbackArgs = {};
            if (return_data.indexOf("session_id") > -1)
                callbackArgs["session_id"] = UHT_GAME_CONFIG["rcSettings"]["session_id"];
            if (return_data.indexOf("game_name") > -1)
                callbackArgs["game_name"] = UHT_GAME_CONFIG["rcSettings"]["game_name"];
            if (return_data.indexOf("user_id") > -1)
                callbackArgs["user_id"] = UHT_GAME_CONFIG["rcSettings"]["user_id"];
            if (!RC2API.isGamePaused) {
                if (!SystemMessageManager.IsMessageOpen())
                    UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                        common: "EVT_MESSAGE_OPENED",
                        args: null
                    }));
                SystemMessageManager.SetHiddenMode(true);
                RC2API.isGamePaused = true;
                RC2API.rciframe.className = "rciframe_visible"
            }
            RC2API.PostMessage(String(params["callback"]), callbackArgs)
        }
        break;
    case "resumeGame":
        if (RC2API.isGamePaused) {
            RC2API.isGamePaused = false;
            RC2API.rciframe.className = "rciframe_hidden";
            if (!SystemMessageManager.IsMessageOpen())
                UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                    common: "EVT_MESSAGE_CLOSED",
                    args: null
                }));
            SystemMessageManager.SetHiddenMode(false)
        }
        break;
    case "navigateTo":
        if (typeof params == "object" && typeof params["url"] == "string")
            location.href = params["url"];
        break
    }
}
;
RC2API.PostMessage = function(method, params) {
    if (RC2API.rciwindow != null)
        RC2API.rciwindow.postMessage({
            method: method,
            params: params
        }, "*")
}
;
RC2API.HandleResize = function() {
    var styles = [];
    styles.push(["width:", window.innerWidth, "px"].join(""));
    styles.push(["height:", window.innerHeight, "px"].join(""));
    RC2API.rciframe.setAttribute("style", styles.join(";"))
}
;
RC2API.Init = function() {
    if (UHT_GAME_CONFIG["rcSettings"] == null)
        return;
    RC2API.enabled = UHT_GAME_CONFIG["rcSettings"]["rctype"] == "RC2";
    if (RC2API.enabled) {
        var frame = document.createElement("iframe");
        frame.name = "rciframe";
        frame.className = "rciframe_hidden";
        frame.setAttribute("frameborder", "0");
        frame.setAttribute("allowtransparency", "true");
        document.body.appendChild(frame);
        RC2API.rciwindow = window.open(UHT_GAME_CONFIG["rcSettings"]["rciframeurl"], frame.name);
        RC2API.rciframe = frame;
        RC2API.HandleResize();
        window.addEventListener("message", RC2API.ReceiveMessage, false);
        window.addEventListener("resize", RC2API.HandleResize, false)
    }
}
;
RC2API.Init();
goog.provide("UHT.SystemMessageHelpers");
var SystemMessageType = {
    NoMoney: "NoMoney",
    Frozen: "Frozen",
    Reload: "Reload",
    Disabled: "Disabled",
    Techbreak: "Techbreak",
    GameAvailableOnlyAtRealMode: "GameAvailableOnlyAtRealMode",
    ProgressiveJackpotGamesAvailableOnlyAtRealMode: "ProgressiveJackpotGamesAvailableOnlyAtRealMode",
    SaveSettingError: "SaveSettingError",
    LostConnect: "LostConnect",
    PleaseLogin: "PleaseLogin",
    UseGoogleChrome: "UseGoogleChrome",
    UseSafari: "UseSafari",
    Timeout: "Timeout",
    ClientRegulation: "ClientRegulation",
    Regulation: "Regulation"
};
var SystemMessageFrozenError = {
    t0: "UNKNOWN",
    t1: "COULD_NOT_RESTORE_WITH_FRB",
    t2: "INVALID_SESSION",
    t3: "RETRY_REQUEST_ERROR",
    t4: "POSTPONED_WIN_ERROR",
    t5: "GAME_CONFIGURATION_ERROR",
    t6: "EXTERNAL_SERVICE_ERROR",
    t7: "SERVER_OBJECT_NOT_FOUND",
    t8: "EXPIRED_SESSION"
};
var SystemMessageFrozenInfo = {
    t100: "PLAYER_FROZEN",
    t101: "PLAYER_LIMIT_REACHED",
    t102: "DISABLED_GAME",
    t103: "RTP_CHANGED"
};
function SystemMessageData(type, text, args) {
    this.type = type;
    this.text = text;
    this.args = args;
    this.id = ""
}
SystemMessageData.prototype.equals = function(data) {
    return this.type == data.type && this.text == data.text && this.args == data.args
}
;
var RCContinueURL;
var RCCloseURL;
var RCHistoryURL;
var RCContinueURL_Type;
var RCCloseURL_Type;
function SystemMessageSettings(type) {
    switch (type) {
    case SystemMessageType.NoMoney:
        return {
            id: "NoMoney",
            buttons: [{
                id: "BtOK",
                handlers: [SystemMessageManager.CloseMessage]
            }]
        };
    case SystemMessageType.Frozen:
    case SystemMessageType.Disabled:
        return {
            id: "Frozen",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.Reload:
        return {
            id: "ServerError",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.Techbreak:
        return {
            id: "Techbreak",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.GameAvailableOnlyAtRealMode:
        return {
            id: "GameAvailableOnlyAtRealMode",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.ProgressiveJackpotGamesAvailableOnlyAtRealMode:
        return {
            id: "ProgressiveJackpotGamesAvailableOnlyAtRealMode",
            title: "ProgressiveJackpotGames",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.SaveSettingError:
        return {
            id: "SaveSettingError",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.LostConnect:
        return {
            id: "LostConnect",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.PleaseLogin:
        return {
            id: "PleaseLogin",
            buttons: UHT_DEVICE_TYPE.DESKTOP ? [] : [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }]
        };
    case SystemMessageType.UseGoogleChrome:
        return {
            id: "UseGoogleChrome",
            title: "UnsupportedBrowserTitle",
            buttons: [{
                id: "BtOK",
                handlers: [SystemMessageManager.CloseMessage]
            }]
        };
    case SystemMessageType.UseSafari:
        return {
            id: "UseSafari",
            title: "UnsupportedBrowserTitle",
            buttons: [{
                id: "BtOK",
                handlers: [SystemMessageManager.CloseMessage]
            }]
        };
    case SystemMessageType.Timeout:
        return {
            id: "Timeout",
            buttons: Globals.isMobile ? [{
                id: "BtCLOSE",
                handlers: [SystemMessageManager.CloseGame]
            }] : []
        };
    case SystemMessageType.ClientRegulation:
        var rc_buttons = [];
        var i;
        var continue_found = false;
        if (UHT_GAME_CONFIG["rcSettings"]["buttons"] != undefined)
            for (i = 0; i < UHT_GAME_CONFIG["rcSettings"]["buttons"].length; i++)
                if (UHT_GAME_CONFIG["rcSettings"]["buttons"][i].action == "continue") {
                    continue_found = true;
                    RCContinueURL = UHT_GAME_CONFIG["rcSettings"]["buttons"][i].url;
                    RCContinueURL_Type = UHT_GAME_CONFIG["rcSettings"]["buttons"][i]["rcContinueType"];
                    rc_buttons.push({
                        id: "BtContinuePlaying",
                        handlers: [SystemMessageManager.RCContinue]
                    })
                }
        if (!continue_found)
            rc_buttons.push({
                id: "BtContinuePlaying",
                handlers: [SystemMessageManager.RCCloseMessage]
            });
        if (UHT_GAME_CONFIG["rcSettings"]["buttons"] != undefined)
            for (i = 0; i < UHT_GAME_CONFIG["rcSettings"]["buttons"].length; i++)
                if (UHT_GAME_CONFIG["rcSettings"]["buttons"][i].action == "history") {
                    var url = UHT_GAME_CONFIG["rcSettings"]["buttons"][i].url;
                    if (url != "")
                        RCHistoryURL = url;
                    rc_buttons.push({
                        id: "BtRCHistory",
                        handlers: [SystemMessageManager.RCHistory]
                    })
                }
        if (UHT_GAME_CONFIG["rcSettings"]["buttons"] != undefined)
            for (i = 0; i < UHT_GAME_CONFIG["rcSettings"]["buttons"].length; i++)
                if (UHT_GAME_CONFIG["rcSettings"]["buttons"][i].action == "exit") {
                    RCCloseURL = UHT_GAME_CONFIG["rcSettings"]["buttons"][i].url;
                    RCCloseURL_Type = UHT_GAME_CONFIG["rcSettings"]["buttons"][i]["rcCloseType"];
                    rc_buttons.push({
                        id: "BtCLOSE",
                        handlers: [SystemMessageManager.RCClose]
                    })
                }
        return {
            id: "ClientRegulation",
            buttons: rc_buttons
        };
    case SystemMessageType.Regulation:
        var rc_rbuttons = [{
            id: "BtContinuePlaying",
            handlers: [SystemMessageManager.RegulationContinuePressed]
        }, {
            id: "BtRCHistory",
            handlers: [SystemMessageManager.RCHistory]
        }, {
            id: "BtStopPlaying",
            handlers: [SystemMessageManager.RegulationStopPressed]
        }];
        return {
            id: "Regulation",
            buttons: rc_rbuttons
        }
    }
    return null
}
var ScaleHelper = {};
ScaleHelper.ScaleContent = function() {
    var scaleRootHeight = 999;
    var zoom = 1;
    if (window.innerWidth > window.innerHeight)
        zoom = window.innerHeight / scaleRootHeight;
    else
        zoom = window.innerWidth / scaleRootHeight;
    var styles = ["-moz-transform: scale(VAL)", "-webkit-transform: scale(VAL)", "-ms-transform: scale(VAL)", "-o-transform: scale(VAL)", "transform: scale(VAL)"];
    if (UHT_DEVICE_TYPE.DESKTOP)
        zoom = zoom > 1 ? 1 : zoom;
    for (var i = 0; i < styles.length; ++i)
        styles[i] = styles[i].replace("VAL", zoom);
    styles.push("width:" + window.innerWidth / zoom + "px");
    styles.push("margin-top:" + (window.innerHeight - scaleRootHeight * zoom) / 2 + "px");
    document.getElementById("ScaleRoot").setAttribute("style", styles.join(";"))
}
;
ScaleHelper.Init = function() {
    ScaleHelper.ScaleContent();
    window.addEventListener("resize", ScaleHelper.ScaleContent, false)
}
;
ScaleHelper.Init();
goog.require("UHT.SystemMessageHelpers");
goog.require("UHT.Tracking");
var SystemMessageManager = {};
SystemMessageManager.OS = {
    iOS: "iOS",
    Android: "Android"
};
SystemMessageManager.os = null;
SystemMessageManager.root = null;
SystemMessageManager.scaleRoot = null;
SystemMessageManager.defaultTexts = null;
SystemMessageManager.localizedTexts = null;
SystemMessageManager.initialized = false;
SystemMessageManager.showMessageTimeout = null;
SystemMessageManager.messagesToShow = [];
SystemMessageManager.shownMessages = [];
SystemMessageManager.browserWarningShownCallback = null;
SystemMessageManager.regulationType = null;
SystemMessageManager.isHiddenMode = false;
SystemMessageManager.msgOpenWasTriggered = false;
SystemMessageManager.fontName = "Tahoma";
SystemMessageManager.msgFontLoaded = {};
SystemMessageManager.canShowMessage = true;
SystemMessageManager.handleNoMoney = true;
SystemMessageManager.OnLoad = function() {
    var mng = SystemMessageManager;
    UHTEventBroker.AddHandler(UHTEventBroker.Type.Wrapper, new UHTEventBroker.Handler(mng,mng.HandleWrapperEvent));
    mng.LoadLocalizedMessages()
}
;
SystemMessageManager.CheckUserAgent = function(browserWarningShown, callback, object) {
    if (window.navigator.userAgent == "Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230")
        return;
    SystemMessageManager.browserWarningShownCallback = new UHTEventBroker.Handler(object,callback);
    var parser = new UAParser2;
    var browser = parser.getBrowser();
    var os = parser.getOS();
    if (os.name == SystemMessageManager.OS.Android) {
        SystemMessageManager.os = SystemMessageManager.OS.Android;
        if (browser.name != "Chrome")
            SystemMessageManager.ShowMessage(SystemMessageType.UseGoogleChrome)
    } else if (os.name == SystemMessageManager.OS.iOS) {
        SystemMessageManager.os = SystemMessageManager.OS.iOS;
        if (!browserWarningShown)
            if (browser.name != "Mobile Safari")
                SystemMessageManager.ShowMessage(SystemMessageType.UseSafari)
    }
}
;
SystemMessageManager.LoadLocalizedMessages = function() {
    var allMsg = JSON.parse(String(UHT_SYSTEM_MESSAGES).replace(/\n/g, "<br>"));
    var defaultLocale = "en";
    var locale = UHT_CONFIG.LANGUAGE;
    if (allMsg[locale] != undefined) {
        SystemMessageManager.locale = locale;
        SystemMessageManager.localizedTexts = SystemMessageManager.Merge(allMsg[defaultLocale], allMsg[locale]);
        console.log("Localized messages found for locale " + locale)
    } else {
        SystemMessageManager.locale = defaultLocale;
        SystemMessageManager.localizedTexts = allMsg[defaultLocale];
        console.warn("Localized messages not found, locale " + locale)
    }
    SystemMessageManager.initialized = true;
    UHT_SYSTEM_MESSAGES = null;
    var deferredLoading = document.getElementById("DeferredLoadingText");
    if (deferredLoading != null)
        deferredLoading.innerHTML = SystemMessageManager.LocalizedText("DeferredLoading")
}
;
SystemMessageManager.Merge = function(src, override) {
    var result = {};
    for (var key in src)
        result[key] = src[key];
    for (var key in override)
        result[key] = override[key];
    return result
}
;
SystemMessageManager.HandleWrapperEvent = function(json) {
    var params = JSON.parse(json);
    var msg = params["common"];
    var args = params["args"];
    switch (msg) {
    case "EVT_HTTP_RESPONSE":
        SystemMessageManager.HandleHttpResponse(args);
        return;
    case "EVT_SHOW_MESSAGE":
        SystemMessageManager.HandleShowMessage(args);
        return
    }
}
;
SystemMessageManager.HandleHttpResponse = function(args) {
    var mng = SystemMessageManager;
    var mt = SystemMessageType;
    var httpCode = Number(args["httpCode"]);
    if (httpCode != 200)
        return;
    var data = args["data"];
    if (data == undefined)
        return;
    if (data.indexOf("unlogged") != -1) {
        mng.ShowMessage(mt.PleaseLogin, true);
        return
    }
    var variables = {};
    var pairs = String(data).split("&");
    for (var i = 0; i < pairs.length; ++i) {
        var pair = pairs[i].split("=");
        variables[pair[0]] = pair[1] || ""
    }
    if (mng.handleNoMoney && variables["nomoney"] != undefined && Number(variables["nomoney"]) == 1) {
        UHTInterfaceBOSS.PostMessage("balanceTooLow");
        mng.ShowMessage(mt.NoMoney)
    } else if (variables["frozen"] != undefined) {
        var decodeError = SystemMessageFrozenError["t" + variables["msg_code"]] || "";
        var decodeInfo = SystemMessageFrozenInfo["t" + variables["msg_code"]] || "";
        var outStr = "BAD_CODE_" + variables["msg_code"] + "_" + variables["frozen"];
        if (decodeError != "")
            outStr = "ERROR_" + decodeError;
        if (decodeInfo != "")
            outStr = "INFO_" + decodeInfo;
        globalTracking.SendEvent("uht_server_errors", "Frozen_" + outStr, loaderIsVisible ? 1 : 0, "ServerErrorsTracker");
        mng.ShowMessage(mt.Frozen, true, variables["frozen"])
    } else if (variables["reload"] != undefined)
        mng.ShowMessage(mt.Reload, true, variables["reload"], variables["link"]);
    else if (variables["disabled"] != undefined)
        mng.ShowMessage(mt.Disabled, true, variables["disabled"]);
    else if (variables["techbreak"] == 2)
        mng.ShowMessage(mt.Techbreak, true);
    else if (variables["msg_code"] != undefined) {
        var code = Number(variables["msg_code"]);
        if (code == 1)
            mng.ShowMessage(mt.GameAvailableOnlyAtRealMode, true);
        else if (code == 2)
            mng.ShowMessage(mt.ProgressiveJackpotGamesAvailableOnlyAtRealMode, true)
    } else if (variables["regulation"] != undefined) {
        mng.regulationType = variables["regulation"];
        mng.ShowMessage(mt.Regulation, false, variables["msg"])
    }
    CustomMsgManager.HandleResponse(data, variables)
}
;
SystemMessageManager.HandleShowMessage = function(args) {
    var msgType = args["message"] || "";
    switch (msgType) {
    case "ALERT_CANT_SAVE_SETTINGS":
        globalTracking.SendEvent("uht_server_errors", SystemMessageType.SaveSettingError, loaderIsVisible ? 1 : 0, "ServerErrorsTracker");
        break;
    case "ALERT_CONNECTION_LOST":
        SystemMessageManager.ShowMessage(SystemMessageType.LostConnect, true);
        break
    }
}
;
var TimeoutWindowShown = false;
SystemMessageManager.ShowMessage = function(type, unlogged, text, args, customMsg) {
    if (TimeoutWindowShown)
        return;
    var isCustom = customMsg != undefined;
    if (!isCustom && type != SystemMessageType.Frozen)
        globalTracking.SendEvent("uht_server_errors", type, loaderIsVisible ? 1 : 0, "ServerErrorsTracker");
    if (unlogged == true)
        UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
            common: "UNLOGGED",
            type: "html5"
        }));
    var mng = SystemMessageManager;
    if (type != undefined) {
        var data = isCustom ? customMsg : new SystemMessageData(type,text || null,args);
        if (!mng.MessageExists(data))
            mng.messagesToShow.push(data)
    }
    if (!mng.initialized) {
        mng.showMessageTimeout = setTimeout(mng.ShowMessage, 200);
        return
    }
    if (mng.showMessageTimeout != null) {
        clearTimeout(mng.showMessageTimeout);
        mng.showMessageTimeout = null
    }
    if (mng.root == null)
        mng.InitRootElements();
    if (mng.messagesToShow.length == 0)
        return;
    for (var i = 0; i < mng.messagesToShow.length; ++i) {
        var options = isCustom ? customMsg : SystemMessageSettings(mng.messagesToShow[i].type);
        if (options == null)
            continue;
        var isI11 = !UHT_CONFIG.MINI_MODE;
        if (isI11 && !isCustom) {
            for (var j = 0; j < options.buttons.length; ++j)
                options.buttons[j].label = mng.LocalizedText(options.buttons[j].id);
            mng.messagesToShow[i].buttons = options.buttons;
            mng.messagesToShow[i].title = mng.LocalizedText(options.title || "WindowTitle");
            mng.messagesToShow[i].text = mng.messagesToShow[i].text != null ? mng.ProcessText(mng.messagesToShow[i].text) : mng.LocalizedText(options.id)
        }
        mng.messagesToShow[i].id = options.id;
        mng.scaleRoot.appendChild(mng.CreateMessage(mng.messagesToShow[i], options, isCustom))
    }
    if (!SystemMessageManager.isHiddenMode)
        mng.shownMessages = mng.shownMessages.concat(mng.messagesToShow);
    mng.messagesToShow = [];
    mng.InternalShowMessage()
}
;
SystemMessageManager.InternalShowMessage = function() {
    var mng = SystemMessageManager;
    if (mng.root == null)
        mng.InitRootElements();
    var rootStyle = "sys-msg-root-hidden";
    var msg = null;
    if (!XT.RegisterAndInitDone) {
        setTimeout(mng.InternalShowMessage, 100);
        return
    }
    if (mng.canShowMessage && mng.shownMessages.length > 0 && !mng.isHiddenMode) {
        msg = mng.shownMessages[mng.shownMessages.length - 1];
        var topMsgId = msg.id;
        if (msg["nonIntrusive"] == true) {
            mng.TriggerMessageClosed();
            XT.SetObject(CustomNotificationVars.CustomNotification, msg);
            XT.TriggerEvent(CustomNotificationVars.Evt_Internal_ShowNonIntrusiveNotification)
        } else {
            var isI11 = !UHT_CONFIG.MINI_MODE;
            if (isI11) {
                XT.SetObject(CustomNotificationVars.CustomNotification, msg);
                XT.TriggerEvent(CustomNotificationVars.Evt_Internal_ShowIntrusiveNotification)
            } else {
                if (!mng.msgFontLoaded[topMsgId]) {
                    setTimeout(mng.InternalShowMessage, 100);
                    return
                }
                rootStyle = ["sys-msg-root-visible", topMsgId].join(" ")
            }
            if (!mng.msgOpenWasTriggered) {
                UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                    common: "EVT_MESSAGE_OPENED",
                    args: null
                }));
                mng.msgOpenWasTriggered = true
            }
            if (topMsgId == "UseSafari")
                mng.BrowserWarningShown()
        }
    }
    mng.root.className = rootStyle;
    if (msg != null && msg.isCustom)
        msg.element.style.top = (563 - msg.element.clientHeight) * .5 + "px"
}
;
SystemMessageManager.SetHiddenMode = function(hidden) {
    SystemMessageManager.isHiddenMode = hidden;
    SystemMessageManager.InternalShowMessage()
}
;
SystemMessageManager.IsMessageOpen = function() {
    var mng = SystemMessageManager;
    var messageShown = mng.shownMessages.length > 0;
    if (messageShown)
        if (mng.shownMessages[mng.shownMessages.length - 1]["nonIntrusive"] == true)
            messageShown = false;
    return messageShown || SystemMessageManager.messagesToShow.length > 0 || RC2API.isGamePaused
}
;
SystemMessageManager.RCContinue = function() {
    if (RCContinueURL_Type == "notify") {
        var xhr = new XMLHttpRequest;
        xhr.open("GET", RCContinueURL, true);
        xhr.send(null);
        SystemMessageManager.RCCloseMessage()
    } else
        location.href = RCContinueURL
}
;
SystemMessageManager.RCClose = function() {
    if (RCCloseURL != undefined)
        if (RCCloseURL_Type == "notify") {
            var xhr = new XMLHttpRequest;
            xhr.open("GET", RCCloseURL, true);
            xhr.send(null);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
                common: "EVT_CLOSE_GAME",
                args: null
            }))
        } else
            location.href = RCCloseURL;
    else
        UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
            common: "EVT_CLOSE_GAME",
            args: null
        }))
}
;
SystemMessageManager.RCHistory = function() {
    var oGH = ServerOptions.gameHistory;
    if (RCHistoryURL != undefined)
        ServerOptions.gameHistory = RCHistoryURL;
    if (UHT_GAME_CONFIG_SRC["externalHistoryUrl"] != undefined)
        ServerOptions.gameHistory = UHT_GAME_CONFIG_SRC["externalHistoryUrl"];
    if (UHT_GAME_CONFIG_SRC["openHistoryInWindow"])
        window.location.assign(ServerOptions.gameHistory);
    else if (UHT_GAME_CONFIG["openHistoryInTab"])
        window.open(ServerOptions.gameHistory);
    else
        (new GameHistoryWindow).Open();
    ServerOptions.gameHistory = oGH
}
;
SystemMessageManager.RCCloseMessage = function() {
    SystemMessageManager.CloseMessage();
    RC_timer = (new Date).getTime();
    RC_WindowShown = false
}
;
SystemMessageManager.CloseMessage = function() {
    var mng = SystemMessageManager;
    mng.scaleRoot.removeChild(mng.scaleRoot.lastChild);
    var msg = mng.shownMessages.pop();
    if (msg["nonIntrusive"] == true)
        XT.TriggerEvent(CustomNotificationVars.Evt_Internal_HideNonIntrusiveNotification);
    else
        XT.TriggerEvent(CustomNotificationVars.Evt_Internal_HideIntrusiveNotification);
    mng.InternalShowMessage();
    if (mng.shownMessages.length < 1)
        setTimeout(mng.TriggerMessageClosed, 1)
}
;
SystemMessageManager.TriggerMessageClosed = function() {
    UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
        common: "EVT_MESSAGE_CLOSED",
        args: null
    }));
    SystemMessageManager.msgOpenWasTriggered = false
}
;
SystemMessageManager.MessageExists = function(data) {
    var msgs = SystemMessageManager.shownMessages;
    for (var i = 0; i < msgs.length; ++i)
        if (msgs[i].equals(data))
            return true;
    msgs = SystemMessageManager.messagesToShow;
    for (var j = 0; j < msgs.length; ++j)
        if (msgs[j].equals(data))
            return true;
    return false
}
;
SystemMessageManager.CreateMessage = function(data, options, isCustom) {
    var mng = SystemMessageManager;
    var allTexts = [];
    var title = document.createElement("p");
    title.className = "sys-msg-title";
    title.innerHTML = isCustom ? mng.ProcessText(options.title) : mng.LocalizedText(options.title || "WindowTitle");
    allTexts.push(title.innerHTML);
    var text = document.createElement("table");
    text.className = "sys-msg-text";
    var txt = data.text != null ? mng.ProcessText(data.text) : mng.LocalizedText(options.id);
    text.innerHTML = ["<tbody><tr><td>", txt, "</td></tr></tbody>"].join("");
    allTexts.push(txt);
    var buttons = document.createElement("p");
    buttons.className = "sys-msg-buttons";
    for (var i = 0; i < options.buttons.length; ++i) {
        var btn = document.createElement("a");
        btn.className = ["sys-msg-button", options.buttons[i].id].join(" ");
        btn.innerHTML = isCustom ? mng.ProcessText(options.buttons[i].label) : mng.LocalizedText(options.buttons[i].id);
        allTexts.push(btn.innerHTML);
        mng.SetBtnHandlers(btn, options.buttons[i].handlers, data.args);
        buttons.appendChild(btn)
    }
    var msg = document.createElement("div");
    msg.id = options.id;
    msg.className = isCustom ? options.className : "sys-msg";
    msg.appendChild(title);
    msg.appendChild(text);
    msg.appendChild(buttons);
    if (SystemMessageManager.msgFontLoaded[options.id] != true) {
        mng.msgFontLoaded[options.id] = false;
        FontLoader.LoadFont(mng.fontName, null, {
            force: true,
            text: allTexts.join("")
        });
        FontLoader.AddHandler(mng.fontName, function() {
            mng.msgFontLoaded[options.id] = true
        }, mng)
    }
    data.element = msg;
    data.isCustom = isCustom;
    return msg
}
;
SystemMessageManager.InitRootElements = function() {
    var mng = SystemMessageManager;
    if (mng.root != null)
        return;
    mng.root = document.createElement("div");
    mng.root.className = "sys-msg-root-hidden";
    mng.root.id = "SysMsgRoot_" + mng.locale;
    mng.scaleRoot = document.createElement("div");
    mng.scaleRoot.className = "sys-msg-scale-root";
    mng.root.appendChild(mng.scaleRoot);
    document.body.appendChild(mng.root);
    mng.HandleResize();
    window.addEventListener("resize", mng.HandleResize, false);
    if (mng.os == mng.OS.iOS)
        mng.root.addEventListener("touchmove", mng.HandleTouchMove, false)
}
;
SystemMessageManager.HandleTouchMove = function(evt) {
    evt.returnValue = false;
    evt.cancelBubble = true;
    if (evt.preventDefault) {
        evt.preventDefault();
        evt.stopPropagation()
    }
    return false
}
;
SystemMessageManager.SetBtnHandlers = function(btn, clickHandlers, clickArgs) {
    var mng = SystemMessageManager;
    btn.addEventListener("click", mng.GetBtnClickHandler(clickHandlers, clickArgs), false);
    btn.addEventListener("touchstart", mng.AddBtnActiveStyle, false);
    btn.addEventListener("touchend", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("touchcancel", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("touchleave", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("mousedown", mng.AddBtnActiveStyle, false);
    btn.addEventListener("mouseup", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("mouseout", mng.RemoveBtnActiveStyle, false);
    btn.addEventListener("mouseleave", mng.RemoveBtnActiveStyle, false)
}
;
SystemMessageManager.AddBtnActiveStyle = function() {
    var target = this || null;
    if (target == null)
        return;
    if (/\bactive\b/.test(target.className))
        return;
    target.className = [target.className, "active"].join(" ")
}
;
SystemMessageManager.RemoveBtnActiveStyle = function() {
    var target = this || null;
    if (target == null)
        return;
    if (!/\bactive\b/.test(target.className))
        return;
    target.className = String(target.className).replace(/\bactive\b/g, "").replace(/^\s/g, "").replace(/\s$/g, "").replace(/\s\s/g, " ")
}
;
SystemMessageManager.GetBtnClickHandler = function(handlers, args) {
    return function() {
        for (var i = 0; i < handlers.length; ++i)
            handlers[i](args)
    }
}
;
SystemMessageManager.HandleResize = function() {
    var scaleRootHeight = 567;
    var zoom = 1;
    if (window.innerWidth > window.innerHeight)
        zoom = window.innerHeight / scaleRootHeight;
    else
        zoom = window.innerWidth / scaleRootHeight;
    var styles = ["-moz-transform: scale(VAL)", "-webkit-transform: scale(VAL)", "-ms-transform: scale(VAL)", "-o-transform: scale(VAL)", "transform: scale(VAL)"];
    if (UHT_DEVICE_TYPE.DESKTOP)
        zoom = zoom > 1 ? 1 : zoom;
    for (var i = 0; i < styles.length; ++i)
        styles[i] = styles[i].replace("VAL", zoom);
    styles.push("width:" + window.innerWidth / zoom + "px");
    styles.push("margin-top:" + (window.innerHeight - scaleRootHeight * zoom) / 2 + "px");
    SystemMessageManager.scaleRoot.setAttribute("style", styles.join(";"))
}
;
SystemMessageManager.ProcessText = function(text) {
    text = decodeURIComponent(text).replace(/\+/g, " ");
    var isI11 = !UHT_CONFIG.MINI_MODE;
    if (isI11)
        text = text.replace(/<br/ig, "\n<br").replace(/<p/ig, "\n<p").replace(/(<([^>]+)>)/ig, "").replace(/\n\n/ig, "\n").replace(/^\n/ig, "").replace(/\n$/ig, "");
    return text
}
;
SystemMessageManager.LocalizedText = function(id) {
    if (SystemMessageManager.localizedTexts == null)
        return "*" + id + "*";
    var txt = SystemMessageManager.localizedTexts[id];
    if (txt == undefined)
        return "**" + id + "**";
    return SystemMessageManager.ProcessText(txt)
}
;
SystemMessageManager.RealMoney = function() {
    console.warn("real money");
    UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
        common: "EVT_OPEN_CASHIER",
        args: null
    }))
}
;
SystemMessageManager.CloseGame = function() {
    console.warn("CloseGame");
    UHTEventBroker.Trigger(UHTEventBroker.Type.Adapter, JSON.stringify({
        common: "EVT_CLOSE_GAME",
        args: null
    }))
}
;
SystemMessageManager.Reload = function(link) {
    console.warn("Reload");
    location.assign(link)
}
;
SystemMessageManager.BrowserWarningShown = function() {
    SystemMessageManager.browserWarningShownCallback.call()
}
;
SystemMessageManager.RegulationContinuePressed = function() {
    SystemMessageManager.SendRegulationChoice(true)
}
;
SystemMessageManager.RegulationStopPressed = function() {
    SystemMessageManager.SendRegulationChoice(false)
}
;
SystemMessageManager.SendRegulationChoice = function(_continue) {
    var xhr = new XMLHttpRequest;
    xhr.open("POST", UHT_GAME_CONFIG["REGULATION"], true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
            var data = {};
            try {
                data = JSON.parse(_string.Trim(xhr.responseText))
            } catch (e) {}
            if (data["status"] == "OK")
                if (_continue)
                    SystemMessageManager.CloseMessage();
                else
                    SystemMessageManager.RCClose();
            else
                setTimeout(function() {
                    SystemMessageManager.SendRegulationChoice(_continue)
                }, 1E3)
        }
    }
    ;
    var params = [];
    params.push(["action", _continue ? "RESUME" : "STOP"].join("="));
    params.push(["type", SystemMessageManager.regulationType].join("="));
    xhr.send(params.join("&"))
}
;
SystemMessageManager.SendTimeout = function() {
    var xhr = new XMLHttpRequest;
    xhr.open("POST", UHT_GAME_CONFIG["LOGOUT"], true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function() {
        if (xhr.readyState == 4)
            if (xhr.responseText == "OK")
                ;
            else
                setTimeout(function() {
                    SystemMessageManager.SendTimeout()
                }, 2E3)
    }
    ;
    xhr.send()
}
;
SystemMessageManager.OnLoad();
var LastInteractionTime = (new Date).getTime();
SystemMessageManager.UserInteraction = function() {
    LastInteractionTime = (new Date).getTime()
}
;
var RC_timer = -1;
var RC_sessionTimer = -1;
var RC_WindowShown = false;
function RC_CheckShowWindow() {
    if (RC_timer == -1)
        return;
    if (UHT_GAME_CONFIG["rcSettings"] == null)
        return;
    if (UHT_GAME_CONFIG["rcSettings"]["rctype"] != "RC0")
        return;
    if (RC_WindowShown)
        return;
    var now = (new Date).getTime();
    var interval = UHT_GAME_CONFIG["rcSettings"]["interval"];
    var minutes_passed = (Math.floor((now - RC_timer) / 6E4) | 0) + (UHT_GAME_CONFIG["rcSettings"]["elapsed"] || 0);
    var all_minutes_passed = Math.floor((now - RC_sessionTimer) / 6E4) | 0;
    if (minutes_passed >= interval) {
        SystemMessageManager.ShowMessage(SystemMessageType.ClientRegulation, false, UHT_GAME_CONFIG["rcSettings"]["msg"].replace("{0}", interval.toString()).replace("{1}", all_minutes_passed));
        UHT_GAME_CONFIG["rcSettings"]["elapsed"] = 0;
        RC_WindowShown = true
    }
}
function CheckTimeout() {
    if (UHT_GAME_CONFIG["sessionTimeout"] == "-1")
        return;
    if ((new Date).getTime() - LastInteractionTime > UHT_GAME_CONFIG["sessionTimeout"] * 60 * 1E3) {
        if (!TimeoutWindowShown) {
            SystemMessageManager.ShowMessage(SystemMessageType.Timeout, true);
            SystemMessageManager.SendTimeout()
        }
        TimeoutWindowShown = true
    } else
        setTimeout(CheckTimeout, 1E4)
}
setTimeout(CheckTimeout, 6E4);
function IPhone7Helper() {}
IPhone7Helper.prototype.ResetScroll = function() {
    if (window.scrollY != 0)
        window.scrollTo(0, 0)
}
;
IPhone7Helper.prototype.ScrollHandler = function() {
    this.ResetScroll()
}
;
IPhone8Helper.prototype = Object.create(IPhone7Helper.prototype);
IPhone8Helper.prototype.constructor = IPhone8Helper;
function IPhone8Helper() {
    IPhone7Helper.call(this);
    this.root = null;
    this.canvas = null;
    this.isTouch = false;
    this.isTopPanel = false;
    this.isLandscape = false;
    this.resetScrollTimeout = null;
    this.clientHeight = 0;
    this.panelHiddenTime = -1;
    this.scaleRootMarginTop = -1
}
IPhone8Helper.prototype.GameStarted = function() {
    var logoVisible = window["UHTLogoIsVisible"];
    var loaderVisible = window["loaderIsVisible"] != undefined ? window["loaderIsVisible"] : true;
    return !logoVisible && !loaderVisible
}
;
IPhone8Helper.prototype.CreateElement = function(className, append) {
    var el = document.createElement("div");
    el.className = className;
    if (append)
        document.body.appendChild(el);
    return el
}
;
IPhone8Helper.prototype.InitElements = function() {
    var self = this;
    this.CreateElement("fullscreen-reserve", true);
    this.root = this.CreateElement("fullscreen-root-hidden", true);
    this.root.addEventListener("touchstart", function() {
        self.HandleTouchStart.apply(self, arguments)
    }, false);
    this.root.addEventListener("touchmove", function() {
        self.HandleTouchMove.apply(self, arguments)
    }, false);
    this.root.addEventListener("touchend", function() {
        self.HandleTouchEnd.apply(self, arguments)
    }, false);
    this.root.addEventListener("touchcancel", function() {
        self.HandleTouchEnd.apply(self, arguments)
    }, false);
    this.root.addEventListener("gesturestart", function() {
        self.PreventEvent.apply(self, arguments)
    }, false);
    this.root.addEventListener("gesturechange", function() {
        self.PreventEvent.apply(self, arguments)
    }, false);
    this.root.addEventListener("gestureend", function() {
        self.PreventEvent.apply(self, arguments)
    }, false);
    this.canvas = document.getElementsByTagName("canvas")[0]
}
;
IPhone8Helper.prototype.PreventEvent = function(e) {
    e.preventDefault()
}
;
IPhone8Helper.prototype.ResizeHandler = function(e) {
    var self = this;
    if (!this.GameStarted()) {
        setTimeout(function() {
            self.ResizeHandler()
        }, 100);
        return
    }
    if (this.root == null)
        this.InitElements();
    var wasLandscape = this.isLandscape;
    this.isLandscape = window.innerWidth > window.innerHeight;
    if (!this.isTouch)
        if (wasLandscape == this.isLandscape) {
            if (this.panelHiddenTime > 0)
                if (Date.now() - this.panelHiddenTime < 69) {
                    setTimeout(function() {
                        self.ResizeHandler(e)
                    }, 500);
                    return
                }
        } else
            this.ResetScroll();
    var screenHeight = this.isLandscape ? Math.min(screen.width, screen.height) : Math.max(screen.width, screen.height) - 60;
    if (!this.isLandscape && screenHeight == 752)
        screenHeight -= 35;
    if (!this.isLandscape && screenHeight == 836)
        screenHeight -= 4;
    this.clientHeight = this.GetClientHeight();
    var wasTopPanel = this.isTopPanel;
    this.isTopPanel = this.clientHeight < screenHeight;
    if (this.isTopPanel) {
        if (!wasTopPanel) {
            this.UpdateStyle(true);
            this.ResetScroll();
            this.UpdateScrollable(true);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                common: "EVT_FULLSCREEN_OVERLAY_SHOWN",
                args: null
            }));
            this.panelHiddenTime = -1
        }
    } else {
        if (wasTopPanel) {
            this.UpdateStyle(false);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                common: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
                args: null
            }));
            this.panelHiddenTime = Date.now()
        }
        this.UpdateScrollable(false)
    }
    if (e !== undefined)
        setTimeout(function() {
            self.ResizeHandler()
        }, 500)
}
;
IPhone8Helper.prototype.UpdateStyle = function(visible) {
    var c = String(document.documentElement.className).replace("fullscreen-visible", "").split(" ");
    var cn = [];
    for (var i = 0; i < c.length; ++i)
        if (c[i] != "")
            cn.push(c[i]);
    if (visible)
        cn.push("fullscreen-visible");
    document.documentElement.className = cn.join(" ");
    this.root.className = visible ? "fullscreen-root-visible" : "fullscreen-root-hidden"
}
;
IPhone8Helper.prototype.UpdateScrollable = function(scrollable) {
    document.body.style.position = scrollable ? "static" : "fixed";
    this.canvas.style.position = scrollable ? "fixed" : "static"
}
;
IPhone8Helper.prototype.HandleTouchStart = function(event) {
    if (this.resetScrollTimeout != null) {
        clearTimeout(this.resetScrollTimeout);
        this.resetScrollTimeout = null
    }
    this.isTouch = true;
    this.UpdateScrollable(false)
}
;
IPhone8Helper.prototype.HandleTouchMove = function(event) {
    if (this.isTopPanel)
        this.ResizeHandler();
    if (this.isTopPanel && window.scrollY > 0)
        this.UpdateScrollable(true);
    else
        this.UpdateScrollable(false)
}
;
IPhone8Helper.prototype.HandleTouchEnd = function() {
    var self = this;
    this.isTouch = false;
    this.UpdateScrollable(false);
    this.resetScrollTimeout = setTimeout(function() {
        self.ResetScroll()
    }, 200)
}
;
IPhone8Helper.prototype.ScrollHandler = function() {
    if (this.clientHeight != this.GetClientHeight()) {
        var event = document.createEvent("HTMLEvents");
        event.initEvent("resize", true, true);
        window.dispatchEvent(event)
    }
}
;
IPhone8Helper.prototype.ResetScroll = function() {
    if (window.scrollY != 0)
        window.scrollTo(0, 0)
}
;
IPhone8Helper.prototype.GetClientHeight = function() {
    var height = window.innerHeight;
    if (!this.isTouch && this.resetScrollTimeout == null)
        if (window.scrollY > 0)
            height -= window.scrollY;
    return height
}
;
var FullScreenIPhoneHelper = {};
FullScreenIPhoneHelper.Init = function() {
    if (UHT_FRAME)
        return;
    if (!(UHT_UA_INFO.device.model == "iPhone" && UHT_UA_INFO.browser.name == "Mobile Safari"))
        return;
    var version = _number.otoui(UHT_UA_INFO.os.version);
    if (version == 7) {
        var h = new IPhone7Helper;
        var onScroll = function() {
            h.ScrollHandler.apply(h, arguments)
        };
        window.addEventListener("scroll", onScroll, false);
        h.ScrollHandler()
    } else {
        var h = new IPhone8Helper;
        var onScroll = function() {
            h.ScrollHandler.apply(h, arguments)
        };
        var onResize = function() {
            h.ResizeHandler.apply(h, arguments)
        };
        window.addEventListener("resize", onResize, false);
        window.addEventListener("scroll", onScroll, false);
        h.ResizeHandler();
        h.ScrollHandler();
        h.ResetScroll()
    }
}
;
(function() {
    var keyboardAllowed = typeof Element !== "undefined" && "ALLOW_KEYBOARD_INPUT"in Element;
    var fn = function() {
        var val;
        var valLength;
        var fnMap = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]];
        var i = 0;
        var l = fnMap.length;
        var ret = {};
        for (; i < l; i++) {
            val = fnMap[i];
            if (val && val[1]in document) {
                for (i = 0,
                valLength = val.length; i < valLength; i++)
                    ret[fnMap[0][i]] = val[i];
                return ret
            }
        }
        return false
    }();
    var screenfull = {
        request: function(elem) {
            var request = fn.requestFullscreen;
            elem = elem || document.documentElement;
            var isAndroidChrome71Plus = UHT_UA_INFO.os.name == "Android" && UHT_UA_INFO.browser.name == "Chrome" && _number.otoui(UHT_UA_INFO.browser.version) >= 71;
            if (isAndroidChrome71Plus)
                elem[request]({
                    navigationUI: "hide"
                });
            else if (/5\.1[\.\d]* Safari/.test(navigator.userAgent))
                elem[request]();
            else
                elem[request](keyboardAllowed && Element.ALLOW_KEYBOARD_INPUT)
        },
        exit: function() {
            document[fn.exitFullscreen]()
        },
        toggle: function(elem) {
            if (this.isFullscreen)
                this.exit();
            else
                this.request(elem)
        },
        raw: fn
    };
    if (!fn) {
        window.screenfull = false;
        return
    }
    Object.defineProperties(screenfull, {
        isFullscreen: {
            get: function() {
                return !!document[fn.fullscreenElement]
            }
        },
        element: {
            enumerable: true,
            get: function() {
                return document[fn.fullscreenElement]
            }
        },
        enabled: {
            enumerable: true,
            get: function() {
                return !!document[fn.fullscreenEnabled]
            }
        }
    });
    window.screenfull = screenfull
}
)();
var FullScreenManager = {};
FullScreenManager.overlay = null;
FullScreenManager.reserve = null;
FullScreenManager.RequestFullscreen = function() {
    if (!window.screenfull.isFullscreen)
        window.screenfull.request()
}
;
FullScreenManager.ExitFullscreen = function() {
    if (window.screenfull.isFullscreen)
        window.screenfull.exit()
}
;
FullScreenManager.IsFullscreen = function() {
    return window.screenfull.isFullscreen
}
;
FullScreenManager.Init = function() {
    if (!UHT_DEVICE_TYPE.MOBILE)
        return;
    if (UHT_GAME_CONFIG_SRC["allowFullscreen"] != undefined)
        if (window.top != window && !UHT_GAME_CONFIG_SRC["allowFullscreen"])
            return;
    var self = FullScreenManager;
    var inputMng = globalColliderInputManager;
    if (inputMng == undefined) {
        setTimeout(self.Init, 50);
        return
    }
    if (window.screenfull && window.screenfull.enabled)
        inputMng.addEventHandler(ColliderEvent.ButtonUp, new EventHandler(self,self.RequestFullscreen));
    FullScreenIPhoneHelper.Init()
}
;
FullScreenManager.OnLoad = function() {
    var self = FullScreenManager;
    self.Init();
    window.RequestFullscreen = self.RequestFullscreen;
    window.ExitFullscreen = self.ExitFullscreen;
    window.IsFullscreen = self.IsFullscreen
}
;
FullScreenManager.OnLoad();
function IPhoneChromeFullscreen() {
    this.root = null;
    this.reserve = null;
    this.minHeight = -1;
    this.maxHeight = -1;
    this.topBarHeightLand = -1;
    this.topBarHeightPort = -1;
    this.isInit = false;
    this.isLand = false;
    this.isVisible = false;
    this.isResized = false;
    this.gameJustStarted = true;
    this.timer = 0;
    this.CreateElement = IPhone8Helper.prototype.CreateElement;
    this.UpdateStyle = IPhone8Helper.prototype.UpdateStyle;
    this.GameStarted = IPhone8Helper.prototype.GameStarted
}
IPhoneChromeFullscreen.instance = null;
IPhoneChromeFullscreen.prototype.UpdateReserve = function() {
    this.reserve.style.height = (this.isLand ? this.minHeight : this.maxHeight) + Math.max(0, window.scrollY) + "px"
}
;
IPhoneChromeFullscreen.prototype.FixScroll = function() {
    if (window.scrollY < this.scrollY)
        window.scrollTo(0, this.scrollY);
    this.UpdateReserve()
}
;
IPhoneChromeFullscreen.prototype.Init = function() {
    var min = Math.min(screen.width, screen.height);
    var max = Math.max(screen.width, screen.height);
    if (min == 320 && max == 568)
        this.topBarHeightLand = this.topBarHeightPort = this.scrollY = 76;
    if (min == 375 && max == 667)
        this.topBarHeightLand = this.topBarHeightPort = this.scrollY = 76;
    if (min == 414 && max == 736)
        this.topBarHeightLand = this.topBarHeightPort = this.scrollY = 76;
    if (min == 375 && max == 812) {
        this.topBarHeightLand = 56;
        this.topBarHeightPort = this.scrollY = 100
    }
    if (min == 414 && max == 896) {
        this.topBarHeightLand = 56;
        this.topBarHeightPort = this.scrollY = 100
    }
    this.minHeight = min;
    this.maxHeight = max;
    this.root = this.CreateElement("fullscreen-root-hidden", true);
    this.reserve = document.createElement("div");
    document.body.insertBefore(this.reserve, document.getElementsByTagName("canvas")[0]);
    this.UpdateReserve();
    this.isInit = true
}
;
IPhoneChromeFullscreen.prototype.IsMinimalMode = function() {
    this.isLand = window.innerWidth > window.innerHeight;
    var h = this.isLand ? this.minHeight : this.maxHeight;
    return h - window.innerHeight < (this.isLand ? this.topBarHeightLand : this.topBarHeightPort)
}
;
IPhoneChromeFullscreen.prototype.OnUHTResize = function(unused) {
    if (!this.isInit)
        this.Init();
    if (!this.IsMinimalMode()) {
        if (!this.isVisible) {
            window.scrollTo(0, 0);
            this.UpdateReserve();
            this.isVisible = true;
            this.UpdateStyle(true);
            UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
                common: "EVT_FULLSCREEN_OVERLAY_SHOWN",
                args: null
            }))
        }
    } else if (this.isVisible) {
        this.isVisible = false;
        this.UpdateStyle(false);
        UHTEventBroker.Trigger(UHTEventBroker.Type.Game, JSON.stringify({
            common: "EVT_FULLSCREEN_OVERLAY_HIDDEN",
            args: null
        }))
    }
    this.isResized = true
}
;
IPhoneChromeFullscreen.prototype.OnUHTUpdate = function(unused) {
    if (this.gameJustStarted)
        if (this.GameStarted()) {
            this.OnUHTResize(null);
            this.gameJustStarted = false
        }
    if (!this.isInit)
        return;
    if (this.isResized) {
        this.isResized = false;
        this.timer = 0;
        return
    }
    if (this.IsMinimalMode())
        if (this.timer > 1) {
            this.timer = 0;
            this.FixScroll()
        } else
            this.timer += Time.deltaTime
}
;
IPhoneChromeFullscreen.OnLoad = function() {
    if (!UHT_FRAME && UHT_UA_INFO.device.model == "iPhone" && UHT_UA_INFO.browser.name == "Chrome") {
        var instance = IPhoneChromeFullscreen.instance = new IPhoneChromeFullscreen;
        EventManager.AddHandler("EVT_UHT_RESIZE", instance.OnUHTResize, instance);
        EventManager.AddHandler("EVT_UHT_UPDATE", instance.OnUHTUpdate, instance)
    }
}
;
IPhoneChromeFullscreen.OnLoad();
var NoSleep = {};
NoSleep.os = null;
NoSleep.uap = null;
NoSleep.browserName = "";
NoSleep.Android = function() {
    var srcWebM = document.createElement("source");
    srcWebM.src = "data:video/webm;base64,GkXfo0AgQoaBAUL3gQFC8oEEQvOBCEKCQAR3ZWJtQoeBAkKFgQIYU4BnQI0VSalmQCgq17FAAw9CQE2AQAZ3aGFtbXlXQUAGd2hhbW15RIlACECPQAAAAAAAFlSua0AxrkAu14EBY8WBAZyBACK1nEADdW5khkAFVl9WUDglhohAA1ZQOIOBAeBABrCBCLqBCB9DtnVAIueBAKNAHIEAAIAwAQCdASoIAAgAAUAmJaQAA3AA/vz0AAA=";
    srcWebM.type = "video/webm";
    var srcMP4 = document.createElement("source");
    srcMP4.src = "data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAAG21kYXQAAAGzABAHAAABthADAowdbb9/AAAC6W1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAAAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIVdHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAIAAAACAAAAAABsW1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAAA+gAAAAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAVxtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAEcc3RibAAAALhzdHNkAAAAAAAAAAEAAACobXA0dgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIAAgASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAAFJlc2RzAAAAAANEAAEABDwgEQAAAAADDUAAAAAABS0AAAGwAQAAAbWJEwAAAQAAAAEgAMSNiB9FAEQBFGMAAAGyTGF2YzUyLjg3LjQGAQIAAAAYc3R0cwAAAAAAAAABAAAAAQAAAAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAAEwAAAAEAAAAUc3RjbwAAAAAAAAABAAAALAAAAGB1ZHRhAAAAWG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAK2lsc3QAAAAjqXRvbwAAABtkYXRhAAAAAQAAAABMYXZmNTIuNzguMw==";
    srcMP4.type = "video/mp4";
    var video = document.createElement("video");
    video.setAttribute("loop", "");
    video.appendChild(srcWebM);
    video.appendChild(srcMP4);
    video.play();
    renderCanvas.removeEventListener("touchend", NoSleep.Android, false);
    NoSleep = null
}
;
NoSleep.IOS10 = function() {
    var video = document.createElement("video");
    video.setAttribute("playsinline", "");
    video.setAttribute("src", "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=");
    video.addEventListener("timeupdate", function() {
        if (video.currentTime > .5)
            video.currentTime = Math.random()
    });
    video.play();
    document.removeEventListener("touchend", NoSleep.IOS10, false);
    NoSleep = null
}
;
NoSleep.Init = function() {
    if (NoSleep.uap == null) {
        NoSleep.uap = new UAParser2;
        NoSleep.os = NoSleep.uap.getOS() || {
            name: "",
            version: "0"
        };
        NoSleep.browserName = NoSleep.uap.getBrowser().name
    }
    if (NoSleep.os.name == "Android" && NoSleep.uap.getBrowser().name == "Chrome" && !IS_UCBROWSER) {
        if (renderCanvas == undefined) {
            setTimeout(NoSleep.Init, 100);
            return
        }
        renderCanvas.addEventListener("touchend", NoSleep.Android, false)
    } else if (NoSleep.os.name == "iOS" && (NoSleep.browserName.indexOf("Safari") != -1 || NoSleep.browserName.indexOf("Chrome") != -1))
        if (parseFloat(NoSleep.os.version) >= 10)
            document.addEventListener("touchend", NoSleep.IOS10, false)
}
;
NoSleep.Init();
